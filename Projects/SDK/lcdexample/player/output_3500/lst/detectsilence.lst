TASKING DSP2410 assembler v1.5r1 Build 138 SN 00100122
                                                                                                                                                                                                                                                       Page   1
C:\STMP3XXX_SDK_FIRMWARE_320_finalfix\Projects\SDK\lcdexample\player\make\ccfccc4b.src
M:ADDR CODE           CYCLES LINE SOURCELINE
                                1 ; TASKING DSP2410 C compiler v1.5r1 Build 208 SN 00100122
                                2 ; options: -OG -si -DPLAYER -DALL -DD3500 -DMMC -DLIION -DPL3_FB
                                3 ;          -DSTMP_BUILD_PLAYER -DPLAYER_BUILD -DPLAYER -DSTFM1000_LCD
                                4 ;          -DFULL_PLAYER_KERNEL -DDCDC_POWER_TRANSFER -DBACKLIGHT
                                5 ;          -DWMAAPI_NO_DRM -DREVB_ENGR_BD -DSED15XX_LCD -DSYNC_LYRICS
                                6 ;          -DTUNER_STFM1000 -DFM_EUROPE_REGION -DSD_USE_100KHZ_TUNING_GRID
                                7 ;          -DNEWSHINGYIH -DREAL_I2S_DATA -DFUNCLET
                                8 ;          -DMEDIA_DDI_COUNT_HIDDEN_SYSTEM_BLOCKS -DFMTUNER -DMP3_ENCODE
                                9 ;          -DCHKDSK -DFAT16 -DDEBUG -DDEVICE_3500 -DSDK2400 -DENGR_BD
                               10 ;          -DUSE_PLAYLIST3 -DBATTERY_TYPE_LI_ION -DBATTERY_CHARGE -w68 -w66
                               11 ;          -I..\output_3500\include
                               12 ;          -I..\..\..\..\..\Projects\sdk\lcdexample\Player
                               13 ;          -I..\..\..\..\..\Projects\sdk\lcdexample\Player\Menus -I..\..
                               14 ;          -I..\..\..\..\..\inc -I..\..\..\..\..\System\Common
                               15 ;          -I..\..\..\..\..\System\Common\symbols
                               16 ;          -I..\..\..\..\..\Projects\sdk\lcdexample\Player\Display
                               17 ;          -I..\..\..\..\..\Algorithms\DRM\janus\src\h
                               18 ;          -I..\..\..\..\..\FileSystem\Fat32\h
                               19 ;          -I..\..\..\..\..\FileSystem\Fat32\cmp\cmp_stdtype
                               20 ;          -I..\..\..\..\..\FileSystem\Fat32\cmp\cmp_debug
                               21 ;          -I..\..\..\..\..\FileSystem\Fat32\cmp\cmp_file_system
                               22 ;          -I..\..\..\..\..\DeviceDriver\Media\cmp\cmp_media_nand -I -I
                               23 ;          -I..\..\..\..\..\system\common\resourcemanager -I..\..\..\..\..\inc
                               24 ;          -I..\..\..\..\..\devicedriver\media\MediaTypeNAND\include
                               25 ;          -I..\..\..\..\..\devicedriver\media\MediaTypeNAND\DDI\DataDrive\include
                               26 ;          -I..\..\..\..\..\devicedriver\media\MediaTypeNAND\DDI\include
                               27 ;          -I..\..\..\..\..\devicedriver\media\MediaTypeNAND\HAL\include
                               28 ;          -I..\..\..\..\..\devicedriver\media\MediaTypeNAND\DDI\DataDrive
                               29 ;          -I..\..\..\..\..\devicedriver\media\ddildl\include
                               30 ;          -I..\..\..\..\..\FileSystem\Fat32\h
                               31 ;          -I..\..\..\..\..\FileSystem\Fat32\cmp\cmp_stdtype
                               32 ;          -I..\..\..\..\..\FileSystem\Fat32\cmp\cmp_debug
                               33 ;          -I..\..\..\..\..\FileSystem\Fat32\cmp\cmp_file_system
                               34 ;          -I..\..\..\..\..\DeviceDriver\Media\cmp\cmp_media_nand
                               35 ;          -I..\..\..\..\..\devicedriver\media\MediaTypeNAND\include
                               36 ;          -I..\..\..\..\..\devicedriver\media\MediaTypeNAND\DDI\Common\include
                               37 ;          -I..\..\..\..\..\devicedriver\media\MediaTypeNAND\DDI\include
                               38 ;          -I..\..\..\..\..\devicedriver\media\MediaTypeNAND\HAL\include
                               39 ;          -I..\..\..\..\..\devicedriver\media\MediaTypeNAND\DDI\Common
                               40 ;          -I..\..\..\..\..\devicedriver\media\MediaTypeNAND\include
                               41 ;          -I..\..\..\..\..\devicedriver\media\MediaTypeNAND\DDI\SystemDrive\include
                               42 ;          -I..\..\..\..\..\devicedriver\media\MediaTypeNAND\DDI\include
                               43 ;          -I..\..\..\..\..\devicedriver\media\MediaTypeNAND\HAL\include
                               44 ;          -I..\..\..\..\..\devicedriver\media\MediaTypeNAND\DDI\SystemDrive
                               45 ;          -I..\..\..\..\..\devicedriver\media\MediaTypeNAND\include
                               46 ;          -I..\..\..\..\..\devicedriver\media\MediaTypeNAND\DDI\Media\include
                               47 ;          -I..\..\..\..\..\devicedriver\media\MediaTypeNAND\DDI\include
                               48 ;          -I..\..\..\..\..\devicedriver\media\MediaTypeNAND\HAL\include
                               49 ;          -I..\..\..\..\..\devicedriver\media\MediaTypeNAND\DDI\Media
                               50 ;          -I..\..\..\..\..\devicedriver\media\include
                               51 ;          -I..\..\..\..\..\devicedriver\media\ddildl
                               52 ;          -I..\..\..\..\..\devicedriver\media\ddildl\include
                               53 ;          -I..\..\..\..\..\devicedriver\media\MediaTypeNAND\DDI\Common\include
                               54 ;          -I..\..\..\..\..\devicedriver\media\MediaTypeNAND\DDI\include
                               55 ;          -I..\..\..\..\..\DeviceDriver\Media\MediaTypeNAND\HAL
                               56 ;          -I..\..\..\..\..\DeviceDriver\Media\MediaTypeNAND\HAL\include
                               57 ;          -I..\..\..\..\..\DeviceDriver\Media\include
                               58 ;          -I..\..\..\..\..\DeviceDriver\Media\PortHIL\GPFlash\include
                               59 ;          -I..\..\..\..\..\DeviceDriver\Media\PortHIL\GPFlash
                               60 ;          -I..\..\..\..\..\devicedriver\media\ddildl
                               61 ;          -I..\..\..\..\..\devicedriver\media\ddildl\include
                               62 ;          -I..\..\..\..\..\libsource\sysserialnumber
                               63 ;          -I..\..\..\..\..\devicedriver\media\MediaTypeMMC\DDI\include
                               64 ;          -I..\..\..\..\..\devicedriver\media\ddildl\include
                               65 ;          -I..\..\..\..\..\devicedriver\media\MediaTypeMMC\DDI\include
                               66 ;          -I..\..\..\..\..\devicedriver\media\MediaTypeMMC\DDI\Media
                               67 ;          -I..\..\..\..\..\devicedriver\media\MediaTypeMMC\HAL\include
                               68 ;          -I..\..\..\..\..\FileSystem\Fat32\h
                               69 ;          -I..\..\..\..\..\FileSystem\Fat32\cmp\cmp_stdtype
                               70 ;          -I..\..\..\..\..\FileSystem\Fat32\cmp\cmp_debug
                               71 ;          -I..\..\..\..\..\FileSystem\Fat32\cmp\cmp_file_system
                               72 ;          -I..\..\..\..\..\DeviceDriver\Media\cmp\cmp_media_nand
                               73 ;          -I..\..\..\..\..\DeviceDriver\Media\MediaTypeNAND\HAL\include
                               74 ;          -I..\..\..\..\..\System\MsgModules\Software\Effects\srswow
                               75 ;          -I..\..\..\..\..\System\Common\rtcaccess
                               76 ;          -I..\..\..\..\..\System\Common\playlist3
                               77 ;          -I..\..\..\..\..\System\Common\record
                               78 ;          -I..\..\..\..\..\System\Common\mp3filename
                               79 ;          -I..\..\..\..\..\FileSystem\chkdsk\include
                               80 ;          -I..\..\..\..\..\FileSystem\Fat32\h -DFULL_PLAYER_KERNEL
                               81 ;          -DSYNC_LYRICS -DMP3_ENCODE -DBATTERY_TYPE_LI_ION -Dk_opt_single_fat
                               82 ;          -DPL3_FB -g -O2 -R -Cs -DMS_ADPCM -DIMA_ADPCM -DWINDOWS_PCM
                               83 ;          -I..\..\..\..\..\System\MsgModules\Software\musiclib\ghdr
                               84 ;          -I..\..\..\..\..\devicedriver\display
                               85 ;          -I..\..\..\..\..\System\MsgModules\Hardware\Display -MmyL
                               86 
                               94 
                               95 ;detectsilence.c:
                               96 ; 1    |/**********************************************************************************
                               97 ; 2    |/*                                                       
                               98 ; 3    |/* SigmaTel, Inc                                         
                               99 ; 4    |/* $Archive:  $ 
                              100 ; 5    |/* $Revision: 2 $
                              101 ; 6    |/* $Date: 1/24/04 12:14p $
                              102 ; 7    |/* Description: detectsilence.c
                              103 ; 8    |/* Notes: TBD - Move DCOffset code into a separate file
                              104 ; 9    |/*                                                       
                              105 ; 10   |/***********************************************************************************/
                              106 ; 11   |#include "types.h"
                              107 
                              109 
                              110 ; 1    |////////////////////////////////////////////////////////////////////////////////
                              111 ; 2    |// Copyright(C) SigmaTel, Inc. 2000-2004
                              112 ; 3    |//
                              113 ; 4    |// Filename: types.h
                              114 ; 5    |// Description: Standard data types
                              115 ; 6    |////////////////////////////////////////////////////////////////////////////////
                              116 ; 7    |
                              117 ; 8    |#ifndef _TYPES_H
                              118 ; 9    |#define _TYPES_H
                              119 ; 10   |
                              120 ; 11   |// TODO:  move this outta here!
                              121 ; 12   |#if !defined(NOERROR)
                              122 ; 13   |#define NOERROR 0
                              123 ; 14   |#define SUCCESS 0
                              124 ; 15   |#endif 
                              125 ; 16   |#if !defined(SUCCESS)
                              126 ; 17   |#define SUCCESS  0
                              127 ; 18   |#endif
                              128 ; 19   |#if !defined(ERROR)
                              129 ; 20   |#define ERROR   -1
                              130 ; 21   |#endif
                              131 ; 22   |#if !defined(FALSE)
                              132 ; 23   |#define FALSE 0
                              133 ; 24   |#endif
                              134 ; 25   |#if !defined(TRUE)
                              135 ; 26   |#define TRUE  1
                              136 ; 27   |#endif
                              137 ; 28   |
                              138 ; 29   |#if !defined(NULL)
                              139 ; 30   |#define NULL 0
                              140 ; 31   |#endif
                              141 ; 32   |
                              142 ; 33   |#define MAX_INT     0x7FFFFF
                              143 ; 34   |#define MAX_LONG    0x7FFFFFffffff
                              144 ; 35   |        // max positive unsigned long value: -1 == 0xFFFFFFffffff
                              145 ; 36   |#define MAX_ULONG   (-1) 
                              146 ; 37   |
                              147 ; 38   |#define WORD_SIZE   24              // word size in bits
                              148 ; 39   |#define BYTES_PER_WORD 3            // 8 bit bytes
                              149 ; 40   |
                              150 ; 41   |
                              151 ; 42   |#define BYTE    unsigned char       // btVarName
                              152 ; 43   |#define CHAR    signed char         // cVarName
                              153 ; 44   |#define USHORT  unsigned short      // usVarName
                              154 ; 45   |#define SHORT   unsigned short      // sVarName
                              155 ; 46   |#define WORD    unsigned int        // wVarName
                              156 ; 47   |#define INT     signed int          // iVarName
                              157 ; 48   |#define DWORD   unsigned long       // dwVarName
                              158 ; 49   |#define LONG    signed long         // lVarName
                              159 ; 50   |#define BOOL    unsigned int        // bVarName
                              160 ; 51   |#define FRACT   _fract              // frVarName
                              161 ; 52   |#define LFRACT  long _fract         // lfrVarName
                              162 ; 53   |#define CIRC    _circ               // cp<type prefix>VarName (see below)
                              163 ; 54   |#define FLOAT   float               // fVarName
                              164 ; 55   |#define DBL     double              // dVarName
                              165 ; 56   |#define ENUM    enum                // eVarName
                              166 ; 57   |#define CMX     _complex            // cmxVarName
                              167 ; 58   |typedef WORD UCS3;                   // 
                              168 ; 59   |
                              169 ; 60   |#define UINT16  unsigned short
                              170 ; 61   |#define UINT8   unsigned char   
                              171 ; 62   |#define UINT32  unsigned long
                              172 ; 63   |#define UINT64  unsigned long   // need to figure out how to do 64 bit values.  Or port exisiting code to only use 48 bit
                              173 ; 64   |#define INT64   unsigned long   // need to figure out how to do 64 bit values.  Or port exisiting code to only use 48 bit
                              174 ; 65   |#define WCHAR   UINT16
                              175 ; 66   |
                              176 ; 67   |//UINT128 is 16 bytes or 6 words
                              177 ; 68   |typedef struct UINT128_3500 {   
                              178 ; 69   |    int val[6];     
                              179 ; 70   |} UINT128_3500;
                              180 ; 71   |
                              181 ; 72   |#define UINT128   UINT128_3500
                              182 ; 73   |
                              183 ; 74   |// Little endian word packed byte strings:   
                              184 ; 75   |//      _packed BYTE bTextVarName[]="a string";  bText is a packed byte string prefix
                              185 ; 76   |// Convert to big endian words by reordering bytes from high to low using swizzle.
                              186 ; 77   |// Little endian word packed byte strings:   
                              187 ; 78   |//      _packed BYTE bTextVarName[]="a string";  bText is a packed byte string prefix
                              188 ; 79   |// Convert to big endian words by reordering bytes from high to low using swizzle.
                              189 ; 80   |
                              190 ; 81   |// Declare Memory Spaces To Use When Coding
                              191 ; 82   |// A. Sector Buffers
                              192 ; 83   |#define SECTOR_BUFFER_MEM_X _X
                              193 ; 84   |#define SECTOR_BUFFER_MEM_Y _Y
                              194 ; 85   |#define SECTOR_BUFFER_MEM SECTOR_BUFFER_MEM_X
                              195 ; 86   |typedef WORD SECTOR_BUFFER_MEM SECTOR_BUFFER;
                              196 
                              198 
                              199 ; 87   |typedef SECTOR_BUFFER * P_SECTOR_BUFFER;
                              200 ; 88   |// B. Media DDI Memory
                              201 ; 89   |#define MEDIA_DDI_MEM _Y
                              202 ; 90   |
                              203 ; 91   |
                              204 ; 92   |
                              205 ; 93   |// Pointers to linear structures are labeled as: p<type prefix>VarName
                              206 ; 94   |// Examples of circular pointers:
                              207 ; 95   |//    INT CIRC cpiVarName
                              208 ; 96   |//    DWORD CIRC cpdwVarName
                              209 ; 97   |
                              210 ; 98   |#define RETCODE INT                 // rcVarName
                              211 ; 99   |
                              212 ; 100  |// generic bitfield structure
                              213 ; 101  |struct Bitfield {
                              214 ; 102  |    unsigned int B0  :1;
                              215 ; 103  |    unsigned int B1  :1;
                              216 ; 104  |    unsigned int B2  :1;
                              217 ; 105  |    unsigned int B3  :1;
                              218 ; 106  |    unsigned int B4  :1;
                              219 ; 107  |    unsigned int B5  :1;
                              220 ; 108  |    unsigned int B6  :1;
                              221 ; 109  |    unsigned int B7  :1;
                              222 ; 110  |    unsigned int B8  :1;
                              223 ; 111  |    unsigned int B9  :1;
                              224 ; 112  |    unsigned int B10 :1;
                              225 ; 113  |    unsigned int B11 :1;
                              226 ; 114  |    unsigned int B12 :1;
                              227 ; 115  |    unsigned int B13 :1;
                              228 ; 116  |    unsigned int B14 :1;
                              229 ; 117  |    unsigned int B15 :1;
                              230 ; 118  |    unsigned int B16 :1;
                              231 ; 119  |    unsigned int B17 :1;
                              232 ; 120  |    unsigned int B18 :1;
                              233 ; 121  |    unsigned int B19 :1;
                              234 ; 122  |    unsigned int B20 :1;
                              235 ; 123  |    unsigned int B21 :1;
                              236 ; 124  |    unsigned int B22 :1;
                              237 ; 125  |    unsigned int B23 :1;
                              238 ; 126  |};
                              239 ; 127  |
                              240 ; 128  |union BitInt {
                              241 ; 129  |        struct Bitfield B;
                              242 ; 130  |        int        I;
                              243 ; 131  |};
                              244 ; 132  |
                              245 ; 133  |#define MAX_MSG_LENGTH 10
                              246 ; 134  |struct CMessage
                              247 ; 135  |{
                              248 ; 136  |        unsigned int m_uLength;
                              249 ; 137  |        unsigned int m_uMsg[MAX_MSG_LENGTH];
                              250 ; 138  |};
                              251 ; 139  |
                              252 ; 140  |typedef struct {
                              253 ; 141  |    WORD m_wLength;
                              254 ; 142  |    WORD m_wMessage;
                              255 ; 143  |    WORD m_wParams[MAX_MSG_LENGTH];
                              256 ; 144  |} Message;
                              257 ; 145  |
                              258 ; 146  |struct MessageQueueDescriptor
                              259 ; 147  |{
                              260 ; 148  |        int *m_pBase;
TASKING DSP2410 assembler v1.5r1 Build 138 SN 00100122
                                                                                                                                                                                                                                                       Page   2

M:ADDR CODE           CYCLES LINE SOURCELINE
                              261 ; 149  |        int m_iModulo;
                              262 ; 150  |        int m_iSize;
                              263 ; 151  |        int *m_pHead;
                              264 ; 152  |        int *m_pTail;
                              265 ; 153  |};
                              266 ; 154  |
                              267 ; 155  |struct ModuleEntry
                              268 ; 156  |{
                              269 ; 157  |    int m_iSignaledEventMask;
                              270 ; 158  |    int m_iWaitEventMask;
                              271 ; 159  |    int m_iResourceOfCode;
                              272 ; 160  |    struct MessageQueueDescriptor *m_pMessageQueue;
                              273 ; 161  |    int _asmfunc (*m_pProcessEntryPoint)(union WaitMask Signals,struct MessageQueueDescriptor *);
                              274 ; 162  |    int _asmfunc (*m_pInitFunction)(struct MessageQueueDescriptor *);
                              275 ; 163  |    int m_uTimeOutHigh;
                              276 ; 164  |    int m_uTimeOutLow;
                              277 ; 165  |    int _asmfunc (*m_pBackgroundFunction)(struct MessageQueueDescriptor *);
                              278 ; 166  |};
                              279 ; 167  |
                              280 ; 168  |union WaitMask{
                              281 ; 169  |    struct B{
                              282 ; 170  |        unsigned int m_bNone     :1;
                              283 ; 171  |        unsigned int m_bMessage  :1;
                              284 ; 172  |        unsigned int m_bTimer    :1;
                              285 ; 173  |        unsigned int m_bButton   :1;
                              286 ; 174  |    } B;
                              287 ; 175  |    int I;
                              288 ; 176  |} ;
                              289 ; 177  |
                              290 ; 178  |
                              291 ; 179  |struct Button {
                              292 ; 180  |        WORD wButtonEvent;
                              293 ; 181  |        WORD wUnused[MAX_MSG_LENGTH];   
                              294 ; 182  |};
                              295 ; 183  |
                              296 ; 184  |struct Message {
                              297 ; 185  |        WORD wMsgLength;
                              298 ; 186  |        WORD wMsgCommand;
                              299 ; 187  |        WORD wMsgParms[MAX_MSG_LENGTH-1];
                              300 ; 188  |};
                              301 ; 189  |
                              302 ; 190  |union EventTypes {
                              303 ; 191  |        struct CMessage msg;
                              304 ; 192  |        struct Button Button ;
                              305 ; 193  |        struct Message Message;
                              306 ; 194  |};
                              307 ; 195  |
                              308 ; 196  |// next 2 used to get updater build to return correct protocol ver in scsi response.
                              309 ; 197  |#define BUILD_TYPE_UPDATER  0x100
                              310 ; 198  |#define BUILD_TYPE_HOSTLINK 0x101
                              311 ; 199  |#define BUILD_TYPE_PLAYER   0x102
                              312 ; 200  |
                              313 ; 201  |// Resets part if RETAIL build. DEBUG build executes debug instruction to halt.
                              314 ; 202  |#define SystemHalt() __asm(" include 'sysmacro.asm' \n error") 
                              315 ; 203  |#define assert(x)    if(!(x)) __asm(" include 'sysmacro.asm' \n error")
                              316 ; 204  |
                              317 ; 205  |#if DEBUG
                              318 ; 206  |// For DEBUG builds, DebugBuildAssert(condition) halts if condition evaluates to FALSE. 
                              319 ; 207  |#define DebugBuildAssert(x)    if(!(x)) __asm(" debug ")
                              320 ; 208  |#else 
                              321 ; 209  |// For RETAIL builds, DebugBuildAssert(condition) does nothing & execution continues rather than halt or reset. 
                              322 ; 210  |#define DebugBuildAssert(x)    
                              323 ; 211  |#endif
                              324 ; 212  |
                              325 ; 213  |// Do this in your C files to make a reminder that's displayed during the build.
                              326 ; 214  |//  #pragma asm
                              327 ; 215  |//  WARN 'Note to builder: reminder to do this after verifying that'
                              328 ; 216  |//  #pragma endasm
                              329 ; 217  |
                              330 ; 218  |
                              331 ; 219  |#ifdef COLOR_262K
                              332 ; 220  |#define RGB(r,g,b)    ((0x0000FC & (r)) << 10) | ((0x0000FC & (g)) << 4) | ((0x0000FC & (b)) >> 2)    //262k
                              333 ; 221  |#elif defined(COLOR_65K)
                              334 ; 222  |#define RGB(r,g,b)    ((0x0000F8 & (r)) << 8) | ((0x0000FC & (g)) << 3) | ((0x0000F8 & (b)) >> 3)  //65k
                              335 ; 223  |#else
                              336 ; 224  |#define RGB(r,g,b)       ((0x0000F0 & (r)) << 4) | (0x0000F0 & (g)) | ((0x0000F0 & (b)) >> 4)
                              337 ; 225  |#endif
                              338 ; 226  |    
                              339 ; 227  |#endif // #ifndef _TYPES_H
                              340 
                              342 
                              343 ; 12   |#include "fsapi.h"
                              344 
                              346 
                              347 ; 1    |#ifndef _FSAPI_H_
                              348 ; 2    |#define _FSAPI_H_
                              349 ; 3    |#include "filespec.h"
                              350 
                              352 
                              353 ; 1    |#ifndef _FILESPEC_H_
                              354 ; 2    |#define _FILESPEC_H_
                              355 ; 3    |#include  "fstypes.h"
                              356 
                              358 
                              359 ; 1    |#ifndef _FS_TYPE_H_
                              360 ; 2    |#define _FS_TYPE_H_
                              361 ; 3    |
                              362 ; 4    |#include   "types.h"
                              363 
                              365 
                              366 ; 1    |////////////////////////////////////////////////////////////////////////////////
                              367 ; 2    |// Copyright(C) SigmaTel, Inc. 2000-2004
                              368 ; 3    |//
                              369 ; 4    |// Filename: types.h
                              370 ; 5    |// Description: Standard data types
                              371 ; 6    |////////////////////////////////////////////////////////////////////////////////
                              372 ; 7    |
                              373 ; 8    |#ifndef _TYPES_H
                              374 ; 9    |#define _TYPES_H
                              375 ; 10   |
                              376 ; 11   |// TODO:  move this outta here!
                              377 ; 12   |#if !defined(NOERROR)
                              378 ; 13   |#define NOERROR 0
                              379 ; 14   |#define SUCCESS 0
                              380 ; 15   |#endif 
                              381 ; 16   |#if !defined(SUCCESS)
                              382 ; 17   |#define SUCCESS  0
                              383 ; 18   |#endif
                              384 ; 19   |#if !defined(ERROR)
                              385 ; 20   |#define ERROR   -1
                              386 ; 21   |#endif
                              387 ; 22   |#if !defined(FALSE)
                              388 ; 23   |#define FALSE 0
                              389 ; 24   |#endif
                              390 ; 25   |#if !defined(TRUE)
                              391 ; 26   |#define TRUE  1
                              392 ; 27   |#endif
                              393 ; 28   |
                              394 ; 29   |#if !defined(NULL)
                              395 ; 30   |#define NULL 0
                              396 ; 31   |#endif
                              397 ; 32   |
                              398 ; 33   |#define MAX_INT     0x7FFFFF
                              399 ; 34   |#define MAX_LONG    0x7FFFFFffffff
                              400 ; 35   |        // max positive unsigned long value: -1 == 0xFFFFFFffffff
                              401 ; 36   |#define MAX_ULONG   (-1) 
                              402 ; 37   |
                              403 ; 38   |#define WORD_SIZE   24              // word size in bits
                              404 ; 39   |#define BYTES_PER_WORD 3            // 8 bit bytes
                              405 ; 40   |
                              406 ; 41   |
                              407 ; 42   |#define BYTE    unsigned char       // btVarName
                              408 ; 43   |#define CHAR    signed char         // cVarName
                              409 ; 44   |#define USHORT  unsigned short      // usVarName
                              410 ; 45   |#define SHORT   unsigned short      // sVarName
                              411 ; 46   |#define WORD    unsigned int        // wVarName
                              412 ; 47   |#define INT     signed int          // iVarName
                              413 ; 48   |#define DWORD   unsigned long       // dwVarName
                              414 ; 49   |#define LONG    signed long         // lVarName
                              415 ; 50   |#define BOOL    unsigned int        // bVarName
                              416 ; 51   |#define FRACT   _fract              // frVarName
                              417 ; 52   |#define LFRACT  long _fract         // lfrVarName
                              418 ; 53   |#define CIRC    _circ               // cp<type prefix>VarName (see below)
                              419 ; 54   |#define FLOAT   float               // fVarName
                              420 ; 55   |#define DBL     double              // dVarName
                              421 ; 56   |#define ENUM    enum                // eVarName
                              422 ; 57   |#define CMX     _complex            // cmxVarName
                              423 ; 58   |typedef WORD UCS3;                   // 
                              424 ; 59   |
                              425 ; 60   |#define UINT16  unsigned short
                              426 ; 61   |#define UINT8   unsigned char   
                              427 ; 62   |#define UINT32  unsigned long
                              428 ; 63   |#define UINT64  unsigned long   // need to figure out how to do 64 bit values.  Or port exisiting code to only use 48 bit
                              429 ; 64   |#define INT64   unsigned long   // need to figure out how to do 64 bit values.  Or port exisiting code to only use 48 bit
                              430 ; 65   |#define WCHAR   UINT16
                              431 ; 66   |
                              432 ; 67   |//UINT128 is 16 bytes or 6 words
                              433 ; 68   |typedef struct UINT128_3500 {   
                              434 ; 69   |    int val[6];     
                              435 ; 70   |} UINT128_3500;
                              436 ; 71   |
                              437 ; 72   |#define UINT128   UINT128_3500
                              438 ; 73   |
                              439 ; 74   |// Little endian word packed byte strings:   
                              440 ; 75   |//      _packed BYTE bTextVarName[]="a string";  bText is a packed byte string prefix
                              441 ; 76   |// Convert to big endian words by reordering bytes from high to low using swizzle.
                              442 ; 77   |// Little endian word packed byte strings:   
                              443 ; 78   |//      _packed BYTE bTextVarName[]="a string";  bText is a packed byte string prefix
                              444 ; 79   |// Convert to big endian words by reordering bytes from high to low using swizzle.
                              445 ; 80   |
                              446 ; 81   |// Declare Memory Spaces To Use When Coding
                              447 ; 82   |// A. Sector Buffers
                              448 ; 83   |#define SECTOR_BUFFER_MEM_X _X
                              449 ; 84   |#define SECTOR_BUFFER_MEM_Y _Y
                              450 ; 85   |#define SECTOR_BUFFER_MEM SECTOR_BUFFER_MEM_X
                              451 ; 86   |typedef WORD SECTOR_BUFFER_MEM SECTOR_BUFFER;
                              452 ; 87   |typedef SECTOR_BUFFER * P_SECTOR_BUFFER;
                              453 ; 88   |// B. Media DDI Memory
                              454 ; 89   |#define MEDIA_DDI_MEM _Y
                              455 ; 90   |
                              456 ; 91   |
                              457 ; 92   |
                              458 ; 93   |// Pointers to linear structures are labeled as: p<type prefix>VarName
                              459 ; 94   |// Examples of circular pointers:
                              460 ; 95   |//    INT CIRC cpiVarName
                              461 ; 96   |//    DWORD CIRC cpdwVarName
                              462 ; 97   |
                              463 ; 98   |#define RETCODE INT                 // rcVarName
                              464 ; 99   |
                              465 ; 100  |// generic bitfield structure
                              466 ; 101  |struct Bitfield {
                              467 ; 102  |    unsigned int B0  :1;
                              468 ; 103  |    unsigned int B1  :1;
                              469 ; 104  |    unsigned int B2  :1;
                              470 ; 105  |    unsigned int B3  :1;
                              471 ; 106  |    unsigned int B4  :1;
                              472 ; 107  |    unsigned int B5  :1;
                              473 ; 108  |    unsigned int B6  :1;
                              474 ; 109  |    unsigned int B7  :1;
                              475 ; 110  |    unsigned int B8  :1;
                              476 ; 111  |    unsigned int B9  :1;
                              477 ; 112  |    unsigned int B10 :1;
                              478 ; 113  |    unsigned int B11 :1;
                              479 ; 114  |    unsigned int B12 :1;
                              480 ; 115  |    unsigned int B13 :1;
                              481 ; 116  |    unsigned int B14 :1;
                              482 ; 117  |    unsigned int B15 :1;
                              483 ; 118  |    unsigned int B16 :1;
                              484 ; 119  |    unsigned int B17 :1;
                              485 ; 120  |    unsigned int B18 :1;
                              486 ; 121  |    unsigned int B19 :1;
                              487 ; 122  |    unsigned int B20 :1;
                              488 ; 123  |    unsigned int B21 :1;
                              489 ; 124  |    unsigned int B22 :1;
                              490 ; 125  |    unsigned int B23 :1;
                              491 ; 126  |};
                              492 ; 127  |
                              493 ; 128  |union BitInt {
                              494 ; 129  |        struct Bitfield B;
                              495 ; 130  |        int        I;
                              496 ; 131  |};
                              497 ; 132  |
                              498 ; 133  |#define MAX_MSG_LENGTH 10
                              499 ; 134  |struct CMessage
                              500 ; 135  |{
                              501 ; 136  |        unsigned int m_uLength;
                              502 ; 137  |        unsigned int m_uMsg[MAX_MSG_LENGTH];
                              503 ; 138  |};
                              504 ; 139  |
                              505 ; 140  |typedef struct {
                              506 ; 141  |    WORD m_wLength;
                              507 ; 142  |    WORD m_wMessage;
                              508 ; 143  |    WORD m_wParams[MAX_MSG_LENGTH];
                              509 ; 144  |} Message;
                              510 ; 145  |
                              511 ; 146  |struct MessageQueueDescriptor
                              512 ; 147  |{
                              513 ; 148  |        int *m_pBase;
                              514 ; 149  |        int m_iModulo;
                              515 ; 150  |        int m_iSize;
                              516 ; 151  |        int *m_pHead;
TASKING DSP2410 assembler v1.5r1 Build 138 SN 00100122
                                                                                                                                                                                                                                                       Page   3

M:ADDR CODE           CYCLES LINE SOURCELINE
                              517 ; 152  |        int *m_pTail;
                              518 ; 153  |};
                              519 ; 154  |
                              520 ; 155  |struct ModuleEntry
                              521 ; 156  |{
                              522 ; 157  |    int m_iSignaledEventMask;
                              523 ; 158  |    int m_iWaitEventMask;
                              524 ; 159  |    int m_iResourceOfCode;
                              525 ; 160  |    struct MessageQueueDescriptor *m_pMessageQueue;
                              526 ; 161  |    int _asmfunc (*m_pProcessEntryPoint)(union WaitMask Signals,struct MessageQueueDescriptor *);
                              527 ; 162  |    int _asmfunc (*m_pInitFunction)(struct MessageQueueDescriptor *);
                              528 ; 163  |    int m_uTimeOutHigh;
                              529 ; 164  |    int m_uTimeOutLow;
                              530 ; 165  |    int _asmfunc (*m_pBackgroundFunction)(struct MessageQueueDescriptor *);
                              531 ; 166  |};
                              532 ; 167  |
                              533 ; 168  |union WaitMask{
                              534 ; 169  |    struct B{
                              535 ; 170  |        unsigned int m_bNone     :1;
                              536 ; 171  |        unsigned int m_bMessage  :1;
                              537 ; 172  |        unsigned int m_bTimer    :1;
                              538 ; 173  |        unsigned int m_bButton   :1;
                              539 ; 174  |    } B;
                              540 ; 175  |    int I;
                              541 ; 176  |} ;
                              542 ; 177  |
                              543 ; 178  |
                              544 ; 179  |struct Button {
                              545 ; 180  |        WORD wButtonEvent;
                              546 ; 181  |        WORD wUnused[MAX_MSG_LENGTH];   
                              547 ; 182  |};
                              548 ; 183  |
                              549 ; 184  |struct Message {
                              550 ; 185  |        WORD wMsgLength;
                              551 ; 186  |        WORD wMsgCommand;
                              552 ; 187  |        WORD wMsgParms[MAX_MSG_LENGTH-1];
                              553 ; 188  |};
                              554 ; 189  |
                              555 ; 190  |union EventTypes {
                              556 ; 191  |        struct CMessage msg;
                              557 ; 192  |        struct Button Button ;
                              558 ; 193  |        struct Message Message;
                              559 ; 194  |};
                              560 ; 195  |
                              561 ; 196  |// next 2 used to get updater build to return correct protocol ver in scsi response.
                              562 ; 197  |#define BUILD_TYPE_UPDATER  0x100
                              563 ; 198  |#define BUILD_TYPE_HOSTLINK 0x101
                              564 ; 199  |#define BUILD_TYPE_PLAYER   0x102
                              565 ; 200  |
                              566 ; 201  |// Resets part if RETAIL build. DEBUG build executes debug instruction to halt.
                              567 ; 202  |#define SystemHalt() __asm(" include 'sysmacro.asm' \n error") 
                              568 ; 203  |#define assert(x)    if(!(x)) __asm(" include 'sysmacro.asm' \n error")
                              569 ; 204  |
                              570 ; 205  |#if DEBUG
                              571 ; 206  |// For DEBUG builds, DebugBuildAssert(condition) halts if condition evaluates to FALSE. 
                              572 ; 207  |#define DebugBuildAssert(x)    if(!(x)) __asm(" debug ")
                              573 ; 208  |#else 
                              574 ; 209  |// For RETAIL builds, DebugBuildAssert(condition) does nothing & execution continues rather than halt or reset. 
                              575 ; 210  |#define DebugBuildAssert(x)    
                              576 ; 211  |#endif
                              577 ; 212  |
                              578 ; 213  |// Do this in your C files to make a reminder that's displayed during the build.
                              579 ; 214  |//  #pragma asm
                              580 ; 215  |//  WARN 'Note to builder: reminder to do this after verifying that'
                              581 ; 216  |//  #pragma endasm
                              582 ; 217  |
                              583 ; 218  |
                              584 ; 219  |#ifdef COLOR_262K
                              585 ; 220  |#define RGB(r,g,b)    ((0x0000FC & (r)) << 10) | ((0x0000FC & (g)) << 4) | ((0x0000FC & (b)) >> 2)    //262k
                              586 ; 221  |#elif defined(COLOR_65K)
                              587 ; 222  |#define RGB(r,g,b)    ((0x0000F8 & (r)) << 8) | ((0x0000FC & (g)) << 3) | ((0x0000F8 & (b)) >> 3)  //65k
                              588 ; 223  |#else
                              589 ; 224  |#define RGB(r,g,b)       ((0x0000F0 & (r)) << 4) | (0x0000F0 & (g)) | ((0x0000F0 & (b)) >> 4)
                              590 ; 225  |#endif
                              591 ; 226  |    
                              592 ; 227  |#endif // #ifndef _TYPES_H
                              593 
                              595 
                              596 ; 5    |
                              597 ; 6    |// move FSMEDIA_TABLE from devicetable.h  15Apr2005   First moved in SDK2.6.
                              598 ; 7    |typedef struct
                              599 ; 8    |{
                              600 ; 9    |
                              601 ; 10   |INT     _Y BytesPerSector;
                              602 ; 11   |INT     _Y SectorsPerCluster;
                              603 ; 12   |INT     _Y RsvdSectors;
                              604 ; 13   |INT     _Y NoOfFATs;
                              605 ; 14   |INT     _Y MaxRootDirEntries;
                              606 ; 15   |LONG    _Y TotalSectors;
                              607 ; 16   |LONG    _Y FATSize;
                              608 ; 17   |LONG    _Y RootdirCluster;
                              609 ; 18   |//INT   _Y FSInfoSector;
                              610 ; 19   |//INT   _Y BkBootSector;
                              611 ; 20   |LONG    _Y NextFreeCluster;
                              612 ; 21   |LONG    _Y TotalFreeClusters;
                              613 ; 22   |INT     _Y RootDirSectors;
                              614 ; 23   |INT     _Y FIRSTDataSector;
                              615 ; 24   |INT    _Y FATType;
                              616 ; 25   |LONG   _Y TotalNoofclusters;
                              617 ; 26   |INT    _Y ClusterMask;
                              618 ; 27   |INT    _Y ClusterShift;
                              619 ; 28   |INT    _Y SectorShift;
                              620 ; 29   |INT    _Y SectorMask;
                              621 ; 30   |INT    _Y DevicePresent;
                              622 ; 31   |LONG   _Y FirRootdirsec;
                              623 ; 32   |INT             _Y FSInfoSector;
                              624 ; 33   |}FSMEDIA_TABLE;
                              625 ; 34   |
                              626 ; 35   |
                              627 ; 36   |#define         MAXDEVICES              2
                              628 ; 37   |//#define       NUMCACHES               8  // this is already in fsproj.h (2 for player 2 for mtp as of 28jun2005) TOVERIFY 2 ok for player and mtp. 
                              629 ; 38   |
                              630 ; 39   |// NOTE:  This offset is the same no matter what the sector actual size!  
                              631 ; 40   |//        TOVERIFY 3.0 doesn't have this defined but uses it in filesystempresent.c. lbmlc def'd it here so I insert it here.
                              632 ; 41   |#define         FATFS_SIGNATURE_OFFSET  510
                              633 ; 42   |#define         BOOTSECTOR              0
                              634 ; 43   |#define     FSINFOSECTOR        1
                              635 ; 44   |
                              636 ; 45   |#define     READ_MODE           1
                              637 ; 46   |#define     WRITE_MODE          2
                              638 ; 47   |#define     APPEND_MODE         4
                              639 ; 48   |#define     SEQ_WRITE_MODE      8
                              640 ; 49   |#define     DIRECTORY_MODE         16
                              641 ; 50   |#define     CREATE_MODE        32
                              642 ; 51   |
                              643 ; 52   |#define     RPLUS               5
                              644 ; 53   |#define     WPLUS                   6
                              645 ; 54   |#define     APLUS               7
                              646 ; 55   |
                              647 ; 56   |
                              648 ; 57   |
                              649 ; 58   |#define     X_MEMORY            0
                              650 ; 59   |#define     Y_MEMORY            2
                              651 ; 60   |#define     P_MEMORY            4
                              652 ; 61   |
                              653 ; 62   |#define     FAT12               0 
                              654 ; 63   |#define     FAT16               1   
                              655 ; 64   |#define     FAT32               2 
                              656 ; 65   |
                              657 ; 66   |
                              658 ; 67   |#define FAT12EOF            0x0FFF
                              659 ; 68   |#define FAT16EOF            0xFFFF
                              660 ; 69   |#define FAT32EOF            0x0FFFFFFF
                              661 ; 70   |
                              662 ; 71   |
                              663 ; 72   |
                              664 ; 73   |#define FAT12FREECX         0x000
                              665 ; 74   |#define FAT16FREECX         0x0000
                              666 ; 75   |#define FAT32FREECX         0x00000000
                              667 ; 76   |
                              668 ; 77   |
                              669 ; 78   |#define  DBCS               1
                              670 ; 79   |#define  UNICODE            2
                              671 ; 80   |
                              672 ; 81   |
                              673 ; 82   |#define     CREATION_DATE       1
                              674 ; 83   |#define     CREATION_TIME       2
                              675 ; 84   |#define     MODIFICATION_DATE   3
                              676 ; 85   |#define     MODIFICATION_TIME   4
                              677 ; 86   |
                              678 ; 87   |
                              679 ; 88   |#define     READ_ONLY      0X01
                              680 ; 89   |#define     HIDDEN         0X02
                              681 ; 90   |#define     SYSTEM         0X04
                              682 ; 91   |#define     VOLUME_ID      0X08
                              683 ; 92   |#define     DIRECTORY      0X10
                              684 ; 93   |#define     ARCHIVE        0X20
                              685 ; 94   |
                              686 ; 95   |#define READCOUNTER         105
                              687 ; 96   |#define WRITECOUNTER        100
                              688 ; 97   |#define FLUSHCOUNTER        200
                              689 ; 98   |
                              690 ; 99   |
                              691 ; 100  |#define DEFAULT_MEMORY      Y_MEMORY
                              692 ; 101  |
                              693 ; 102  |#define  CWD_HANDLE           0
                              694 ; 103  |#define  DIRECTORY_HANDLE     1
                              695 ; 104  |#define  FIRST_VALID_HANDLE   2
                              696 ; 105  |#define  END_OF_DIR_PATH      3
                              697 ; 106  |
                              698 ; 107  |//Constants for Sector read and write (Normal and FAT 
                              699 ; 108  |#define         NORMALTYPE              0
                              700 ; 109  |#define         FATTYPE                 1
                              701 ; 110  |#define     RAWTYPE         2
                              702 ; 111  |
                              703 ; 112  |#define  SHORTNAMERES_CH      6
                              704 ; 113  |#define  LONGNAMERES_CH       9
                              705 ; 114  |#define  MAXFILENAME_CH       260
                              706 ; 115  |
                              707 ; 116  |#define VOLUME_TYPE          0
                              708 ; 117  |#define DIR_TYPE             1
                              709 ; 118  |#define FILE_TYPE            2
                              710 ; 119  |                                           
                              711 ; 120  |#define WRITE_TYPE_RANDOM               0
                              712 ; 121  |#define WRITE_TYPE_SEQ_FIRST    1
                              713 ; 122  |#define WRITE_TYPE_SEQ_NEXT             2
                              714 ; 123  |#define WRITE_TYPE_NOREADBACK   3
                              715 ; 124  |                  
                              716 ; 125  |
                              717 ; 126  |#define     HANDLEENTRYSIZE         19
                              718 ; 127  |
                              719 ; 128  |// DEVICERECORDSIZE is now only defined in cachedef.h so deleted from here in first 3.1 prelim 
                              720 ; 129  |
                              721 ; 130  |#define     CACHEDESCRSIZE          8
                              722 ; 131  |#define     CACHEBUFSIZE            705
                              723 ; 132  |
                              724 ; 133  |#define     UCS2s                     0
                              725 ; 134  |#define     UCS3s                     1
                              726 ; 135  |
                              727 ; 136  |#define     FAT32FSIFREECOUNTSIZE       4
                              728 ; 137  |
                              729 ; 138  |#endif // _FS_TYPE_H_
                              730 ; 139  |
                              731 
                              733 
                              734 ; 4    |#define MAX_FILESNAME   13
                              735 ; 5    |
                              736 ; 6    |typedef struct {
                              737 ; 7    |    INT     gCurrentRecord;
                              738 ; 8    |    INT     DirAttribute;
                              739 ; 9    |    _packed char    FileName[9];
                              740 ; 10   |    _packed char    FileExtension[4];
                              741 ; 11   |}FILESPEC;
                              742 ; 12   |
                              743 ; 13   |typedef struct {
                              744 ; 14   |    INT attrib;
                              745 ; 15   |        LONG FileSize;
                              746 ; 16   |    int  device;
                              747 ; 17   |    INT startrecord;
                              748 ; 18   |    _packed char name[MAX_FILESNAME];
                              749 ; 19   |        LONG Key;
                              750 ; 20   |}Finddata;
                              751 ; 21   |#endif
                              752 ; 22   |
                              753 
                              755 
                              756 ; 4    |extern _reentrant LONG Ftell(INT HandleNumber);
                              757 ; 5    |extern _reentrant LONG Feof(INT HandleNumber);
                              758 ; 6    |extern _reentrant INT *Fputs(INT HandleNumber,INT *Buffer);
                              759 ; 7    |extern _reentrant LONG Fread(INT HandleNumber,INT *Buffer,LONG NumBytesToRead,INT Source_Memory,INT MOdulo);
                              760 ; 8    |extern _reentrant INT Fgetc(INT HandleNumber);
                              761 ; 9    |extern _reentrant INT Fputc(INT HandleNumber,INT ByteToWrite);
                              762 ; 10   |extern _reentrant LONG ReadDirectoryRecord(INT HandleNumber,INT RecordNumber,INT *Buffer);
                              763 ; 11   |extern _reentrant INT Fseek(INT HandleNumber,LONG NumBytesToSeek,INT SeekPosition);
                              764 ; 12   |extern _reentrant INT Fopen(_packed char *filepath,_packed char *mode);
                              765 ; 13   |extern _reentrant LONG Fwrite(INT HandleNumber,INT  *Buffer,LONG NumBytesToWrite,INT Source_Memory,INT MOdulo);
                              766 ; 14   |extern _reentrant LONG Totalfreecluster(INT DeviceNum);
                              767 ; 15   |extern _reentrant INT Rmdir(_packed char *filepath);
                              768 ; 16   |extern _reentrant INT Rmdirw(_packed char *filepath);
                              769 ; 17   |extern _reentrant INT Mkdir(_packed char *filepath);
                              770 
TASKING DSP2410 assembler v1.5r1 Build 138 SN 00100122
                                                                                                                                                                                                                                                       Page   4

M:ADDR CODE           CYCLES LINE SOURCELINE
                              772 
                              773 ; 18   |
                              774 ; 19   |        //      SGTL-HK 27-05-2005
                              775 ; 20   |extern _reentrant INT Mkdirw(UCS3 *filepath);
                              776 ; 21   |
                              777 ; 22   |extern _reentrant INT Chdir(_packed char *filepath);
                              778 ; 23   |extern _reentrant INT FastOpen(LONG Key,_packed char *mode);
                              779 ; 24   |
                              780 ; 25   |extern _reentrant INT Setcwd(_packed char *filepath, _packed char *gCworkingDir,INT index,INT length);
                              781 ; 26   |extern _reentrant _packed char *Getcwd(void);
                              782 ; 27   |extern  _reentrant _packed char *Fgets(INT HandleNumber,INT NumBytesToRead, _packed char *Buffer);
                              783 ; 28   |extern INT  FSInit(INT _X *bufx, INT _Y *bufy, INT maxdevices, INT maxhandles, INT maxcaches);
                              784 ; 29   |extern INT  FlushCache(void);
                              785 ; 30   |extern _reentrant INT FsShutDown(void);
                              786 ; 31   |extern _reentrant LONG GetFileSize(INT HandleNumber);
                              787 ; 32   |
                              788 ; 33   |extern _reentrant INT filegetattrib(_packed char *FilePath);
                              789 ; 34   |extern _reentrant INT Fopenw(INT *filepath,_packed char *mode);
                              790 ; 35   |extern _reentrant INT Fremove(_packed char *filepath);
                              791 ; 36   |extern _reentrant INT Fremovew(_packed char *filepath);
                              792 ; 37   |extern _reentrant void DBCSToUnicode(_packed unsigned char *pDBCS, WORD *pUnicode,INT iLength);
                              793 ; 38   |extern INT FlushCache(void);
                              794 ; 39   |extern _reentrant INT DeleteTree(_packed char *Path);
                              795 ; 40   |extern _reentrant INT Fclose(INT HandleNumber);
                              796 ; 41   |extern INT FSMediaPresent(INT DeviceNum);
                              797 ; 42   |extern INT FSFATType (INT DeviceNum);
                              798 ; 43   |extern  INT _reentrant  GetVolumeLabel(_packed char *Buffer,INT DeviceNum);
                              799 ; 44   |extern _reentrant INT SetVolumeLabel(_packed char *Buffer,INT DeviceNum);
                              800 ; 45   |extern _reentrant LONG FgetFastHandle(INT HandleNumber);
                              801 ; 46   |
                              802 ; 47   |extern _reentrant INT ConstructLongFileName(INT HandleNumber, INT RecordNumber, INT *LFNBuffer);
                              803 ; 48   |extern _reentrant void Uppercase(_packed char *file); 
                              804 ; 49   |extern _reentrant INT FindNext(INT HandleNumber,Finddata *_finddata);
                              805 
                              815 
                              816 ; 50   |extern _reentrant INT FindFirst(Finddata *_finddata,_packed char *FileName);
                              817 ; 51   |extern _reentrant void ClearData(Finddata *_finddata);
                              818 ; 52   |extern _reentrant INT GetShortfilename(LONG Key,INT *Buffer);
                              819 ; 53   |
                              820 ; 54   |
                              821 ; 55   |
                              822 ; 56   |
                              823 ; 57   |typedef struct
                              824 ; 58   |{
                              825 ; 59   |
                              826 ; 60   |INT             Day;
                              827 ; 61   |INT             Month;
                              828 ; 62   |INT             Year;
                              829 ; 63   |}DIR_DATE;
                              830 ; 64   |
                              831 ; 65   |
                              832 ; 66   |typedef struct
                              833 ; 67   |{
                              834 ; 68   |
                              835 ; 69   |INT             Second;
                              836 ; 70   |INT             Minute;
                              837 ; 71   |INT             Hour;
                              838 ; 72   |}DIR_TIME;
                              839 ; 73   |
                              840 ; 74   |
                              841 ; 75   |typedef struct
                              842 ; 76   |{
                              843 ; 77   |LONG CurrentOffset;     
                              844 ; 78   |LONG CurrentCluster;
                              845 ; 79   |}HANDLECONTEXT;
                              846 ; 80   |
                              847 ; 81   |extern _reentrant INT filesetattrib(INT HandleNumber,INT dirattribute);
                              848 ; 82   |extern _reentrant INT filesetdate(_packed char *FilePath,INT crt_mod_date_time_para,DIR_DATE *dirdate,DIR_TIME *dirtime);
                              849 
                              860 
                              861 ; 83   |extern _reentrant INT filegetdate(INT HandleNumber,INT crt_mod_date_time_para,DIR_DATE *dirdate,DIR_TIME *dirtime);
                              862 ; 84   |#endif
                              863 
                              865 
                              866 ; 13   |#include "sysmem.h"
                              867 
                              869 
                              870 ; 1    |//;******************************************************************************
                              871 ; 2    |//; Copyright(C) SigmaTel, Inc. 2000-2003
                              872 ; 3    |//; File: sysmem.h
                              873 ; 4    |//; ST System Memory Externs
                              874 ; 5    |//;******************************************************************************
                              875 ; 6    |
                              876 ; 7    |#ifndef SYSMEM_XREF_C
                              877 ; 8    |#define SYSMEM_XREF_C
                              878 ; 9    |
                              879 ; 10   |// Variables in X
                              880 ; 11   |extern unsigned int _X g_wDecoderCSR;
                              881 ; 12   |extern unsigned int _X g_wDecoderSR;
                              882 ; 13   |extern unsigned int _X g_wDecoderCSR2;  // DECODE2EOF
                              883 ; 14   |extern unsigned int _X g_wEncoderSR;
                              884 ; 15   |extern unsigned int _X g_wEncoderCSR;
                              885 ; 16   |extern unsigned int _X g_wRecStartTimeHigh;
                              886 ; 17   |extern unsigned int _X g_wRecStartTimeLow;
                              887 ; 18   |extern unsigned int _X g_wSysError;
                              888 ; 19   |#ifdef TRACEBUF_EN
                              889 ; 20   |extern unsigned int _X g_wTraceBuffer; //Disabled by default.   
                              890 ; 21   |extern unsigned int _X g_wTracePointer;
                              891 ; 22   |#endif
                              892 ; 23   |extern unsigned int _X g_wUserScratchX[];
                              893 ; 24   |extern unsigned int _X g_wNextVoiceNumValue;
                              894 ; 25   |extern unsigned int _X g_wEncAdpcmSave_r7;
                              895 ; 26   |extern unsigned int _X g_wEncAdpcmSave_m7;
                              896 ; 27   |extern unsigned int _X g_wEncModuleState;
                              897 ; 28   |extern unsigned int _X g_wEncoderIsrSR;
                              898 ; 29   |extern unsigned int _X g_bAudibleNeedFileSize;          // 10/12/04 mmiu - Added for AA file navigation
                              899 ; 30   |extern unsigned int _X g_bAudiblePlayThrough;           // 11/1/04 mmiu - Added for file position play-through indicator
                              900 ; 31   |extern unsigned int _X g_wSongStartOffsetHigh;          // 11/1/04 mmiu - Added until confirmed we can use g_wSongByteTotalConsumedHigh/Low
                              901 ; 32   |extern unsigned int _X g_wSongStartOffsetLow;
                              902 ; 33   |
                              903 ; 34   |// Variables in Y
                              904 ; 35   |extern int          _Y g_VolumeBias;
                              905 ; 36   |extern unsigned int _Y g_wCurrentRoutinePtr;
                              906 ; 37   |extern unsigned int _Y g_wSystemFileHandle;
                              907 ; 38   |extern unsigned int _Y g_wSongByteTotalHigh;
                              908 ; 39   |extern unsigned int _Y g_wSongByteTotalLow; 
                              909 ; 40   |extern unsigned int _Y g_wSongByteLengthHigh;
                              910 ; 41   |extern unsigned int _Y g_wSongByteLengthLow;
                              911 ; 42   |extern unsigned int _Y g_wInvSampleRate;
                              912 ; 43   |extern unsigned int _Y g_wCurrentSongBad;
                              913 ; 44   |extern unsigned int _Y g_iSongType;
                              914 ; 45   |extern _packed BYTE _Y g_CurrentSongName[];
                              915 ; 46   |extern unsigned int _Y g_wCurrentDirDevId;
                              916 ; 47   |extern unsigned int _Y g_wSongInvBitRatePtr;
                              917 ; 48   |extern unsigned int _Y g_wUserScratchXDescriptor;
                              918 ; 49   |extern unsigned int _Y g_wUserScratchYDescriptor;
                              919 ; 50   |extern _packed BYTE _Y g_EncFileNameString[];
                              920 ; 51   |extern unsigned int _Y g_wEncFileHandle;
                              921 ; 52   |extern unsigned int _Y g_wEncAdpcmOvlSave_sp;
                              922 ; 53   |extern unsigned int _Y g_wRootDirectory;
                              923 ; 54   |extern unsigned int _Y g_wUserScratchY[];
                              924 ; 55   |extern unsigned int _Y g_wPrevInvBitRatePtr;
                              925 ; 56   |
                              926 ; 57   |#endif  // SYSMEM_XREF_C
                              927 
                              929 
                              930 ; 14   |#include "silencedetection.h"
                              931 
                              933 
                              934 ; 1    |///////////////////////////////////////////////////////////////////////////////
                              935 ; 2    |// Copyright(C) SigmaTel, Inc. 2000
                              936 ; 3    |
                              937 ; 4    |// System defs
                              938 ; 5    |///////////////////////////////////////////////////////////////////////////////
                              939 ; 6    |
                              940 ; 7    |#define STOP_ENCODER_IDLE 2
                              941 ; 8    |
                              942 ; 9    |#define SILENCE_DETECTED  1
                              943 ; 10   |
                              944 ; 11   |#define AUDIO_DETECTED    0
                              945 ; 12   |
                              946 ; 13   |#define THRESHOLD_ENERGY  64000
                              947 ; 14   |
                              948 ; 15   |#define SILENCE_PERIOD  3                          // Silence Period = 3 Seconds
                              949 ; 16   |
                              950 ; 17   |#define IDLE_SILENCE_PERIOD 300                                         //  5 minutes before it goes idle
                              951 ; 18   |
                              952 ; 19   |extern int _Y Mp3Enc_NumChannels;
                              953 ; 20   |
                              954 ; 21   |extern int _Y MP3EncoderBufHeadPtr;
                              955 ; 22   |
                              956 ; 23   |extern int _Y MP3EncoderBufSizePtr;
                              957 ; 24   |
                              958 ; 25   |extern int _Y MP3EncoderBufAddrPtr;
                              959 ; 26   |
                              960 ; 27   |extern int _asmfunc FindEnergy(int BlockSize,int Ptr, int NumChannels,int modulo);
                              961 ; 28   |
                              962 ; 29   |int CheckSilenceBlockCount(void);
                              963 ; 30   |
                              964 
                              966 
                              967 ; 15   |#include "sysequ.h"
                              968 
                              970 
                              971 ; 1    |/////////////////////////////////////////////////////////////////////////////////
                              972 ; 2    |// Copyright(C) SigmaTel, Inc. 2000
                              973 ; 3    |// System defs
                              974 ; 4    |/////////////////////////////////////////////////////////////////////////////////
                              975 ; 5    |
                              976 ; 6    |#if (!defined(SYSEQU_INC))
                              977 ; 7    |#define SYSEQU_INC 1
                              978 ; 8    |
                              979 ; 9    |#define SOFTTIMER_CONTINUOUS_EVENT 0
                              980 ; 10   |
                              981 ; 11   |
                              982 ; 12   |#define HOLD_BUTTON_REPORTED_BITMASK 4
                              983 ; 13   |
                              984 ; 14   |
                              985 ; 15   |// Decoder types
                              986 ; 16   |#define DECODER_TYPE_MP3 0
                              987 ; 17   |#define DECODER_TYPE_WMA 1
                              988 ; 18   |#define DECODER_TYPE_AAC 2
                              989 ; 19   |#define DECODER_TYPE_ADPCM_IMA 3
                              990 ; 20   |#define DECODER_TYPE_ADPCM_MS 4
                              991 ; 21   |#define DECODER_TYPE_PCM 5
                              992 ; 22   |#define DECODER_TYPE_STFM 6
                              993 ; 23   |
                              994 ; 24   |// Encoder types
                              995 ; 25   |#define ENCODER_TYPE_ADPCM_IMA 0
                              996 ; 26   |#define ENCODER_TYPE_PCM 1
                              997 ; 27   |#define ENCODER_TYPE_MP3 2
                              998 ; 28   |
                              999 ; 29   |// EncoderSR/EncoderCSR bit equates.  Also uses Stop & Play below.
                             1000 ; 30   |#define EncNotEnoughSpace 0
                             1001 ; 31   |#define EncRanOutOfSpace 1
                             1002 ; 32   |#define EncRecordError 2
                             1003 ; 33   |#define EncToldToStop 3
                             1004 ; 34   |#define EncAlreadyRecording 4
                             1005 ; 35   |// ENCODER_STOPPED       equ     6   ; As RecorderStateMachine.h
                             1006 ; 36   |#define EncWarnLowSpace 7
                             1007 ; 37   |#define EncWarningSent 8
                             1008 ; 38   |// ENCODER_RECORDING     equ     12
                             1009 ; 39   |
                             1010 ; 40   |// DecoderSR/DecoderCSR bit equates
                             1011 ; 41   |//  This bit is set when the decoder sends a message to the parser and is 
                             1012 ; 42   |#define DecoderIgnoreMessages 0   
                             1013 ; 43   |//  waiting for a response.
                             1014 ; 44   |#define VBRFlag 1
                             1015 ; 45   |#define RepeatSong 2
                             1016 ; 46   |#define RepeatAll 3
                             1017 ; 47   |#define Random 4
                             1018 ; 48   |#define Pause 5
                             1019 ; 49   |#define Stop 6
                             1020 ; 50   |#define Rwnd 7
                             1021 ; 51   |#define Ffwd 8
                             1022 ; 52   |#define TimeMode 9
                             1023 ; 53   |// set when Fstatus_o = 1 for mp3 
                             1024 ; 54   |#define DecSync 10    
                             1025 ; 55   |#define Play 12
                             1026 ; 56   |// starting with sdk2.105: changed to set when decoder done instead of when file reads done 
                             1027 ; 57   |#define EndOfSong 13    
                             1028 ; 58   |#define EndOfList 14
                             1029 ; 59   |#define SongInfo 15
                             1030 ; 60   |// set when a song file is currently opened by the decoder
                             1031 ; 61   |#define FileIsOpen 16    
                             1032 ; 62   |// used by parser
                             1033 ; 63   |#define SkipBlockHeader 17    
                             1034 ; 64   |#define ABMode_A 18
                             1035 ; 65   |#define ABMode_B 19
                             1036 ; 66   |#define ABQuiet 20
                             1037 ; 67   |// set if bad file encountered
                             1038 ; 68   |#define BadFile 21    
                             1039 ; 69   |// mp3 decoder looking for sync
                             1040 ; 70   |#define SyncWait 22    
                             1041 ; 71   |// error reading file, duh
                             1042 ; 72   |#define FileReadError 23    
                             1043 ; 73   |
                             1044 ; 74   |// DecoderCSR2 bit equates
                             1045 ; 75   |//Set when EOF reached, prevent freads beyond EOF 
                             1046 ; 76   |#define EndOfFileReached 0  
                             1047 ; 77   |// Set when need to allow LCD to update time
TASKING DSP2410 assembler v1.5r1 Build 138 SN 00100122
                                                                                                                                                                                                                                                       Page   5

M:ADDR CODE           CYCLES LINE SOURCELINE
                             1048 ; 78   |#define TimeNeedsUpdate 1  
                             1049 ; 79   |
                             1050 ; 80   |
                             1051 ; 81   |// ParserVoiceCSR bits (specific to voice files)
                             1052 ; 82   |// repeat playing current file
                             1053 ; 83   |#define RepeatOneFile 0     
                             1054 ; 84   |// continuously loop through files
                             1055 ; 85   |#define RepeatAllFiles 1     
                             1056 ; 86   |// start at current file, play all files, then stop
                             1057 ; 87   |#define LoopOnce 2     
                             1058 ; 88   |
                             1059 ; 89   |// DecAdpcmFlags bits (used by ADPCM decoders)
                             1060 ; 90   |// Set to '1' when header unpacked, cleared during StopCurrentSong
                             1061 ; 91   |#define WaveHeaderFound 0       
                             1062 ; 92   |
                             1063 ; 93   |#if (defined(TRACEBUF_EN))
                             1064 ; 94   |// Trace buffer words.  Not ENabled by default.
                             1065 ; 95   |#define TRACE_BUFF_SIZE 256
                             1066 ; 96   |#define TRACE_BUFF_MODULO TRACE_BUFF_SIZE-1 
                             1067 ; 97   |#endif
                             1068 ; 98   |
                             1069 ; 99   |// Scratch area stuff
                             1070 ; 100  |#if defined(STMP_BUILD_PLAYER)
                             1071 ; 101  |#define SCRATCH_USER_Y_SIZE 512
                             1072 ; 102  |#define SCRATCH_USER_X_SIZE 256
                             1073 ; 103  |#else 
                             1074 ; 104  |#if defined(FAT32TEST)
                             1075 ; 105  |#define SCRATCH_USER_Y_SIZE 683
                             1076 ; 106  |#define SCRATCH_USER_X_SIZE 128
                             1077 ; 107  |#else 
                             1078 ; 108  |#define SCRATCH_USER_Y_SIZE 128
                             1079 ; 109  |#define SCRATCH_USER_X_SIZE 128
                             1080 ; 110  |#endif
                             1081 ; 111  |#endif
                             1082 ; 112  |
                             1083 ; 113  |#define SCRATCH_USER_X_SIZE_BYTES SCRATCH_USER_X_SIZE*3
                             1084 ; 114  |#define SCRATCH_USER_X_MODULO SCRATCH_USER_X_SIZE-1
                             1085 ; 115  |#define SCRATCH_USER_Y_SIZE_BYTES SCRATCH_USER_Y_SIZE*3
                             1086 ; 116  |#define SCRATCH_USER_Y_MODULO SCRATCH_USER_Y_SIZE-1
                             1087 ; 117  |
                             1088 ; 118  |// Boot ROM execute location
                             1089 ; 119  |#define BootExecuteCommand 0x012B
                             1090 ; 120  |
                             1091 ; 121  |#define BOOT_USB 0x000002
                             1092 ; 122  |#define BOOT_SMARTMEDIA 0x000004
                             1093 ; 123  |#define BOOT_COMPACTFLASH 0x000005
                             1094 ; 124  |#define BOOT_I2C_SLAVE 0x000009
                             1095 ; 125  |#define BOOT_I2C_MASTER 0x00000A
                             1096 ; 126  |#define BOOT_SPI_SLAVE 0x00000B
                             1097 ; 127  |#define BOOT_SPI_MASTER 0x00000C
                             1098 ; 128  |#define BOOT_HOSTPORT 0x00000D
                             1099 ; 129  |#define BOOT_BURNIN 0x00000F
                             1100 ; 130  |
                             1101 ; 131  |// Numerical constants
                             1102 ; 132  |//PI              equ     3.141592654
                             1103 ; 133  |
                             1104 ; 134  |// Buffer Descriptor offsets
                             1105 ; 135  |#define BD_BufferBaseAddress 0
                             1106 ; 136  |#define BD_BufferModulo 1
                             1107 ; 137  |#define BD_BufferSize 2
                             1108 ; 138  |#define BD_HdPtr 3
                             1109 ; 139  |#define BD_TailPtr 4
                             1110 ; 140  |
                             1111 ; 141  |// Size of a buffer descriptor
                             1112 ; 142  |#define BUFF_DESC_SIZE 5
                             1113 ; 143  |
                             1114 ; 144  |// Mp3 Song Table Descriptor Offsets
                             1115 ; 145  |// number of elements for each song
                             1116 ; 146  |#define MST_ELEMENT_COUNT 7        
                             1117 ; 147  |#define MST_CARD_NUMBER 0
                             1118 ; 148  |#define MST_ADDR_LOW 1
                             1119 ; 149  |#define MST_ADDR_HIGH 2
                             1120 ; 150  |#define MST_BYTES_LOW 3
                             1121 ; 151  |#define MST_BYTES_HIGH 4
                             1122 ; 152  |#define MST_SAMPLE_RATE 5
                             1123 ; 153  |#define MST_SONG_TYPE 6
                             1124 ; 154  |
                             1125 ; 155  |// Data Format Descriptor offsets
                             1126 ; 156  |#define DF_NumChannels 0
                             1127 ; 157  |#define DF_SampleRate 1
                             1128 ; 158  |#define DF_BitsPerSample 2
                             1129 ; 159  |
                             1130 ; 160  |
                             1131 ; 161  |// Timer Descriptor Offset
                             1132 ; 162  |#define TD_TimerNumber 0
                             1133 ; 163  |#define TD_ControlValue 1
                             1134 ; 164  |#define TD_CountValue 2
                             1135 ; 165  |#define TD_ControlRegister 3
                             1136 ; 166  |#define TD_CountRegister 4
                             1137 ; 167  |
                             1138 ; 168  |
                             1139 ; 169  |// File IO defines
                             1140 ; 170  |#define FileInPort 0x8000
                             1141 ; 171  |#define FileOutPort 0x8001
                             1142 ; 172  |#define OnceInPort 0x8000
                             1143 ; 173  |#define OnceOutPort 0x8001
                             1144 ; 174  |#define SmFakeInPort 0x8002
                             1145 ; 175  |#define SmFakeOutPort 0x8003
                             1146 ; 176  |#define UsbFakeInPort 0x8004
                             1147 ; 177  |#define UsbFakeOutPort 0x8005
                             1148 ; 178  |
                             1149 ; 179  |// Target memory stuff
                             1150 ; 180  |#define TARGET_MEM_MASK 0xF00000
                             1151 ; 181  |#define TARGET_MEM_X 0x800000
                             1152 ; 182  |#define TARGET_MEM_Y 0x400000
                             1153 ; 183  |#define TARGET_MEM_L 0x200000
                             1154 ; 184  |#define TARGET_MEM_P 0x100000
                             1155 ; 185  |
                             1156 ; 186  |#define TARGET_MEM_X_BITPOS 23
                             1157 ; 187  |#define TARGET_MEM_Y_BITPOS 22
                             1158 ; 188  |#define TARGET_MEM_L_BITPOS 21
                             1159 ; 189  |#define TARGET_MEM_P_BITPOS 20
                             1160 ; 190  |
                             1161 ; 191  |
                             1162 ; 192  |// File System Stuff
                             1163 ; 193  |// assume 3 deep max with 8.3 format (38 bytes inc. /'s)
                             1164 ; 194  |#define MaxDirCount 13         
                             1165 ; 195  |
                             1166 ; 196  |// Error Codes
                             1167 ; 197  |//      Value           Error
                             1168 ; 198  |//      --------------------------------------------
                             1169 ; 199  |//      $000000         Reserved - no error
                             1170 ; 200  |//      $000001         SmartMedia Bad Programming Error
                             1171 ; 201  |//      $000002         SmartMedia Read Timeout
                             1172 ; 202  |//      $000003         USB PLL Lock Timeout
                             1173 ; 203  |//       $000010         GetNumSongs returned an error
                             1174 ; 204  |//       $000011         fopen failed to open file number (in x:TrackNum)
                             1175 ; 205  |//       $000012         fread failed when attempting to read page
                             1176 ; 206  |//       $000013         fread failed to read correct number of bytes
                             1177 ; 207  |#define NO_ERROR 0x000000
                             1178 ; 208  |#define ERROR_PLL_LOCK_TIMEOUT 0x000001
                             1179 ; 209  |
                             1180 ; 210  |#define ERROR_SM_BADP 0x000100
                             1181 ; 211  |#define ERROR_SM_TIMEOUT 0x000101
                             1182 ; 212  |#define ERROR_SM_INVALID_BLOCK 0x000102
                             1183 ; 213  |#define ERROR_SM_INVALID_DATA 0x000103
                             1184 ; 214  |#define ERROR_SM_ECC 0x000104
                             1185 ; 215  |#define ERROR_SM_BLOCK_ERASE_FAILED 0x000105
                             1186 ; 216  |#define ERROR_SM_CARD_NOT_FOUND 0x000106
                             1187 ; 217  |#define ERROR_SM_BUSY_TIMEOUT 0x000107
                             1188 ; 218  |#define ERROR_SM_WRITE_FAILED 0x000108
                             1189 ; 219  |#define ERROR_SM_DEVICE_ID 0x000109
                             1190 ; 220  |
                             1191 ; 221  |#define ERROR_NUM_SONGS 0x000200
                             1192 ; 222  |#define ERROR_FOPEN_FILENUM 0x000201
                             1193 ; 223  |#define ERROR_FREAD_PAGE 0x000202
                             1194 ; 224  |#define ERROR_FREAD_BYTE_COUNT 0x000203
                             1195 ; 225  |#define ERROR_CREATING_VOICE_DIR 0x000204 
                             1196 ; 226  |
                             1197 ; 227  |#define ERROR_USB_DISCONNECTED 0x000300
                             1198 ; 228  |
                             1199 ; 229  |#define ERROR_DECODER_PLAYING 0x000400
                             1200 ; 230  |// Attempted to set position past the end of file
                             1201 ; 231  |#define ERROR_DECODER_SETPOS 0x000401             
                             1202 ; 232  |
                             1203 ; 233  |// PLL defs
                             1204 ; 234  |// According to Mike May, the PLL takes about 200us to stabalize, worst-case.
                             1205 ; 235  |//   PLL lock delay is $000000001388 = 5000. We're always using the xtal at
                             1206 ; 236  |//   24.576MHz, so this delay is 5000/(24.576MHz) = 203.5us.  We'll do this 5000
                             1207 ; 237  |//   times for a total of 1.017s.
                             1208 ; 238  |#define PLL_LOCK_DELAY_HIGH 0x000000
                             1209 ; 239  |#define PLL_LOCK_DELAY_LOW 0x001388
                             1210 ; 240  |#define PLL_TIMEOUT 0x001388
                             1211 ; 241  |
                             1212 ; 242  |// Generic wait defs
                             1213 ; 243  |#define WAIT_10_MS 245760/2
                             1214 ; 244  |
                             1215 ; 245  |//Those equates are used in the DCC/USBMSC
                             1216 ; 246  |//Low battery detection bit
                             1217 ; 247  |#define LOW_BATTERY_DETECTED_BITPOS 0
                             1218 ; 248  |
                             1219 ; 249  |#endif // IF (!@def(SYSEQU_INC))
                             1220 ; 250  |
                             1221 ; 251  |
                             1222 
                             1224 
                             1225 ; 16   |#include "encoderproperties.h"
                             1226 
                             1228 
                             1229 ; 1    |/////////////////////////////////////////////////////////////////////////////////
                             1230 ; 2    |// Copyright(C) SigmaTel, Inc. 2000-2006
                             1231 ; 3    |//
                             1232 ; 4    |// Filename: encoderproperties.h
                             1233 ; 5    |// Description: Definitions used in manipulating Encoder Properties
                             1234 ; 6    |/////////////////////////////////////////////////////////////////////////////////
                             1235 ; 7    |
                             1236 ; 8    |extern _Y WORD g_wEncSamplingRate;
                             1237 ; 9    |extern _Y WORD g_wEncBitRate;
                             1238 ; 10   |extern _Y WORD g_wEncADCGain;
                             1239 ; 11   |extern _Y WORD g_wEncADCSRR;
                             1240 ; 12   |extern _Y WORD g_wEncInvSampleRateScale;
                             1241 ; 13   |extern _Y WORD g_wEncNAvgBytesPerSec;
                             1242 ; 14   |extern _Y WORD g_wEncClusterTimeScale;
                             1243 ; 15   |extern _X WORD g_wEncoderSR;
                             1244 ; 16   |extern _Y WORD g_wEncCurrentDeviceNum;
                             1245 ; 17   |extern _Y WORD g_wEncFormatTag;
                             1246 ; 18   |extern _Y WORD g_wEncNumberOfChannels;
                             1247 ; 19   |extern _Y WORD g_wEncPCMBits;
                             1248 ; 20   |extern _Y _packed BYTE g_EncFileNameString[];
                             1249 ; 21   |extern _Y WORD g_wSamplingRateIndex;
                             1250 ; 22   |extern _Y WORD g_wEncSamplingRateIdx;
                             1251 ; 23   |extern _Y _fract g_wEncADCLChOffset;
                             1252 ; 24   |extern _Y _fract g_wEncADCRChOffset;
                             1253 ; 25   |extern _X _fract DCOffsetADC[2][7];
                             1254 ; 26   |
                             1255 ; 27   |                             // struct passed as argument to EncSetProperties
                             1256 ; 28   |typedef struct {
                             1257 ; 29   |  int    device;
                             1258 ; 30   |  _packed BYTE *pFilename;
                             1259 ; 31   |  int    samplingRateInHz;
                             1260 ; 32   |  int    bitRateInKbps;
                             1261 ; 33   |  int    FormatTag; // Algorithm. 1 = PCMWAVE, 2 = MS ADPCM, 0x11 = IMA ADPCM
                             1262 ; 34   |  int    EncNumberOfChannels;
                             1263 ; 35   |  int    EncPCMBits;    // Number of bits for PCMWAVE (8,16,24), else ignored
                             1264 ; 36   |  int    iSource;     // Note: Not implemeted, yet.
                             1265 ; 37   |} EncProperties;
                             1266 ; 38   |
                             1267 ; 39   |typedef struct {
                             1268 ; 40   |  WORD   wNSamplesPerSec;
                             1269 ; 41   |  WORD   wADCGain;
                             1270 ; 42   |  WORD   wADCSRR;
                             1271 ; 43   |  WORD   wInvSampleRateScale;
                             1272 ; 44   |  WORD   wNAvgBytesPerSec;
                             1273 ; 45   |  WORD   wClusterTimeScale;
                             1274 ; 46   |} EncoderSampleRateParms;
                             1275 
                             1288 
                             1289 ; 47   |
                             1290 ; 48   |RETCODE _reentrant EncSetProperties(EncProperties *pProps);
                             1291 ; 49   |
                             1292 ; 50   |// Access functions (macros)
                             1293 ; 51   |
                             1294 ; 52   |#define EncGetSampleRateInHz()  (g_wEncNSamplesPerSec)
                             1295 ; 53   |
                             1296 ; 54   |
                             1297 ; 55   |// These properties are not yet implemented
                             1298 ; 56   |
                             1299 ; 57   |#define EncGetDevice()          (0)
                             1300 ; 58   |#define EncGetFilename()        ("")
                             1301 ; 59   |#define EncGetEncodingMethod()  (0)
                             1302 ; 60   |
                             1303 ; 61   |
                             1304 ; 62   |#define ERROR_ENCODER_INVALID_SAMPLE_RATE ((RETCODE)(-1))
                             1305 ; 63   |#define ERROR_ENCODER_IS_ACTIVE           ((RETCODE)(-2))
                             1306 ; 64   |
                             1307 ; 65   |
                             1308 ; 66   |
                             1309 ; 67   |
                             1310 ; 68   |
                             1311 ; 69   |
                             1312 
TASKING DSP2410 assembler v1.5r1 Build 138 SN 00100122
                                                                                                                                                                                                                                                       Page   6

M:ADDR CODE           CYCLES LINE SOURCELINE
                             1314 
                             1315 ; 17   |
                             1316 ; 18   |int SilenceSR; 
                             1317 ; 19   |int SilencePtr;   
                             1318 ; 20   |int SilenceCount;
                             1319 ; 21   |int MaxSilenceCnt;
                             1320 ; 22   |int MaxDelay;
                             1321 ; 23   |
                             1322 ; 24   |/*//////////////////////////////////////////////////////////////////////////////
                             1323 ; 25   |
                             1324 ; 26   |/*  Name:  ComputeDCOffsetInit
                             1325 ; 27   |
                             1326 ; 28   |    Type:       void ComputeDCOffsetInit(SamplingRate,*SourceBufDesc_Ptr)
                             1327 ; 29   |
                             1328 ; 30   |    Description: initializes silence variables
                             1329 ; 31   |
                             1330 ; 32   |    Inputs:             
                             1331 ; 33   |                        1)  sampling rate 
                             1332 ; 34   |            2)  pointer to the source buffer descriptor
                             1333 ; 35   |    Outputs:            
                             1334 ; 36   |                        Nil
                             1335 ; 37   |    Notes: 
                             1336 ; 38   |                        
                             1337 ; 39   |//////////////////////////////////////////////////////////////////////////////*/
                             1338 ; 40   |static int DCOffsetPtr;       
                             1339 ; 41   |static int DCOffsetPwr;             // Blocks desired (power of 2)
                             1340 ; 42   |static int DCOffsetCnt;             // = 2^DCOffsetPwr;  
                             1341 ; 43   |static int DCOffsetBlocksProcessed; // Blocks processed
                             1342 ; 44   |static int DCOffsetSetback;         // Delay timer to start measurements to let ADC/MIXER voltage stabilize
                             1343 ; 45   |static  _fract DCOffset[2];        
                             1344 ; 46   |
                             1345 ; 47   |// Max ofset is aprox 2% of full scale
                             1346 ; 48   |#define MAX_DC_OFFSET 02
                             1347 ; 49   |
                             1348 ; 50   |extern _fract _asmfunc FindDCOffset(int BlockSize,int Ptr, int NumChannels,int modulo);
                             1349 
                             1358 
                             1359 ; 51   |extern _P EncoderSampleRateParms parmsTbl[];
                             1360 ; 52   |
                             1361 ; 53   |_reentrant void ComputeDCOffsetInit(int SamplingRate, int *SourceBufDesc_Ptr)
                             1362 ; 54   |{  
                             1363 
P:0000                       1364         org     p,".ptextdetectsilence":
                             1371 FComputeDCOffsetInit:
                             1376 
                             1377 ; 55   |    
                             1378 ; 56   |    DCOffsetPtr =  *( SourceBufDesc_Ptr + BD_BufferBaseAddress );
                             1379 
P:0000 4EE000         2    2 1381         move    y:(r0),y0
P:0001 4E7000 rrrrrr  3    5 1382         move    y0,y:FDCOffsetPtr
                             1383 
                             1384 ; 57   |// Use a power of 2 to simplify normalization
                             1385 ; 58   |// e.g. for 6:  2^6 = 64; 64 * 64 = 4096 ; sampling time is from 4096/48000 = 85ms to  4096/32000 = 128ms   
                             1386 ; 59   |// e.g. for 5:  2^5 = 32; 64 * 64 = 2048 ; sampling time is from 2048/48000 = 43ms to  2048/32000 = 64ms
                             1387 ; 60   |// e.g. for 4:  2^4 = 16; 16 * 64 = 1024 ; sampling time is from 1024/48000 = 21ms to  1024/32000 = 32ms  
                             1388 ; 61   |   
                             1389 ; 62   |    DCOffsetPwr = 4;   // 32 ms
                             1390 
P:0003 45F400 000004  3    8 1392         move    #>4,x1
                             1393 
                             1394 ; 63   |    DCOffsetCnt = 16;  // (1 << DCOffsetPwr);     // = 2^DCOffsetPwr;  
                             1395 
P:0005 46F400 000010  3   11 1397         move    #>16,y0
                             1398 
                             1399 ; 64   |    DCOffsetSetback = 8; // 50% 0f DCOffsetCnt  (16ms)
                             1400 
P:0007 44F400 000008  3   14 1402         move    #>8,x0
P:0009 4C7000 rrrrrr  3   17 1403         move    x0,y:FDCOffsetSetback
                             1404 
                             1405 ; 65   |     
                             1406 ; 66   |    if(32000 != SamplingRate) 
                             1407 
P:000B 47F400 007D00  3   20 1409         move    #$7D00,y1
P:000D 200075         2   22 1410         cmp     y1,a
P:000E 0AF0AA rrrrrr  6   28 1411         jeq     L4
                             1412 
                             1413 ; 67   |    {
                             1414 ; 68   |        DCOffsetPwr = 5;   // 43ms @48K; 46ms @ 44.1K
                             1415 
P:0010 45F400 000005  3   31 1417         move    #>5,x1
                             1418 
                             1419 ; 69   |        DCOffsetCnt = 32;  // (1 << DCOffsetPwr);     // = 2^DCOffsetPwr;  
                             1420 
P:0012 46F400 000020  3   34 1422         move    #>$20,y0
                             1423 
                             1424 ; 70   |//        DCOffsetSetback = 8; // 25% 0f DCOffsetCnt (10.75ms to 16ms)
                             1425 ; 71   |    }
                             1426 ; 72   |    
                             1427 ; 73   |    DCOffsetBlocksProcessed = 0; 
                             1428 
P:0014 20001B         2   36 1430 L4:     clr     b   
P:0015 5F7000 rrrrrr  3   39 1431         move    b,y:FDCOffsetBlocksProcessed
                             1432 
                             1433 ; 74   |    DCOffset[0] = DCOffset[1] = 0;   
                             1434 
P:0017 5F7000 rrrrrr  3   42 1436         move    b,y:FDCOffset+1
P:0019 5F7000 rrrrrr  3   45 1437         move    b,y:FDCOffset
P:001B 4D7000 rrrrrr  3   48 1438         move    x1,y:FDCOffsetPwr
P:001D 4E7000 rrrrrr  3   51 1439         move    y0,y:FDCOffsetCnt
                             1440 
                             1441 ; 75   |}
                             1442 
P:001F 00000C         4   55 1444         rts
                             1448 
                             1449 ; 76   |/*//////////////////////////////////////////////////////////////////////////////
                             1450 ; 77   |
                             1451 ; 78   |/*  Name:  ComputeDCOffset
                             1452 ; 79   |
                             1453 ; 80   |    Type:       void ComputeDCOffset(*SourceBufDesc_Ptr,NumChannels)
                             1454 ; 81   |
                             1455 ; 82   |    Description: finds DC bias for the number of samples available
                             1456 ; 83   |
                             1457 ; 84   |    Inputs:             
                             1458 ; 85   |                        1)  pointer to the source buffer descriptor
                             1459 ; 86   |            2)  number Of Channels
                             1460 ; 87   |    Outputs:            
                             1461 ; 88   |                        returns 0 for complete
                             1462 ; 89   |                        returns 1 for more to do  
                             1463 ; 90   |    Notes: Made a funclet to save P_ memory. But, performance may be an issue.
                             1464 ; 91   |           MP3 recording fails so, un-made funclet and made a regular function
                             1465 ; 92   |                        
                             1466 ; 93   |//////////////////////////////////////////////////////////////////////////////*/
                             1467 ; 94   |_reentrant INT ComputeDCOffset(int *SourceBufDesc_Ptr, int NumChannels)  // stmp6964
                             1468 ; 95   |{
                             1469 
                             1474 FComputeDCOffset:
P:0020 055F7C         2   57 1475         movec   ssh,y:(r7)+
P:0021 3F0700         2   59 1478         move    #7,n7
P:0022 000000         2   61 1479         nop
P:0023 204F00         2   63 1480         move    (r7)+n7
                             1498 
                             1499 ; 96   |    int RetValue = AUDIO_DETECTED;
                             1500 ; 97   |    int BlockSize,NumSamples,Ptr;
                             1501 ; 98   |    int i;
                             1502 ; 99   |    int idx = g_wEncSamplingRateIdx;
                             1503 
P:0024 4EF000 rrrrrr  3   66 1505         move    y:Fg_wEncSamplingRateIdx,y0
P:0026 77F400 FFFFFB  3   69 1506         move    #-5,n7
P:0028 000000         2   71 1507         nop
P:0029 4E6F00         4   75 1508         move    y0,y:(r7+n7)
                             1514 
                             1515 ; 100  |    _fract CurDCOffset;   
                             1516 ; 101  |    _fract TempResult;
                             1517 ; 102  | 
                             1518 ; 103  |    if ( DCOffsetCnt <=  DCOffsetBlocksProcessed ) return 0;   // Already computed DC bias for this recording
                             1519 
P:002A 5FF000 rrrrrr  3   78 1521         move    y:FDCOffsetCnt,b
P:002C 4EF000 rrrrrr  3   81 1522         move    y:FDCOffsetBlocksProcessed,y0
P:002E 20005D         2   83 1523         cmp     y0,b
P:002F 0AF0AF rrrrrr  6   89 1524         jle     L52
                             1525 
                             1526 ; 104  |    
                             1527 ; 105  |    // number of samples available to process
                             1528 ; 106  |    NumSamples = *( SourceBufDesc_Ptr + BD_HdPtr ) - DCOffsetPtr;                
                             1529 
P:0031 3E0300         2   91 1531         move    #3,n6
P:0032 221600         2   93 1532         move    r0,r6
P:0033 77F400 FFFFF9  3   96 1533         move    #-7,n7
P:0035 000000         2   98 1534         nop
P:0036 6E6F00         4  102 1535         move    r6,y:(r7+n7)
P:0037 204E00         2  104 1536         move    (r6)+n6
P:0038 5FE600         2  106 1539         move    y:(r6),b
P:0039 4EF000 rrrrrr  3  109 1540         move    y:FDCOffsetPtr,y0
P:003B 20005C         2  111 1541         sub     y0,b
P:003C 21A500         2  113 1542         move    b1,x1
                             1544 
                             1545 ; 107  |    
                             1546 ; 108  |    if ( NumSamples < 0 )
                             1547 
P:003D 0AF0A1 rrrrrr  6  119 1549         jge     L39
                             1550 
                             1551 ; 109  |    {
                             1552 ; 110  |        NumSamples = NumSamples + *( SourceBufDesc_Ptr + BD_BufferSize );
                             1553 
P:003F 3E0200         2  121 1555         move    #2,n6
P:0040 6EEF00         4  125 1556         move    y:(r7+n7),r6
P:0041 000000         2  127 1557         nop
P:0042 204E00         2  129 1558         move    (r6)+n6
P:0043 4CE600         2  131 1559         move    y:(r6),x0
P:0044 200048         2  133 1560         add     x0,b
P:0045 21A500         2  135 1561         move    b1,x1
                             1562 
                             1563 ; 111  |    }
                             1564 ; 112  |       
                             1565 ; 113  |    // BlockSize 64 for single channel 128 for dual channel
                             1566 ; 114  |    BlockSize = 64 * NumChannels;                                      
                             1567 
P:0046 77F400 FFFFFA  3  138 1569 L39:    move    #-6,n7
P:0048 000000         2  140 1570         nop
P:0049 5C6F00         4  144 1571         move    a1,y:(r7+n7)
P:004A 060680 rrrrrr  6  150 1572         do      #6,L55
P:004C 200033         2  152 1574         lsl     a
P:004D 000000         2  154 1575         nop
                         (4) 1576 L55:
P:004E 218700         2  156 1580         move    a1,y1
                             1582 
                             1583 ; 115  |  
                             1584 ; 116  |    while ( ( BlockSize < NumSamples) && ( DCOffsetBlocksProcessed <  DCOffsetCnt ) )
                             1585 
P:004F 0AF080 rrrrrr  6  162 1587         jmp     L44
                             1588 
                             1589 ; 117  |    {
                             1590 ; 118  |        if ( 0 < --DCOffsetSetback) break;  // Wait for ADC / MIXER voltages become stable
                             1591 
                             1593 L40:
P:0051 5FF000 rrrrrr  3  165 1598         move    y:FDCOffsetSetback,b
P:0053 46F400 000001  3  168 1599         move    #>1,y0
P:0055 20005C         2  170 1600         sub     y0,b
P:0056 5D7000 rrrrrr  3  173 1601         move    b1,y:FDCOffsetSetback
P:0058 4CF000 rrrrrr  3  176 1602         move    y:FDCOffsetSetback,x0
P:005A 20001B         2  178 1603         clr     b   
P:005B 20004D         2  180 1604         cmp     x0,b
P:005C 0AF0A9 rrrrrr  6  186 1605         jlt     L46
                             1606 
                             1607 ; 119  |        DCOffsetBlocksProcessed++;        
                             1608 
P:005E 5FF000 rrrrrr  3  189 1610         move    y:FDCOffsetBlocksProcessed,b
P:0060 200058         2  191 1611         add     y0,b
P:0061 5D7000 rrrrrr  3  194 1612         move    b1,y:FDCOffsetBlocksProcessed
                             1613 
                             1614 ; 120  |        Ptr = DCOffsetPtr;      
                             1615 
P:0063 5EF000 rrrrrr  3  197 1617         move    y:FDCOffsetPtr,a
                             1619 
                             1620 ; 121  |        for ( i = 0 ; i < NumChannels ; i++)
                             1621 
P:0065 20001B         2  199 1623         clr     b   
P:0066 66F400 rrrrrr  3  202 1625         move    #FDCOffset,r6
P:0068 045FA0         2  204 1626         movec   m0,n7
P:0069 000000         2  206 1627         nop
P:006A 6E6F00         4  210 1628         move    r6,y:(r7+n7)
P:006B 0AF080 rrrrrr  6  216 1629         jmp     L42
                             1630 
                             1631 ; 122  |        {   // finds DC bias for the block of 64 samples 
                             1632 ; 123  |            TempResult = FindDCOffset(Ptr, 64 , NumChannels, *( SourceBufDesc_Ptr + BD_BufferModulo ));
                             1633 
                             1635 L41:
P:006D 77F400 FFFFF9  3  219 1638         move    #-7,n7
P:006F 000000         2  221 1639         nop
P:0070 6EEF00         4  225 1640         move    y:(r7+n7),r6
P:0071 000000         2  227 1641         nop
P:0072 205E00         2  229 1642         move    (r6)+
P:0073 4EE600         2  231 1643         move    y:(r6),y0
P:0074 77F400 FFFFFA  3  234 1644         move    #-6,n7
P:0076 000000         2  236 1645         nop
P:0077 4CEF00         4  240 1646         move    y:(r7+n7),x0
P:0078 57F400 000040  3  243 1649         move    #>$40,b
P:007A 0BF080 rrrrrr  6  249 1650         jsr     FindDCOffset
                             1655 
                             1656 ; 124  |            TempResult =  TempResult >> 6;    // TempResult / 64;
                             1657 
TASKING DSP2410 assembler v1.5r1 Build 138 SN 00100122
                                                                                                                                                                                                                                                       Page   7

M:ADDR CODE           CYCLES LINE SOURCELINE
P:007C 060680 rrrrrr  6  255 1659         do      #6,L56
P:007E 200022         2  257 1661         asr     a
P:007F 000000         2  259 1662         nop
                         (4) 1663 L56:
P:0080 21C600         2  261 1666         move    a,y0
                             1668 
                             1669 ; 125  |            DCOffset[i] +=  TempResult ;     
                             1670 
P:0081 045FA0         2  263 1672         movec   m0,n7
P:0082 000000         2  265 1673         nop
P:0083 6EEF00         4  269 1674         move    y:(r7+n7),r6
P:0084 000000         2  271 1675         nop
P:0085 5FE600         2  273 1676         move    y:(r6),b
P:0086 200058         2  275 1677         add     y0,b
P:0087 5F5E00         2  277 1678         move    b,y:(r6)+
                             1679 
                             1680 ; 126  |            Ptr = DCOffsetPtr + 1;
                             1681 
P:0088 5EF000 rrrrrr  3  280 1683         move    y:FDCOffsetPtr,a
P:008A 45F400 000001  3  283 1684         move    #>1,x1
P:008C 200060         2  285 1685         add     x1,a
P:008D 6E6F00         4  289 1688         move    r6,y:(r7+n7)
P:008E 77F400 FFFFFE  3  292 1689         move    #-2,n7
P:0090 000000         2  294 1690         nop
P:0091 5FEF00         4  298 1691         move    y:(r7+n7),b
P:0092 200068         2  300 1692         add     x1,b
P:0093 77F400 FFFFFA  3  303 1695 L42:    move    #-6,n7
P:0095 000000         2  305 1696         nop
P:0096 4EEF00         4  309 1697         move    y:(r7+n7),y0
P:0097 77F400 FFFFFE  3  312 1698         move    #-2,n7
P:0099 000000         2  314 1699         nop
P:009A 5D6F00         4  318 1700         move    b1,y:(r7+n7)
P:009B 20005D         2  320 1701         cmp     y0,b
P:009C 0AF0A9 rrrrrr  6  326 1704         jlt     L41
                             1705 
                             1706 ; 127  |        } 
                             1707 ; 128  |        //  increment the DCOffset pointer by the number of samples processed
                             1708 ; 129  |        DCOffsetPtr = ( DCOffsetPtr + BlockSize ) ;   
                             1709 
P:009E 5EF000 rrrrrr  3  329 1711         move    y:FDCOffsetPtr,a
P:00A0 77F400 FFFFFD  3  332 1713         move    #-3,n7
P:00A2 000000         2  334 1714         nop
P:00A3 4FEF00         4  338 1715         move    y:(r7+n7),y1
P:00A4 200070         2  340 1716         add     y1,a
P:00A5 5C7000 rrrrrr  3  343 1719         move    a1,y:FDCOffsetPtr
                             1720 
                             1721 ; 130  |
                             1722 ; 131  |        //  change for modulo buffer    
                             1723 ; 132  |        if ( DCOffsetPtr >=  ( *( SourceBufDesc_Ptr + BD_BufferBaseAddress ) + 
                             1724 ; 133  |                               *( SourceBufDesc_Ptr + BD_BufferSize ) ) )
                             1725 
P:00A7 77F400 FFFFF9  3  346 1727         move    #-7,n7
P:00A9 000000         2  348 1728         nop
P:00AA 6EEF00         4  352 1729         move    y:(r7+n7),r6
P:00AB 000000         2  354 1730         nop
P:00AC 5FE600         2  356 1731         move    y:(r6),b
P:00AD 3E0200         2  358 1734         move    #2,n6
P:00AE 000000         2  360 1735         nop
P:00AF 204E00         2  362 1736         move    (r6)+n6
P:00B0 4EE600         2  364 1739         move    y:(r6),y0
P:00B1 200058         2  366 1741         add     y0,b
P:00B2 200005         2  368 1742         cmp     b,a
P:00B3 0AF0A9 rrrrrr  6  374 1743         jlt     L43
                             1744 
                             1745 ; 134  |        {
                             1746 ; 135  |            DCOffsetPtr =  DCOffsetPtr - ( *( SourceBufDesc_Ptr + BD_BufferSize ) );     
                             1747 
P:00B5 200054         2  376 1749         sub     y0,a
P:00B6 5C7000 rrrrrr  3  379 1750         move    a1,y:FDCOffsetPtr
                             1751 
                             1752 ; 136  |        }
                             1753 ; 137  |        NumSamples = NumSamples -  BlockSize;
                             1754 
P:00B8 77F400 FFFFFC  3  382 1756 L43:    move    #-4,n7
P:00BA 000000         2  384 1757         nop
P:00BB 5FEF00         4  388 1758         move    y:(r7+n7),b
P:00BC 20007C         2  390 1759         sub     y1,b
P:00BD 21A500         2  392 1762         move    b1,x1
P:00BE 77F400 FFFFFC  3  395 1766 L44:    move    #-4,n7
P:00C0 000000         2  397 1767         nop
P:00C1 4D6F00         4  401 1768         move    x1,y:(r7+n7)
P:00C2 200079         2  403 1769         tfr     y1,b
P:00C3 77F400 FFFFFD  3  406 1770         move    #-3,n7
P:00C5 000000         2  408 1771         nop
P:00C6 5F6F00         4  412 1772         move    b,y:(r7+n7)
P:00C7 20006D         2  414 1773         cmp     x1,b
P:00C8 0AF0A1 rrrrrr  6  420 1778         jge     L46
P:00CA 5FF000 rrrrrr  3  423 1779         move    y:FDCOffsetBlocksProcessed,b
P:00CC 4EF000 rrrrrr  3  426 1780         move    y:FDCOffsetCnt,y0
P:00CE 20005D         2  428 1781         cmp     y0,b
P:00CF 0AF0A9 rrrrrr  6  434 1782         jlt     L40
                             1783 
                             1784 ; 138  |    }
                             1785 ; 139  |
                             1786 ; 140  |    if ( DCOffsetCnt <=  DCOffsetBlocksProcessed)
                             1787 
P:00D1 5FF000 rrrrrr  3  437 1789 L46:    move    y:FDCOffsetCnt,b
P:00D3 4FF000 rrrrrr  3  440 1790         move    y:FDCOffsetBlocksProcessed,y1
P:00D5 20007D         2  442 1791         cmp     y1,b
P:00D6 0AF0A7 rrrrrr  6  448 1792         jgt     L53
                             1793 
                             1794 ; 141  |    {    
                             1795 ; 142  |        for ( i = 0 ; i < NumChannels ; i++)
                             1796 
P:00D8 240000         2  450 1798         move    #0,x0
P:00D9 66F400 rrrrrr  3  453 1801         move    #FDCOffset,r6
P:00DB 45F400 000007  3  456 1802         move    #>7,x1
P:00DD 65F400 rrrrrr  3  459 1803         move    #FDCOffsetADC,r5
P:00DF 0AF080 rrrrrr  6  465 1804         jmp     L51
                             1805 
                             1806 ; 143  |        {
                             1807 ; 144  |            CurDCOffset = (DCOffset[i] >> DCOffsetPwr); 
                             1808 
P:00E1 5FE600         2  467 1810 L47:    move    y:(r6),b
P:00E2 5EF000 rrrrrr  3  470 1811         move    y:FDCOffsetPwr,a
P:00E4 200003         2  472 1812         tst     a
P:00E5 0AF0AF rrrrrr  6  478 1813         jle     L57
P:00E7 06CC00 rrrrrr  6  484 1814         do      a1,L57
P:00E9 20002A         2  486 1816         asr     b
P:00EA 000000         2  488 1817         nop
                         (4) 1818 L57:
P:00EB 21E700         2  490 1820         move    b,y1
                             1822 
                             1823 ; 145  |            CurDCOffset += DCOffsetADC[i][idx];      
                             1824 
P:00EC 77F400 FFFFFB  3  493 1826         move    #-5,n7
P:00EE 000000         2  495 1827         nop
P:00EF 59EF00         4  499 1828         move    y:(r7+n7),b0
P:00F0 20003A         2  501 1829         asl     b
P:00F1 2000AA         2  503 1830         mac     x0,x1,b
P:00F2 20002A         2  505 1831         asr     b
P:00F3 213B00         2  507 1832         move    b0,n3
P:00F4 22B300         2  509 1833         move    r5,r3
P:00F5 000000         2  511 1834         nop
P:00F6 204B00         2  513 1835         move    (r3)+n3
P:00F7 56E300         2  515 1836         move    x:(r3),a
P:00F8 200070         2  517 1837         add     y1,a
                             1840 
                             1841 ; 146  |            if ( (-MAX_DC_OFFSET < CurDCOffset) && (CurDCOffset < MAX_DC_OFFSET))   // limit check
                             1842 
P:00F9 21CF00         2  519 1844         move    a,b
P:00FA 21E700         2  521 1845         move    b,y1
P:00FB 20003E         2  523 1846         neg     b
P:00FC 2F0000         2  525 1847         move    #0,b
P:00FD 0AF0AF rrrrrr  6  531 1848         jle     L58
P:00FF 0AF0A5 rrrrrr  6  537 1849         jec     L58
P:0101 57F400 FFFFFF  3  540 1850         move    #>-1,b
                             1851 L58:
P:0103 56F400 FFFFFE  3  543 1854         move    #>-2,a
P:0105 200005         2  545 1855         cmp     b,a
P:0106 0AF0A1 rrrrrr  6  551 1856         jge     L49
P:0108 46F400 000002  3  554 1857         move    #>2,y0
P:010A 20005D         2  556 1858         cmp     y0,b
P:010B 0AF0A1 rrrrrr  6  562 1859         jge     L49
                             1860 
                             1861 ; 147  |            {
                             1862 ; 148  |                DCOffsetADC[i][idx] = CurDCOffset;           // UpdateDC bias  
                             1863 
P:010D 476300         2  564 1865         move    y1,x:(r3)
                             1866 
                             1867 ; 149  |            }
                             1868 
P:010E 0AF080 rrrrrr  6  570 1870         jmp     L50
                             1871 L49:
                             1872 
                             1873 ; 150  |            else SystemHalt();  // debug only
                             1874 
                             1876 
                             1877 ; Start __asm() call number 1
                             1879  error
P:0110 000200         4  574 1879     debug
                             1880 ; End   __asm() call number 1
                             1881 L50:
P:0111 205E00         2  576 1883         move    (r6)+
P:0112 46F400 000001  3  579 1884         move    #>1,y0
P:0114 200049         2  581 1885         tfr     x0,b
P:0115 200058         2  583 1886         add     y0,b
P:0116 21A400         2  585 1889         move    b1,x0
P:0117 77F400 FFFFFA  3  588 1892 L51:    move    #-6,n7
P:0119 000000         2  590 1893         nop
P:011A 5EEF00         4  594 1894         move    y:(r7+n7),a
P:011B 200049         2  596 1895         tfr     x0,b
P:011C 20000D         2  598 1896         cmp     a,b
P:011D 0AF0A9 rrrrrr  6  604 1897         jlt     L47
                             1898 
                             1899 ; 151  |        }
                             1900 ; 152  |        g_wEncADCLChOffset = DCOffsetADC[0][idx];         // L-Chan DC Offset
                             1901 
P:011F 77F400 FFFFFB  3  607 1903         move    #-5,n7
P:0121 000000         2  609 1904         nop
P:0122 4EEF00         4  613 1905         move    y:(r7+n7),y0
P:0123 20DB00         2  615 1906         move    y0,n3
P:0124 22B300         2  617 1909         move    r5,r3
P:0125 000000         2  619 1910         nop
P:0126 204B00         2  621 1911         move    (r3)+n3
P:0127 44E300         2  623 1912         move    x:(r3),x0
P:0128 4C7000 rrrrrr  3  626 1914         move    x0,y:Fg_wEncADCLChOffset
                             1915 
                             1916 ; 153  |        g_wEncADCRChOffset = DCOffsetADC[1][idx];         // R-Chan DC Offset
                             1917 
P:012A 63F400 rrrrrr  3  629 1919         move    #FDCOffsetADC+7,r3
P:012C 000000         2  631 1920         nop
P:012D 204B00         2  633 1921         move    (r3)+n3
P:012E 44E300         2  635 1922         move    x:(r3),x0
P:012F 4C7000 rrrrrr  3  638 1923         move    x0,y:Fg_wEncADCRChOffset
                             1924 
                             1925 ; 154  |        return 0;
                             1926 
P:0131 200013         2  640 1928 L52:    clr     a   
P:0132 0AF080 rrrrrr  6  646 1929         jmp     L54
                             1930 
                             1931 ; 155  |    }
                             1932 ; 156  |   
                             1933 ; 157  |    return 1;   // more to do 
                             1934 
P:0134 56F400 000001  3  649 1936 L53:    move    #>1,a
                             1937 
                             1938 ; 158  |  
                             1939 ; 159  | }   
                             1940 
P:0136 77F400 FFFFF8  3  652 1942 L54:    move    #-8,n7
P:0138 000000         2  654 1943         nop
P:0139 05EF7C         4  658 1944         movec   y:(r7+n7),ssh
P:013A 204F00         2  660 1946         move    (r7)+n7
P:013B 00000C         4  664 1948         rts
                             1956 
                             1957 ; 160  |
                             1958 ; 161  |  
                             1959 ; 162  |/*//////////////////////////////////////////////////////////////////////////////
                             1960 ; 163  |
                             1961 ; 164  |/*  Name:  DetectSilenceInit
                             1962 ; 165  |
                             1963 ; 166  |    Type:       void DetectSilenceInit(SamplingRate,*SourceBufDesc_Ptr)
                             1964 ; 167  |
                             1965 ; 168  |    Description: initializes silence variables
                             1966 ; 169  |
                             1967 ; 170  |    Inputs:             
                             1968 ; 171  |                        1)  sampling rate 
                             1969 ; 172  |            2)  pointer to the source buffer descriptor
                             1970 ; 173  |    Outputs:            
                             1971 ; 174  |                        Nil
                             1972 ; 175  |    Notes: 
                             1973 ; 176  |                        
                             1974 ; 177  |//////////////////////////////////////////////////////////////////////////////*/
                             1975 ; 178  |void DetectSilenceInit(int SamplingRate, int *SourceBufDesc_Ptr)
                             1976 ; 179  |{
                             1977 
                             1982 FDetectSilenceInit:
                             1987 
                             1988 ; 180  |    SilenceSR = 0;
                             1989 
TASKING DSP2410 assembler v1.5r1 Build 138 SN 00100122
                                                                                                                                                                                                                                                       Page   8

M:ADDR CODE           CYCLES LINE SOURCELINE
P:013C 20001B         2  666 1991         clr     b   
P:013D 5F7000 rrrrrr  3  669 1992         move    b,y:FSilenceSR
                             1993 
                             1994 ; 181  |
                             1995 ; 182  |    SilencePtr =  *( SourceBufDesc_Ptr + BD_BufferBaseAddress );
                             1996 
P:013F 4EE000         2  671 1998         move    y:(r0),y0
P:0140 4E7000 rrrrrr  3  674 1999         move    y0,y:FSilencePtr
                             2000 
                             2001 ; 183  |       
                             2002 ; 184  |    SilenceCount = 0;
                             2003 
P:0142 5F7000 rrrrrr  3  677 2005         move    b,y:FSilenceCount
                             2006 
                             2007 ; 185  |
                             2008 ; 186  |    MaxSilenceCnt = (SamplingRate*SILENCE_PERIOD)/64;                   // SILENCE_PERIOD = 4.5 secs
                             2009 
P:0144 218400         2  679 2011         move    a1,x0
P:0145 45F400 000003  3  682 2012         move    #>3,x1
P:0147 2000A8         2  684 2013         mpy     x0,x1,b
P:0148 20002A         2  686 2014         asr     b
P:0149 212600         2  688 2015         move    b0,y0
P:014A 0106E8         2  690 2016         mpy     y0,#6,b
P:014B 5D7000 rrrrrr  3  693 2017         move    b1,y:FMaxSilenceCnt
                             2018 
                             2019 ; 187  |
                             2020 ; 188  |    MaxDelay = (SamplingRate/64)*IDLE_SILENCE_PERIOD;                                    // MaxDelay = 1 Min
                             2021 
P:014D 060680 rrrrrr  6  699 2023         do      #6,L59
P:014F 200022         2  701 2025         asr     a
P:0150 000000         2  703 2026         nop
                         (4) 2027 L59:
P:0151 45F400 00012C  3  706 2030         move    #300,x1
P:0153 218700         2  708 2031         move    a1,y1
P:0154 2000F0         2  710 2032         mpy     y1,x1,a
P:0155 200022         2  712 2033         asr     a
P:0156 587000 rrrrrr  3  715 2034         move    a0,y:FMaxDelay
                             2035 
                             2036 ; 189  |    
                             2037 ; 190  |}
                             2038 
P:0158 00000C         4  719 2040         rts
                             2043 
                             2044 ; 191  |
                             2045 ; 192  |/*//////////////////////////////////////////////////////////////////////////////
                             2046 ; 193  |
                             2047 ; 194  |/*  Name:  DetectSilence
                             2048 ; 195  |
                             2049 ; 196  |    Type:       void DetectSilence(*SourceBufDesc_Ptr,NumChannels)
                             2050 ; 197  |
                             2051 ; 198  |    Description: finds silence or audio for the number of samples available
                             2052 ; 199  |
                             2053 ; 200  |    Inputs:             
                             2054 ; 201  |                        1)  pointer to the source buffer descriptor
                             2055 ; 202  |            2)  number Of Channels
                             2056 ; 203  |    Outputs:            
                             2057 ; 204  |                        returns AUDIO_DETECTED or SILENCE_DETECTED 
                             2058 ; 205  |    Notes: 
                             2059 ; 206  |                        
                             2060 ; 207  |//////////////////////////////////////////////////////////////////////////////*/
                             2061 ; 208  |int _reentrant DetectSilence(int *SourceBufDesc_Ptr, int NumChannels)
                             2062 ; 209  |{
                             2063 
                             2068 FDetectSilence:
P:0159 055F7C         2  721 2069         movec   ssh,y:(r7)+
P:015A 3F0900         2  723 2072         move    #9,n7
P:015B 000000         2  725 2073         nop
P:015C 204F00         2  727 2074         move    (r7)+n7
                             2082 
                             2083 ; 210  |    int RetValue = AUDIO_DETECTED;
                             2084 
P:015D 270000         2  729 2086         move    #0,y1
P:015E 77F400 FFFFFB  3  732 2088         move    #-5,n7
P:0160 000000         2  734 2089         nop
P:0161 4F6F00         4  738 2090         move    y1,y:(r7+n7)
                             2103 
                             2104 ; 211  |    int BlockSize,NumSamples,Ptr;
                             2105 ; 212  |    int i;
                             2106 ; 213  |    int Energy[2];
                             2107 ; 214  |
                             2108 ; 215  |    // number of samples available to process
                             2109 ; 216  |    NumSamples = *( SourceBufDesc_Ptr + BD_HdPtr ) - SilencePtr;                
                             2110 
P:0162 3E0300         2  740 2112         move    #3,n6
P:0163 221600         2  742 2113         move    r0,r6
P:0164 77F400 FFFFF9  3  745 2114         move    #-7,n7
P:0166 000000         2  747 2115         nop
P:0167 6E6F00         4  751 2116         move    r6,y:(r7+n7)
P:0168 204E00         2  753 2117         move    (r6)+n6
P:0169 5FE600         2  755 2120         move    y:(r6),b
P:016A 4EF000 rrrrrr  3  758 2121         move    y:FSilencePtr,y0
P:016C 20005C         2  760 2122         sub     y0,b
P:016D 21A600         2  762 2123         move    b1,y0
                             2125 
                             2126 ; 217  |    
                             2127 ; 218  |    if ( NumSamples < 0 )
                             2128 
P:016E 0AF0A1 rrrrrr  6  768 2130         jge     L74
                             2131 
                             2132 ; 219  |        NumSamples = NumSamples + *( SourceBufDesc_Ptr + BD_BufferSize );
                             2133 
P:0170 3E0200         2  770 2135         move    #2,n6
P:0171 6EEF00         4  774 2136         move    y:(r7+n7),r6
P:0172 000000         2  776 2137         nop
P:0173 204E00         2  778 2138         move    (r6)+n6
P:0174 4FE600         2  780 2139         move    y:(r6),y1
P:0175 200078         2  782 2140         add     y1,b
P:0176 21A600         2  784 2141         move    b1,y0
                             2142 
                             2143 ; 220  |        
                             2144 ; 221  |    // BlockSize 64 for single channel 128 for dual channel
                             2145 ; 222  |    BlockSize = 64*NumChannels;                                      
                             2146 
P:0177 77F400 FFFFFA  3  787 2148 L74:    move    #-6,n7
P:0179 000000         2  789 2149         nop
P:017A 5C6F00         4  793 2150         move    a1,y:(r7+n7)
P:017B 060680 rrrrrr  6  799 2151         do      #6,L87
P:017D 200033         2  801 2153         lsl     a
P:017E 000000         2  803 2154         nop
                         (4) 2155 L87:
P:017F 218500         2  805 2159         move    a1,x1
                             2161 
                             2162 ; 223  |        
                             2163 ; 224  |    while ( NumSamples > BlockSize )
                             2164 
P:0180 44F400 000001  3  808 2166         move    #>1,x0
P:0182 0AF080 rrrrrr  6  814 2167         jmp     L85
                             2168 
                             2169 ; 225  |    {
                             2170 ; 226  |        Ptr = SilencePtr;
                             2171 
                             2173 L75:
P:0184 4FF000 rrrrrr  3  817 2178         move    y:FSilencePtr,y1
                             2180 
                             2181 ; 227  |
                             2182 ; 228  |        for ( i = 0 ; i < NumChannels ; i++)
                             2183 
P:0186 200013         2  819 2185         clr     a   
P:0187 77F400 FFFFF7  3  822 2187         move    #-9,n7
P:0189 000000         2  824 2188         nop
P:018A 044F16         4  828 2189         lua     (r7)+n7,r6
P:018B 045FA0         2  830 2190         movec   m0,n7
P:018C 000000         2  832 2191         nop
P:018D 6E6F00         4  836 2192         move    r6,y:(r7+n7)
P:018E 0AF080 rrrrrr  6  842 2193         jmp     L77
                             2194 
                             2195 ; 229  |        {
                             2196 ; 230  |            // finds energy for the block of 64 samples 
                             2197 ; 231  |            Energy[i] = FindEnergy(Ptr,64,NumChannels,*( SourceBufDesc_Ptr + BD_BufferModulo )); 
                             2198 
                             2200 L76:
P:0190 77F400 FFFFF9  3  845 2205         move    #-7,n7
P:0192 000000         2  847 2206         nop
P:0193 6EEF00         4  851 2207         move    y:(r7+n7),r6
P:0194 000000         2  853 2208         nop
P:0195 205E00         2  855 2209         move    (r6)+
P:0196 4EE600         2  857 2210         move    y:(r6),y0
P:0197 77F400 FFFFFA  3  860 2211         move    #-6,n7
P:0199 000000         2  862 2212         nop
P:019A 5D6F00         4  866 2213         move    b1,y:(r7+n7)
P:019B 21A400         2  868 2214         move    b1,x0
P:019C 57F400 000040  3  871 2219         move    #>$40,b
P:019E 200071         2  873 2220         tfr     y1,a
P:019F 0BF080 rrrrrr  6  879 2221         jsr     FindEnergy
P:01A1 045FA0         2  881 2227         movec   m0,n7
P:01A2 000000         2  883 2228         nop
P:01A3 6EEF00         4  887 2229         move    y:(r7+n7),r6
P:01A4 000000         2  889 2230         nop
P:01A5 5E5E00         2  891 2231         move    a,y:(r6)+
                             2232 
                             2233 ; 232  |            Ptr = SilencePtr + 1;
                             2234 
P:01A6 5EF000 rrrrrr  3  894 2236         move    y:FSilencePtr,a
P:01A8 44F400 000001  3  897 2237         move    #>1,x0
P:01AA 200040         2  899 2238         add     x0,a
P:01AB 218700         2  901 2239         move    a1,y1
P:01AC 6E6F00         4  905 2242         move    r6,y:(r7+n7)
P:01AD 77F400 FFFFFE  3  908 2243         move    #-2,n7
P:01AF 000000         2  910 2244         nop
P:01B0 5FEF00         4  914 2245         move    y:(r7+n7),b
P:01B1 200048         2  916 2246         add     x0,b
P:01B2 21AE00         2  918 2249         move    b1,a
P:01B3 77F400 FFFFFA  3  921 2252 L77:    move    #-6,n7
P:01B5 000000         2  923 2253         nop
P:01B6 5FEF00         4  927 2254         move    y:(r7+n7),b
P:01B7 77F400 FFFFFE  3  930 2255         move    #-2,n7
P:01B9 000000         2  932 2256         nop
P:01BA 5C6F00         4  936 2257         move    a1,y:(r7+n7)
P:01BB 200005         2  938 2258         cmp     b,a
P:01BC 0AF0A9 rrrrrr  6  944 2263         jlt     L76
                             2264 
                             2265 ; 233  |        } 
                             2266 ; 234  |        
                             2267 ; 235  |        // if energy for the block is below THRESHOLD_ENERGY then increment the SilenceCount
                             2268 ; 236  |        if ( NumChannels == 2 )
                             2269 
P:01BE 46F400 000002  3  947 2271         move    #>2,y0
P:01C0 20005D         2  949 2272         cmp     y0,b
P:01C1 0AF0A2 rrrrrr  6  955 2275         jne     L78
                             2276 
                             2277 ; 237  |        {
                             2278 ; 238  |            if ( (Energy[0] < THRESHOLD_ENERGY ) && ( Energy[1] <  THRESHOLD_ENERGY) )
                             2279 
P:01C3 77F400 FFFFF7  3  958 2281         move    #-9,n7
P:01C5 000000         2  960 2282         nop
P:01C6 5FEF00         4  964 2283         move    y:(r7+n7),b
P:01C7 47F400 00FA00  3  967 2284         move    #$FA00,y1
P:01C9 20007D         2  969 2285         cmp     y1,b
P:01CA 0AF0A1 rrrrrr  6  975 2286         jge     L82
P:01CC 77F400 FFFFF8  3  978 2287         move    #-8,n7
P:01CE 000000         2  980 2288         nop
P:01CF 5FEF00         4  984 2289         move    y:(r7+n7),b
P:01D0 20E500         2  986 2290         move    y1,x1
P:01D1 20006D         2  988 2291         cmp     x1,b
                             2292 
                             2293 ; 239  |            {
                             2294 ; 240  |                SilenceCount++;
                             2295 
P:01D2 0AF080 rrrrrr  6  994 2297         jmp     L79
                             2298 
                             2299 ; 241  |            }
                             2300 ; 242  |            else 
                             2301 ; 243  |            {
                             2302 ; 244  |                // if audio is detected then reset SilenceCount to zero
                             2303 ; 245  |                SilenceCount = 0;
                             2304 ; 246  |            }    
                             2305 ; 247  |        }
                             2306 ; 248  |        else
                             2307 ; 249  |        {
                             2308 ; 250  |            if ( Energy[0] < THRESHOLD_ENERGY )
                             2309 
P:01D4 77F400 FFFFF7  3  997 2311 L78:    move    #-9,n7
P:01D6 000000         2  999 2312         nop
P:01D7 5EEF00         4 1003 2313         move    y:(r7+n7),a
P:01D8 47F400 00FA00  3 1006 2314         move    #$FA00,y1
P:01DA 200075         2 1008 2315         cmp     y1,a
                             2316 
                             2317 ; 251  |            {
                             2318 ; 252  |                SilenceCount++;
                             2319 
                             2321 L79:
P:01DB 0AF0A1 rrrrrr  6 1014 2323         jge     L82
P:01DD 5FF000 rrrrrr  3 1017 2325         move    y:FSilenceCount,b
P:01DF 200048         2 1019 2326         add     x0,b
P:01E0 5D7000 rrrrrr  3 1022 2327         move    b1,y:FSilenceCount
                             2328 
                             2329 ; 253  |            }
                             2330 
P:01E2 0AF080 rrrrrr  6 1028 2332         jmp     L83
                             2333 
                             2334 ; 254  |            else 
TASKING DSP2410 assembler v1.5r1 Build 138 SN 00100122
                                                                                                                                                                                                                                                       Page   9

M:ADDR CODE           CYCLES LINE SOURCELINE
                             2335 ; 255  |            {
                             2336 ; 256  |                SilenceCount = 0;
                             2337 
P:01E4 20001B         2 1030 2339 L82:    clr     b   
P:01E5 5F7000 rrrrrr  3 1033 2340         move    b,y:FSilenceCount
                             2341 
                             2342 ; 257  |            }    
                             2343 ; 258  |        }        
                             2344 ; 259  |
                             2345 ; 260  |        //  increment the silence pointer by the number of samples processed
                             2346 ; 261  |        SilencePtr = ( SilencePtr + BlockSize ) ;   
                             2347 
P:01E7 5EF000 rrrrrr  3 1036 2349 L83:    move    y:FSilencePtr,a
P:01E9 77F400 FFFFFD  3 1039 2350         move    #-3,n7
P:01EB 000000         2 1041 2351         nop
P:01EC 4DEF00         4 1045 2352         move    y:(r7+n7),x1
P:01ED 200060         2 1047 2353         add     x1,a
P:01EE 5C7000 rrrrrr  3 1050 2356         move    a1,y:FSilencePtr
                             2357 
                             2358 ; 262  |
                             2359 ; 263  |        //  change for modulo buffer    
                             2360 ; 264  |        if ( SilencePtr >=  ( *( SourceBufDesc_Ptr + BD_BufferBaseAddress ) + *( SourceBufDesc_Ptr + BD_BufferSize ) ) )
                             2361 
P:01F0 77F400 FFFFF9  3 1053 2363         move    #-7,n7
P:01F2 000000         2 1055 2364         nop
P:01F3 6EEF00         4 1059 2365         move    y:(r7+n7),r6
P:01F4 000000         2 1061 2366         nop
P:01F5 5FE600         2 1063 2367         move    y:(r6),b
P:01F6 3E0200         2 1065 2370         move    #2,n6
P:01F7 000000         2 1067 2371         nop
P:01F8 204E00         2 1069 2372         move    (r6)+n6
P:01F9 4EE600         2 1071 2375         move    y:(r6),y0
P:01FA 200058         2 1073 2376         add     y0,b
P:01FB 200005         2 1075 2377         cmp     b,a
P:01FC 0AF0A9 rrrrrr  6 1081 2378         jlt     L84
                             2379 
                             2380 ; 265  |        {
                             2381 ; 266  |            SilencePtr =  SilencePtr - ( *( SourceBufDesc_Ptr + BD_BufferSize ) );     
                             2382 
P:01FE 200054         2 1083 2384         sub     y0,a
P:01FF 5C7000 rrrrrr  3 1086 2385         move    a1,y:FSilencePtr
                             2386 
                             2387 ; 267  |        }
                             2388 ; 268  |        NumSamples = NumSamples -  BlockSize;
                             2389 
P:0201 77F400 FFFFFC  3 1089 2391 L84:    move    #-4,n7
P:0203 000000         2 1091 2392         nop
P:0204 5FEF00         4 1095 2393         move    y:(r7+n7),b
P:0205 20006C         2 1097 2394         sub     x1,b
P:0206 21A600         2 1099 2397         move    b1,y0
P:0207 200059         2 1101 2401 L85:    tfr     y0,b
P:0208 77F400 FFFFFC  3 1104 2402         move    #-4,n7
P:020A 000000         2 1106 2403         nop
P:020B 5F6F00         4 1110 2404         move    b,y:(r7+n7)
P:020C 77F400 FFFFFD  3 1113 2405         move    #-3,n7
P:020E 000000         2 1115 2406         nop
P:020F 4D6F00         4 1119 2407         move    x1,y:(r7+n7)
P:0210 20006D         2 1121 2408         cmp     x1,b
P:0211 0AF0A7 rrrrrr  6 1127 2413         jgt     L75
                             2414 
                             2415 ; 269  |
                             2416 ; 270  |    }
                             2417 ; 271  |    // if SilenceCount is greater than MaxSilenceCnt ( equivalent to 4.5 seconds ) then return SILENCE_DETECTED
                             2418 ; 272  |    if ( SilenceCount >= MaxSilenceCnt )
                             2419 
P:0213 5EF000 rrrrrr  3 1130 2421         move    y:FSilenceCount,a
P:0215 4EF000 rrrrrr  3 1133 2422         move    y:FMaxSilenceCnt,y0
P:0217 200055         2 1135 2423         cmp     y0,a
P:0218 0AF0A9 rrrrrr  6 1141 2424         jlt     L86
                             2425 
                             2426 ; 273  |    {
                             2427 ; 274  |        RetValue = SILENCE_DETECTED;
                             2428 
P:021A 77F400 FFFFFB  3 1144 2430         move    #-5,n7
P:021C 000000         2 1146 2431         nop
P:021D 4C6F00         4 1150 2432         move    x0,y:(r7+n7)
                             2433 
                             2434 ; 275  |    }
                             2435 ; 276  |    //  else return AUDIO_DETECTED 
                             2436 ; 277  |    return  RetValue;
                             2437 
P:021E 77F400 FFFFFB  3 1153 2439 L86:    move    #-5,n7
P:0220 000000         2 1155 2440         nop
P:0221 5EEF00         4 1159 2441         move    y:(r7+n7),a
                             2444 
                             2445 ; 278  |}
                             2446 
P:0222 77F400 FFFFF6  3 1162 2448         move    #-10,n7
P:0224 000000         2 1164 2449         nop
P:0225 05EF7C         4 1168 2450         movec   y:(r7+n7),ssh
P:0226 204F00         2 1170 2452         move    (r7)+n7
P:0227 00000C         4 1174 2454         rts
                             2463 
                             2464 ; 279  |/*//////////////////////////////////////////////////////////////////////////////
                             2465 ; 280  |
                             2466 ; 281  |/*  Name:  CheckSilenceBlockCount
                             2467 ; 282  |
                             2468 ; 283  |    Type:       void DetectSilence(void)
                             2469 ; 284  |
                             2470 ; 285  |    Description: determines whether end of album reached
                             2471 ; 286  |
                             2472 ; 287  |    Inputs:             
                             2473 ; 288  |            Nil
                             2474 ; 289  |    Outputs:            
                             2475 ; 290  |                    returns 1 for end of album reached and 0 for end of album not reached
                             2476 ; 291  |    Notes: 
                             2477 ; 292  |                        
                             2478 ; 293  |//////////////////////////////////////////////////////////////////////////////*/
                             2479 ; 294  |int CheckSilenceBlockCount()
                             2480 ; 295  |{
                             2481 
                             2486 FCheckSilenceBlockCount:
                             2487 
                             2488 ; 296  |    if ( SilenceCount > MaxDelay )
                             2489 
P:0228 5FF000 rrrrrr  3 1177 2491         move    y:FSilenceCount,b
P:022A 4EF000 rrrrrr  3 1180 2492         move    y:FMaxDelay,y0
P:022C 20005D         2 1182 2493         cmp     y0,b
                             2494 
                             2495 ; 297  |    {
                             2496 ; 298  |        return 1;
                             2497 
P:022D 56F400 000001  3 1185 2499         move    #>1,a
P:022F 0AF0A7 rrrrrr  6 1191 2501         jgt     L88
                             2502 
                             2503 ; 299  |    }
                             2504 ; 300  |    else 
                             2505 ; 301  |    {
                             2506 ; 302  |        return 0;
                             2507 
P:0231 200013         2 1193 2509         clr     a   
                             2510 
                             2511 ; 303  |    }
                             2512 ; 304  |}
                             2513 
P:0232 00000C         4 1197 2515 L88:    rts
                             2518 
                             2521 
Y:0000                       2522         org     y,".ybssdetectsilence",bss:
                             2523 FDCOffset:
Y:0000                       2524         ds      2
   |   RESERVED                   
Y:0001
                             2526 FDCOffsetBlocksProcessed:
Y:0002 RESERVED              2527         ds      1
Y:0002
                             2529 FDCOffsetSetback:
Y:0003 RESERVED              2530         ds      1
Y:0003
                             2533 FSilenceSR:
Y:0004 RESERVED              2534         ds      1
Y:0004
                             2536 FDCOffsetCnt:
Y:0005 RESERVED              2537         ds      1
Y:0005
                             2540 FMaxDelay:
Y:0006 RESERVED              2541         ds      1
Y:0006
                             2543 FDCOffsetPwr:
Y:0007 RESERVED              2544         ds      1
Y:0007
                             2551 FDCOffsetPtr:
Y:0008 RESERVED              2552         ds      1
Y:0008
                             2555 FSilenceCount:
Y:0009 RESERVED              2556         ds      1
Y:0009
                             2559 FSilencePtr:
Y:000A RESERVED              2560         ds      1
Y:000A
                             2564 FMaxSilenceCnt:
Y:000B RESERVED              2565         ds      1
Y:000B
                             2566 
                             2567         extern  FindDCOffset, FindEnergy, x:FDCOffsetADC
                             2568         extern  y:Fg_wEncADCLChOffset, y:Fg_wEncADCRChOffset
                             2569         extern  y:Fg_wEncSamplingRateIdx
                             2570 
                             2571         global  FCheckSilenceBlockCount, FComputeDCOffset
                             2572         global  FComputeDCOffsetInit, FDetectSilence, FDetectSilenceInit
                             2573         global  FMaxDelay, FMaxSilenceCnt, FSilenceCount, FSilencePtr
                             2574         global  FSilenceSR
                             2575 
                             2576         local   FDCOffset, FDCOffsetBlocksProcessed, FDCOffsetCnt
                             2577         local   FDCOffsetPtr, FDCOffsetPwr, FDCOffsetSetback, L4, L39, L40
                             2578         local   L41, L42, L43, L44, L46, L47, L49, L50, L51, L52, L53, L54
                             2579         local   L55, L56, L57, L58, L59, L74, L75, L76, L77, L78, L79, L82
                             2580         local   L83, L84, L85, L86, L87, L88
                             2581 
                             2582         calls   "ComputeDCOffset", "FindDCOffset"
                             2583         calls   "DetectSilence", "FindEnergy"
                             2584 
