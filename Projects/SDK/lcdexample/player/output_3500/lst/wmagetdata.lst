TASKING DSP2410 assembler v1.5r1 Build 138 SN 00100122
                                                                                                                                                                                                                                                       Page   1
C:\STMP3XXX_SDK_FIRMWARE_320_finalfix\algorithms\decoders\wma\wmagetdata.asm
M:ADDR CODE           CYCLES LINE SOURCELINE
                                1 ;;***********************************************************************
                                2 ;SigmaTel, Inc
                                3 ;$Archive: $
                                4 ;$Revision:  $
                                5 ;$Date: $
                                6 ;Description: Call back function for FileRead.
                                7 ;   Equivalent C code is available at the end of file.
                                8 ;***********************************************************************/
                               10     section WmaGetData
                               12 ;********************************************************************************
                               13 ;*      INCLUDES
                               14 ;********************************************************************************
                               15         include "sysmacro.asm"
                                1 ;///////////////////////////////////////////////////////////////////////////////
                                2 ;  Copyright(C) SigmaTel, Inc. 2000-2001
                                3 ;
                                4 ;  File        : sysmacro.asm
                                5 ;  Description : Misc System Macros
                                6 ;///////////////////////////////////////////////////////////////////////////////
                                8     define   SysMacro_asm    '1'
                               10     page    255,255,0
                               12 ;///////////////////////////////////////////////////////////////////////////////
                               13 ;   Macros
                               14 ;///////////////////////////////////////////////////////////////////////////////
                               16 ;///////////////////////////////////////////////////////////////////////////////
                               17 ;   Includes
                               18 ;///////////////////////////////////////////////////////////////////////////////
                               20 ;///////////////////////////////////////////////////////////////////////////////
                               21 ;   External Definitions
                               22 ;///////////////////////////////////////////////////////////////////////////////
                               24 ;///////////////////////////////////////////////////////////////////////////////
                               25 ;   External References
                               26 ;///////////////////////////////////////////////////////////////////////////////
                               28 ;///////////////////////////////////////////////////////////////////////////////
                               29 ;   Equates
                               30 ;///////////////////////////////////////////////////////////////////////////////
                               31         
                               32 ;///////////////////////////////////////////////////////////////////////////////
                               33 ;   X Memory
                               34 ;///////////////////////////////////////////////////////////////////////////////
                               35         
                               36 ;///////////////////////////////////////////////////////////////////////////////
                               37 ;   Y Memory
                               38 ;///////////////////////////////////////////////////////////////////////////////
                               39         
                               40 ;///////////////////////////////////////////////////////////////////////////////
                               41 ;   P Memory
                               42 ;///////////////////////////////////////////////////////////////////////////////
                               44 ;///////////////////////////////////////////////////////////////////////////////
                               45 ;
                               46 ;>  Name:           push
                               47 ;
                               48 ;   Type:           Macro
                               49 ;
                               50 ;   Description:    Push a 24-bit value onto the data stack
                               51 ;
                               52 ;   Inputs:         Usage : push reg
                               53 ;                   reg = any core register that is 24-bits or less
                               54 ;
                               55 ;   Outputs:        none
                               56 ;                   
                               57 ;   Notes:          For every push, there must be a corresponding pop to keep
                               58 ;                   data stack balanced.
                               59 ;
                               60 ;   SeeAlso:        pop
                               61 ;<
                               62 ;///////////////////////////////////////////////////////////////////////////////
                               63 push    macro   reg
                               64     move    reg,y:(r7)+
                               65     endm
                               67 ;///////////////////////////////////////////////////////////////////////////////
                               68 ;
                               69 ;>  Name:           pop
                               70 ;
                               71 ;   Type:           Macro
                               72 ;
                               73 ;   Description:    Pop a 24-bit value from the data stack
                               74 ;
                               75 ;   Inputs:         Usage : pop reg
                               76 ;                   reg = any core register that is 24-bits or less
                               77 ;
                               78 ;   Outputs:        none
                               79 ;                   
                               80 ;   Notes:          For every pop, there must be a corresponding push to keep
                               81 ;                   data stack balanced.
                               82 ;
                               83 ;   SeeAlso:        push
                               84 ;<
                               85 ;///////////////////////////////////////////////////////////////////////////////
                               86 pop     macro   reg
                               87     move    y:-(r7),reg
                               88     endm
                               90 ;///////////////////////////////////////////////////////////////////////////////
                               91 ;
                               92 ;>  Name:           CallFunclet
                               93 ;
                               94 ;   Type:           Macro
                               95 ;
                               96 ;   Description:    Loads and Executes the funclet defined by the Resource argument
                               97 ;
                               98 ;   Inputs:         Resource = Resource number for the specific funclet.
                               99 ;
                              100 ;   Outputs:        none
                              101 ;                   
                              102 ;   Notes:          Jumps to SysCallFunclet.   TODO: change to a label instead of hard addresses like $80
                              103 ;<
                              104 ;///////////////////////////////////////////////////////////////////////////////
                              105 ; if ((@DEF('STMP_BUILD_PLAYER'))||(@DEF('PLAYER'))) ; sdk3.110 and before did this. 3.120 add short jump for mtp.
                              107 CallFunclet   macro Resource
                              108     jsr       $80
                              109     DC       Resource  ; 1 word
                              110  endm    
                              111 CallFunclet2   macro Resource
                              112  if ((@DEF('STMP_BUILD_PLAYER'))||(@DEF('PLAYER')))
                              113     jsr       $82
                              114     DC       Resource  ; 1 word
                              115  else ;;; MTP
                              116     jsr       $80
                              117     DC       Resource  ; 1 word
                              118  endif
                              119     endm    
                              130 ;///////////////////////////////////////////////////////////////////////////////
                              131 ;
                              132 ;>  Name:           error
                              133 ;
                              134 ;   Type:           Macro
                              135 ;
                              136 ;   Description:    Fatal system error macro.  This macro works in conjunction
                              137 ;                   with contents of syserror.asm.  Depending upon the build
                              138 ;                   arguments DEBUG, BETA, or RETAIL, this will either produce
                              139 ;                   a "debug" statement or a JMP to an error handling reset routine.
                              140 ;
                              141 ;   Inputs:         none 
                              142 ;   Outputs:        none                   
                              143 ;   Notes:          Can use debugOrContinue or ccerror for conditional halts. 
                              144 ;                   SystemHalt() C macro uses this asm macro.
                              145 ;<
                              146 ;///////////////////////////////////////////////////////////////////////////////
                              147 error   macro
                              148   if (@DEF('BETA')||@DEF('RETAIL')||@DEF('TRACEBUFFER'))
                              149     jmp $000C ;Use vector at P:000C to shutdown & restart the STMP device. 
                              150               ; Jmp to addr in low 12 bits is 1 word smaller than jsr. (changed apr 6 '05)
                              151   else
                              152     debug
                              153   endif ; if ( @DEF('BETA')||@DEF('RETAIL') 
                              154     endm
                              156 ;///////////////////////////////////////////////////////////////////////////////
                              157 ;
                              158 ;   Name:           debugOrContinue
                              159 ;   Type:           Macro
                              160 ;   Description:    System error macro. Depending upon the build
                              161 ;                   arguments DEBUG, BETA, or RETAIL, this will either produce
                              162 ;                   a "debug" statement or nothing to allow continued execution.
                              163 ;   Inputs:         none 
                              164 ;   Outputs:        none
                              165 ;   Notes:          none
                              166 ;
                              167 ;///////////////////////////////////////////////////////////////////////////////
                              168 debugOrContinue   macro
                              169   if (@DEF('DEBUG'))
                              170     debug
                              171     nop
                              172   endif 
                              173     endm
                              175 ;///////////////////////////////////////////////////////////////////////////////
                              176 ;
                              177 ;   Name:           debugOrShutdown
                              178 ;   Type:           Macro
                              179 ;   Description:    System error macro. Depending upon the build
                              180 ;                   arguments DEBUG, BETA, or RETAIL, this will either produce
                              181 ;                   a "debug" statement or Prevent RETAIL build from hanging on 
                              182 ;                   debug line by attempting graceful shutdown.
                              183 ;   Inputs:         none 
                              184 ;   Outputs:        none
                              185 ;   Notes:          See SystemShutdownFinal in SystemAPI.asm
                              186 ;
                              187 ;///////////////////////////////////////////////////////////////////////////////
                              188 ;debugOrShutdown   macro
                              189 ;  if (@DEF('DEBUG'))
                              190 ;    debug
                              191 ;    nop
                              192 ;  else  ; ( @DEF('BETA')||@DEF('RETAIL')
                              193 ;    jmp SystemShutdownFinal                ; reference not resolved
                              194 ;  endif 
                              195 ;    endm
                              198 ;///////////////////////////////////////////////////////////////////////////////
                              199 ;> Name:            ccerror
                              200 ;
                              201 ;  Type:            Macro
                              202 ;  Description:     Conditional fatal system error macro.  If the indicated
                              203 ;                   condition code ("CC") is met, signal the error.  (See "error",
                              204 ;                   above for more info on error hanlding.)
                              205 ;                   The allowed condition condition codes are
                              206 ;
                              207 ;                       cc, cs, ec, eq, es, ge, gt, lc, le, ls, lt, 
                              208 ;                       mi, ne, nr, pl, nn 
                              209 ;
                              210 ;  Inputs:          condition
                              211 ;
                              212 ;  Outputs:         none
                              213 ;
                              214 ;  Notes:           The normal way of using these macros is shown below:
                              215 ;
                              216 ;                       <some operation which sets/clears a condition code>
                              217 ;                       ccerror cs             ; Error if carry is set
                              218 ;                       <normal continuation>
                              219 ;
                              220 ;                   This can replace old code of the form:
                              221 ;
                              222 ;                       <some operation which sets/clears a condition code>
                              223 ;                       jcc     _OK
                              224 ;                       error
                              225 ;                   _OK
                              226 ;                       <normal continuation>
                              227 ;
                              228 ;                   Depending on the BETA/RETAIL flags, the first operation can
                              229 ;                   save one or two words of program memory over the second method.
                              230 ;<
                              231 ;///////////////////////////////////////////////////////////////////////////////
                              232 ccerror macro   condition
                              233   if (@DEF('BETA')||@DEF('RETAIL'))
                              234     js\condition $000C
                              235   else
                              236     debug\condition
                              237   endif ; if ( @DEF('BETA')||@DEF('RETAIL') 
                              238     endm
                              240 ;///////////////////////////////////////////////////////////////////////////////
                              241 ;> Name: GetLogicalDriveNumForResourceBin
                              242 ;
                              243 ; Description: Used for our RestoreDriveFromBackup routine.
                              244 ; INPUT: 1 for primary resource.bin
                              245 ;        2 for secondary resource.bin
                              246 ;        3 for master redundant resource.bin that is used to restore 1 and 2 at power up if needed.
                              247 ;
                              248 ; NOTE: If the drive arrays is modified in ddiproject.c then the values below will
                              249 ;       have to change. Inspect that file to verify these values are correct.
                              250 ;
                              251 ;<
                              252 ;///////////////////////////////////////////////////////////////////////////////
                              253 GetLogicalDriveNumForResourceBin macro drive
                              254     if (drive==0)
                              255     fail    "drive=0 invalid value used in GetLogicalDriveNumForresourceBin macro"
                              256     endif
                              258     if (drive>3)
                              259     fail    "drive>3 invalid value used in GetLogicalDriveNumForresourceBin macro"
                              260     endif
                              262     if (@DEF('MMC'))
                              264         if drive==1
                              265              move   #>6,a
                              266         endif
                              267     
TASKING DSP2410 assembler v1.5r1 Build 138 SN 00100122
                                                                                                                                                                                                                                                       Page   2

M:ADDR CODE           CYCLES LINE SOURCELINE
                              268         if drive==2
                              269              move   #>7,a
                              270         endif
                              272         if drive==3
                              273              move   #>8,a
                              274         endif
                              275     else
                              277         if drive==1
                              278              move   #>5,a
                              279         endif
                              280     
                              281         if drive==2
                              282              move   #>6,a
                              283         endif
                              285         if drive==3
                              286              move   #>7,a
                              287         endif
                              288     endif
                              289  endm
                              291 ;///////////////////////////////////////////////////////////////////////////////
                              292 ;
                              293 ;>  Name:           SaveRange
                              294 ;
                              295 ;   Type:           Macro
                              296 ;
                              297 ;   Description:    This is a supporting macro for saving memory locations to
                              298 ;                   the settings.dat file at shutdown, for later restoration
                              299 ;                   at system startup.
                              300 ;
                              301 ;   Inputs:         Usage : SaveRange Label,Length
                              302 ;                        
                              303 ;   Outputs:        
                              304 ;                   
                              305 ;   Notes:          This macro automatically determines the memory space of the
                              306 ;                   label specified.  It then constructs a command that is 
                              307 ;                   written to settings.dat by SysSaveSettings, and is
                              308 ;                   understood by the SysLoadSettings function to restore the
                              309 ;                   memory locations.  For the SaveRange macro to be recognized 
                              310 ;                   by the SysSaveSettings function.  The section name where the
                              311 ;                   SaveRange command is used, must be included in the 
                              312 ;                   Settings_Y cluster in the stmp3400.dsc file.  The makefile
                              313 ;                   will then extract these commands as a resource to be used
                              314 ;                   by SysSaveSettings and SysLoadSettings.
                              315 ;
                              316 ;   SeeAlso:        SysLoadSettings, SysSaveSettings, SaveRangeX, 
                              317 ;                   SaveRangeY, SaveRangeP, SaveRangeL
                              318 ;
                              319 ;<
                              320 ;///////////////////////////////////////////////////////////////////////////////
                              321 SaveRange macro Label,Length
                              322     if @MSP(Label)==0  ;None
                              323     fail    "Invalid label used in SaveRange macro"
                              324     dc      Label
                              325     endif ; if @MSP(Label)==0
                              327     if @MSP(Label)==1  ;X
                              328     dc      $800000|Label
                              329     endif ; if @MSP(Label)==1
                              331     if @MSP(Label)==2  ;Y
                              332     dc      $400000|Label
                              333     endif ; if @MSP(Label)==2
                              335     if @MSP(Label)==3  ;L
                              336     dc      $200000|Label
                              337     endif ; if @MSP(Label)==3
                              339     if @MSP(Label)==4  ;P
                              340     dc      $100000|Label
                              341     endif ; if @MSP(Label)==4
                              343     if @MSP(Label)==5  ;E
                              344     fail    "Invalid label used in SaveRange macro"
                              345     dc      Label
                              346     endif ; if @MSP(Label)==5
                              348     dc      Length*3
                              349     endm
                              351 ;///////////////////////////////////////////////////////////////////////////////
                              352 ;
                              353 ;>  Name:           SaveRangeY
                              354 ;
                              355 ;   Type:           Macro
                              356 ;
                              357 ;   Description:    This is a supporting macro for saving memory locations to
                              358 ;                   the settings.dat file at shutdown, for later restoration
                              359 ;                   at system startup.
                              360 ;
                              361 ;   Inputs:         Usage : SaveRangeY Label,Length
                              362 ;                        
                              363 ;   Outputs:        
                              364 ;                   
                              365 ;   Notes:          Refer to the SaveRange macro for more details.  This macro
                              366 ;                   can take a numeric address, or a label, but will only
                              367 ;                   create a save memory command that indicates Y memory
                              368 ;                   to be saved.
                              369 ;
                              370 ;   SeeAlso:        SysLoadSettings, SysSaveSettings, SaveRange, 
                              371 ;                   SaveRangeX, SaveRangeP, SaveRangeL
                              372 ;
                              373 ;<
                              374 ;///////////////////////////////////////////////////////////////////////////////
                              375 SaveRangeY macro Address,Length
                              376     dc      $400000|Address
                              377     dc      Length*3
                              378     endm
                              380 ;///////////////////////////////////////////////////////////////////////////////
                              381 ;
                              382 ;>  Name:           SaveRangeX
                              383 ;
                              384 ;   Type:           Macro
                              385 ;
                              386 ;   Description:    This is a supporting macro for saving memory locations to
                              387 ;                   the settings.dat file at shutdown, for later restoration
                              388 ;                   at system startup.
                              389 ;
                              390 ;   Inputs:         Usage : SaveRangeX Label,Length
                              391 ;                        
                              392 ;   Outputs:        
                              393 ;                   
                              394 ;   Notes:          Refer to the SaveRange macro for more details.  This macro
                              395 ;                   can take a numeric address, or a label, but will only
                              396 ;                   create a save memory command that indicates X memory
                              397 ;                   to be saved.
                              398 ;
                              399 ;   See Also:       SysLoadSettings, SysSaveSettings, SaveRange, 
                              400 ;                   SaveRangeY, SaveRangeP, SaveRangeL
                              401 ;
                              402 ;<
                              403 ;///////////////////////////////////////////////////////////////////////////////
                              404 SaveRangeX macro Address,Length
                              405     dc      $800000|Address
                              406     dc      Length*3
                              407     endm
                              409 ;///////////////////////////////////////////////////////////////////////////////
                              410 ;
                              411 ;>  Name:           SaveRangeL
                              412 ;
                              413 ;   Type:           Macro
                              414 ;
                              415 ;   Description:    This is a supporting macro for saving memory locations to
                              416 ;                   the settings.dat file at shutdown, for later restoration
                              417 ;                   at system startup.
                              418 ;
                              419 ;   Inputs:         Usage : SaveRangeL Label,Length
                              420 ;                        
                              421 ;   Outputs:        
                              422 ;                   
                              423 ;   Notes:          Refer to the SaveRange macro for more details.  This macro
                              424 ;                   can take a numeric address, or a label, but will only
                              425 ;                   create a save memory command that indicates L memory
                              426 ;                   to be saved.
                              427 ;
                              428 ;   SeeAlso:        SysLoadSettings, SysSaveSettings, SaveRange, 
                              429 ;                   SaveRangeX, SaveRangeY, SaveRangeP
                              430 ;
                              431 ;<
                              432 ;///////////////////////////////////////////////////////////////////////////////
                              433 SaveRangeL macro Address,Length
                              434     dc      $200000|Address
                              435     dc      Length*3
                              436     endm
                              438 ;///////////////////////////////////////////////////////////////////////////////
                              439 ;
                              440 ;>  Name:           SaveRangeP
                              441 ;
                              442 ;   Type:           Macro
                              443 ;
                              444 ;   Description:    This is a supporting macro for saving memory locations to
                              445 ;                   the settings.dat file at shutdown, for later restoration
                              446 ;                   at system startup.
                              447 ;
                              448 ;   Inputs:         Usage : SaveRangeP Label,Length
                              449 ;                        
                              450 ;   Outputs:        
                              451 ;                   
                              452 ;   Notes:          Refer to the SaveRange macro for more details.  This macro
                              453 ;                   can take a numeric address, or a label, but will only
                              454 ;                   create a save memory command that indicates P memory
                              455 ;                   to be saved.
                              456 ;
                              457 ;   SeeAlso:        SysLoadSettings, SysSaveSettings, SaveRange, 
                              458 ;                   SaveRangeX, SaveRangeY, SaveRangeL
                              459 ;
                              460 ;<
                              461 ;///////////////////////////////////////////////////////////////////////////////
                              462 SaveRangeP macro Address,Length
                              463     dc      $100000|Address
                              464     dc      Length*3
                              465     endm
                              468 ;///////////////////////////////////////////////////////////////////////////////
                              469 ;       BUTTON MACROS
                              470 ;///////////////////////////////////////////////////////////////////////////////
                              472 ;///////////////////////////////////////////////////////////////////////////////
                              473 ;
                              474 ;>  Name:           DEFINE_ROW
                              475 ;
                              476 ;   Type:           Macro
                              477 ;
                              478 ;   Description:    This is a supporting macro for defining the GPIO setup for 
                              479 ;                   the scan matrix.
                              480 ;
                              481 ;   Inputs:         Usage : DEFINE_ROW RowNumber,WhichGPIORegister,WhichBit
                              482 ;                        
                              483 ;   Outputs:        Sets up equates required for data structures in button.asm
                              484 ;                   
                              485 ;   Notes:          Must be used in conjuction with DEFINE_COLUMN, DEFINE_SCAN_BUTTON_EVENT,
                              486 ;                   DEFINE_NON_SCAN_BUTTON,DEFINE_NON_SCAN_BUTTON_EVENT, and DEFINE_MAPPED_EVENT to
                              487 ;                   completely define the players button scan matrix, non scan buttons, and
                              488 ;                   how these buttons map to events as recieved by the menus.  There must be one of these
                              489 ;                   macro definitions for each row in the scan matrix.
                              490 ;
                              491 ;   SeeAlso:        DEFINE_COLUMN, DEFINE_SCAN_BUTTON_EVENT,DEFINE_NON_SCAN_BUTTON,
                              492 ;                   DEFINE_NON_SCAN_BUTTON_EVENT, and DEFINE_MAPPED_EVENT
                              493 ;
                              494 ;<
                              495 ;///////////////////////////////////////////////////////////////////////////////
                              497 DEFINE_ROW macro RowNumber,WhichGPIO,WhichBit
                              498     BUTTON_GPIO_ENABLE_ROW_\RowNumber:  equ HW_\WhichGPIO\ENR
                              499     BUTTON_GPIO_SENSE_ROW_\RowNumber:   equ HW_\WhichGPIO\DIR
                              500     BUTTON_BITPOS_ROW_\RowNumber:       equ 1<<\WhichBit
                              501     endm
                              503 ;///////////////////////////////////////////////////////////////////////////////
                              504 ;
                              505 ;>  Name:           DEFINE_COLUMN
                              506 ;
                              507 ;   Type:           Macro
                              508 ;
                              509 ;   Description:    This is a supporting macro for defining the GPIO setup for 
                              510 ;                   the scan matrix.
                              511 ;
                              512 ;   Inputs:         Usage : DEFINE_COLUMN ColumnNumber,WhichGPIORegister,WhichBit
                              513 ;                        
                              514 ;   Outputs:        Sets up equates required for data structures in button.asm
                              515 ;                   
                              516 ;   Notes:          Must be used in conjuction with DEFINE_COLUMN, DEFINE_SCAN_BUTTON_EVENT,
                              517 ;                   DEFINE_NON_SCAN_BUTTON,DEFINE_NON_SCAN_BUTTON_EVENT, and DEFINE_MAPPED_EVENT to
                              518 ;                   completely define the players button scan matrix, non scan buttons, and
                              519 ;                   how these buttons map to events as recieved by the menus.  There must be one
                              520 ;                   of these macro definitions for each column in the scan matrix.
                              521 ;
                              522 ;   SeeAlso:        DEFINE_COLUMN, DEFINE_SCAN_BUTTON_EVENT,DEFINE_NON_SCAN_BUTTON,
                              523 ;                   DEFINE_NON_SCAN_BUTTON_EVENT, and DEFINE_MAPPED_EVENT
                              524 ;
                              525 ;<
                              526 ;///////////////////////////////////////////////////////////////////////////////
                              527 DEFINE_COLUMN macro ColumnNumber,WhichGPIO,WhichBit
                              528     BUTTON_GPIO_ENABLE_COLUMN_\ColumnNumber:        equ HW_\WhichGPIO\ENR
                              529     BUTTON_GPIO_DATA_OUT_COLUMN_\ColumnNumber:      equ HW_\WhichGPIO\DOR
                              530     BUTTON_GPIO_OUTPUT_ENABLE_COLUMN_\ColumnNumber: equ HW_\WhichGPIO\DOER
                              531     BUTTON_BITPOS_COLUMN_\ColumnNumber:             equ 1<<\WhichBit
                              532     endm
                              534 ;///////////////////////////////////////////////////////////////////////////////
                              535 ;
                              536 ;>  Name:           DEFINE_SCAN_BUTTON_EVENT
                              537 ;
                              538 ;   Type:           Macro
TASKING DSP2410 assembler v1.5r1 Build 138 SN 00100122
                                                                                                                                                                                                                                                       Page   3

M:ADDR CODE           CYCLES LINE SOURCELINE
                              539 ;
                              540 ;   Description:    This is a supporting macro for defining the mapping between a scan
                              541 ;                   matrix location and a button event.
                              542 ;
                              543 ;   Inputs:         Usage : DEFINE_SCAN_BUTTON_EVENT Column,Row,EventNumber,ButtonName.  
                              544 ;                       Column is in the format COL0,COL1,COL2, etc.  
                              545 ;                       Row is in the format ROW0,ROW1,etc. 
                              546 ;                       The EventNumber is an integer with a single bit set that is unique to all button events
                              547 ;                       ButtonName is a label by which this button event can be referenced in the event mapping.
                              548 ;                        
                              549 ;   Outputs:        Sets up equates required for data structures in button.asm
                              550 ;                   
                              551 ;   Notes:          Must be used in conjuction with DEFINE_COLUMN, DEFINE_SCAN_BUTTON_EVENT,
                              552 ;                   DEFINE_NON_SCAN_BUTTON,DEFINE_NON_SCAN_BUTTON_EVENT, and DEFINE_MAPPED_EVENT to
                              553 ;                   completely define the players button scan matrix, non scan buttons, and
                              554 ;                   how these buttons map to events as recieved by the menus. This macro sets up buttons for each
                              555 ;                   spot in the button scan matrix.  Each place in the matrix must be defined, even if no
                              556 ;                   physical button exists in it.  Use $000000 for placeholders.
                              557 ;
                              558 ;   SeeAlso:        DEFINE_COLUMN, DEFINE_SCAN_BUTTON_EVENT,DEFINE_NON_SCAN_BUTTON,
                              559 ;                   DEFINE_NON_SCAN_BUTTON_EVENT, and DEFINE_MAPPED_EVENT
                              560 ;
                              561 ;<
                              562 ;///////////////////////////////////////////////////////////////////////////////
                              563 DEFINE_SCAN_BUTTON_EVENT macro Column,Row,EventNumber,ButtonName
                              564     BUTTON_EVENT_\Column\Row:  equ \EventNumber
                              565     ButtonName: equ \EventNumber
                              566     endm 
                              568 ;///////////////////////////////////////////////////////////////////////////////
                              569 ;
                              570 ;>  Name:           DEFINE_NON_SCAN_BUTTON
                              571 ;
                              572 ;   Type:           Macro
                              573 ;
                              574 ;   Description:    This is a supporting macro for defining a non scan button.
                              575 ;
                              576 ;   Inputs:         Usage : DEFINE_NON_SCAN_BUTTON NSNumber,WhichGPIO,WhichBit.  
                              577 ;                       NSNumber is a unique number (starting at 0) and counting up to BUTTON_NON_SCAN_BUTTONS-1
                              578 ;                       WhichGPIO is the GPIO register used
                              579 ;                       WhichBit is the bit in this register.
                              580 ;                        
                              581 ;   Outputs:        Sets up equates required for data structures in button.asm
                              582 ;                   
                              583 ;   Notes:          Must be used in conjuction with DEFINE_COLUMN, DEFINE_SCAN_BUTTON_EVENT,
                              584 ;                   DEFINE_NON_SCAN_BUTTON,DEFINE_NON_SCAN_BUTTON_EVENT, and DEFINE_MAPPED_EVENT to
                              585 ;                   completely define the players button scan matrix, non scan buttons, and
                              586 ;                   how these buttons map to events as recieved by the menus. This macro sets up non scan
                              587 ;                   buttons.  Use DEFINE_NON_SCAN_BUTTON_EVENT to define the event generated by this non scan
                              588 ;                   button.
                              589 ;
                              590 ;   SeeAlso:        DEFINE_COLUMN, DEFINE_SCAN_BUTTON_EVENT,DEFINE_NON_SCAN_BUTTON,
                              591 ;                   DEFINE_NON_SCAN_BUTTON_EVENT, and DEFINE_MAPPED_EVENT
                              592 ;
                              593 ;<
                              594 ;///////////////////////////////////////////////////////////////////////////////
                              595 DEFINE_NON_SCAN_BUTTON macro NSNumber,WhichGPIO,WhichBit
                              596     BUTTON_GPIO_ENABLE_NON_SCAN_\NSNumber:  equ HW_\WhichGPIO\ENR
                              597     BUTTON_GPIO_SENSE_NON_SCAN_\NSNumber:   equ HW_\WhichGPIO\DIR
                              598     BUTTON_BITPOS_NON_SCAN_\NSNumber:       equ 1<<\WhichBit
                              599     BUTTON_REAL_BITPOS_NON_SCAN_\NSNumber:  equ \WhichBit
                              600     endm
                              602 ;///////////////////////////////////////////////////////////////////////////////
                              603 ;
                              604 ;>  Name:           DEFINE_NON_SCAN_BUTTON_EVENT
                              605 ;
                              606 ;   Type:           Macro
                              607 ;
                              608 ;   Description:    This is a supporting macro for defining a non scan button.
                              609 ;
                              610 ;   Inputs:         Usage : DEFINE_NON_SCAN_BUTTON_EVENT Number,EventNumber,ButtonName  
                              611 ;                       Number is a unique number (starting at 0) and counting up to BUTTON_NON_SCAN_BUTTONS-1
                              612 ;                       EventNumber is an integer with 1 bit set that is unique to all other buttons
                              613 ;                       ButtonName is a label later referenced in the event mapping
                              614 ;                        
                              615 ;   Outputs:        Sets up equates required for data structures in button.asm
                              616 ;                   
                              617 ;   Notes:          Must be used in conjuction with DEFINE_COLUMN, DEFINE_SCAN_BUTTON_EVENT,
                              618 ;                   DEFINE_NON_SCAN_BUTTON,DEFINE_NON_SCAN_BUTTON_EVENT, and DEFINE_MAPPED_EVENT to
                              619 ;                   completely define the players button scan matrix, non scan buttons, and
                              620 ;                   how these buttons map to events as recieved by the menus. This macro sets up non scan
                              621 ;                   buttons.  
                              622 ;
                              623 ;   SeeAlso:        DEFINE_COLUMN, DEFINE_SCAN_BUTTON_EVENT,DEFINE_NON_SCAN_BUTTON,
                              624 ;                   DEFINE_NON_SCAN_BUTTON_EVENT, and DEFINE_MAPPED_EVENT
                              625 ;
                              626 ;<
                              627 ;///////////////////////////////////////////////////////////////////////////////
                              628 DEFINE_NON_SCAN_BUTTON_EVENT macro Number,EventNumber,ButtonName
                              629     BUTTON_EVENT_NONSCAN\Number:  equ \EventNumber
                              630     ButtonName: equ \EventNumber
                              631     endm 
                              635 ;///////////////////////////////////////////////////////////////////////////////
                              636 ;> Name: DEFINE_LRADC_BUTTON
                              637 ;
                              638 ;  Type: Macro
                              639 ;
                              640 ;  Description: This is a supporting macro for defining an Low Resolution ADC (LRADC)-based button
                              641 ;
                              642 ;  Inputs:      Usage : DEFINE_LRADC_BUTTON LBNumber,UpperLimitVoltage
                              643 ;
                              644 ;  Outputs:     Sets up equates required for data structures in button.asm
                              645 ;
                              646 ;  Notes:       Must be used in conjuction with DEFINE_LRADC_BUTTON_EVENT, and DEFINE_MAPPED_EVENT to
                              647 ;                   completely define the player's LRADC buttons and how these buttons map to 
                              648 ;                   events as recieved by the menus. This macro sets up LRADC buttons.  Use 
                              649 ;                   DEFINE_LRADC_BUTTON_EVENT to define the event generated by this LRADC button.
                              650 ;
                              651 ;   SeeAlso:        DEFINE_LRADC_BUTTON_EVENT, DEFINE_COLUMN, DEFINE_SCAN_BUTTON_EVENT,
                              652 ;                   DEFINE_NON_SCAN_BUTTON, DEFINE_NON_SCAN_BUTTON_EVENT, and DEFINE_MAPPED_EVENT
                              653 ;<
                              654 ;///////////////////////////////////////////////////////////////////////////////
                              655 DEFINE_LRADC_BUTTON     macro   num,level
                              656     BUTTON_LRADC_LEVEL_\num:    equ level
                              657     endm
                              661 ;///////////////////////////////////////////////////////////////////////////////
                              662 ;> Name: DEFINE_LRADC_BUTTON_EVENT
                              663 ;
                              664 ;  Type: Macro
                              665 ;
                              666 ;  Description:     This is a supporting macro for defining a Low Resolution ADC (LRADC)-based button.
                              667 ;
                              668 ;  Inputs:          Usage : DEFINE_LRADC_BUTTON_EVENT Number,EventNumber,ButtonName  
                              669 ;                       Number is a unique number (starting at 0) and counting up to BUTTON_LRADC_BUTTONS-1
                              670 ;                       EventNumber is an integer with 1 bit set that is unique to all other buttons
                              671 ;                       ButtonName is a label later referenced in the event mapping
                              672  
                              673 ;
                              674 ;  Outputs:         Sets up equates required for data structures in button.asm
                              675 ;
                              676 ;  Notes:           Must be used in conjuction with DEFINE_LRADC_BUTTON, and DEFINE_MAPPED_EVENT to
                              677 ;                   completely define the player's LRADC buttons and how these buttons map to events 
                              678 ;                   as recieved by the menus. This macro sets up LRADC buttons.
                              679 ;
                              680 ;
                              681 ;   SeeAlso:        DEFINE_LRADC_BUTTON, DEFINE_COLUMN, DEFINE_SCAN_BUTTON_EVENT,DEFINE_NON_SCAN_BUTTON,
                              682 ;                   DEFINE_NON_SCAN_BUTTON_EVENT, and DEFINE_MAPPED_EVENT
                              683 ;<
                              684 ;///////////////////////////////////////////////////////////////////////////////
                              685 DEFINE_LRADC_BUTTON_EVENT      macro   num,EventNumber,ButtonName
                              686     BUTTON_EVENT_LRADC_BUTTON\num: equ \EventNumber
                              687     ButtonName:     equ     \EventNumber   
                              688     endm
                              689   
                              692 ;///////////////////////////////////////////////////////////////////////////////
                              693 ;
                              694 ;>  Name:           DEFINE_MAPPED_EVENT
                              695 ;
                              696 ;   Type:           Macro
                              697 ;
                              698 ;   Description:    This is a supporting macro for defining button events.
                              699 ;
                              700 ;   Inputs:         Usage : DEFINE_MAPPED_EVENT Number,Action,ButtonNames 
                              701 ;                       Number is a unique number (starting at 0) and counting up to BUTTON_MAPPED_EVENTS-1
                              702 ;                       Action is either PRESS_RELEASE or PRESS_HOLD
                              703 ;                       ButtonNames is a collection of labels defined for scan or non scan buttons that relate
                              704 ;                           to this button event.
                              705 ;                        
                              706 ;   Outputs:        Sets up equates required for data structures in button.asm
                              707 ;                   
                              708 ;   Notes:          Must be used in conjuction with DEFINE_COLUMN, DEFINE_SCAN_BUTTON_EVENT,
                              709 ;                   DEFINE_NON_SCAN_BUTTON,DEFINE_NON_SCAN_BUTTON_EVENT, and DEFINE_MAPPED_EVENT to
                              710 ;                   completely define the players button scan matrix, non scan buttons, and
                              711 ;                   how these buttons map to events as recieved by the menus. This macro sets up the mapping
                              712 ;                   between scan and non scan buttons, and the eventual event number that is sent to the menus.
                              713 ;
                              714 ;   SeeAlso:        DEFINE_COLUMN, DEFINE_SCAN_BUTTON_EVENT,DEFINE_NON_SCAN_BUTTON,
                              715 ;                   DEFINE_NON_SCAN_BUTTON_EVENT, and DEFINE_MAPPED_EVENT
                              716 ;
                              717 ;<
                              718 ;///////////////////////////////////////////////////////////////////////////////
                              719 DEFINE_MAPPED_EVENT macro Number,Action,ButtonNames
                              720     
                              721   IF (@SCP("Action","PRESS_RELEASE"))
                              722     BUTTON_EVENT_\Number:  equ ButtonNames
                              723   else 
                              724     if (@SCP("Action","PRESS_HOLD"))
                              725         BUTTON_EVENT_\Number:  equ $800000|ButtonNames
                              726     else
                              727         ERROR "Unknown Action for DEFINE_MAPPED_EVENT" 
                              728     endif
                              729   endif 
                              730     endm
                              733 ;///////////////////////////////////////////////////////////////////////////////
                              734 ;
                              735 ;>  Name:           DEFINE_2BUTTON_MAPPED_EVENT
                              736 ;
                              737 ;   Type:           Macro
                              738 ;
                              739 ;   Description:    This is a supporting macro for defining button events.
                              740 ;
                              741 ;   Inputs:         Usage : DEFINE_2BUTTON_MAPPED_EVENT Number,Action,Event1,Event2 
                              742 ;                       Number is a unique number (starting at 0) and counting up to BUTTON_MAPPED_EVENTS-1
                              743 ;                       Action is either PRESS_RELEASE or PRESS_HOLD
                              744 ;                       Event1 is 1 of 2 previously defined button events
                              745 ;                       Event2 is 2 of 2 previously defined button events
                              746 ;                        
                              747 ;   Outputs:        Sets up equates required for data structures in button.asm
                              748 ;                   
                              749 ;   Notes:          Must be used in conjuction with DEFINE_COLUMN, DEFINE_SCAN_BUTTON_EVENT,
                              750 ;                   DEFINE_NON_SCAN_BUTTON,DEFINE_NON_SCAN_BUTTON_EVENT, and DEFINE_MAPPED_EVENT to
                              751 ;                   completely define the players button scan matrix, non scan buttons, and
                              752 ;                   how these buttons map to events as recieved by the menus. This macro sets up the mapping
                              753 ;                   between scan and non scan buttons, and the eventual event number that is sent to the menus.
                              754 ;
                              755 ;   SeeAlso:        DEFINE_COLUMN, DEFINE_SCAN_BUTTON_EVENT,DEFINE_NON_SCAN_BUTTON,
                              756 ;                   DEFINE_NON_SCAN_BUTTON_EVENT, and DEFINE_MAPPED_EVENT
                              757 ;
                              758 ;<
                              759 ;///////////////////////////////////////////////////////////////////////////////
                              760 DEFINE_2BUTTON_MAPPED_EVENT macro Number,Action,Event1,Event2
                              761     
                              762   IF (@SCP("Action","PRESS_RELEASE"))
                              763     BUTTON_EVENT_\Number:  equ BUTTON_EVENT_\Event1|BUTTON_EVENT_\Event2
                              764   else 
                              765     if (@SCP("Action","PRESS_HOLD"))
                              766         BUTTON_EVENT_\Number:  equ BUTTON_EVENT_\Event1|BUTTON_EVENT_\Event2|$800000
                              767     else
                              768         ERROR "Unknown Action for DEFINE_MAPPED_EVENT" 
                              769     endif
                              770   endif 
                              771   endm
                              773 ;///////////////////////////////////////////////////////////////////////////////
                              774 ;
                              775 ;>  Name:           StackCheckIn
                              776 ;
                              777 ;   Type:           Macro
                              778 ;
                              779 ;   Description:    Records the current stack pointer on the stack
                              780 ;
                              781 ;   Inputs:         none
                              782 ;                        
                              783 ;   Outputs:        places the current PC and the current software stack pointer on the stack
                              784 ;   
                              785 ;   Notes:          This does not modify any registers (except r7)                
                              786 ;
                              787 ;   SeeAlso:        FStackCheckIn
                              788 ;
                              789 ;<
                              790 ;///////////////////////////////////////////////////////////////////////////////
                              791 StackCheckIn macro
                              792   if (@DEF('DEBUG'))
                              793     extern FStackCheckIn
                              794     jsr FStackCheckIn
                              795   endif
                              796   endm
                              798 ;///////////////////////////////////////////////////////////////////////////////
                              799 ;
                              800 ;>  Name:           StackCheckOut
                              801 ;
                              802 ;   Type:           Macro
                              803 ;
TASKING DSP2410 assembler v1.5r1 Build 138 SN 00100122
                                                                                                                                                                                                                                                       Page   4

M:ADDR CODE           CYCLES LINE SOURCELINE
                              804 ;   Description:    Verifies that the stack is still balanced
                              805 ;
                              806 ;   Inputs:         none
                              807 ;                        
                              808 ;   Outputs:        none (though hits a debug if the stack is unbalanced)
                              809 ;   
                              810 ;   Notes:          This does not modify any registers (except r7) 
                              811 ;
                              812 ;   SeeAlso:        FStackCheckOut
                              813 ;
                              814 ;<
                              815 ;///////////////////////////////////////////////////////////////////////////////
                              816 StackCheckOut macro
                              817   if (@DEF('DEBUG'))
                              818     extern FStackCheckOut
                              819     jsr FStackCheckOut
                              820   endif 
                              821   endm
                              824 ;///////////////////////////////////////////////////////////////////////////////
                              825 ;
                              826 ;>  Name:           InstrumentPushContext 
                              827 ;
                              828 ;   Type:           Macro
                              829 ;
                              830 ;   Description:    calls the instrument functions specified.
                              831 ;
                              832 ;   Inputs:         new context
                              833 ;                   new value
                              834 ;                        
                              835 ;   Outputs:        
                              836 ;   
                              837 ;   Notes:          This does not modify any registers  
                              838 ;
                              839 ;   SeeAlso:        
                              840 ;
                              841 ;<
                              842 ;///////////////////////////////////////////////////////////////////////////////
                              843 InstrumentPushContext macro context,value
                              844   if (@DEF('USE_INSTRUMENTATION'))
                              845     extern FInstrumentPushContext
                              846     extern PushAandB
                              847     extern PopAandB
                              848     jsr PushAandB
                              849     move    #>context,a
                              850     move    #>value,b
                              851     jsr FInstrumentPushContext
                              852     jsr PopAandB
                              853   endif 
                              854   endm
                              856 ;///////////////////////////////////////////////////////////////////////////////
                              857 ;
                              858 ;>  Name:           InstrumentPopContext 
                              859 ;
                              860 ;   Type:           Macro
                              861 ;
                              862 ;   Description:    calls the instrument functions specified.
                              863 ;
                              864 ;   Inputs:         none
                              865 ;                        
                              866 ;   Outputs:        none
                              867 ;   
                              868 ;   Notes:          This does not modify any registers  
                              869 ;
                              870 ;   SeeAlso:        
                              871 ;
                              872 ;<
                              873 ;///////////////////////////////////////////////////////////////////////////////
                              874 InstrumentPopContext macro 
                              875   if (@DEF('USE_INSTRUMENTATION'))
                              876     extern FInstrumentPopContext
                              877     jsr FInstrumentPopContext
                              878   endif 
                              879   endm
                              881 ;///////////////////////////////////////////////////////////////////////////////
                              882 ;
                              883 ;>  Name:           InstrumentSetValue 
                              884 ;
                              885 ;   Type:           Macro
                              886 ;
                              887 ;   Description:    calls the instrument functions specified.
                              888 ;
                              889 ;   Inputs:         Value
                              890 ;                        
                              891 ;   Outputs:        none
                              892 ;   
                              893 ;   Notes:          This does not modify any registers  
                              894 ;
                              895 ;   SeeAlso:        
                              896 ;
                              897 ;<
                              898 ;///////////////////////////////////////////////////////////////////////////////
                              899 InstrumentSetValue macro value
                              900   if (@DEF('USE_INSTRUMENTATION'))
                              901     extern FInstrumentSetValue
                              902     jsr PushA
                              903     move #>value,a
                              904     jsr FInstrumentSetValue
                              905     jsr PopA
                              906   endif 
                              907   endm
                              910 ;///////////////////////////////////////////////////////////////////////////////
                              911 ;
                              912 ;>  Name:           InstrumentSetEvent 
                              913 ;
                              914 ;   Type:           Macro
                              915 ;
                              916 ;   Description:    calls the instrument functions specified.
                              917 ;
                              918 ;   Inputs:         Value
                              919 ;                        
                              920 ;   Outputs:        none
                              921 ;   
                              922 ;   Notes:          This does not modify any registers  
                              923 ;
                              924 ;   SeeAlso:        
                              925 ;
                              926 ;<
                              927 ;///////////////////////////////////////////////////////////////////////////////
                              928 InstrumentSetEvent macro event
                              929   if (@DEF('USE_INSTRUMENTATION'))
                              930     extern FInstrumentSetEvent
                              931     jsr PushA
                              932     move #>event,a
                              933     jsr FInstrumentSetEvent
                              934     jsr PopA
                              935   endif 
                              936   endm
                              938 ;///////////////////////////////////////////////////////////////////////////////
                              939 ;
                              940 ;>  Name:           InstrumentClearEvent 
                              941 ;
                              942 ;   Type:           Macro
                              943 ;
                              944 ;   Description:    calls the instrument functions specified.
                              945 ;
                              946 ;   Inputs:         event
                              947 ;                        
                              948 ;   Outputs:        none
                              949 ;   
                              950 ;   Notes:          This does not modify any registers  
                              951 ;
                              952 ;   SeeAlso:        
                              953 ;
                              954 ;<
                              955 ;///////////////////////////////////////////////////////////////////////////////
                              956 InstrumentClearEvent macro event
                              957   if (@DEF('USE_INSTRUMENTATION'))
                              958     extern FInstrumentClearEvent
                              959     jsr PushA
                              960     move #>event,a
                              961     jsr FInstrumentClearEvent
                              962     jsr PopA
                              963   endif 
                              964   endm
                              966 ;///////////////////////////////////////////////////////////////////////////////
                              967 ;
                              968 ;>  Name:           InstrumentToggleEvent 
                              969 ;
                              970 ;   Type:           Macro
                              971 ;
                              972 ;   Description:    calls the instrument functions specified.
                              973 ;
                              974 ;   Inputs:         event
                              975 ;                        
                              976 ;   Outputs:        none
                              977 ;   
                              978 ;   Notes:          This does not modify any registers  
                              979 ;
                              980 ;   SeeAlso:        
                              981 ;
                              982 ;<
                              983 ;///////////////////////////////////////////////////////////////////////////////
                              984 InstrumentToggleEvent macro event
                              985   if (@DEF('USE_INSTRUMENTATION'))
                              986     extern FInstrumentToggleEvent
                              987     jsr PushA
                              988     move #>event,a
                              989     jsr FInstrumentToggleEvent
                              990     jsr PopA
                              991   endif 
                              992   endm
                               16         include "const.xref"    
                                1 ;******************************************************************************
                                2 ; Copyright(C) SigmaTel, Inc. 2000
                                3 ;
                                4 ; ST Mp3 const.EXTERN 
                                5 ;******************************************************************************
                                7    DEFINE   const_xref  '1'
                               42     ; Parthus compatability
                               18 ;********************************************************************************
                               19 ;*      DEFINES
                               20 ;********************************************************************************
                               21 INBUFSIZE                       equ     96  ; INBUFSIZE*3 bytes.
                               22 INBUF2SIZE                       equ     6  ; INBUFSIZE*3 bytes.
                               23 WMA_MAX_DATA_REQUESTED                  equ             128
                               24 STRINGSIZE                                              equ     128
                               26 ;********************************************************************************
                               27 ;*      GLOBALs
                               28 ;********************************************************************************
                               36 ;********************************************************************************
                               37 ;*      EXTERNs
                               38 ;********************************************************************************
                               43 ;********************************************************************************
                               44 ;*       Y memory
                               45 ;********************************************************************************
Y:0000                         47          org y,".InBuf":
Y:0000                         48 Finbuf                                                  ds              INBUFSIZE
   |   RESERVED                   
Y:005F
Y:0060                         49 Finbuf2                         ds      INBUF2SIZE
   |   RESERVED                   
Y:0065
Y:0000                         51         org y,"WMA_Y_mem":
                               52         buffer  M,3
                               53 ByteState
Y:0000 000000                  54                                                                 dc              0
Y:0001 008000                  55                                                                 dc              $8000
Y:0002 000080                  56                                                                 dc              $80
                               57         endbuf
Y:0003 000000                  58 streaming_started                               dc              0
Y:0004 000000                  59 BufRead                                                 dc              0
Y:0005 RESERVED                60 read_offset                                             ds              1
Y:0005
Y:0006 RESERVED                61 read_reqd_flag                                  ds              1
Y:0006
                               62 Fstreaming_started
Y:0007 RESERVED                63 num_bytes_wanted                                ds              1
Y:0007
Y:0008 RESERVED                64 totalRead                                               ds              1
Y:0008
Y:0009 RESERVED                65 wmadecsp                                                ds              1
Y:0009
X:0000                         68         org x,".OtherInputData":
X:0000                         69 Gpbuffer                        ds      WMA_MAX_DATA_REQUESTED
   |   RESERVED                   
X:007F
                               70     ; Other Global data.
X:0000                         71         org x,".OtherInputData_ovl":
                               72 FpTitle
X:0000                         73 pTitle                                                  ds              STRINGSIZE
   |   RESERVED                   
X:007F
                               74 FpAuthor
X:0080                         75 pAuthor                                         ds              STRINGSIZE
   |   RESERVED                   
X:00FF
                               76 FpCopyright
X:0100                         77 pCopyright                                      ds              STRINGSIZE
   |   RESERVED                   
X:017F
                               78 FpDescription
TASKING DSP2410 assembler v1.5r1 Build 138 SN 00100122
                                                                                                                                                                                                                                                       Page   5

M:ADDR CODE           CYCLES LINE SOURCELINE
X:0180                         79 pDescription                                    ds              STRINGSIZE
   |   RESERVED                   
X:01FF
                               80 FpRating
X:0200                         81 pRating                                         ds              STRINGSIZE
   |   RESERVED                   
X:027F
                               84 ;********************************************************************************
                               85 ;*       L memory
                               86 ;********************************************************************************
L:0000                         87         org L,"WMA_LongVariables":
L:0000 000000 000000           88 last_offset                                             dc              0
L:0001 000000 000000           89 WMA_File_Offset                                 dc              0
                               93 ;********************************************************************************
                               94 ;*       Code
                               95 ;********************************************************************************
P:0000                         97     org p,".pCommon":
                               98 ;///////////////////////////////////////////////////////////////////////////////
                               99 ;
                              100 ;>   Name:  WMAFileCBGetData
                              101 ;
                              102 ;    Type:    Function
                              103 ;           
                              104 ;    Description:    
                              105 ;   This routine reads only when required. Typical buffer size is 96 words, 
                              106 ;   but any optimum size as required by the file system can be selected.
                              107 ;   This is defined by INBUFSIZE. 
                              108 ;   During initialization phase, we allow excess file reads and seeks, but no real-time
                              109 ;   requirements exist.
                              110 ;   Once streaming is started, the file reads are minimized. File seeks rarely occur.
                              111 ;   This ensures that file-system is minimally loaded and the function performs optimally.
                              112 ;       Data stored in g_pBuffer[128] in char format.
                              113 ;
                              114 ;    Inputs:        
                              115 ;           x1:x0 = offset
                              116 ;           A = num_bytes
                              117 ;    Outputs:        
                              118 ;       r0 : ptr to the buffer
                              119 ;       A = num bytes read.
                              120 ;    Notes:
                              121 ;       All trashed registers are backed up and restored. The file-system trashes these.
                              122 ;///////////////////////////////////////////////////////////////////////////////
                              124 WMAFileCBGetData
                              125         push    r1
P:0000 695F00         2    2  125     move    r1,y:(r7)+
                              126         push    r2
P:0001 6A5F00         2    4  126     move    r2,y:(r7)+
                              127         push    r3
P:0002 6B5F00         2    6  127     move    r3,y:(r7)+
                              128         push    r4
P:0003 6C5F00         2    8  128     move    r4,y:(r7)+
                              129         push    r5
P:0004 6D5F00         2   10  129     move    r5,y:(r7)+
                              130         push    r6
P:0005 6E5F00         2   12  130     move    r6,y:(r7)+
                              132         push    ssh
P:0006 055F7C         2   14  132     movec   ssh,y:(r7)+
                              134         push    n0
P:0007 785F00         2   16  134     move    n0,y:(r7)+
                              135         push    n1
P:0008 795F00         2   18  135     move    n1,y:(r7)+
                              136         push    n2
P:0009 7A5F00         2   20  136     move    n2,y:(r7)+
                              137         push    n3
P:000A 7B5F00         2   22  137     move    n3,y:(r7)+
                              138         push    n4
P:000B 7C5F00         2   24  138     move    n4,y:(r7)+
                              139         push    n5
P:000C 7D5F00         2   26  139     move    n5,y:(r7)+
                              140         push    n6
P:000D 7E5F00         2   28  140     move    n6,y:(r7)+
                              142         push    x0
P:000E 4C5F00         2   30  142     move    x0,y:(r7)+
                              143         push    x1
P:000F 4D5F00         2   32  143     move    x1,y:(r7)+
                              144         push    y0
P:0010 4E5F00         2   34  144     move    y0,y:(r7)+
                              145         push    y1
P:0011 4F5F00         2   36  145     move    y1,y:(r7)+
                              147         push    B0
P:0012 595F00         2   38  147     move    B0,y:(r7)+
                              148         push    B1
P:0013 5D5F00         2   40  148     move    B1,y:(r7)+
                              149         push    B2
P:0014 5B5F00         2   42  149     move    B2,y:(r7)+
                              150         push    m0
P:0015 055F60         2   44  150     movec   m0,y:(r7)+
P:0016 46F400 000080  3   47  152         move    #>WMA_MAX_DATA_REQUESTED,y0
P:0018 427055 rrrrrr  3   50  153         cmp             y0,A            x,L:WMA_File_Offset
P:001A 027050         2   52  154         tgt             y0,A
P:001B 21C600         2   54  155         move    A,y0                                                                    ; y0 = nWanted
P:001C 200013         2   56  158         clr     A
P:001D 5E7000 rrrrrr  3   59  159         move    A,y:totalRead
                              160 ;       if (streaming_started == 1)
P:001F 5EF000 rrrrrr  3   62  161         move    y:streaming_started,A                                   ; minimize the FILE read calls during streaming.        
P:0021 4E7003 rrrrrr  3   65  162         tst     A                       y0,y:num_bytes_wanted
P:0023 0AF0AA rrrrrr  6   71  163         jeq     NoStreaming
                              165 ReadBuf
                              166 ;       if (offset > last_offset)
P:0025 48F000 rrrrrr  3   74  167         move    L:last_offset,A
P:0027 270024         2   76  168         sub     x,A                     #0,y1                                           ; last_offset - offset
P:0028 200036         2   78  169         neg     A                                                                                       ; offset - last_offset
P:0029 0AF0A9 rrrrrr  6   84  170         jlt     NoStreaming                                                                     
P:002B 210600         2   86  171         move    A0,y0                                                                   
P:002C 218713         2   88  172         clr     A   A1,y1                                   ; y1:y0 = read_offset.
P:002D 58F000 rrrrrr  3   91  173         move    y:BufRead,A0
P:002F 200034         2   93  174         sub     y,A     
P:0030 390003         2   95  175         tst     A                       #0,n1                                           ; A = navailable.
P:0031 0AF0A9 rrrrrr  6  101  176         jlt     NoStreamingCheck                                                        ; Hit, during first streaming frame.
                              178     ; If we hit here, we are within a narrow range of INPUTBUFSIZE
P:0033 210E00         2  103  179     move    A0,A
P:0034 20C400         2  105  180     move    y0,x0
P:0035 4EF000 rrrrrr  3  108  181     move    y:num_bytes_wanted,y0
                              183 ;       x0 = read_offset, A = navailable, y0 = nWanted.
                              184     
P:0037 200055         2  110  185         cmp             y0,A 
P:0038 021050         2  112  186         tge             y0,A
P:0039 21C703         2  114  187         tst             A                       A,y1                                            ; is available data zero? Skip GetData, if yes.
P:003A 0AF0AA rrrrrr  6  120  188         jeq     _ContinueRead
                              190 ;       reqd = y1, x0 = Read_offset, n1 = index.
P:003C 64F400 rrrrrr  3  123  191     move #>Finbuf,r4
P:003E 0BF080 rrrrrr  6  129  192         jsr     GetData
                              193 _ContinueRead
P:0040 5EF000 rrrrrr  3  132  194         move    y:num_bytes_wanted,A
P:0042 200074         2  134  195         sub             y1,A                                            
P:0043 0AF0AA rrrrrr  6  140  196         jeq             exitGetData
                              198         push    A1                                                                              ; reqd
P:0045 5C5F00         2  142  198     move    A1,y:(r7)+
                              199         push    y1                                                                              ; navailable
P:0046 4F5F00         2  144  199     move    y1,y:(r7)+
P:0047 66F400 rrrrrr  3  147  201     move    #_stackSaved,r6                                     ; setup the return address
P:0049 65F400 rrrrrr  3  150  202     move    #wmadecsp,r5                                        ; pointer to the SP local save
P:004B 0AF080 rrrrrr  6  156  203     jmp     SaveSystemStack                                     ; save the hardware stack
                              204 _stackSaved
                              205 ;   ret = fread (&inbuf[0], INBUFSIZE, 1, g_fp);
P:004D 5AF000 rrrrrr  3  159  206         move    y:WmaDecoderFileHandle,a2
P:004F 54F400 000120  3  162  207         move    #>INBUFSIZE*3,A1                                                ; Always read data of size INBUFSIZE. Data passed is bytes
P:0051 588000r        2  164  208         move    y:<Const_400000,A0                                              ; X memory
P:0052 60F400 rrrrrr  3  167  209         move    #Finbuf,r0
P:0054 0BF080 rrrrrr  6  173  210         jsr     FileRead
P:0056 54F400 000120  3  176  211         move    #>INBUFSIZE*3,A1
P:0058 5C7000 rrrrrr  3  179  212         move    A1,y:BufRead
P:005A 65F400 rrrrrr  3  182  213     move    #wmadecsp,r5                                        ; pointer to the SP local save
P:005C 66F400 rrrrrr  3  185  214     move    #_stackRestored,r6                                  ; setup the return address
P:005E 0AF080 rrrrrr  6  191  215     jmp     RestoreSystemStack                                  ; restore the hardware stack
                              216 _stackRestored
P:0060 42F01B rrrrrr  3  194  218         clr             B                       L:last_offset,x
P:0062 59F000 rrrrrr  3  197  219         move    y:BufRead,B0                                                    ; A1 contains bytes read.
P:0064 200028         2  199  220         add             x,B                     
P:0065 497000 rrrrrr  3  202  221         move    B,L:last_offset
                              223         pop             n1              
P:0067 79FF00         4  206  223     move    y:-(r7),n1
                              224         pop             y1
P:0068 4FFF00         4  210  224     move    y:-(r7),y1
P:0069 5EF000 rrrrrr  3  213  225         move    y:BufRead,A                                                                     ; A = BufRead
P:006B 240075         2  215  226         cmp             y1,A            #0,x0
P:006C 027070         2  217  227         tgt             y1,A
P:006D 21C700         2  219  228         move    A,y1
                              229 ;       reqd = y1, x0 = Read_offset, x1 = index.
P:006E 64F400 rrrrrr  3  222  230     move    #>Finbuf,r4
P:0070 0BF080 rrrrrr  6  228  231         jsr             GetData
                              232         
P:0072 0AF080 rrrrrr  6  234  233         jmp             exitGetData
                              235 NoStreamingCheck
P:0074 270000         2  236  237         move  #0,y1
P:0075 46F436 000120  3  239  238         neg   A         #>INBUFSIZE*3,y0
P:0077 200034         2  241  239         sub   y,A
P:0078 0AF0A7 rrrrrr  6  247  240         jgt   NoStreaming
P:007A 66F400 rrrrrr  3  250  243     move    #_stackSaved,r6                                     ; setup the return address
P:007C 65F400 rrrrrr  3  253  244     move    #wmadecsp,r5                                        ; pointer to the SP local save
P:007E 0AF080 rrrrrr  6  259  245     jmp     SaveSystemStack                                     ; save the hardware stack
                              246 _stackSaved
                              249 ;   ret = fread (&inbuf[0], INBUFSIZE, 1, g_fp);
P:0080 5AF000 rrrrrr  3  262  250         move    y:WmaDecoderFileHandle,a2
P:0082 54F400 000120  3  265  251         move    #>INBUFSIZE*3,A1                                                ; Always read data of size INBUFSIZE. Data passed is bytes
P:0084 588000r        2  267  252         move    y:<Const_400000,A0                                              ; X memory
P:0085 60F400 rrrrrr  3  270  253         move    #Finbuf,r0
P:0087 0BF080 rrrrrr  6  276  254         jsr     FileRead
                              255         
                              256         
P:0089 54F400 000120  3  279  257         move    #>INBUFSIZE*3,A1
P:008B 5C7000 rrrrrr  3  282  258         move    A1,y:BufRead
P:008D 65F400 rrrrrr  3  285  259     move    #wmadecsp,r5                                        ; pointer to the SP local save
P:008F 66F400 rrrrrr  3  288  260     move    #_stackRestored,r6                                  ; setup the return address
P:0091 0AF080 rrrrrr  6  294  261     jmp     RestoreSystemStack                                  ; restore the hardware stack
                              262 _stackRestored
P:0093 42F01B rrrrrr  3  297  264         clr             B                       L:last_offset,x
P:0095 59F000 rrrrrr  3  300  265         move    y:BufRead,B0                                                    ; A1 contains bytes read.
P:0097 200028         2  302  266         add             x,B                     
P:0098 497000 rrrrrr  3  305  267         move    B,L:last_offset
P:009A 42F000 rrrrrr  3  308  268         move   L:WMA_File_Offset,x
P:009C 0AF080 rrrrrr  6  314  269         jmp    ReadBuf
                              273 NoStreaming
                              274 ;       last_offset = offset;
P:009E 5E8000r        2  316  275         move    y:<Const_000001,A
P:009F 5E7000 rrrrrr  3  319  276         move    A,y:streaming_started
P:00A1 208600         2  321  277         move    x0,y0                                                                   ; x0 destroyed in stack save, below
P:00A2 66F400 rrrrrr  3  324  279     move    #_stackSaved,r6                                             ; setup the return address
P:00A4 65F400 rrrrrr  3  327  280     move    #wmadecsp,r5                                                ; pointer to the SP local save
P:00A6 0AF080 rrrrrr  6  333  281     jmp     SaveSystemStack                                             ; save the hardware stack
                              282 _stackSaved
                              284 ;       push    y0
                              285 ;       push    x1
                              286 ;;      The file system does not support SEEK_SET. So seek to zero first
                              287 ;       clr             A
                              288 ;    move    y:WmaDecoderFileHandle,a2
                              289 ;       jsr             FileSeek
                              290 ;       pop             A1
                              291 ;       pop             A0
P:00A8 200013         2  335  292         clr             A
P:00A9 20AC00         2  337  293     move    x1,A1
P:00AA 20C800         2  339  294     move    y0,A0
P:00AB 487000 rrrrrr  3  342  295         move    A,L:last_offset
                              296         
                              297 ;       fseek(g_fp, offset, SEEK_SET);
P:00AD 5AF000 rrrrrr  3  345  298         move    y:WmaDecoderFileHandle,a2
P:00AF 0BF080 rrrrrr  6  351  299         jsr             FileSeek
                              300 ;       ret = fread (&inbuf[0], INBUFSIZE, 1, g_fp);
P:00B1 5AF000 rrrrrr  3  354  301         move    y:WmaDecoderFileHandle,a2
P:00B3 54F400 000120  3  357  302         move    #>INBUFSIZE*3,A1                                                ; Always read data of size INBUFSIZE. Data passed is bytes!
P:00B5 588000r        2  359  303         move    y:<Const_400000,A0                                              ; X memory
P:00B6 60F400 rrrrrr  3  362  304         move    #Finbuf,r0
P:00B8 0BF080 rrrrrr  6  368  305         jsr             FileRead
P:00BA 54F400 000120  3  371  306         move    #>INBUFSIZE*3,A1
P:00BC 5C7000 rrrrrr  3  374  307         move    A1,y:BufRead
P:00BE 65F400 rrrrrr  3  377  309     move    #wmadecsp,r5                                                ; pointer to the SP local save
P:00C0 66F400 rrrrrr  3  380  310     move    #_stackRestored,r6                                          ; setup the return address
P:00C2 0AF080 rrrrrr  6  386  311     jmp     RestoreSystemStack                                          ; restore the hardware stack
                              312 _stackRestored
                              313 ;       reqd = y1, x0 = Read_offset, n1 = index.
P:00C4 5EF000 rrrrrr  3  389  314         move    y:BufRead,A
P:00C6 4FF000 rrrrrr  3  392  315         move    y:num_bytes_wanted,y1
P:00C8 200075         2  394  316         cmp             y1,A            
P:00C9 027070         2  396  317         tgt             y1,A
P:00CA 21C700         2  398  318         move    A,y1
P:00CB 390000         2  400  319         move    #0,n1
P:00CC 240000         2  402  320         move    #0,x0
P:00CD 64F400 rrrrrr  3  405  321     move    #>Finbuf,r4
P:00CF 0BF080 rrrrrr  6  411  322         jsr     GetData
                              324 exitGetData
                              325 _exit
P:00D1 5EF000 rrrrrr  3  414  326         move    y:totalRead,A
P:00D3 60F400 rrrrrr  3  417  327         move    #>Gpbuffer,r0
                              328         pop             m0
P:00D5 05FF60         4  421  328     movec   y:-(r7),m0
                              329         pop             B2
P:00D6 5BFF00         4  425  329     move    y:-(r7),B2
                              330         pop             B1
P:00D7 5DFF00         4  429  330     move    y:-(r7),B1
                              331         pop             B0
P:00D8 59FF00         4  433  331     move    y:-(r7),B0
TASKING DSP2410 assembler v1.5r1 Build 138 SN 00100122
                                                                                                                                                                                                                                                       Page   6

M:ADDR CODE           CYCLES LINE SOURCELINE
                              333         pop             y1
P:00D9 4FFF00         4  437  333     move    y:-(r7),y1
                              334         pop             y0
P:00DA 4EFF00         4  441  334     move    y:-(r7),y0
                              335         pop             x1
P:00DB 4DFF00         4  445  335     move    y:-(r7),x1
                              336         pop             x0
P:00DC 4CFF00         4  449  336     move    y:-(r7),x0
                              338         pop             n6
P:00DD 7EFF00         4  453  338     move    y:-(r7),n6
                              339         pop             n5
P:00DE 7DFF00         4  457  339     move    y:-(r7),n5
                              340         pop             n4
P:00DF 7CFF00         4  461  340     move    y:-(r7),n4
                              341         pop             n3
P:00E0 7BFF00         4  465  341     move    y:-(r7),n3
                              342         pop             n2
P:00E1 7AFF00         4  469  342     move    y:-(r7),n2
                              343         pop             n1
P:00E2 79FF00         4  473  343     move    y:-(r7),n1
                              344         pop             n0
P:00E3 78FF00         4  477  344     move    y:-(r7),n0
                              346         pop             ssh
P:00E4 05FF7C         4  481  346     movec   y:-(r7),ssh
                              347         pop             r6
P:00E5 6EFF00         4  485  347     move    y:-(r7),r6
                              348         pop             r5
P:00E6 6DFF00         4  489  348     move    y:-(r7),r5
                              349         pop             r4
P:00E7 6CFF00         4  493  349     move    y:-(r7),r4
                              350         pop             r3
P:00E8 6BFF00         4  497  350     move    y:-(r7),r3
                              351         pop             r2
P:00E9 6AFF00         4  501  351     move    y:-(r7),r2
                              352         pop             r1
P:00EA 69FF00         4  505  352     move    y:-(r7),r1
P:00EB 00000C         4  509  354         rts                                                                                             ; Return value in A.
                              357 ;///////////////////////////////////////////////////////////////////////////////
                              358 ;
                              359 ;>   Name:  GetData
                              360 ;
                              361 ;    Type:    Function
                              362 ;           
                              363 ;    Description:    
                              364 ;       The routine converts the input data into character format 
                              365 ;       24bit packed word to 8 bit character conversion.
                              366 ;
                              367 ;    Inputs:        
                              368 ;       y1 = Reqd.
                              369 ;       n1 = index
                              370 ;       x0 = read_offset 
                              371 ;    Outputs:        
                              372 ;    Notes:
                              373 ;       Preserve y1.
                              374 ;///////////////////////////////////////////////////////////////////////////////
                              376 GetData
P:00EC 5EF000 rrrrrr  3  512  377         move    y:totalRead,A
P:00EE 200070         2  514  378         add     y1,A
P:00EF 5E7000 rrrrrr  3  517  379         move    A,y:totalRead
                              380         push    y1                                                                              ; push this up the stack.
P:00F1 4F5F00         2  519  380     move    y1,y:(r7)+
P:00F2 20E600         2  521  381         move    y1,y0
P:00F3 47F400 2AAAAB  3  524  382         move    #>$2aaaab,y1                            
P:00F5 4F80C0r        2  526  383         mpy             x0,y1,A                 y:<Const_7fffff,y1              ; Convert byte offset to word.
P:00F6 21DC22         2  528  384         asr             A                               A,n4
P:00F7 210E00         2  530  385         move    A0,A
                              386 ;       byte_offset = (get_L(Acc0)>>1 & 0x7fffff);
                              387 ;       Word offset is now saved in x0
                              388 ;       Byte offset is available in A1
P:00F8 4F8076r        2  532  389         and     y1,A                    y:<Const_200000,y1
P:00F9 4D801Br        2  534  390         clr             B                               y:<Const_000001,x1
P:00FA 2A0000         2  536  391         move    #0,A2
P:00FB 200075         2  538  392         cmp             y1,A                    
P:00FC 027068         2  540  393         tgt             x1,B            
P:00FD 4F8000r        2  542  394         move    y:<Const_400000,y1
P:00FE 4D8075r        2  544  395         cmp             y1,A                    y:<Const_000002,x1
P:00FF 027068         2  546  396         tgt             x1,B            
P:0100 47F400 rrrrrr  3  549  397         move    #ByteState,y1
P:0102 204C78         2  551  398         add             y1,B                    (r4)+n4                                 ; r4 = &inbuf[read_offset]
P:0103 058060r        2  553  399         movec   y:<Const_000002,m0
P:0104 21F000         2  555  400         move    B,r0
P:0105 61F400 rrrrrr  3  558  401         move    #Gpbuffer,r1
P:0107 4CDC00         2  560  402         move    y:(r4)+,x0                                                              ; Get the first word
P:0108 204900         2  562  403         move    (r1)+n1                                                                 ; Index it correctly.
P:0109 45F400 0000FF  3  565  404         move    #>$ff,x1
P:010B 06C600 rrrrrr  6  571  405         do      y0,_LoopEnd1
P:010D 4ED800         2  573  406                 move    y:(r0)+,y0                                                      ; Get byte state
P:010E 2000D0         2  575  407                 mpy             x0,y0,A                                                         ; Locate byte.
P:010F 20007D         2  577  408                 cmp             y1,B    
P:0110 02A040         2  579  409                 teq             x0,A                                                            ; Is this byte 0? Yes! Transfer the word.
P:0111 220F66         2  581  410                 and             x1,A            r0,B    
P:0112 54597D         2  583  411                 cmp             y1,B            A1,x:(r1)+
P:0113 0AF0A2 rrrrrr  6  589  412                 jne             _LoopEnd
P:0115 4CDC00         2  591  413                 move    y:(r4)+,x0
                              414 _LoopEnd
P:0116 220F00         2  593  415                 move    r0,B
                        (22)  416 _LoopEnd1
P:0117 058060r        2  595  417         movec   y:<Const_ffffff,m0
                              418         pop             y1
P:0118 4FFF00         4  599  418     move    y:-(r7),y1
P:0119 00000C         4  603  419         rts
                              423 ;///////////////////////////////////////////////////////////////////////////////
                              424 ;
                              425 ;>   Name:  WMAFileCBGetData2
                              426 ;
                              427 ;    Type:    Function
                              428 ;           
                              429 ;    Description:    
                              430 ;   This routine reads only when required. Typical buffer size is 6 words, 
                              431 ;   but any optimum size as required by the file system can be selected.
                              432 ;   This is defined by INBUF2SIZE. 
                              433 ;   During initialization phase, we allow excess file reads and seeks, but no real-time
                              434 ;   requirements exist.
                              435 ;   Once streaming is started, the file reads are minimized. File seeks rarely occur.
                              436 ;   This ensures that file-system is minimally loaded and the function performs optimally.
                              437 ;       Data stored in g_pBuffer[128] in char format.
                              438 ;
                              439 ;    Inputs:        
                              440 ;           x1:x0 = offset
                              441 ;           A = num_bytes
                              442 ;    Outputs:        
                              443 ;       r0 : ptr to the buffer
                              444 ;       A = num bytes read.
                              445 ;    Notes:
                              446 ;       All trashed registers are backed up and restored. The file-system trashes these.
                              447 ;///////////////////////////////////////////////////////////////////////////////
                              449 WMAFileCBGetData2
                              450         push    r1
P:011A 695F00         2  605  450     move    r1,y:(r7)+
                              451         push    r2
P:011B 6A5F00         2  607  451     move    r2,y:(r7)+
                              452         push    r3
P:011C 6B5F00         2  609  452     move    r3,y:(r7)+
                              453         push    r4
P:011D 6C5F00         2  611  453     move    r4,y:(r7)+
                              454         push    r5
P:011E 6D5F00         2  613  454     move    r5,y:(r7)+
                              455         push    r6
P:011F 6E5F00         2  615  455     move    r6,y:(r7)+
                              457         push    ssh
P:0120 055F7C         2  617  457     movec   ssh,y:(r7)+
                              459         push    n0
P:0121 785F00         2  619  459     move    n0,y:(r7)+
                              460         push    n1
P:0122 795F00         2  621  460     move    n1,y:(r7)+
                              461         push    n2
P:0123 7A5F00         2  623  461     move    n2,y:(r7)+
                              462         push    n3
P:0124 7B5F00         2  625  462     move    n3,y:(r7)+
                              463         push    n4
P:0125 7C5F00         2  627  463     move    n4,y:(r7)+
                              464         push    n5
P:0126 7D5F00         2  629  464     move    n5,y:(r7)+
                              465         push    n6
P:0127 7E5F00         2  631  465     move    n6,y:(r7)+
                              467         push    x0
P:0128 4C5F00         2  633  467     move    x0,y:(r7)+
                              468         push    x1
P:0129 4D5F00         2  635  468     move    x1,y:(r7)+
                              469         push    y0
P:012A 4E5F00         2  637  469     move    y0,y:(r7)+
                              470         push    y1
P:012B 4F5F00         2  639  470     move    y1,y:(r7)+
                              472         push    B0
P:012C 595F00         2  641  472     move    B0,y:(r7)+
                              473         push    B1
P:012D 5D5F00         2  643  473     move    B1,y:(r7)+
                              474         push    B2
P:012E 5B5F00         2  645  474     move    B2,y:(r7)+
                              475         push    m0
P:012F 055F60         2  647  475     movec   m0,y:(r7)+
P:0130 4E7013 rrrrrr  3  650  477         clr     A   y0,y:num_bytes_wanted
P:0132 5E7000 rrrrrr  3  653  478         move    A,y:totalRead
P:0134 208600         2  655  480         move    x0,y0                                                                   ; x0 destroyed in stack save, below
P:0135 66F400 rrrrrr  3  658  482     move    #_stackSaved,r6                                             ; setup the return address
P:0137 65F400 rrrrrr  3  661  483     move    #wmadecsp,r5                                                ; pointer to the SP local save
P:0139 0AF080 rrrrrr  6  667  484     jmp     SaveSystemStack                                             ; save the hardware stack
                              485 _stackSaved
P:013B 200013         2  669  487         clr     A
P:013C 20AC00         2  671  488     move    x1,A1
P:013D 20C800         2  673  489     move    y0,A0
                              490         
                              491 ;       fseek(g_fp, offset, SEEK_SET);
P:013E 5AF000 rrrrrr  3  676  492     move    y:WmaDecoderFileHandle2,a2
P:0140 0BF080 rrrrrr  6  682  493         jsr             FileSeek
                              494 ;       ret = fread (&inbuf[0], INBUFSIZE, 1, g_fp);
P:0142 5AF000 rrrrrr  3  685  495     move    y:WmaDecoderFileHandle2,a2
P:0144 54F400 000012  3  688  496         move    #>INBUF2SIZE*3,A1                                               ; Always read data of size INBUFSIZE. Data passed is bytes!
P:0146 588000r        2  690  497         move    y:<Const_400000,A0                                              ; X memory
P:0147 60F400 rrrrrr  3  693  498         move    #Finbuf2,r0
P:0149 0BF080 rrrrrr  6  699  499         jsr             FileRead
P:014B 65F400 rrrrrr  3  702  501     move    #wmadecsp,r5                                                ; pointer to the SP local save
P:014D 66F400 rrrrrr  3  705  502     move    #_stackRestored,r6                                          ; setup the return address
P:014F 0AF080 rrrrrr  6  711  503     jmp     RestoreSystemStack                                          ; restore the hardware stack
                              504 _stackRestored
                              505 ;       reqd = y1, x0 = Read_offset, n1 = index.
P:0151 5EF000 rrrrrr  3  714  506         move    y:BufRead,A
P:0153 4FF000 rrrrrr  3  717  507         move    y:num_bytes_wanted,y1
P:0155 200075         2  719  508         cmp             y1,A            
P:0156 027070         2  721  509         tgt             y1,A
P:0157 21C700         2  723  510         move    A,y1
P:0158 390000         2  725  511         move    #0,n1
P:0159 240000         2  727  512         move    #0,x0
P:015A 64F400 rrrrrr  3  730  513     move    #>Finbuf2,r4
P:015C 0BF080 rrrrrr  6  736  514         jsr     GetData
                              516 _exit
P:015E 5EF000 rrrrrr  3  739  517         move    y:totalRead,A
P:0160 60F400 rrrrrr  3  742  518         move    #>Gpbuffer,r0
                              519         pop             m0
P:0162 05FF60         4  746  519     movec   y:-(r7),m0
                              520         pop             B2
P:0163 5BFF00         4  750  520     move    y:-(r7),B2
                              521         pop             B1
P:0164 5DFF00         4  754  521     move    y:-(r7),B1
                              522         pop             B0
P:0165 59FF00         4  758  522     move    y:-(r7),B0
                              524         pop             y1
P:0166 4FFF00         4  762  524     move    y:-(r7),y1
                              525         pop             y0
P:0167 4EFF00         4  766  525     move    y:-(r7),y0
                              526         pop             x1
P:0168 4DFF00         4  770  526     move    y:-(r7),x1
                              527         pop             x0
P:0169 4CFF00         4  774  527     move    y:-(r7),x0
                              529         pop             n6
P:016A 7EFF00         4  778  529     move    y:-(r7),n6
                              530         pop             n5
P:016B 7DFF00         4  782  530     move    y:-(r7),n5
                              531         pop             n4
P:016C 7CFF00         4  786  531     move    y:-(r7),n4
                              532         pop             n3
P:016D 7BFF00         4  790  532     move    y:-(r7),n3
                              533         pop             n2
P:016E 7AFF00         4  794  533     move    y:-(r7),n2
                              534         pop             n1
P:016F 79FF00         4  798  534     move    y:-(r7),n1
                              535         pop             n0
P:0170 78FF00         4  802  535     move    y:-(r7),n0
                              537         pop             ssh
P:0171 05FF7C         4  806  537     movec   y:-(r7),ssh
                              538         pop             r6
P:0172 6EFF00         4  810  538     move    y:-(r7),r6
                              539         pop             r5
P:0173 6DFF00         4  814  539     move    y:-(r7),r5
                              540         pop             r4
P:0174 6CFF00         4  818  540     move    y:-(r7),r4
                              541         pop             r3
P:0175 6BFF00         4  822  541     move    y:-(r7),r3
                              542         pop             r2
P:0176 6AFF00         4  826  542     move    y:-(r7),r2
                              543         pop             r1
TASKING DSP2410 assembler v1.5r1 Build 138 SN 00100122
                                                                                                                                                                                                                                                       Page   7

M:ADDR CODE           CYCLES LINE SOURCELINE
P:0177 69FF00         4  830  543     move    y:-(r7),r1
P:0178 00000C         4  834  545         rts                                                                                             ; Return value in A.
                              546     
                              548     endsec
                              554 ; EQUIVALENT C CODE
                              555 ; tWMA_U32 WMAFileCBGetData(tHWMAFileState *state, tWMA_U32 offset,
                              556 ;                                                  tWMA_U32 num_bytes,  int **ppData)
                              557 ; {
                              558 ;     tWMA_U32 ret;
                              559 ;       int i;
                              560 ;       int read_offset = 0;
                              561 ;       int reqd;
                              562 ;       int navailable;
                              563 ;       int total_read = 0;
                              564 ; 
                              565 ; 
                              566 ;     tWMA_U32 nWanted = num_bytes <= (tWMA_U32) MAX_BUFSIZE ? num_bytes : (tWMA_U32) MAX_BUFSIZE;
                              567 ;     
                              568 ;       data_func_call++;
                              569 ;       if(num_bytes != nWanted)
                              570 ;     {
                              571 ;         fprintf(stderr, "** WMAFileCBGetData: Requested too much (%lu).\n",
                              572 ;                 num_bytes);
                              573 ;     }
                              574 ; 
                              575 ;       if (streaming_started == 1)
                              576 ;       {
                              577 ;               if (offset > last_offset)
                              578 ;               {
                              579 ;                       read_offset = offset - last_offset;
                              580 ; 
                              581 ;                       if (last_offset == 0x3a704)     
                              582 ;                                       last_offset=0x3a704;
                              583 ;                       navailable = BufRead - read_offset;
                              584 ;                       if (navailable < 0)                     // Likely the first time.
                              585 ;                       {
                              586 ;               // This condition will occur very rarely.
                              587 ;                               fseek(g_fp, offset, SEEK_SET);
                              588 ;                               last_offset = offset;
                              589 ;                               BufRead = fread (&inbuf[0], 1, INBUFSIZE, g_fp);
                              590 ;                               if (nWanted > BufRead)
                              591 ;                                       nWanted = BufRead;
                              592 ;                               total_read = nWanted;
                              593 ;                               GetData(0,nWanted,0);
                              594 ;                       }
                              595 ;                       else
                              596 ;                       {
                              597 ;                               if (navailable >= nWanted)
                              598 ;                                       reqd = nWanted;
                              599 ;                               else
                              600 ;                                       reqd = navailable;
                              601 ;                               if (reqd !=0)
                              602 ;                                       GetData(read_offset,reqd,0);
                              603 ;                               total_read = reqd;
                              604 ;                               if (reqd !=nWanted)
                              605 ;                               {
                              606 ;                                       reqd = nWanted - navailable;
                              607 ;                                       last_offset += BufRead;
                              608 ;                                       BufRead = fread (&inbuf[0], 1, INBUFSIZE, g_fp);
                              609 ;                                       if (reqd > BufRead)
                              610 ;                                               reqd = BufRead;
                              611 ;                                       total_read += reqd;
                              612 ;                                       GetData(0,reqd,navailable);
                              613 ;                               }
                              614 ;                       }
                              615 ;               }
                              616 ; // The following condition not reqd to be coded. Validated in prototype.
                              617 ;               else
                              618 ;               {
                              619 ;                       printf("\n Streaming Error!");
                              620 ;               }
                              621 ;       }
                              622 ;       else
                              623 ;       {
                              624 ;               fseek(g_fp, offset, SEEK_SET);
                              625 ;               last_offset = offset;
                              626 ;           BufRead = fread (&inbuf[0], 1, INBUFSIZE, g_fp);
                              627 ;               if (nWanted > BufRead)
                              628 ;                       nWanted = BufRead;
                              629 ;               total_read = nWanted;
                              630 ;               GetData(0,nWanted,0);
                              631 ;       }
                              632 ;       
                              633 ;     g_cbBuffer = total_read;
                              634 ; 
                              635 ;     *ppData = g_pBuffer;
                              636 ; 
                              637 ; 
                              638 ; //    fprintf(stderr, "++ WMAFileCBGetData: %lu bytes from %lu.\n", ret, offset);
                              639 ; 
                              640 ;     return total_read;
                              641 ; }
