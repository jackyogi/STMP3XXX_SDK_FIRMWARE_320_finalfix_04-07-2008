TASKING DSP2410 assembler v1.5r1 Build 138 SN 00100122
                                                                                                                                                                                                                                                       Page   1
C:\STMP3XXX_SDK_FIRMWARE_320_finalfix\Projects\SDK\lcdexample\player\make\ccfd289b.src
M:ADDR CODE           CYCLES LINE SOURCELINE
                                1 ; TASKING DSP2410 C compiler v1.5r1 Build 208 SN 00100122
                                2 ; options: -OG -si -DPLAYER -DALL -DD3500 -DMMC -DLIION -DPL3_FB
                                3 ;          -DSTMP_BUILD_PLAYER -DPLAYER_BUILD -DPLAYER -DSTFM1000_LCD
                                4 ;          -DFULL_PLAYER_KERNEL -DDCDC_POWER_TRANSFER -DBACKLIGHT
                                5 ;          -DWMAAPI_NO_DRM -DREVB_ENGR_BD -DSED15XX_LCD -DSYNC_LYRICS
                                6 ;          -DTUNER_STFM1000 -DFM_EUROPE_REGION -DSD_USE_100KHZ_TUNING_GRID
                                7 ;          -DNEWSHINGYIH -DREAL_I2S_DATA -DFUNCLET
                                8 ;          -DMEDIA_DDI_COUNT_HIDDEN_SYSTEM_BLOCKS -DFMTUNER -DMP3_ENCODE
                                9 ;          -DCHKDSK -DFAT16 -DDEBUG -DDEVICE_3500 -DSDK2400 -DENGR_BD
                               10 ;          -DUSE_PLAYLIST3 -DBATTERY_TYPE_LI_ION -DBATTERY_CHARGE -w68 -w66
                               11 ;          -I..\output_3500\include
                               12 ;          -I..\..\..\..\..\Projects\sdk\lcdexample\Player
                               13 ;          -I..\..\..\..\..\Projects\sdk\lcdexample\Player\Menus -I..\..
                               14 ;          -I..\..\..\..\..\inc -I..\..\..\..\..\System\Common
                               15 ;          -I..\..\..\..\..\System\Common\symbols
                               16 ;          -I..\..\..\..\..\Projects\sdk\lcdexample\Player\Display
                               17 ;          -I..\..\..\..\..\Algorithms\DRM\janus\src\h
                               18 ;          -I..\..\..\..\..\FileSystem\Fat32\h
                               19 ;          -I..\..\..\..\..\FileSystem\Fat32\cmp\cmp_stdtype
                               20 ;          -I..\..\..\..\..\FileSystem\Fat32\cmp\cmp_debug
                               21 ;          -I..\..\..\..\..\FileSystem\Fat32\cmp\cmp_file_system
                               22 ;          -I..\..\..\..\..\DeviceDriver\Media\cmp\cmp_media_nand -I -I
                               23 ;          -I..\..\..\..\..\system\common\resourcemanager -I..\..\..\..\..\inc
                               24 ;          -I..\..\..\..\..\devicedriver\media\MediaTypeNAND\include
                               25 ;          -I..\..\..\..\..\devicedriver\media\MediaTypeNAND\DDI\DataDrive\include
                               26 ;          -I..\..\..\..\..\devicedriver\media\MediaTypeNAND\DDI\include
                               27 ;          -I..\..\..\..\..\devicedriver\media\MediaTypeNAND\HAL\include
                               28 ;          -I..\..\..\..\..\devicedriver\media\MediaTypeNAND\DDI\DataDrive
                               29 ;          -I..\..\..\..\..\devicedriver\media\ddildl\include
                               30 ;          -I..\..\..\..\..\FileSystem\Fat32\h
                               31 ;          -I..\..\..\..\..\FileSystem\Fat32\cmp\cmp_stdtype
                               32 ;          -I..\..\..\..\..\FileSystem\Fat32\cmp\cmp_debug
                               33 ;          -I..\..\..\..\..\FileSystem\Fat32\cmp\cmp_file_system
                               34 ;          -I..\..\..\..\..\DeviceDriver\Media\cmp\cmp_media_nand
                               35 ;          -I..\..\..\..\..\devicedriver\media\MediaTypeNAND\include
                               36 ;          -I..\..\..\..\..\devicedriver\media\MediaTypeNAND\DDI\Common\include
                               37 ;          -I..\..\..\..\..\devicedriver\media\MediaTypeNAND\DDI\include
                               38 ;          -I..\..\..\..\..\devicedriver\media\MediaTypeNAND\HAL\include
                               39 ;          -I..\..\..\..\..\devicedriver\media\MediaTypeNAND\DDI\Common
                               40 ;          -I..\..\..\..\..\devicedriver\media\MediaTypeNAND\include
                               41 ;          -I..\..\..\..\..\devicedriver\media\MediaTypeNAND\DDI\SystemDrive\include
                               42 ;          -I..\..\..\..\..\devicedriver\media\MediaTypeNAND\DDI\include
                               43 ;          -I..\..\..\..\..\devicedriver\media\MediaTypeNAND\HAL\include
                               44 ;          -I..\..\..\..\..\devicedriver\media\MediaTypeNAND\DDI\SystemDrive
                               45 ;          -I..\..\..\..\..\devicedriver\media\MediaTypeNAND\include
                               46 ;          -I..\..\..\..\..\devicedriver\media\MediaTypeNAND\DDI\Media\include
                               47 ;          -I..\..\..\..\..\devicedriver\media\MediaTypeNAND\DDI\include
                               48 ;          -I..\..\..\..\..\devicedriver\media\MediaTypeNAND\HAL\include
                               49 ;          -I..\..\..\..\..\devicedriver\media\MediaTypeNAND\DDI\Media
                               50 ;          -I..\..\..\..\..\devicedriver\media\include
                               51 ;          -I..\..\..\..\..\devicedriver\media\ddildl
                               52 ;          -I..\..\..\..\..\devicedriver\media\ddildl\include
                               53 ;          -I..\..\..\..\..\devicedriver\media\MediaTypeNAND\DDI\Common\include
                               54 ;          -I..\..\..\..\..\devicedriver\media\MediaTypeNAND\DDI\include
                               55 ;          -I..\..\..\..\..\DeviceDriver\Media\MediaTypeNAND\HAL
                               56 ;          -I..\..\..\..\..\DeviceDriver\Media\MediaTypeNAND\HAL\include
                               57 ;          -I..\..\..\..\..\DeviceDriver\Media\include
                               58 ;          -I..\..\..\..\..\DeviceDriver\Media\PortHIL\GPFlash\include
                               59 ;          -I..\..\..\..\..\DeviceDriver\Media\PortHIL\GPFlash
                               60 ;          -I..\..\..\..\..\devicedriver\media\ddildl
                               61 ;          -I..\..\..\..\..\devicedriver\media\ddildl\include
                               62 ;          -I..\..\..\..\..\libsource\sysserialnumber
                               63 ;          -I..\..\..\..\..\devicedriver\media\MediaTypeMMC\DDI\include
                               64 ;          -I..\..\..\..\..\devicedriver\media\ddildl\include
                               65 ;          -I..\..\..\..\..\devicedriver\media\MediaTypeMMC\DDI\include
                               66 ;          -I..\..\..\..\..\devicedriver\media\MediaTypeMMC\DDI\Media
                               67 ;          -I..\..\..\..\..\devicedriver\media\MediaTypeMMC\HAL\include
                               68 ;          -I..\..\..\..\..\FileSystem\Fat32\h
                               69 ;          -I..\..\..\..\..\FileSystem\Fat32\cmp\cmp_stdtype
                               70 ;          -I..\..\..\..\..\FileSystem\Fat32\cmp\cmp_debug
                               71 ;          -I..\..\..\..\..\FileSystem\Fat32\cmp\cmp_file_system
                               72 ;          -I..\..\..\..\..\DeviceDriver\Media\cmp\cmp_media_nand
                               73 ;          -I..\..\..\..\..\DeviceDriver\Media\MediaTypeNAND\HAL\include
                               74 ;          -I..\..\..\..\..\System\MsgModules\Software\Effects\srswow
                               75 ;          -I..\..\..\..\..\System\Common\rtcaccess
                               76 ;          -I..\..\..\..\..\System\Common\playlist3
                               77 ;          -I..\..\..\..\..\System\Common\record
                               78 ;          -I..\..\..\..\..\System\Common\mp3filename
                               79 ;          -I..\..\..\..\..\FileSystem\chkdsk\include
                               80 ;          -I..\..\..\..\..\FileSystem\Fat32\h -DFULL_PLAYER_KERNEL
                               81 ;          -DSYNC_LYRICS -DMP3_ENCODE -DBATTERY_TYPE_LI_ION -Dk_opt_single_fat
                               82 ;          -DPL3_FB -g -O2 -R -Cs -DMS_ADPCM -DIMA_ADPCM -DWINDOWS_PCM
                               83 ;          -I..\..\..\..\..\System\MsgModules\Software\musiclib\ghdr
                               84 ;          -I..\..\..\..\..\devicedriver\display
                               85 ;          -I..\..\..\..\..\System\MsgModules\Hardware\Display -MmyL
                               86 
                               94 
                               95 ;     fatutils.c:
                               96 ; 1    |////////////////////////////////////////////////////////////////////////////////
                               97 ; 2    |// Copyright(C) SigmaTel, Inc. 2002-2005
                               98 ; 3    |//
                               99 ; 4    |// Filename: FatUtils.c
                              100 ; 5    |// Description: Utilities to work on the FAT
                              101 ; 6    |////////////////////////////////////////////////////////////////////////////////
                              102 ; 7    |
                              103 ; 8    |////////////////////////////////////////////////////////////////////////////////
                              104 ; 9    |//   Includes and external references
                              105 ; 10   |////////////////////////////////////////////////////////////////////////////////
                              106 ; 11   |
                              107 ; 12   |#include "types.h"
                              108 
                              110 
                              111 ; 1    |////////////////////////////////////////////////////////////////////////////////
                              112 ; 2    |// Copyright(C) SigmaTel, Inc. 2000-2004
                              113 ; 3    |//
                              114 ; 4    |// Filename: types.h
                              115 ; 5    |// Description: Standard data types
                              116 ; 6    |////////////////////////////////////////////////////////////////////////////////
                              117 ; 7    |
                              118 ; 8    |#ifndef _TYPES_H
                              119 ; 9    |#define _TYPES_H
                              120 ; 10   |
                              121 ; 11   |// TODO:  move this outta here!
                              122 ; 12   |#if !defined(NOERROR)
                              123 ; 13   |#define NOERROR 0
                              124 ; 14   |#define SUCCESS 0
                              125 ; 15   |#endif 
                              126 ; 16   |#if !defined(SUCCESS)
                              127 ; 17   |#define SUCCESS  0
                              128 ; 18   |#endif
                              129 ; 19   |#if !defined(ERROR)
                              130 ; 20   |#define ERROR   -1
                              131 ; 21   |#endif
                              132 ; 22   |#if !defined(FALSE)
                              133 ; 23   |#define FALSE 0
                              134 ; 24   |#endif
                              135 ; 25   |#if !defined(TRUE)
                              136 ; 26   |#define TRUE  1
                              137 ; 27   |#endif
                              138 ; 28   |
                              139 ; 29   |#if !defined(NULL)
                              140 ; 30   |#define NULL 0
                              141 ; 31   |#endif
                              142 ; 32   |
                              143 ; 33   |#define MAX_INT     0x7FFFFF
                              144 ; 34   |#define MAX_LONG    0x7FFFFFffffff
                              145 ; 35   |        // max positive unsigned long value: -1 == 0xFFFFFFffffff
                              146 ; 36   |#define MAX_ULONG   (-1) 
                              147 ; 37   |
                              148 ; 38   |#define WORD_SIZE   24              // word size in bits
                              149 ; 39   |#define BYTES_PER_WORD 3            // 8 bit bytes
                              150 ; 40   |
                              151 ; 41   |
                              152 ; 42   |#define BYTE    unsigned char       // btVarName
                              153 ; 43   |#define CHAR    signed char         // cVarName
                              154 ; 44   |#define USHORT  unsigned short      // usVarName
                              155 ; 45   |#define SHORT   unsigned short      // sVarName
                              156 ; 46   |#define WORD    unsigned int        // wVarName
                              157 ; 47   |#define INT     signed int          // iVarName
                              158 ; 48   |#define DWORD   unsigned long       // dwVarName
                              159 ; 49   |#define LONG    signed long         // lVarName
                              160 ; 50   |#define BOOL    unsigned int        // bVarName
                              161 ; 51   |#define FRACT   _fract              // frVarName
                              162 ; 52   |#define LFRACT  long _fract         // lfrVarName
                              163 ; 53   |#define CIRC    _circ               // cp<type prefix>VarName (see below)
                              164 ; 54   |#define FLOAT   float               // fVarName
                              165 ; 55   |#define DBL     double              // dVarName
                              166 ; 56   |#define ENUM    enum                // eVarName
                              167 ; 57   |#define CMX     _complex            // cmxVarName
                              168 ; 58   |typedef WORD UCS3;                   // 
                              169 ; 59   |
                              170 ; 60   |#define UINT16  unsigned short
                              171 ; 61   |#define UINT8   unsigned char   
                              172 ; 62   |#define UINT32  unsigned long
                              173 ; 63   |#define UINT64  unsigned long   // need to figure out how to do 64 bit values.  Or port exisiting code to only use 48 bit
                              174 ; 64   |#define INT64   unsigned long   // need to figure out how to do 64 bit values.  Or port exisiting code to only use 48 bit
                              175 ; 65   |#define WCHAR   UINT16
                              176 ; 66   |
                              177 ; 67   |//UINT128 is 16 bytes or 6 words
                              178 ; 68   |typedef struct UINT128_3500 {   
                              179 ; 69   |    int val[6];     
                              180 ; 70   |} UINT128_3500;
                              181 ; 71   |
                              182 ; 72   |#define UINT128   UINT128_3500
                              183 ; 73   |
                              184 ; 74   |// Little endian word packed byte strings:   
                              185 ; 75   |//      _packed BYTE bTextVarName[]="a string";  bText is a packed byte string prefix
                              186 ; 76   |// Convert to big endian words by reordering bytes from high to low using swizzle.
                              187 ; 77   |// Little endian word packed byte strings:   
                              188 ; 78   |//      _packed BYTE bTextVarName[]="a string";  bText is a packed byte string prefix
                              189 ; 79   |// Convert to big endian words by reordering bytes from high to low using swizzle.
                              190 ; 80   |
                              191 ; 81   |// Declare Memory Spaces To Use When Coding
                              192 ; 82   |// A. Sector Buffers
                              193 ; 83   |#define SECTOR_BUFFER_MEM_X _X
                              194 ; 84   |#define SECTOR_BUFFER_MEM_Y _Y
                              195 ; 85   |#define SECTOR_BUFFER_MEM SECTOR_BUFFER_MEM_X
                              196 ; 86   |typedef WORD SECTOR_BUFFER_MEM SECTOR_BUFFER;
                              197 
                              199 
                              200 ; 87   |typedef SECTOR_BUFFER * P_SECTOR_BUFFER;
                              201 ; 88   |// B. Media DDI Memory
                              202 ; 89   |#define MEDIA_DDI_MEM _Y
                              203 ; 90   |
                              204 ; 91   |
                              205 ; 92   |
                              206 ; 93   |// Pointers to linear structures are labeled as: p<type prefix>VarName
                              207 ; 94   |// Examples of circular pointers:
                              208 ; 95   |//    INT CIRC cpiVarName
                              209 ; 96   |//    DWORD CIRC cpdwVarName
                              210 ; 97   |
                              211 ; 98   |#define RETCODE INT                 // rcVarName
                              212 ; 99   |
                              213 ; 100  |// generic bitfield structure
                              214 ; 101  |struct Bitfield {
                              215 ; 102  |    unsigned int B0  :1;
                              216 ; 103  |    unsigned int B1  :1;
                              217 ; 104  |    unsigned int B2  :1;
                              218 ; 105  |    unsigned int B3  :1;
                              219 ; 106  |    unsigned int B4  :1;
                              220 ; 107  |    unsigned int B5  :1;
                              221 ; 108  |    unsigned int B6  :1;
                              222 ; 109  |    unsigned int B7  :1;
                              223 ; 110  |    unsigned int B8  :1;
                              224 ; 111  |    unsigned int B9  :1;
                              225 ; 112  |    unsigned int B10 :1;
                              226 ; 113  |    unsigned int B11 :1;
                              227 ; 114  |    unsigned int B12 :1;
                              228 ; 115  |    unsigned int B13 :1;
                              229 ; 116  |    unsigned int B14 :1;
                              230 ; 117  |    unsigned int B15 :1;
                              231 ; 118  |    unsigned int B16 :1;
                              232 ; 119  |    unsigned int B17 :1;
                              233 ; 120  |    unsigned int B18 :1;
                              234 ; 121  |    unsigned int B19 :1;
                              235 ; 122  |    unsigned int B20 :1;
                              236 ; 123  |    unsigned int B21 :1;
                              237 ; 124  |    unsigned int B22 :1;
                              238 ; 125  |    unsigned int B23 :1;
                              239 ; 126  |};
                              240 ; 127  |
                              241 ; 128  |union BitInt {
                              242 ; 129  |        struct Bitfield B;
                              243 ; 130  |        int        I;
                              244 ; 131  |};
                              245 ; 132  |
                              246 ; 133  |#define MAX_MSG_LENGTH 10
                              247 ; 134  |struct CMessage
                              248 ; 135  |{
                              249 ; 136  |        unsigned int m_uLength;
                              250 ; 137  |        unsigned int m_uMsg[MAX_MSG_LENGTH];
                              251 ; 138  |};
                              252 ; 139  |
                              253 ; 140  |typedef struct {
                              254 ; 141  |    WORD m_wLength;
                              255 ; 142  |    WORD m_wMessage;
                              256 ; 143  |    WORD m_wParams[MAX_MSG_LENGTH];
                              257 ; 144  |} Message;
                              258 ; 145  |
                              259 ; 146  |struct MessageQueueDescriptor
                              260 ; 147  |{
TASKING DSP2410 assembler v1.5r1 Build 138 SN 00100122
                                                                                                                                                                                                                                                       Page   2

M:ADDR CODE           CYCLES LINE SOURCELINE
                              261 ; 148  |        int *m_pBase;
                              262 ; 149  |        int m_iModulo;
                              263 ; 150  |        int m_iSize;
                              264 ; 151  |        int *m_pHead;
                              265 ; 152  |        int *m_pTail;
                              266 ; 153  |};
                              267 ; 154  |
                              268 ; 155  |struct ModuleEntry
                              269 ; 156  |{
                              270 ; 157  |    int m_iSignaledEventMask;
                              271 ; 158  |    int m_iWaitEventMask;
                              272 ; 159  |    int m_iResourceOfCode;
                              273 ; 160  |    struct MessageQueueDescriptor *m_pMessageQueue;
                              274 ; 161  |    int _asmfunc (*m_pProcessEntryPoint)(union WaitMask Signals,struct MessageQueueDescriptor *);
                              275 ; 162  |    int _asmfunc (*m_pInitFunction)(struct MessageQueueDescriptor *);
                              276 ; 163  |    int m_uTimeOutHigh;
                              277 ; 164  |    int m_uTimeOutLow;
                              278 ; 165  |    int _asmfunc (*m_pBackgroundFunction)(struct MessageQueueDescriptor *);
                              279 ; 166  |};
                              280 ; 167  |
                              281 ; 168  |union WaitMask{
                              282 ; 169  |    struct B{
                              283 ; 170  |        unsigned int m_bNone     :1;
                              284 ; 171  |        unsigned int m_bMessage  :1;
                              285 ; 172  |        unsigned int m_bTimer    :1;
                              286 ; 173  |        unsigned int m_bButton   :1;
                              287 ; 174  |    } B;
                              288 ; 175  |    int I;
                              289 ; 176  |} ;
                              290 ; 177  |
                              291 ; 178  |
                              292 ; 179  |struct Button {
                              293 ; 180  |        WORD wButtonEvent;
                              294 ; 181  |        WORD wUnused[MAX_MSG_LENGTH];   
                              295 ; 182  |};
                              296 ; 183  |
                              297 ; 184  |struct Message {
                              298 ; 185  |        WORD wMsgLength;
                              299 ; 186  |        WORD wMsgCommand;
                              300 ; 187  |        WORD wMsgParms[MAX_MSG_LENGTH-1];
                              301 ; 188  |};
                              302 ; 189  |
                              303 ; 190  |union EventTypes {
                              304 ; 191  |        struct CMessage msg;
                              305 ; 192  |        struct Button Button ;
                              306 ; 193  |        struct Message Message;
                              307 ; 194  |};
                              308 ; 195  |
                              309 ; 196  |// next 2 used to get updater build to return correct protocol ver in scsi response.
                              310 ; 197  |#define BUILD_TYPE_UPDATER  0x100
                              311 ; 198  |#define BUILD_TYPE_HOSTLINK 0x101
                              312 ; 199  |#define BUILD_TYPE_PLAYER   0x102
                              313 ; 200  |
                              314 ; 201  |// Resets part if RETAIL build. DEBUG build executes debug instruction to halt.
                              315 ; 202  |#define SystemHalt() __asm(" include 'sysmacro.asm' \n error") 
                              316 ; 203  |#define assert(x)    if(!(x)) __asm(" include 'sysmacro.asm' \n error")
                              317 ; 204  |
                              318 ; 205  |#if DEBUG
                              319 ; 206  |// For DEBUG builds, DebugBuildAssert(condition) halts if condition evaluates to FALSE. 
                              320 ; 207  |#define DebugBuildAssert(x)    if(!(x)) __asm(" debug ")
                              321 ; 208  |#else 
                              322 ; 209  |// For RETAIL builds, DebugBuildAssert(condition) does nothing & execution continues rather than halt or reset. 
                              323 ; 210  |#define DebugBuildAssert(x)    
                              324 ; 211  |#endif
                              325 ; 212  |
                              326 ; 213  |// Do this in your C files to make a reminder that's displayed during the build.
                              327 ; 214  |//  #pragma asm
                              328 ; 215  |//  WARN 'Note to builder: reminder to do this after verifying that'
                              329 ; 216  |//  #pragma endasm
                              330 ; 217  |
                              331 ; 218  |
                              332 ; 219  |#ifdef COLOR_262K
                              333 ; 220  |#define RGB(r,g,b)    ((0x0000FC & (r)) << 10) | ((0x0000FC & (g)) << 4) | ((0x0000FC & (b)) >> 2)    //262k
                              334 ; 221  |#elif defined(COLOR_65K)
                              335 ; 222  |#define RGB(r,g,b)    ((0x0000F8 & (r)) << 8) | ((0x0000FC & (g)) << 3) | ((0x0000F8 & (b)) >> 3)  //65k
                              336 ; 223  |#else
                              337 ; 224  |#define RGB(r,g,b)       ((0x0000F0 & (r)) << 4) | (0x0000F0 & (g)) | ((0x0000F0 & (b)) >> 4)
                              338 ; 225  |#endif
                              339 ; 226  |    
                              340 ; 227  |#endif // #ifndef _TYPES_H
                              341 
                              343 
                              344 ; 13   |#include "platform.h"
                              345 
                              347 
                              348 ; 1    |// Plafform API
                              349 ; 2    |
                              350 ; 3    |extern void EnterNonReentrantSection(void);
                              351 ; 4    |extern void LeaveNonReentrantSection(void);
                              352 ; 5    |
                              353 ; 6    |extern INT FSGetByte(void *buffer, INT Offset,INT MemoryType);
                              354 ; 7    |extern INT FSGetWord(void *buffer, INT Offset,INT MemoryType);
                              355 ; 8    |extern LONG FSGetDWord(void *buffer, INT Offset,INT MemoryType);
                              356 ; 9    |extern void FsCopyBuffer(void *Dest_Buffer,INT Dest_Offset,void *Source_Buffer,INT Source_Offset,INT Size,INT Source_MemoryType,INT Dest_MemoryType,INT Dest_modulo,INT SourceModule);
                              357 ; 10   |extern void PutByte(void *buffer, INT byte,INT Offset ,INT MemoryType);
                              358 ; 11   |extern void PutWord(void *buffer, INT word, INT Offset,INT MemoryType);
                              359 ; 12   |extern void PutDword(void *buffer,  LONG dword,INT Offset,INT MemoryType);
                              360 ; 13   |extern LONG GetDWordY(void *buffer, INT Offset,INT MemoryType);
                              361 
                              363 
                              364 ; 14   |#include "chkdsk.h"
                              365 
                              367 
                              368 ; 1    |////////////////////////////////////////////////////////////////////////////////
                              369 ; 2    |// Copyright(C) SigmaTel, Inc. 2000-2001
                              370 ; 3    |//
                              371 ; 4    |// Filename: chkdsk.h (historic name fattest.h)
                              372 ; 5    |// Description: 
                              373 ; 6    |////////////////////////////////////////////////////////////////////////////////
                              374 ; 7    |#include "types.h"
                              375 
                              377 
                              378 ; 1    |////////////////////////////////////////////////////////////////////////////////
                              379 ; 2    |// Copyright(C) SigmaTel, Inc. 2000-2004
                              380 ; 3    |//
                              381 ; 4    |// Filename: types.h
                              382 ; 5    |// Description: Standard data types
                              383 ; 6    |////////////////////////////////////////////////////////////////////////////////
                              384 ; 7    |
                              385 ; 8    |#ifndef _TYPES_H
                              386 ; 9    |#define _TYPES_H
                              387 ; 10   |
                              388 ; 11   |// TODO:  move this outta here!
                              389 ; 12   |#if !defined(NOERROR)
                              390 ; 13   |#define NOERROR 0
                              391 ; 14   |#define SUCCESS 0
                              392 ; 15   |#endif 
                              393 ; 16   |#if !defined(SUCCESS)
                              394 ; 17   |#define SUCCESS  0
                              395 ; 18   |#endif
                              396 ; 19   |#if !defined(ERROR)
                              397 ; 20   |#define ERROR   -1
                              398 ; 21   |#endif
                              399 ; 22   |#if !defined(FALSE)
                              400 ; 23   |#define FALSE 0
                              401 ; 24   |#endif
                              402 ; 25   |#if !defined(TRUE)
                              403 ; 26   |#define TRUE  1
                              404 ; 27   |#endif
                              405 ; 28   |
                              406 ; 29   |#if !defined(NULL)
                              407 ; 30   |#define NULL 0
                              408 ; 31   |#endif
                              409 ; 32   |
                              410 ; 33   |#define MAX_INT     0x7FFFFF
                              411 ; 34   |#define MAX_LONG    0x7FFFFFffffff
                              412 ; 35   |        // max positive unsigned long value: -1 == 0xFFFFFFffffff
                              413 ; 36   |#define MAX_ULONG   (-1) 
                              414 ; 37   |
                              415 ; 38   |#define WORD_SIZE   24              // word size in bits
                              416 ; 39   |#define BYTES_PER_WORD 3            // 8 bit bytes
                              417 ; 40   |
                              418 ; 41   |
                              419 ; 42   |#define BYTE    unsigned char       // btVarName
                              420 ; 43   |#define CHAR    signed char         // cVarName
                              421 ; 44   |#define USHORT  unsigned short      // usVarName
                              422 ; 45   |#define SHORT   unsigned short      // sVarName
                              423 ; 46   |#define WORD    unsigned int        // wVarName
                              424 ; 47   |#define INT     signed int          // iVarName
                              425 ; 48   |#define DWORD   unsigned long       // dwVarName
                              426 ; 49   |#define LONG    signed long         // lVarName
                              427 ; 50   |#define BOOL    unsigned int        // bVarName
                              428 ; 51   |#define FRACT   _fract              // frVarName
                              429 ; 52   |#define LFRACT  long _fract         // lfrVarName
                              430 ; 53   |#define CIRC    _circ               // cp<type prefix>VarName (see below)
                              431 ; 54   |#define FLOAT   float               // fVarName
                              432 ; 55   |#define DBL     double              // dVarName
                              433 ; 56   |#define ENUM    enum                // eVarName
                              434 ; 57   |#define CMX     _complex            // cmxVarName
                              435 ; 58   |typedef WORD UCS3;                   // 
                              436 ; 59   |
                              437 ; 60   |#define UINT16  unsigned short
                              438 ; 61   |#define UINT8   unsigned char   
                              439 ; 62   |#define UINT32  unsigned long
                              440 ; 63   |#define UINT64  unsigned long   // need to figure out how to do 64 bit values.  Or port exisiting code to only use 48 bit
                              441 ; 64   |#define INT64   unsigned long   // need to figure out how to do 64 bit values.  Or port exisiting code to only use 48 bit
                              442 ; 65   |#define WCHAR   UINT16
                              443 ; 66   |
                              444 ; 67   |//UINT128 is 16 bytes or 6 words
                              445 ; 68   |typedef struct UINT128_3500 {   
                              446 ; 69   |    int val[6];     
                              447 ; 70   |} UINT128_3500;
                              448 ; 71   |
                              449 ; 72   |#define UINT128   UINT128_3500
                              450 ; 73   |
                              451 ; 74   |// Little endian word packed byte strings:   
                              452 ; 75   |//      _packed BYTE bTextVarName[]="a string";  bText is a packed byte string prefix
                              453 ; 76   |// Convert to big endian words by reordering bytes from high to low using swizzle.
                              454 ; 77   |// Little endian word packed byte strings:   
                              455 ; 78   |//      _packed BYTE bTextVarName[]="a string";  bText is a packed byte string prefix
                              456 ; 79   |// Convert to big endian words by reordering bytes from high to low using swizzle.
                              457 ; 80   |
                              458 ; 81   |// Declare Memory Spaces To Use When Coding
                              459 ; 82   |// A. Sector Buffers
                              460 ; 83   |#define SECTOR_BUFFER_MEM_X _X
                              461 ; 84   |#define SECTOR_BUFFER_MEM_Y _Y
                              462 ; 85   |#define SECTOR_BUFFER_MEM SECTOR_BUFFER_MEM_X
                              463 ; 86   |typedef WORD SECTOR_BUFFER_MEM SECTOR_BUFFER;
                              464 ; 87   |typedef SECTOR_BUFFER * P_SECTOR_BUFFER;
                              465 ; 88   |// B. Media DDI Memory
                              466 ; 89   |#define MEDIA_DDI_MEM _Y
                              467 ; 90   |
                              468 ; 91   |
                              469 ; 92   |
                              470 ; 93   |// Pointers to linear structures are labeled as: p<type prefix>VarName
                              471 ; 94   |// Examples of circular pointers:
                              472 ; 95   |//    INT CIRC cpiVarName
                              473 ; 96   |//    DWORD CIRC cpdwVarName
                              474 ; 97   |
                              475 ; 98   |#define RETCODE INT                 // rcVarName
                              476 ; 99   |
                              477 ; 100  |// generic bitfield structure
                              478 ; 101  |struct Bitfield {
                              479 ; 102  |    unsigned int B0  :1;
                              480 ; 103  |    unsigned int B1  :1;
                              481 ; 104  |    unsigned int B2  :1;
                              482 ; 105  |    unsigned int B3  :1;
                              483 ; 106  |    unsigned int B4  :1;
                              484 ; 107  |    unsigned int B5  :1;
                              485 ; 108  |    unsigned int B6  :1;
                              486 ; 109  |    unsigned int B7  :1;
                              487 ; 110  |    unsigned int B8  :1;
                              488 ; 111  |    unsigned int B9  :1;
                              489 ; 112  |    unsigned int B10 :1;
                              490 ; 113  |    unsigned int B11 :1;
                              491 ; 114  |    unsigned int B12 :1;
                              492 ; 115  |    unsigned int B13 :1;
                              493 ; 116  |    unsigned int B14 :1;
                              494 ; 117  |    unsigned int B15 :1;
                              495 ; 118  |    unsigned int B16 :1;
                              496 ; 119  |    unsigned int B17 :1;
                              497 ; 120  |    unsigned int B18 :1;
                              498 ; 121  |    unsigned int B19 :1;
                              499 ; 122  |    unsigned int B20 :1;
                              500 ; 123  |    unsigned int B21 :1;
                              501 ; 124  |    unsigned int B22 :1;
                              502 ; 125  |    unsigned int B23 :1;
                              503 ; 126  |};
                              504 ; 127  |
                              505 ; 128  |union BitInt {
                              506 ; 129  |        struct Bitfield B;
                              507 ; 130  |        int        I;
                              508 ; 131  |};
                              509 ; 132  |
                              510 ; 133  |#define MAX_MSG_LENGTH 10
                              511 ; 134  |struct CMessage
                              512 ; 135  |{
                              513 ; 136  |        unsigned int m_uLength;
                              514 ; 137  |        unsigned int m_uMsg[MAX_MSG_LENGTH];
                              515 ; 138  |};
                              516 ; 139  |
TASKING DSP2410 assembler v1.5r1 Build 138 SN 00100122
                                                                                                                                                                                                                                                       Page   3

M:ADDR CODE           CYCLES LINE SOURCELINE
                              517 ; 140  |typedef struct {
                              518 ; 141  |    WORD m_wLength;
                              519 ; 142  |    WORD m_wMessage;
                              520 ; 143  |    WORD m_wParams[MAX_MSG_LENGTH];
                              521 ; 144  |} Message;
                              522 ; 145  |
                              523 ; 146  |struct MessageQueueDescriptor
                              524 ; 147  |{
                              525 ; 148  |        int *m_pBase;
                              526 ; 149  |        int m_iModulo;
                              527 ; 150  |        int m_iSize;
                              528 ; 151  |        int *m_pHead;
                              529 ; 152  |        int *m_pTail;
                              530 ; 153  |};
                              531 ; 154  |
                              532 ; 155  |struct ModuleEntry
                              533 ; 156  |{
                              534 ; 157  |    int m_iSignaledEventMask;
                              535 ; 158  |    int m_iWaitEventMask;
                              536 ; 159  |    int m_iResourceOfCode;
                              537 ; 160  |    struct MessageQueueDescriptor *m_pMessageQueue;
                              538 ; 161  |    int _asmfunc (*m_pProcessEntryPoint)(union WaitMask Signals,struct MessageQueueDescriptor *);
                              539 ; 162  |    int _asmfunc (*m_pInitFunction)(struct MessageQueueDescriptor *);
                              540 ; 163  |    int m_uTimeOutHigh;
                              541 ; 164  |    int m_uTimeOutLow;
                              542 ; 165  |    int _asmfunc (*m_pBackgroundFunction)(struct MessageQueueDescriptor *);
                              543 ; 166  |};
                              544 ; 167  |
                              545 ; 168  |union WaitMask{
                              546 ; 169  |    struct B{
                              547 ; 170  |        unsigned int m_bNone     :1;
                              548 ; 171  |        unsigned int m_bMessage  :1;
                              549 ; 172  |        unsigned int m_bTimer    :1;
                              550 ; 173  |        unsigned int m_bButton   :1;
                              551 ; 174  |    } B;
                              552 ; 175  |    int I;
                              553 ; 176  |} ;
                              554 ; 177  |
                              555 ; 178  |
                              556 ; 179  |struct Button {
                              557 ; 180  |        WORD wButtonEvent;
                              558 ; 181  |        WORD wUnused[MAX_MSG_LENGTH];   
                              559 ; 182  |};
                              560 ; 183  |
                              561 ; 184  |struct Message {
                              562 ; 185  |        WORD wMsgLength;
                              563 ; 186  |        WORD wMsgCommand;
                              564 ; 187  |        WORD wMsgParms[MAX_MSG_LENGTH-1];
                              565 ; 188  |};
                              566 ; 189  |
                              567 ; 190  |union EventTypes {
                              568 ; 191  |        struct CMessage msg;
                              569 ; 192  |        struct Button Button ;
                              570 ; 193  |        struct Message Message;
                              571 ; 194  |};
                              572 ; 195  |
                              573 ; 196  |// next 2 used to get updater build to return correct protocol ver in scsi response.
                              574 ; 197  |#define BUILD_TYPE_UPDATER  0x100
                              575 ; 198  |#define BUILD_TYPE_HOSTLINK 0x101
                              576 ; 199  |#define BUILD_TYPE_PLAYER   0x102
                              577 ; 200  |
                              578 ; 201  |// Resets part if RETAIL build. DEBUG build executes debug instruction to halt.
                              579 ; 202  |#define SystemHalt() __asm(" include 'sysmacro.asm' \n error") 
                              580 ; 203  |#define assert(x)    if(!(x)) __asm(" include 'sysmacro.asm' \n error")
                              581 ; 204  |
                              582 ; 205  |#if DEBUG
                              583 ; 206  |// For DEBUG builds, DebugBuildAssert(condition) halts if condition evaluates to FALSE. 
                              584 ; 207  |#define DebugBuildAssert(x)    if(!(x)) __asm(" debug ")
                              585 ; 208  |#else 
                              586 ; 209  |// For RETAIL builds, DebugBuildAssert(condition) does nothing & execution continues rather than halt or reset. 
                              587 ; 210  |#define DebugBuildAssert(x)    
                              588 ; 211  |#endif
                              589 ; 212  |
                              590 ; 213  |// Do this in your C files to make a reminder that's displayed during the build.
                              591 ; 214  |//  #pragma asm
                              592 ; 215  |//  WARN 'Note to builder: reminder to do this after verifying that'
                              593 ; 216  |//  #pragma endasm
                              594 ; 217  |
                              595 ; 218  |
                              596 ; 219  |#ifdef COLOR_262K
                              597 ; 220  |#define RGB(r,g,b)    ((0x0000FC & (r)) << 10) | ((0x0000FC & (g)) << 4) | ((0x0000FC & (b)) >> 2)    //262k
                              598 ; 221  |#elif defined(COLOR_65K)
                              599 ; 222  |#define RGB(r,g,b)    ((0x0000F8 & (r)) << 8) | ((0x0000FC & (g)) << 3) | ((0x0000F8 & (b)) >> 3)  //65k
                              600 ; 223  |#else
                              601 ; 224  |#define RGB(r,g,b)       ((0x0000F0 & (r)) << 4) | (0x0000F0 & (g)) | ((0x0000F0 & (b)) >> 4)
                              602 ; 225  |#endif
                              603 ; 226  |    
                              604 ; 227  |#endif // #ifndef _TYPES_H
                              605 
                              607 
                              608 ; 8    |
                              609 ; 9    |#ifndef _CHKDSK_H
                              610 ; 10   |#define _CHKDSK_H
                              611 ; 11   |
                              612 ; 12   |extern WORD _X cachedSectorSize;
                              613 ; 13   |extern WORD _X cachedSectorSizeInWords;
                              614 ; 14   |extern WORD _X cachedClusterEntryPerSectorShift;
                              615 ; 15   |extern WORD _X cachedDirRecordsPerSector;
                              616 ; 16   |
                              617 ; 17   |#define BYTE_POS_SIGNATURE          0x1fe
                              618 ; 18   |#define BYTE_POS_NUM_SECT_PER_CX    0x0d
                              619 ; 19   |#define BYTE_POS_NUM_RES_SECT       0x0e
                              620 ; 20   |#define BYTE_POS_NUM_FAT            0x10
                              621 ; 21   |#define BYTE_POS_NUM_ROOT_SECT      0x11
                              622 ; 22   |#define BYTE_POS_NUM_FAT_SECT       0x16
                              623 ; 23   |#define BYTE_POS_NUM_HIDDEN_SECT    0x1C
                              624 ; 24   |#define BYTE_POS_NUM_FAT_SECT_32        0x24
                              625 ; 25   |#define BYTE_POS_ROOT_DIR_CX            0x2C
                              626 ; 26   |#define BYTE_POS_TOTAL_SECTS        0x13
                              627 ; 27   |#define BYTE_POS_TOTAL_SECTS_32     0x20
                              628 ; 28   |
                              629 ; 29   |#define DIR_REC_ATT_POS             0x0b
                              630 ; 30   |#define DIR_REC_FIRST_CX_POS        0x1a
                              631 ; 31   |#define DIR_REC_SIZE_POS            0x1c       
                              632 ; 32   |#define DIR_REC_FIRST_CX_HIGH_POS       0x14
                              633 ; 33   |#define SIGN_WORD_VALUE     0x00AA55
                              634 ; 34   |#define FAT_WORD            18
                              635 ; 35   |#define FAT_1ST_WORD        0x544146       
                              636 ; 36   |#define FAT12_SIGN_VALUE    0x203231
                              637 ; 37   |#define FAT16_SIGN_VALUE    0x203631
                              638 ; 38   |#define FAT32_SIGN_VALUE    0x203233
                              639 ; 39   |
                              640 ; 40   |#define DIR_REC_PER_SECTOR  (cachedDirRecordsPerSector)     // Number of directory records per sector
                              641 ; 41   |
                              642 ; 42   |#define MAX_ENTRIES_LONG_FILE_NAME  20      // Any long file name can be up to 255 bytes long
                              643 ; 43   |                                            // and each entry can hold up to 13 characters
                              644 ; 44   |                                            // there can only be up to 20 entries of LFN
                              645 ; 45   |                                            // per file.
                              646 ; 46   |#define BYTES_PER_DIR_RECORD    32
                              647 ; 47   |#define BYTES_PER_SECT          (cachedSectorSize)
                              648 ; 48   |
                              649 ; 49   |#define FILE_DELETED_CODE       0xe5
                              650 ; 50   |#define CLUSTER_ENTRY_PER_SECTOR_SHIFT  (cachedClusterEntryPerSectorShift)
                              651 ; 51   |
                              652 ; 52   |#define  MAX_CACHES             5   // 9
                              653 ; 53   |#define WORDS_IN_CACHE_ENTRY  705   // 705
                              654 ; 54   |#define     X_MEMORY            0
                              655 ; 55   |#define     Y_MEMORY            2
                              656 ; 56   |#define     P_MEMORY            4
                              657 ; 57   |#define READCOUNTER         105
                              658 ; 58   |#define WRITECOUNTER        100
                              659 ; 59   |#define FLUSHCOUNTER        200
                              660 ; 60   |
                              661 ; 61   |
                              662 ; 62   |#define DEFAULT_MEMORY      Y_MEMORY
                              663 ; 63   |
                              664 ; 64   |#include "sectordef.h"
                              665 
                              667 
                              668 ; 1    |////////////////////////////////////////////////////////////////////////////////
                              669 ; 2    |// Copyright(C) SigmaTel, Inc. 2003-2005
                              670 ; 3    |//
                              671 ; 4    |// Filename:     sectordef.h
                              672 ; 5    |// Description:  Contains structs, prototypes, equates for the NAND Hal & other 
                              673 ; 6    |//               routines.
                              674 ; 7    |////////////////////////////////////////////////////////////////////////////////
                              675 ; 8    |
                              676 ; 9    |#ifndef _SECTORDEF_H
                              677 ; 10   |#define _SECTORDEF_H
                              678 ; 11   |
                              679 ; 12   |    #define RAM_SECTOR_TOTAL_SIZE                 (528)
                              680 ; 13   |    #define RAM_SECTOR_DATA_SIZE                  (512)
                              681 ; 14   |    #define RAM_SECTOR_REDUNDANT_SIZE             (16)
                              682 ; 15   |
                              683 ; 16   |
                              684 ; 17   |    #define MMC_SECTOR_TOTAL_SIZE                 (528)
                              685 ; 18   |    #define MMC_SECTOR_DATA_SIZE                  (512)
                              686 ; 19   |    #define MMC_SECTOR_REDUNDANT_SIZE             (16)
                              687 ; 20   |
                              688 ; 21   |
                              689 ; 22   |    #define SSFDC_SECTOR_TOTAL_SIZE                 (528)
                              690 ; 23   |    #define SSFDC_SECTOR_DATA_SIZE                  (512)
                              691 ; 24   |    #define SSFDC_SECTOR_REDUNDANT_SIZE             (16)
                              692 ; 25   |
                              693 ; 26   | // Define large sector macros as small ones so sdk3.x fits in ram and mtp with small 
                              694 ; 27   | // sector flash gets the performance boosts from optimized nand timings, etc. 
                              695 ; 28   | // TOVERIFY: Comment out the next macro def when you want large sector support as 
                              696 ; 29   | // in sdk2.6 and you can find the free data RAM. Or uncomment if you want to save data ram
                              697 ; 30   | // and only support 512 byte sectors and their associated flash types. 
                              698 ; 31   |//#define LARGE_SECTOR_DEFS_AS_SMALL_SECTOR
                              699 ; 32   |#ifdef LARGE_SECTOR_DEFS_AS_SMALL_SECTOR 
                              700 ; 33   |    #define LARGE_SECTOR_TOTAL_SIZE                 (528)
                              701 ; 34   |    #define LARGE_SECTOR_DATA_SIZE                  (512)
                              702 ; 35   |    #define LARGE_SECTOR_REDUNDANT_SIZE             (16)
                              703 ; 36   |#else
                              704 ; 37   |    // Real large sector defines to use when large sector flash support is desired.
                              705 ; 38   |    #define LARGE_SECTOR_TOTAL_SIZE                 (2112)
                              706 ; 39   |    #define LARGE_SECTOR_DATA_SIZE                  (2048)
                              707 ; 40   |    #define LARGE_SECTOR_REDUNDANT_SIZE             (64)
                              708 ; 41   |#endif
                              709 ; 42   |    
                              710 ; 43   |    // round up to the nearest WORD, then add one to pad for the ECC DMA bug
                              711 ; 44   |    #define SECTOR_BUFFER_ALLOC_SIZE(a)             (((a+2)/3)+1)
                              712 ; 45   |
                              713 ; 46   |
                              714 ; 47   |    // These are moved here from chkdsk.h     TOVERIFY. 
                              715 ; 48   |    #define SEC_512_BYTES_PER_SECTOR                        SSFDC_SECTOR_DATA_SIZE
                              716 ; 49   |        #define SEC_512_BYTES_TOTAL_SIZE                                                SSFDC_SECTOR_TOTAL_SIZE
                              717 ; 50   |        #define SEC_512_WORDS_TOTAL_SIZE                                                176
                              718 ; 51   |    #define SEC_512_BYTES_CLUSTER_ENTRY_PER_SECTOR_SHIFT    12
                              719 ; 52   |    #define SEC_512_BYTES_DIR_REC_PER_SECTOR                16
                              720 ; 53   |    #define SEC_512_BYTES_WORDS_PER_SECTOR                  177
                              721 ; 54   |    #define SEC_2K_BYTES_PER_SECTOR                         LARGE_SECTOR_DATA_SIZE
                              722 ; 55   |        #define SEC_2K_BYTES_TOTAL_SIZE                                                 LARGE_SECTOR_TOTAL_SIZE
                              723 ; 56   |    #define SEC_2K_BYTES_CLUSTER_ENTRY_PER_SECTOR_SHIFT     12
                              724 ; 57   |    #define SEC_2K_BYTES_DIR_REC_PER_SECTOR                 64
                              725 ; 58   |    #define SEC_2K_BYTES_WORDS_PER_SECTOR                   705
                              726 ; 59   |    #define SEC_2K_BYTES_WORDS_PER_SECTOR_NO_RA             683
                              727 ; 60   |
                              728 ; 61   |    // Next 5 lines imported from nandsystemdrivewritesector.c
                              729 ; 62   |    #define RA_ATTR_MEMORY_OFFSET           682
                              730 ; 63   |    #define NUMBER_OF_WORDS_IN_512BYTES     171
                              731 ; 64   |    #define NUM_ECC_DATA_IN_WORDS           3
                              732 ; 65   |    #define SEC_512_WORD1_RA_SWAP           171
                              733 ; 66   |    #define SEC_512_WORD2_RA_SWAP           173
                              734 ; 67   |
                              735 ; 68   |#endif  // _SECTORDEF_H
                              736 ; 69   |
                              737 
                              739 
                              740 ; 65   |// exported defines that were here into sectordef.h    
                              741 ; 66   |
                              742 ; 67   |
                              743 ; 68   |//#define BOOL    unsigned int        // bVarName
                              744 ; 69   |//#define FALSE 0
                              745 ; 70   |//#define TRUE  1
                              746 ; 71   |//#define NOERROR 0
                              747 ; 72   |
                              748 ; 73   |// A sector group is the number of sectors in the FAT buffer
                              749 ; 74   |// To improve speed and program writting this buffer 
                              750 ; 75   |// should be a multiple of 3 sectors
                              751 ; 76   |#define FAT12_ENTRIES_PER_SECT_GROUP  ((cachedSectorSize*3)*2/3)  // was 1024   (NumberBufferSect*sectorSize)/1.5
                              752 ; 77   |#define FAT16_ENTRIES_PER_SECT_GROUP  ((cachedSectorSize*3)/2)    // was  768   (NumberBufferSect*sectorSize)/2
                              753 ; 78   |#define FAT32_ENTRIES_PER_SECT_GROUP  ((cachedSectorSize*3)/4)    // was  384   (NumberBufferSect*sectorSize)/4
                              754 ; 79   |
                              755 ; 80   |#define  SET_BIT     1
                              756 ; 81   |#define  FREE_BIT    2
                              757 ; 82   |#define  GET_BIT     0
                              758 ; 83   |
                              759 ; 84   |typedef enum {
                              760 ; 85   |    FS_FAT12 = 0,
                              761 ; 86   |    FS_FAT16,
                              762 ; 87   |        FS_FAT32,
                              763 ; 88   |    FATUNSUPPORTED
                              764 ; 89   |    }FAT_TYPE;
                              765 ; 90   |    
                              766 ; 91   |typedef enum {
                              767 ; 92   |    CLEAN = 0,
                              768 ; 93   |    DIRTY
                              769 ; 94   |    } SECT_CTRL;    
                              770 
TASKING DSP2410 assembler v1.5r1 Build 138 SN 00100122
                                                                                                                                                                                                                                                       Page   4

M:ADDR CODE           CYCLES LINE SOURCELINE
                              777 
                              778 ; 95   |    
                              779 ; 96   |typedef struct {
                              780 ; 97   |    FAT_TYPE    TypeFileSystem;
                              781 ; 98   |    BYTE        bSectPerCx;        
                              782 ; 99   |    BYTE        bNumberFats;
                              783 ; 100  |    WORD        wNumberRootDirEntries;
                              784 ; 101  |    DWORD        wNumberFatSectors;
                              785 ; 102  |    DWORD        wStartSectDataArea;
                              786 ; 103  |    DWORD        wStartSectPrimaryFat;
                              787 ; 104  |    DWORD        wStartSectSecondaryFat;
                              788 ; 105  |    DWORD        wStartSectRootDir;
                              789 ; 106  |    DWORD        wStartSectData;
                              790 ; 107  |    DWORD        dwNumHiddenSectors;
                              791 ; 108  |    DWORD        wNumberRootDirSectors;
                              792 ; 109  |        DWORD        Rootdirstartcx;
                              793 ; 110  |        DWORD            dwTotalsectors;
                              794 ; 111  |        DWORD            dwTotalclusters;
                              795 ; 112  |} PARTITION_BOOT_SECTOR;
                              796 
                              801 
                              802 ; 113  |
                              803 ; 114  |typedef struct {
                              804 ; 115  |    BYTE        Device;                     // Logical device number
                              805 ; 116  |    DWORD        StartSectCurDir;            // Start Sector for the current directory
                              806 ; 117  |    DWORD        wStartCxCurDir;             // Start Cluster Number for current directory
                              807 ; 118  |    SECT_CTRL   Control;                                            // 0 means Root Directory
                              808 ; 119  |    DWORD        CurSect;                    // Current Sector Number Loaded in Buffer
                              809 ; 120  |    WORD        NumberFiles;                // Number of files in the current dir
                              810 ; 121  |    WORD _X     *pwBuffer;                  // Buffer to read device
                              811 ; 122  |} DIR_CTRL_BLK;
                              812 ; 123  |
                              813 ; 124  |typedef struct {
                              814 ; 125  |    BYTE        StartNameCharacter;        
                              815 ; 126  |    WORD        Attribut;
                              816 ; 127  |    DWORD        StartCluster;
                              817 ; 128  |    DWORD       Size;
                              818 ; 129  |} FILE_CTRL_BLK;
                              819 ; 130  |
                              820 ; 131  |typedef struct {
                              821 ; 132  |    BYTE        Device;
                              822 ; 133  |    WORD        FatSectorCached;    // Absolute sector cached in Fat buffer
                              823 ; 134  |    SECT_CTRL   Control;
                              824 ; 135  |    DWORD        FirstPrimaryFatSect;
                              825 ; 136  |    DWORD        FirstSecondaryFatSect;
                              826 ; 137  |    WORD _Y     *pwBuffer;
                              827 ; 138  |    } FAT_STRUCT;
                              828 ; 139  |
                              829 ; 140  |typedef struct {
                              830 ; 141  |    BYTE        RecordNumber;
                              831 ; 142  |    DWORD        SectorNumber;
                              832 ; 143  |} DIR_REC_LOCATION;
                              833 ; 144  |
                              834 ; 145  |
                              835 ; 146  |typedef struct {
                              836 ; 147  |        INT CacheValid;
                              837 ; 148  |        LONG SectorNumber;
                              838 ; 149  |        INT WriteAttribute;
                              839 ; 150  |        INT CacheCounter;
                              840 ; 151  |} tCACHEDESCR_checkdisk;
                              841 ; 152  |
                              842 ; 153  |    
                              843 ; 154  |
                              844 ; 155  |void chkdskall(void);
                              845 ; 156  |void CheckDisk(BYTE bDiskNum);
                              846 ; 157  |BOOL _reentrant InitPartitionBootSectorStruct(BYTE bLogDevNumber);
                              847 
                              859 
                              860 ; 158  |BOOL _reentrant ScanFilesAndSubDirs(DIR_CTRL_BLK *pstDirCtrlBlk);
                              861 ; 159  |void _reentrant HandleFailReadSector(void);
                              862 ; 160  |BOOL _reentrant DeleteFileRecord(BYTE bRecordNumber, DWORD wSectNumber, DIR_CTRL_BLK *pstDirCtrlBlk);
                              863 ; 161  |BOOL _reentrant GetFileCtrlBlk(BYTE bRecordNumber, DWORD wSectNumber, DIR_CTRL_BLK *pstDirCtrlBlk, FILE_CTRL_BLK *pstFileCtrlBlk);
                              864 
                              871 
                              872 ; 162  |//BOOL _reentrant ScanFileList(DIR_CTRL_BLK *pstDirCtrlBlk, DIR_REC_LOCATION *pstFileList);
                              873 ; 163  |DWORD _reentrant CxToSect(DWORD wCx);
                              874 ; 164  |BOOL _reentrant ReadDirSector(DWORD wSectNumber, DIR_CTRL_BLK *pstDirCtrlBlk);
                              875 ; 165  |LONG _reentrant CheckCrossLinkFile(DWORD wStartCluster,BYTE blogdevicenumber);
                              876 ; 166  |void _reentrant ReserveCluster(DWORD wStartCluster,BYTE blogdevicenumber);
                              877 ; 167  |BOOL _reentrant ScanDirectory(DIR_CTRL_BLK *pstDirCtrlBlk);
                              878 ; 168  |BOOL _reentrant ScanAndUpdateFat(BYTE blogdevicenumber,FAT_TYPE TypeFileSystem);
                              879 ; 169  |#ifdef STMP_BUILD_DCC
                              880 ; 170  |void InitTime(void);
                              881 ; 171  |DWORD GetTime(void);
                              882 ; 172  |#endif
                              883 ; 173  |#endif 
                              884 
                              886 
                              887 ; 15   |#include "regsswizzle.h"
                              888 
                              890 
                              891 ; 1    |//;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                              892 ; 2    |//;; Copyright(C) SigmaTel, Inc. 2002-2003
                              893 ; 3    |//;; Filename    : regsswizzle.inc
                              894 ; 4    |//;; Description : Register definitions for Swizzle interface
                              895 ; 5    |//;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                              896 ; 6    |
                              897 ; 7    |/////////////////////////////////////////////////////////////////////////////////
                              898 ; 8    |// The following naming conventions are followed in this file.
                              899 ; 9    |// All registers are named using the format...
                              900 ; 10   |//     HW_<module>_<regname>
                              901 ; 11   |// where <module> is the module name which can be any of the following...
                              902 ; 12   |//     USB20
                              903 ; 13   |// (Note that when there is more than one copy of a particular module, the
                              904 ; 14   |// module name includes a number starting from 0 for the first instance of
                              905 ; 15   |// that module)
                              906 ; 16   |// <regname> is the specific register within that module
                              907 ; 17   |// We also define the following...
                              908 ; 18   |//     HW_<module>_<regname>_BITPOS
                              909 ; 19   |// which defines the starting bit (i.e. LSB) of a multi bit field
                              910 ; 20   |//     HW_<module>_<regname>_SETMASK
                              911 ; 21   |// which does something else, and
                              912 ; 22   |//     HW_<module>_<regname>_CLRMASK
                              913 ; 23   |// which does something else.
                              914 ; 24   |// Other rules
                              915 ; 25   |//     All caps
                              916 ; 26   |//     Numeric identifiers start at 0
                              917 ; 27   |#if !(defined(regsswizzleinc))
                              918 ; 28   |#define regsswizzleinc 1
                              919 ; 29   |
                              920 ; 30   |#include "types.h"
                              921 
                              923 
                              924 ; 1    |////////////////////////////////////////////////////////////////////////////////
                              925 ; 2    |// Copyright(C) SigmaTel, Inc. 2000-2004
                              926 ; 3    |//
                              927 ; 4    |// Filename: types.h
                              928 ; 5    |// Description: Standard data types
                              929 ; 6    |////////////////////////////////////////////////////////////////////////////////
                              930 ; 7    |
                              931 ; 8    |#ifndef _TYPES_H
                              932 ; 9    |#define _TYPES_H
                              933 ; 10   |
                              934 ; 11   |// TODO:  move this outta here!
                              935 ; 12   |#if !defined(NOERROR)
                              936 ; 13   |#define NOERROR 0
                              937 ; 14   |#define SUCCESS 0
                              938 ; 15   |#endif 
                              939 ; 16   |#if !defined(SUCCESS)
                              940 ; 17   |#define SUCCESS  0
                              941 ; 18   |#endif
                              942 ; 19   |#if !defined(ERROR)
                              943 ; 20   |#define ERROR   -1
                              944 ; 21   |#endif
                              945 ; 22   |#if !defined(FALSE)
                              946 ; 23   |#define FALSE 0
                              947 ; 24   |#endif
                              948 ; 25   |#if !defined(TRUE)
                              949 ; 26   |#define TRUE  1
                              950 ; 27   |#endif
                              951 ; 28   |
                              952 ; 29   |#if !defined(NULL)
                              953 ; 30   |#define NULL 0
                              954 ; 31   |#endif
                              955 ; 32   |
                              956 ; 33   |#define MAX_INT     0x7FFFFF
                              957 ; 34   |#define MAX_LONG    0x7FFFFFffffff
                              958 ; 35   |        // max positive unsigned long value: -1 == 0xFFFFFFffffff
                              959 ; 36   |#define MAX_ULONG   (-1) 
                              960 ; 37   |
                              961 ; 38   |#define WORD_SIZE   24              // word size in bits
                              962 ; 39   |#define BYTES_PER_WORD 3            // 8 bit bytes
                              963 ; 40   |
                              964 ; 41   |
                              965 ; 42   |#define BYTE    unsigned char       // btVarName
                              966 ; 43   |#define CHAR    signed char         // cVarName
                              967 ; 44   |#define USHORT  unsigned short      // usVarName
                              968 ; 45   |#define SHORT   unsigned short      // sVarName
                              969 ; 46   |#define WORD    unsigned int        // wVarName
                              970 ; 47   |#define INT     signed int          // iVarName
                              971 ; 48   |#define DWORD   unsigned long       // dwVarName
                              972 ; 49   |#define LONG    signed long         // lVarName
                              973 ; 50   |#define BOOL    unsigned int        // bVarName
                              974 ; 51   |#define FRACT   _fract              // frVarName
                              975 ; 52   |#define LFRACT  long _fract         // lfrVarName
                              976 ; 53   |#define CIRC    _circ               // cp<type prefix>VarName (see below)
                              977 ; 54   |#define FLOAT   float               // fVarName
                              978 ; 55   |#define DBL     double              // dVarName
                              979 ; 56   |#define ENUM    enum                // eVarName
                              980 ; 57   |#define CMX     _complex            // cmxVarName
                              981 ; 58   |typedef WORD UCS3;                   // 
                              982 ; 59   |
                              983 ; 60   |#define UINT16  unsigned short
                              984 ; 61   |#define UINT8   unsigned char   
                              985 ; 62   |#define UINT32  unsigned long
                              986 ; 63   |#define UINT64  unsigned long   // need to figure out how to do 64 bit values.  Or port exisiting code to only use 48 bit
                              987 ; 64   |#define INT64   unsigned long   // need to figure out how to do 64 bit values.  Or port exisiting code to only use 48 bit
                              988 ; 65   |#define WCHAR   UINT16
                              989 ; 66   |
                              990 ; 67   |//UINT128 is 16 bytes or 6 words
                              991 ; 68   |typedef struct UINT128_3500 {   
                              992 ; 69   |    int val[6];     
                              993 ; 70   |} UINT128_3500;
                              994 ; 71   |
                              995 ; 72   |#define UINT128   UINT128_3500
                              996 ; 73   |
                              997 ; 74   |// Little endian word packed byte strings:   
                              998 ; 75   |//      _packed BYTE bTextVarName[]="a string";  bText is a packed byte string prefix
                              999 ; 76   |// Convert to big endian words by reordering bytes from high to low using swizzle.
                             1000 ; 77   |// Little endian word packed byte strings:   
                             1001 ; 78   |//      _packed BYTE bTextVarName[]="a string";  bText is a packed byte string prefix
                             1002 ; 79   |// Convert to big endian words by reordering bytes from high to low using swizzle.
                             1003 ; 80   |
                             1004 ; 81   |// Declare Memory Spaces To Use When Coding
                             1005 ; 82   |// A. Sector Buffers
                             1006 ; 83   |#define SECTOR_BUFFER_MEM_X _X
                             1007 ; 84   |#define SECTOR_BUFFER_MEM_Y _Y
                             1008 ; 85   |#define SECTOR_BUFFER_MEM SECTOR_BUFFER_MEM_X
                             1009 ; 86   |typedef WORD SECTOR_BUFFER_MEM SECTOR_BUFFER;
                             1010 ; 87   |typedef SECTOR_BUFFER * P_SECTOR_BUFFER;
                             1011 ; 88   |// B. Media DDI Memory
                             1012 ; 89   |#define MEDIA_DDI_MEM _Y
                             1013 ; 90   |
                             1014 ; 91   |
                             1015 ; 92   |
                             1016 ; 93   |// Pointers to linear structures are labeled as: p<type prefix>VarName
                             1017 ; 94   |// Examples of circular pointers:
                             1018 ; 95   |//    INT CIRC cpiVarName
                             1019 ; 96   |//    DWORD CIRC cpdwVarName
                             1020 ; 97   |
                             1021 ; 98   |#define RETCODE INT                 // rcVarName
                             1022 ; 99   |
                             1023 ; 100  |// generic bitfield structure
                             1024 ; 101  |struct Bitfield {
                             1025 ; 102  |    unsigned int B0  :1;
                             1026 ; 103  |    unsigned int B1  :1;
                             1027 ; 104  |    unsigned int B2  :1;
                             1028 ; 105  |    unsigned int B3  :1;
                             1029 ; 106  |    unsigned int B4  :1;
                             1030 ; 107  |    unsigned int B5  :1;
                             1031 ; 108  |    unsigned int B6  :1;
                             1032 ; 109  |    unsigned int B7  :1;
                             1033 ; 110  |    unsigned int B8  :1;
                             1034 ; 111  |    unsigned int B9  :1;
                             1035 ; 112  |    unsigned int B10 :1;
                             1036 ; 113  |    unsigned int B11 :1;
                             1037 ; 114  |    unsigned int B12 :1;
                             1038 ; 115  |    unsigned int B13 :1;
                             1039 ; 116  |    unsigned int B14 :1;
                             1040 ; 117  |    unsigned int B15 :1;
                             1041 ; 118  |    unsigned int B16 :1;
                             1042 ; 119  |    unsigned int B17 :1;
                             1043 ; 120  |    unsigned int B18 :1;
                             1044 ; 121  |    unsigned int B19 :1;
                             1045 ; 122  |    unsigned int B20 :1;
                             1046 ; 123  |    unsigned int B21 :1;
                             1047 ; 124  |    unsigned int B22 :1;
                             1048 ; 125  |    unsigned int B23 :1;
                             1049 ; 126  |};
                             1050 ; 127  |
                             1051 ; 128  |union BitInt {
TASKING DSP2410 assembler v1.5r1 Build 138 SN 00100122
                                                                                                                                                                                                                                                       Page   5

M:ADDR CODE           CYCLES LINE SOURCELINE
                             1052 ; 129  |        struct Bitfield B;
                             1053 ; 130  |        int        I;
                             1054 ; 131  |};
                             1055 ; 132  |
                             1056 ; 133  |#define MAX_MSG_LENGTH 10
                             1057 ; 134  |struct CMessage
                             1058 ; 135  |{
                             1059 ; 136  |        unsigned int m_uLength;
                             1060 ; 137  |        unsigned int m_uMsg[MAX_MSG_LENGTH];
                             1061 ; 138  |};
                             1062 ; 139  |
                             1063 ; 140  |typedef struct {
                             1064 ; 141  |    WORD m_wLength;
                             1065 ; 142  |    WORD m_wMessage;
                             1066 ; 143  |    WORD m_wParams[MAX_MSG_LENGTH];
                             1067 ; 144  |} Message;
                             1068 ; 145  |
                             1069 ; 146  |struct MessageQueueDescriptor
                             1070 ; 147  |{
                             1071 ; 148  |        int *m_pBase;
                             1072 ; 149  |        int m_iModulo;
                             1073 ; 150  |        int m_iSize;
                             1074 ; 151  |        int *m_pHead;
                             1075 ; 152  |        int *m_pTail;
                             1076 ; 153  |};
                             1077 ; 154  |
                             1078 ; 155  |struct ModuleEntry
                             1079 ; 156  |{
                             1080 ; 157  |    int m_iSignaledEventMask;
                             1081 ; 158  |    int m_iWaitEventMask;
                             1082 ; 159  |    int m_iResourceOfCode;
                             1083 ; 160  |    struct MessageQueueDescriptor *m_pMessageQueue;
                             1084 ; 161  |    int _asmfunc (*m_pProcessEntryPoint)(union WaitMask Signals,struct MessageQueueDescriptor *);
                             1085 ; 162  |    int _asmfunc (*m_pInitFunction)(struct MessageQueueDescriptor *);
                             1086 ; 163  |    int m_uTimeOutHigh;
                             1087 ; 164  |    int m_uTimeOutLow;
                             1088 ; 165  |    int _asmfunc (*m_pBackgroundFunction)(struct MessageQueueDescriptor *);
                             1089 ; 166  |};
                             1090 ; 167  |
                             1091 ; 168  |union WaitMask{
                             1092 ; 169  |    struct B{
                             1093 ; 170  |        unsigned int m_bNone     :1;
                             1094 ; 171  |        unsigned int m_bMessage  :1;
                             1095 ; 172  |        unsigned int m_bTimer    :1;
                             1096 ; 173  |        unsigned int m_bButton   :1;
                             1097 ; 174  |    } B;
                             1098 ; 175  |    int I;
                             1099 ; 176  |} ;
                             1100 ; 177  |
                             1101 ; 178  |
                             1102 ; 179  |struct Button {
                             1103 ; 180  |        WORD wButtonEvent;
                             1104 ; 181  |        WORD wUnused[MAX_MSG_LENGTH];   
                             1105 ; 182  |};
                             1106 ; 183  |
                             1107 ; 184  |struct Message {
                             1108 ; 185  |        WORD wMsgLength;
                             1109 ; 186  |        WORD wMsgCommand;
                             1110 ; 187  |        WORD wMsgParms[MAX_MSG_LENGTH-1];
                             1111 ; 188  |};
                             1112 ; 189  |
                             1113 ; 190  |union EventTypes {
                             1114 ; 191  |        struct CMessage msg;
                             1115 ; 192  |        struct Button Button ;
                             1116 ; 193  |        struct Message Message;
                             1117 ; 194  |};
                             1118 ; 195  |
                             1119 ; 196  |// next 2 used to get updater build to return correct protocol ver in scsi response.
                             1120 ; 197  |#define BUILD_TYPE_UPDATER  0x100
                             1121 ; 198  |#define BUILD_TYPE_HOSTLINK 0x101
                             1122 ; 199  |#define BUILD_TYPE_PLAYER   0x102
                             1123 ; 200  |
                             1124 ; 201  |// Resets part if RETAIL build. DEBUG build executes debug instruction to halt.
                             1125 ; 202  |#define SystemHalt() __asm(" include 'sysmacro.asm' \n error") 
                             1126 ; 203  |#define assert(x)    if(!(x)) __asm(" include 'sysmacro.asm' \n error")
                             1127 ; 204  |
                             1128 ; 205  |#if DEBUG
                             1129 ; 206  |// For DEBUG builds, DebugBuildAssert(condition) halts if condition evaluates to FALSE. 
                             1130 ; 207  |#define DebugBuildAssert(x)    if(!(x)) __asm(" debug ")
                             1131 ; 208  |#else 
                             1132 ; 209  |// For RETAIL builds, DebugBuildAssert(condition) does nothing & execution continues rather than halt or reset. 
                             1133 ; 210  |#define DebugBuildAssert(x)    
                             1134 ; 211  |#endif
                             1135 ; 212  |
                             1136 ; 213  |// Do this in your C files to make a reminder that's displayed during the build.
                             1137 ; 214  |//  #pragma asm
                             1138 ; 215  |//  WARN 'Note to builder: reminder to do this after verifying that'
                             1139 ; 216  |//  #pragma endasm
                             1140 ; 217  |
                             1141 ; 218  |
                             1142 ; 219  |#ifdef COLOR_262K
                             1143 ; 220  |#define RGB(r,g,b)    ((0x0000FC & (r)) << 10) | ((0x0000FC & (g)) << 4) | ((0x0000FC & (b)) >> 2)    //262k
                             1144 ; 221  |#elif defined(COLOR_65K)
                             1145 ; 222  |#define RGB(r,g,b)    ((0x0000F8 & (r)) << 8) | ((0x0000FC & (g)) << 3) | ((0x0000F8 & (b)) >> 3)  //65k
                             1146 ; 223  |#else
                             1147 ; 224  |#define RGB(r,g,b)       ((0x0000F0 & (r)) << 4) | (0x0000F0 & (g)) | ((0x0000F0 & (b)) >> 4)
                             1148 ; 225  |#endif
                             1149 ; 226  |    
                             1150 ; 227  |#endif // #ifndef _TYPES_H
                             1151 
                             1153 
                             1154 ; 31   |
                             1155 ; 32   |//;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                             1156 ; 33   |
                             1157 ; 34   |//   SWIZZLE STMP3500 Registers 
                             1158 ; 35   |//   Last Updated 7.11.2003 Dave Dyches
                             1159 ; 36   |//;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                             1160 ; 37   |
                             1161 ; 38   |
                             1162 ; 39   |
                             1163 ; 40   |
                             1164 ; 41   |
                             1165 ; 42   |#define HW_SWIZZLE_BASEADDR 0xF380
                             1166 ; 43   |
                             1167 ; 44   |
                             1168 ; 45   |
                             1169 ; 46   |////  Swizzle CSR1 (HW_SWIZZLECSR1) Bit Definitions
                             1170 ; 47   |#define HW_SWIZZLECSR1_EN_BITPOS (0)
                             1171 ; 48   |#define HW_SWIZZLECSR1_LA_BITPOS (1)
                             1172 ; 49   |#define HW_SWIZZLECSR1_LNR_BITPOS (2)
                             1173 ; 50   |#define HW_SWIZZLECSR1_SIGN_BITPOS (3)
                             1174 ; 51   |#define HW_SWIZZLECSR1_SHIFT_BITPOS (4)
                             1175 ; 52   |#define HW_SWIZZLECSR1_MEM_BITPOS (8)
                             1176 ; 53   |#define HW_SWIZZLECSR1_CLK_OFF_BITPOS (9)
                             1177 ; 54   |#define HW_SWIZZLECSR1_NEWADD_BITPOS (10)
                             1178 ; 55   |#define HW_SWIZZLECSR1_RSVD_BITPOS (11)
                             1179 ; 56   |
                             1180 ; 57   |#define HW_SWIZZLECSR1_EN_WIDTH (1)
                             1181 ; 58   |#define HW_SWIZZLECSR1_LA_WIDTH (1)
                             1182 ; 59   |#define HW_SWIZZLECSR1_LNR_WIDTH (1)
                             1183 ; 60   |#define HW_SWIZZLECSR1_SIGN_WIDTH (1)
                             1184 ; 61   |#define HW_SWIZZLECSR1_SHIFT_WIDTH (4)
                             1185 ; 62   |#define HW_SWIZZLECSR1_MEM_WIDTH (1)
                             1186 ; 63   |#define HW_SWIZZLECSR1_CLK_OFF_WIDTH (1)
                             1187 ; 64   |#define HW_SWIZZLECSR1_NEWADD_WIDTH (1)
                             1188 ; 65   |#define HW_SWIZZLECSR1_RSVD_WIDTH (13)
                             1189 ; 66   |
                             1190 ; 67   |#define HW_SWIZZLECSR1_EN_SETMASK (((1<HW_SWIZZLECSR1_EN_WIDTH)-1)<<HW_SWIZZLECSR1_EN_BITPOS)
                             1191 ; 68   |#define HW_SWIZZLECSR1_LA_SETMASK (((1<HW_SWIZZLECSR1_LA_WIDTH)-1)<<HW_SWIZZLECSR1_LA_BITPOS)
                             1192 ; 69   |#define HW_SWIZZLECSR1_LNR_SETMASK (((1<HW_SWIZZLECSR1_LNR_WIDTH)-1)<<HW_SWIZZLECSR1_LNR_BITPOS)
                             1193 ; 70   |#define HW_SWIZZLECSR1_SIGN_SETMASK (((1<HW_SWIZZLECSR1_SIGN_WIDTH)-1)<<HW_SWIZZLECSR1_SIGN_BITPOS)
                             1194 ; 71   |#define HW_SWIZZLECSR1_SHIFT_SETMASK (((1<HW_SWIZZLECSR1_SHIFT_WIDTH)-1)<<HW_SWIZZLECSR1_SHIFT_BITPOS)
                             1195 ; 72   |#define HW_SWIZZLECSR1_MEM_SETMASK (((1<HW_SWIZZLECSR1_MEM_WIDTH)-1)<<HW_SWIZZLECSR1_MEM_BITPOS)
                             1196 ; 73   |#define HW_SWIZZLECSR1_CLK_OFF_SETMASK (((1<HW_SWIZZLECSR1_CLK_OFF_WIDTH)-1)<<HW_SWIZZLECSR1_CLK_OFF_BITPOS)
                             1197 ; 74   |#define HW_SWIZZLECSR1_NEWADD_SETMASK (((1<HW_SWIZZLECSR1_NEWADD_WIDTH)-1)<<HW_SWIZZLECSR1_NEWADD_BITPOS)
                             1198 ; 75   |#define HW_SWIZZLECSR1_RSVD_SETMASK (((1<HW_SWIZZLECSR1_RSVD_WIDTH)-1)<<HW_SWIZZLECSR1_RSVD_BITPOS)
                             1199 ; 76   |
                             1200 ; 77   |#define HW_SWIZZLECSR1_EN_CLRMASK (~(WORD)HW_SWIZZLECSR1_EN_SETMASK)
                             1201 ; 78   |#define HW_SWIZZLECSR1_LA_CLRMASK (~(WORD)HW_SWIZZLECSR1_LA_SETMASK)
                             1202 ; 79   |#define HW_SWIZZLECSR1_LNR_CLRMASK (~(WORD)HW_SWIZZLECSR1_LNR_SETMASK)
                             1203 ; 80   |#define HW_SWIZZLECSR1_SIGN_CLRMASK (~(WORD)HW_SWIZZLECSR1_SIGN_SETMASK)
                             1204 ; 81   |#define HW_SWIZZLECSR1_SHIFT_CLRMASK (~(WORD)HW_SWIZZLECSR1_SHIFT_SETMASK)
                             1205 ; 82   |#define HW_SWIZZLECSR1_MEM_CLRMASK (~(WORD)HW_SWIZZLECSR1_MEM_SETMASK)
                             1206 ; 83   |#define HW_SWIZZLECSR1_CLK_OFF_CLRMASK (~(WORD)HW_SWIZZLECSR1_CLK_OFF_SETMASK)
                             1207 ; 84   |#define HW_SWIZZLECSR1_NEWADD_CLRMASK (~(WORD)HW_SWIZZLECSR1_NEWADD_SETMASK)
                             1208 ; 85   |#define HW_SWIZZLECSR1_RSVD_CLRMASK (~(WORD)HW_SWIZZLECSR1_RSVD_SETMASK)
                             1209 ; 86   |
                             1210 ; 87   |////////////////////////////////////////////////////////////////////////////////
                             1211 ; 88   |//  Bit Manipulation Unit Registers
                             1212 ; 89   |////////////////////////////////////////////////////////////////////////////////
                             1213 ; 90   |typedef union
                             1214 ; 91   |{
                             1215 ; 92   |    struct
                             1216 ; 93   |    {
                             1217 ; 94   |    int EN      :1;     /* Swizzle Enable                           */
                             1218 ; 95   |    int LA      :1;     /* Left Align Data                          */
                             1219 ; 96   |    int LNR     :1;     /* Left Barrel Shift                        */
                             1220 ; 97   |    int SIGN    :1;     /* Sign Extend Data                         */
                             1221 ; 98   |    unsigned SHIFT :4;          /* Number of positions to shift (0 to 23)   */
                             1222 ; 99   |    int MEM     :1;     /* Manipulate in Memory (not in registers)  */
                             1223 ; 100  |    int CLK_OFF :1;     /* Gate the Clock, Power Off                */
                             1224 ; 101  |    int NEWADD  :1;     /* Place the data into a new location       */     
                             1225 ; 102  |    } B;
                             1226 ; 103  |    int I;
                             1227 ; 104  |    unsigned U;
                             1228 ; 105  |} swizzlecsr1_type;
                             1229 ; 106  |////////////////////////////////////////////////////////////////////////////////
                             1230 ; 107  |#define HW_SWIZZLECS1R (*(volatile swizzlecsr1_type _X*) (HW_SWIZZLE_BASEADDR))       /* Swizzle Control & Status Register 1 */
                             1231 ; 108  |
                             1232 ; 109  |////  Swizzle CSR2 (HW_SWIZZLECSR2) Bit Definitions
                             1233 ; 110  |#define HW_SWIZZLECSR2_KICK_BITPOS (0)
                             1234 ; 111  |#define HW_SWIZZLECSR2_SASEL_BITPOS (1)
                             1235 ; 112  |#define HW_SWIZZLECSR2_DESASEL_BITPOS (3)
                             1236 ; 113  |#define HW_SWIZZLECSR2_BIGE_BITPOS (5)
                             1237 ; 114  |#define HW_SWIZZLECSR2_BITREV_BITPOS (6)
                             1238 ; 115  |#define HW_SWIZZLECSR2_PLSB_BITPOS (7)
                             1239 ; 116  |#define HW_SWIZZLECSR2_PISB_OFF_BITPOS (8)
                             1240 ; 117  |#define HW_SWIZZLECSR2_PMSB_BITPOS (9)
                             1241 ; 118  |#define HW_SWIZZLECSR2_P16L_BITPOS (10)
                             1242 ; 119  |#define HW_SWIZZLECSR2_P16I_BITPOS (11)
                             1243 ; 120  |#define HW_SWIZZLECSR2_BS_EN_BITPOS (12)
                             1244 ; 121  |#define HW_SWIZZLECSR2_SBYTEDEST_BITPOS (13)
                             1245 ; 122  |#define HW_SWIZZLECSR2_UNKICK_BITPOS (15)
                             1246 ; 123  |#define HW_SWIZZLECSR2_RSVD_BITPOS (16)
                             1247 ; 124  |
                             1248 ; 125  |#define HW_SWIZZLECSR2_KICK_WIDTH (1)
                             1249 ; 126  |#define HW_SWIZZLECSR2_SASEL_WIDTH (2)
                             1250 ; 127  |#define HW_SWIZZLECSR2_DESASEL_WIDTH (2)
                             1251 ; 128  |#define HW_SWIZZLECSR2_BIGE_WIDTH (1)
                             1252 ; 129  |#define HW_SWIZZLECSR2_BITREV_WIDTH (1)
                             1253 ; 130  |#define HW_SWIZZLECSR2_PLSB_WIDTH (1)
                             1254 ; 131  |#define HW_SWIZZLECSR2_PMSB_WIDTH (1)
                             1255 ; 132  |#define HW_SWIZZLECSR2_P16L_WIDTH (1)
                             1256 ; 133  |#define HW_SWIZZLECSR2_P16I_WIDTH (1)
                             1257 ; 134  |#define HW_SWIZZLECSR2_BS_EN_WIDTH (1)
                             1258 ; 135  |#define HW_SWIZZLECSR2_SBYTEDEST_WIDTH (2)
                             1259 ; 136  |#define HW_SWIZZLECSR2_UNKICK_WIDTH (1)
                             1260 ; 137  |#define HW_SWIZZLECSR2_RSVD_WIDTH (8)
                             1261 ; 138  |
                             1262 ; 139  |#define HW_SWIZZLECSR2_KICK_SETMASK (((1<HW_SWIZZLECSR2_KICK_WIDTH)-1)<<HW_SWIZZLECSR2_KICK_BITPOS)
                             1263 ; 140  |#define HW_SWIZZLECSR2_SASEL_SETMASK (((1<HW_SWIZZLECSR2_SASEL_WIDTH)-1)<<HW_SWIZZLECSR2_SASEL_BITPOS)
                             1264 ; 141  |#define HW_SWIZZLECSR2_DESASEL_SETMASK (((1<HW_SWIZZLECSR2_DESASEL_WIDTH)-1)<<HW_SWIZZLECSR2_DESASEL_BITPOS)
                             1265 ; 142  |#define HW_SWIZZLECSR2_BIGE_SETMASK (((1<HW_SWIZZLECSR2_BIGE_WIDTH)-1)<<HW_SWIZZLECSR2_BIGE_BITPOS)
                             1266 ; 143  |#define HW_SWIZZLECSR2_BITREV_SETMASK (((1<HW_SWIZZLECSR2_BITREV_WIDTH)-1)<<HW_SWIZZLECSR2_BITREV_BITPOS)
                             1267 ; 144  |#define HW_SWIZZLECSR2_PLSB_SETMASK (((1<HW_SWIZZLECSR2_PLSB_WIDTH)-1)<<HW_SWIZZLECSR2_PLSB_BITPOS)
                             1268 ; 145  |#define HW_SWIZZLECSR2_PMSB_SETMASK (((1<HW_SWIZZLECSR2_PMSB_WIDTH)-1)<<HW_SWIZZLECSR2_PMSB_BITPOS)
                             1269 ; 146  |#define HW_SWIZZLECSR2_P16L_SETMASK (((1<HW_SWIZZLECSR2_P16L_WIDTH)-1)<<HW_SWIZZLECSR2_P16L_BITPOS)
                             1270 ; 147  |#define HW_SWIZZLECSR2_P16I_SETMASK (((1<HW_SWIZZLECSR2_P16I_WIDTH)-1)<<HW_SWIZZLECSR2_P16I_BITPOS)
                             1271 ; 148  |#define HW_SWIZZLECSR2_BS_EN_SETMASK (((1<HW_SWIZZLECSR2_BS_EN_WIDTH)-1)<<HW_SWIZZLECSR2_BS_EN_BITPOS)
                             1272 ; 149  |#define HW_SWIZZLECSR2_SBYTEDEST_SETMASK (((1<HW_SWIZZLECSR2_SBYTEDEST_WIDTH)-1)<<HW_SWIZZLECSR2_SBYTEDEST_BITPOS)
                             1273 ; 150  |#define HW_SWIZZLECSR2_UNKICK_SETMASK (((1<HW_SWIZZLECSR2_UNKICK_WIDTH)-1)<<HW_SWIZZLECSR2_UNKICK_BITPOS)
                             1274 ; 151  |#define HW_SWIZZLECSR2_RSVD_SETMASK (((1<HW_SWIZZLECSR2_RSVD_WIDTH)-1)<<HW_SWIZZLECSR2_RSVD_BITPOS)
                             1275 ; 152  |
                             1276 ; 153  |#define HW_SWIZZLECSR2_KICK_CLRMASK (~(WORD)HW_SWIZZLECSR2_KICK_SETMASK)
                             1277 ; 154  |#define HW_SWIZZLECSR2_SASEL_CLRMASK (~(WORD)HW_SWIZZLECSR2_SASEL_SETMASK)
                             1278 ; 155  |#define HW_SWIZZLECSR2_DESASEL_CLRMASK (~(WORD)HW_SWIZZLECSR2_DESASEL_SETMASK)
                             1279 ; 156  |#define HW_SWIZZLECSR2_BIGE_CLRMASK (~(WORD)HW_SWIZZLECSR2_BIGE_SETMASK)
                             1280 ; 157  |#define HW_SWIZZLECSR2_BITREV_CLRMASK (~(WORD)HW_SWIZZLECSR2_BITREV_SETMASK)
                             1281 ; 158  |#define HW_SWIZZLECSR2_PLSB_CLRMASK (~(WORD)HW_SWIZZLECSR2_PLSB_SETMASK)
                             1282 ; 159  |#define HW_SWIZZLECSR2_PMSB_CLRMASK (~(WORD)HW_SWIZZLECSR2_PMSB_SETMASK)
                             1283 ; 160  |#define HW_SWIZZLECSR2_P16L_CLRMASK (~(WORD)HW_SWIZZLECSR2_P16L_SETMASK)
                             1284 ; 161  |#define HW_SWIZZLECSR2_P16I_CLRMASK (~(WORD)HW_SWIZZLECSR2_P16I_SETMASK)
                             1285 ; 162  |#define HW_SWIZZLECSR2_BS_EN_CLRMASK (~(WORD)HW_SWIZZLECSR2_BS_EN_SETMASK)
                             1286 ; 163  |#define HW_SWIZZLECSR2_SBYTEDEST_CLRMASK (~(WORD)HW_SWIZZLECSR2_SBYTEDEST_SETMASK)
                             1287 ; 164  |#define HW_SWIZZLECSR2_UNKICK_CLRMASK (~(WORD)HW_SWIZZLECSR2_UNKICK_SETMASK)
                             1288 ; 165  |#define HW_SWIZZLECSR2_RSVD_CLRMASK (~(WORD)HW_SWIZZLECSR2_RSVD_SETMASK)
                             1289 ; 166  |
                             1290 ; 167  |///////////////////////////////////////////////////////////////////////////////
                             1291 ; 168  |typedef union
                             1292 ; 169  |{
                             1293 ; 170  |    struct
                             1294 ; 171  |    {
                             1295 ; 172  |    int KICK    :1;         /* Start transfer                      */
                             1296 ; 173  |    unsigned SASEL :2;              /* Source memory Select                */
                             1297 ; 174  |    unsigned DESASEL :2;                    /* Destination memory Select           */
                             1298 ; 175  |    int BIGE        :1;             /* Big Endian Enable                   */
                             1299 ; 176  |    int BITREV      :1;     /* Bit reverse the data                */
                             1300 ; 177  |    int PLSB        :1;             /* Pass Least Significant Byte         */
                             1301 ; 178  |    int PISB        :1;     /* Pass Intermediate Byte              */
                             1302 ; 179  |    int PMSB        :1;     /* Pass Most Significant Byte          */
                             1303 ; 180  |    int P16L        :1;     /* Pass Least Significant word         */
TASKING DSP2410 assembler v1.5r1 Build 138 SN 00100122
                                                                                                                                                                                                                                                       Page   6

M:ADDR CODE           CYCLES LINE SOURCELINE
                             1304 ; 181  |    int P16I        :1;     /* Pass Intermediate significant word  */
                             1305 ; 182  |    int BS_EN       :1;     /* Barrel Shift Enable                 */
                             1306 ; 183  |    unsigned SBYTE  :2;                     /* Start byte                          */
                             1307 ; 184  |    int UNKICK      :1;     /* Halt transfer                       */  
                             1308 ; 185  |    } B;
                             1309 ; 186  |    unsigned int I;
                             1310 ; 187  |    unsigned int U;
                             1311 ; 188  |} swizzlecsr2_type;
                             1312 ; 189  |///////////////////////////////////////////////////////////////////////////////
                             1313 ; 190  |#define HW_SWIZZLECS2R (*(volatile swizzlecsr2_type _X*) (HW_SWIZZLE_BASEADDR+1))     /* Swizzle Control & Status Register 2 */
                             1314 ; 191  |
                             1315 ; 192  |////  Swizzle SIZER (HW_SWIZZLESIZER) Bit Definitions
                             1316 ; 193  |#define HW_SWIZZLESIZER_SIZE_BITPOS (0)
                             1317 ; 194  |#define HW_SWIZZLESIZER_NEW_SHIFT_BITPOS (16)
                             1318 ; 195  |#define HW_SWIZZLESIZER_RSVD_BITPOS (21)
                             1319 ; 196  |
                             1320 ; 197  |#define HW_SWIZZLESIZER_SIZE_WIDTH (16)
                             1321 ; 198  |#define HW_SWIZZLESIZER_NEW_SHIFT_WIDTH (5)
                             1322 ; 199  |#define HW_SWIZZLESIZER_RSVD_WIDTH (3)
                             1323 ; 200  |
                             1324 ; 201  |#define HW_SWIZZLESIZER_SIZE_SETMASK (((1<HW_SWIZZLESIZER_SIZE_WIDTH)-1)<<HW_SWIZZLESIZER_SIZE_BITPOS)
                             1325 ; 202  |#define HW_SWIZZLESIZER_NEW_SHIFT_SETMASK (((1<HW_SWIZZLESIZER_NEW_SHIFT_WIDTH)-1)<<HW_SWIZZLESIZER_NEW_SHIFT_BITPOS)
                             1326 ; 203  |#define HW_SWIZZLESIZER_RSVD_SETMASK (((1<HW_SWIZZLESIZER_RSVD_WIDTH)-1)<<HW_SWIZZLESIZER_RSVD_BITPOS)
                             1327 ; 204  |
                             1328 ; 205  |#define HW_SWIZZLESIZER_SIZE_CLRMASK (~(WORD)HW_SWIZZLESIZER_SIZE_SETMASK)
                             1329 ; 206  |#define HW_SWIZZLESIZER_NEW_SHIFT_CLRMASK (~(WORD)HW_SWIZZLESIZER_NEW_SHIFT_SETMASK)
                             1330 ; 207  |#define HW_SWIZZLESIZER_RSVD_CLRMASK (~(WORD)HW_SWIZZLESIZER_RSVD_SETMASK)
                             1331 ; 208  |
                             1332 ; 209  |///////////////////////////////////////////////////////////////////////////////
                             1333 ; 210  |typedef union
                             1334 ; 211  |{
                             1335 ; 212  |    struct
                             1336 ; 213  |    {
                             1337 ; 214  |    unsigned SIZE      :16;        /* Number of memory words to manipulate */
                             1338 ; 215  |    unsigned NEW_SHIFT :5;         /* Source memory Select                 */
                             1339 ; 216  |    } B;
                             1340 ; 217  |    int I;
                             1341 ; 218  |    unsigned U;
                             1342 ; 219  |} swizzlesizer_type;
                             1343 ; 220  |///////////////////////////////////////////////////////////////////////////////
                             1344 ; 221  |#define HW_SWIZZLESIZER (*(volatile swizzlesizer_type _X*) (HW_SWIZZLE_BASEADDR+2))        /* Swizzle Transfer Size Register */
                             1345 ; 222  |#define HW_SWIZZLESOURCER (*(volatile unsigned int _X*) (HW_SWIZZLE_BASEADDR+3))      /* Swizzle Source Address Register */
                             1346 ; 223  |#define HW_SWIZZLEDATA1R (*(volatile unsigned int _X*) (HW_SWIZZLE_BASEADDR+4))       /* Swizzle Data1 Register */
                             1347 ; 224  |#define HW_SWIZZLEDATA2R (*(volatile unsigned int _X*) (HW_SWIZZLE_BASEADDR+5))       /* Swizzle Data2 Register */
                             1348 ; 225  |#define HW_SWIZZLEDESTADDRR (*(volatile unsigned int _X*) (HW_SWIZZLE_BASEADDR+6))    /* Swizzle Destination Address Register */
                             1349 ; 226  |#define HW_SWIZZLEBIGENDIANR (*(volatile unsigned int _X*) (HW_SWIZZLE_BASEADDR+7))   /* Swizzle Big Endian Register */
                             1350 ; 227  |#define HW_SWIZZLEBITREVR (*(volatile unsigned int _X*) (HW_SWIZZLE_BASEADDR+8))      /* Swizzle BITREV Register */
                             1351 ; 228  |#define HW_SWIZZLEPASSLSBR (*(volatile unsigned int _X*) (HW_SWIZZLE_BASEADDR+9))     /* Swizzle Pass Least Significant Byte Register */
                             1352 ; 229  |#define HW_SWIZZLEPASSISBR (*(volatile unsigned int _X*) (HW_SWIZZLE_BASEADDR+10))    /* Swizzle Pass Intermediate Byte Register */
                             1353 ; 230  |#define HW_SWIZZLEPASSMSBR (*(volatile unsigned int _X*) (HW_SWIZZLE_BASEADDR+11))    /* Swizzle Pass Most Significant Byte Register */
                             1354 ; 231  |#define HW_SWIZZLEPASSLSWR (*(volatile unsigned int _X*) (HW_SWIZZLE_BASEADDR+12))    /* Swizzle Pass Least Significant Word Register */
                             1355 ; 232  |#define HW_SWIZZLEPASSISWR (*(volatile unsigned int _X*) (HW_SWIZZLE_BASEADDR+13))    /* Swizzle Pass Intermediate Significant Word Register */
                             1356 ; 233  |#define HW_SWIZZLEPASSMSWR (*(volatile unsigned int _X*) (HW_SWIZZLE_BASEADDR+14))    /* Swizzle Pass Most Significant Word Register */
                             1357 ; 234  |#define HW_SWIZZLEBARRELR (*(volatile unsigned int _X*) (HW_SWIZZLE_BASEADDR+15))    /* Swizzle Barrel Shift Register */
                             1358 ; 235  |#define HW_SWIZZLEDIV3LR (*(volatile unsigned int _X*) (HW_SWIZZLE_BASEADDR+16))    /* Swizzle Divide By 3 Lower Register */
                             1359 ; 236  |
                             1360 ; 237  |
                             1361 ; 238  |////  Swizzle DIV3UR (HW_SWIZZLEDIV3UR) Bit Definitions
                             1362 ; 239  |#define HW_SWIZZLEDIV3UR_DIV3_UPPER_BITPOS (0)
                             1363 ; 240  |#define HW_SWIZZLEDIV3UR_RSVD0_BITPOS (8)
                             1364 ; 241  |#define HW_SWIZZLEDIV3UR_REMAINDER_BITPOS (20)
                             1365 ; 242  |#define HW_SWIZZLEDIV3UR_RSVD1_BITPOS (22)
                             1366 ; 243  |
                             1367 ; 244  |#define HW_SWIZZLEDIV3UR_DIV3_UPPER_WIDTH (8)
                             1368 ; 245  |#define HW_SWIZZLEDIV3UR_RSVD0_WIDTH (12)
                             1369 ; 246  |#define HW_SWIZZLEDIV3UR_REMAINDER_WIDTH (2)
                             1370 ; 247  |#define HW_SWIZZLEDIV3UR_RSVD1_WIDTH (2)
                             1371 ; 248  |
                             1372 ; 249  |#define HW_SWIZZLEDIV3UR_DIV3_UPPER_SETMASK (((1<HW_SWIZZLEDIV3UR_DIV3_UPPER_WIDTH)-1)<<HW_SWIZZLEDIV3UR_DIV3_UPPER_BITPOS)
                             1373 ; 250  |#define HW_SWIZZLEDIV3UR_RSVD0_SETMASK (((1<HW_SWIZZLEDIV3UR_RSVD0_WIDTH)-1)<<HW_SWIZZLEDIV3UR_RSVD0_BITPOS)
                             1374 ; 251  |#define HW_SWIZZLEDIV3UR_REMAINDER_SETMASK (((1<HW_SWIZZLEDIV3UR_REMAINDER_WIDTH)-1)<<HW_SWIZZLEDIV3UR_REMAINDER_BITPOS)
                             1375 ; 252  |#define HW_SWIZZLEDIV3UR_RSVD1_SETMASK (((1<HW_SWIZZLEDIV3UR_RSVD1_WIDTH)-1)<<HW_SWIZZLEDIV3UR_RSVD1_BITPOS)
                             1376 ; 253  |
                             1377 ; 254  |#define HW_SWIZZLEDIV3UR_DIV3_UPPER_CLRMASK (~(WORD)HW_SWIZZLEDIV3UR_DIV3_UPPER_SETMASK)
                             1378 ; 255  |#define HW_SWIZZLEDIV3UR_RSVD0_CLRMASK (~(WORD)HW_SWIZZLEDIV3UR_RSVD0_SETMASK)
                             1379 ; 256  |#define HW_SWIZZLEDIV3UR_REMAINDER_CLRMASK (~(WORD)HW_SWIZZLEDIV3UR_REMAINDER_SETMASK)
                             1380 ; 257  |#define HW_SWIZZLEDIV3UR_RSVD1_CLRMASK (~(WORD)HW_SWIZZLEDIV3UR_RSVD1_SETMASK)
                             1381 ; 258  |
                             1382 ; 259  |///////////////////////////////////////////////////////////////////////////////
                             1383 ; 260  |typedef union
                             1384 ; 261  |{
                             1385 ; 262  |    struct
                             1386 ; 263  |    {
                             1387 ; 264  |    unsigned DIV3_UPPER    :8;     /* Number of memory words to manipulate */
                             1388 ; 265  |    unsigned RSVD0         :12;         /* Source memory Select                 */
                             1389 ; 266  |    unsigned REMAINDER     :2;         /* Source memory Select                 */
                             1390 ; 267  |    } B;
                             1391 ; 268  |    int I;
                             1392 ; 269  |    unsigned U;
                             1393 ; 270  |} swizzlediv3ur_type;
                             1394 ; 271  |///////////////////////////////////////////////////////////////////////////////
                             1395 ; 272  |#define HW_SWIZZLEDIV3UR (*(volatile swizzlediv3ur_type _X*) (HW_SWIZZLE_BASEADDR+17))    /* Swizzle Divide By 3 Upper Register */
                             1396 ; 273  |
                             1397 ; 274  |#endif
                             1398 ; 275  |
                             1399 
                             1401 
                             1402 ; 16   |#include "fatutils.h"
                             1403 
                             1405 
                             1406 ; 1    |////////////////////////////////////////////////////////////////////////////////
                             1407 ; 2    |// Copyright(C) SigmaTel, Inc. 2000-2004
                             1408 ; 3    |//
                             1409 ; 4    |// Filename: Fattest.h
                             1410 ; 5    |// Description: 
                             1411 ; 6    |////////////////////////////////////////////////////////////////////////////////
                             1412 ; 7    |
                             1413 ; 8    |#ifndef _CHKDSK_FATUTILS_H
                             1414 ; 9    |#define _CHKDSK_FATUTILS_H
                             1415 ; 10   |
                             1416 ; 11   |BOOL _reentrant LoadFatSector(DWORD wSect, WORD _X *pwBuffer);
                             1417 ; 12   |BOOL _reentrant WriteFatSector(DWORD wSect, WORD _X *pwBuffer);
                             1418 ; 13   |BOOL _reentrant IsLastCx(DWORD wCluster);
                             1419 ; 14   |LONG _reentrant GetNextCx(DWORD wCurCx);
                             1420 ; 15   |LONG _reentrant GetNextCxFat12(DWORD wCurCx);
                             1421 ; 16   |LONG _reentrant GetNextCxFat16(DWORD wCurCx);
                             1422 ; 17   |LONG _reentrant GetNextCxFat32(DWORD wCurCx);
                             1423 ; 18   |
                             1424 ; 19   |LONG _reentrant FetchCxFat12(DWORD wCurCx);
                             1425 ; 20   |LONG _reentrant GetLengthCxChain(DWORD wCluster);
                             1426 ; 21   |BOOL _reentrant FreeCxFat(DWORD wCluster);
                             1427 ; 22   |extern BOOL _reentrant FreeCxFat12(DWORD wCluster);
                             1428 ; 23   |BOOL _reentrant FreeCxFat16(DWORD wCluster);
                             1429 ; 24   |extern BOOL _reentrant FreeCxFat32(DWORD wCluster);
                             1430 ; 25   |DWORD _reentrant Getsectorno(DWORD wCluster);
                             1431 ; 26   |WORD SearchmatchingSector(LONG sectorNumber,INT MAXCACHES, tCACHEDESCR_checkdisk *CacheDesc_chkdsk);
                             1432 
                             1439 
                             1440 ; 27   |   
                             1441 ; 28   |#endif 
                             1442 ; 29   |
                             1443 ; 30   |
                             1444 
                             1446 
                             1447 ; 17   |#include "cwrapfunc.h"
                             1448 
                             1450 
                             1451 ; 1    |////////////////////////////////////////////////////////////////////////////////
                             1452 ; 2    |// Copyright(C) SigmaTel, Inc. 2000-2004
                             1453 ; 3    |//
                             1454 ; 4    |// Filename: cwrapfunc.h
                             1455 ; 5    |// Description: 
                             1456 ; 6    |////////////////////////////////////////////////////////////////////////////////
                             1457 ; 7    |
                             1458 ; 8    |#ifndef _CHKDSK_CWRAPFUNC_H
                             1459 ; 9    |#define _CHKDSK_CWRAPFUNC_H
                             1460 ; 10   |
                             1461 ; 11   |#include "types.h"
                             1462 
                             1464 
                             1465 ; 1    |////////////////////////////////////////////////////////////////////////////////
                             1466 ; 2    |// Copyright(C) SigmaTel, Inc. 2000-2004
                             1467 ; 3    |//
                             1468 ; 4    |// Filename: types.h
                             1469 ; 5    |// Description: Standard data types
                             1470 ; 6    |////////////////////////////////////////////////////////////////////////////////
                             1471 ; 7    |
                             1472 ; 8    |#ifndef _TYPES_H
                             1473 ; 9    |#define _TYPES_H
                             1474 ; 10   |
                             1475 ; 11   |// TODO:  move this outta here!
                             1476 ; 12   |#if !defined(NOERROR)
                             1477 ; 13   |#define NOERROR 0
                             1478 ; 14   |#define SUCCESS 0
                             1479 ; 15   |#endif 
                             1480 ; 16   |#if !defined(SUCCESS)
                             1481 ; 17   |#define SUCCESS  0
                             1482 ; 18   |#endif
                             1483 ; 19   |#if !defined(ERROR)
                             1484 ; 20   |#define ERROR   -1
                             1485 ; 21   |#endif
                             1486 ; 22   |#if !defined(FALSE)
                             1487 ; 23   |#define FALSE 0
                             1488 ; 24   |#endif
                             1489 ; 25   |#if !defined(TRUE)
                             1490 ; 26   |#define TRUE  1
                             1491 ; 27   |#endif
                             1492 ; 28   |
                             1493 ; 29   |#if !defined(NULL)
                             1494 ; 30   |#define NULL 0
                             1495 ; 31   |#endif
                             1496 ; 32   |
                             1497 ; 33   |#define MAX_INT     0x7FFFFF
                             1498 ; 34   |#define MAX_LONG    0x7FFFFFffffff
                             1499 ; 35   |        // max positive unsigned long value: -1 == 0xFFFFFFffffff
                             1500 ; 36   |#define MAX_ULONG   (-1) 
                             1501 ; 37   |
                             1502 ; 38   |#define WORD_SIZE   24              // word size in bits
                             1503 ; 39   |#define BYTES_PER_WORD 3            // 8 bit bytes
                             1504 ; 40   |
                             1505 ; 41   |
                             1506 ; 42   |#define BYTE    unsigned char       // btVarName
                             1507 ; 43   |#define CHAR    signed char         // cVarName
                             1508 ; 44   |#define USHORT  unsigned short      // usVarName
                             1509 ; 45   |#define SHORT   unsigned short      // sVarName
                             1510 ; 46   |#define WORD    unsigned int        // wVarName
                             1511 ; 47   |#define INT     signed int          // iVarName
                             1512 ; 48   |#define DWORD   unsigned long       // dwVarName
                             1513 ; 49   |#define LONG    signed long         // lVarName
                             1514 ; 50   |#define BOOL    unsigned int        // bVarName
                             1515 ; 51   |#define FRACT   _fract              // frVarName
                             1516 ; 52   |#define LFRACT  long _fract         // lfrVarName
                             1517 ; 53   |#define CIRC    _circ               // cp<type prefix>VarName (see below)
                             1518 ; 54   |#define FLOAT   float               // fVarName
                             1519 ; 55   |#define DBL     double              // dVarName
                             1520 ; 56   |#define ENUM    enum                // eVarName
                             1521 ; 57   |#define CMX     _complex            // cmxVarName
                             1522 ; 58   |typedef WORD UCS3;                   // 
                             1523 ; 59   |
                             1524 ; 60   |#define UINT16  unsigned short
                             1525 ; 61   |#define UINT8   unsigned char   
                             1526 ; 62   |#define UINT32  unsigned long
                             1527 ; 63   |#define UINT64  unsigned long   // need to figure out how to do 64 bit values.  Or port exisiting code to only use 48 bit
                             1528 ; 64   |#define INT64   unsigned long   // need to figure out how to do 64 bit values.  Or port exisiting code to only use 48 bit
                             1529 ; 65   |#define WCHAR   UINT16
                             1530 ; 66   |
                             1531 ; 67   |//UINT128 is 16 bytes or 6 words
                             1532 ; 68   |typedef struct UINT128_3500 {   
                             1533 ; 69   |    int val[6];     
                             1534 ; 70   |} UINT128_3500;
                             1535 ; 71   |
                             1536 ; 72   |#define UINT128   UINT128_3500
                             1537 ; 73   |
                             1538 ; 74   |// Little endian word packed byte strings:   
                             1539 ; 75   |//      _packed BYTE bTextVarName[]="a string";  bText is a packed byte string prefix
                             1540 ; 76   |// Convert to big endian words by reordering bytes from high to low using swizzle.
                             1541 ; 77   |// Little endian word packed byte strings:   
                             1542 ; 78   |//      _packed BYTE bTextVarName[]="a string";  bText is a packed byte string prefix
                             1543 ; 79   |// Convert to big endian words by reordering bytes from high to low using swizzle.
                             1544 ; 80   |
                             1545 ; 81   |// Declare Memory Spaces To Use When Coding
                             1546 ; 82   |// A. Sector Buffers
                             1547 ; 83   |#define SECTOR_BUFFER_MEM_X _X
                             1548 ; 84   |#define SECTOR_BUFFER_MEM_Y _Y
                             1549 ; 85   |#define SECTOR_BUFFER_MEM SECTOR_BUFFER_MEM_X
                             1550 ; 86   |typedef WORD SECTOR_BUFFER_MEM SECTOR_BUFFER;
                             1551 ; 87   |typedef SECTOR_BUFFER * P_SECTOR_BUFFER;
                             1552 ; 88   |// B. Media DDI Memory
                             1553 ; 89   |#define MEDIA_DDI_MEM _Y
                             1554 ; 90   |
                             1555 ; 91   |
                             1556 ; 92   |
                             1557 ; 93   |// Pointers to linear structures are labeled as: p<type prefix>VarName
                             1558 ; 94   |// Examples of circular pointers:
                             1559 ; 95   |//    INT CIRC cpiVarName
                             1560 ; 96   |//    DWORD CIRC cpdwVarName
                             1561 ; 97   |
                             1562 ; 98   |#define RETCODE INT                 // rcVarName
                             1563 ; 99   |
                             1564 ; 100  |// generic bitfield structure
                             1565 ; 101  |struct Bitfield {
TASKING DSP2410 assembler v1.5r1 Build 138 SN 00100122
                                                                                                                                                                                                                                                       Page   7

M:ADDR CODE           CYCLES LINE SOURCELINE
                             1566 ; 102  |    unsigned int B0  :1;
                             1567 ; 103  |    unsigned int B1  :1;
                             1568 ; 104  |    unsigned int B2  :1;
                             1569 ; 105  |    unsigned int B3  :1;
                             1570 ; 106  |    unsigned int B4  :1;
                             1571 ; 107  |    unsigned int B5  :1;
                             1572 ; 108  |    unsigned int B6  :1;
                             1573 ; 109  |    unsigned int B7  :1;
                             1574 ; 110  |    unsigned int B8  :1;
                             1575 ; 111  |    unsigned int B9  :1;
                             1576 ; 112  |    unsigned int B10 :1;
                             1577 ; 113  |    unsigned int B11 :1;
                             1578 ; 114  |    unsigned int B12 :1;
                             1579 ; 115  |    unsigned int B13 :1;
                             1580 ; 116  |    unsigned int B14 :1;
                             1581 ; 117  |    unsigned int B15 :1;
                             1582 ; 118  |    unsigned int B16 :1;
                             1583 ; 119  |    unsigned int B17 :1;
                             1584 ; 120  |    unsigned int B18 :1;
                             1585 ; 121  |    unsigned int B19 :1;
                             1586 ; 122  |    unsigned int B20 :1;
                             1587 ; 123  |    unsigned int B21 :1;
                             1588 ; 124  |    unsigned int B22 :1;
                             1589 ; 125  |    unsigned int B23 :1;
                             1590 ; 126  |};
                             1591 ; 127  |
                             1592 ; 128  |union BitInt {
                             1593 ; 129  |        struct Bitfield B;
                             1594 ; 130  |        int        I;
                             1595 ; 131  |};
                             1596 ; 132  |
                             1597 ; 133  |#define MAX_MSG_LENGTH 10
                             1598 ; 134  |struct CMessage
                             1599 ; 135  |{
                             1600 ; 136  |        unsigned int m_uLength;
                             1601 ; 137  |        unsigned int m_uMsg[MAX_MSG_LENGTH];
                             1602 ; 138  |};
                             1603 ; 139  |
                             1604 ; 140  |typedef struct {
                             1605 ; 141  |    WORD m_wLength;
                             1606 ; 142  |    WORD m_wMessage;
                             1607 ; 143  |    WORD m_wParams[MAX_MSG_LENGTH];
                             1608 ; 144  |} Message;
                             1609 ; 145  |
                             1610 ; 146  |struct MessageQueueDescriptor
                             1611 ; 147  |{
                             1612 ; 148  |        int *m_pBase;
                             1613 ; 149  |        int m_iModulo;
                             1614 ; 150  |        int m_iSize;
                             1615 ; 151  |        int *m_pHead;
                             1616 ; 152  |        int *m_pTail;
                             1617 ; 153  |};
                             1618 ; 154  |
                             1619 ; 155  |struct ModuleEntry
                             1620 ; 156  |{
                             1621 ; 157  |    int m_iSignaledEventMask;
                             1622 ; 158  |    int m_iWaitEventMask;
                             1623 ; 159  |    int m_iResourceOfCode;
                             1624 ; 160  |    struct MessageQueueDescriptor *m_pMessageQueue;
                             1625 ; 161  |    int _asmfunc (*m_pProcessEntryPoint)(union WaitMask Signals,struct MessageQueueDescriptor *);
                             1626 ; 162  |    int _asmfunc (*m_pInitFunction)(struct MessageQueueDescriptor *);
                             1627 ; 163  |    int m_uTimeOutHigh;
                             1628 ; 164  |    int m_uTimeOutLow;
                             1629 ; 165  |    int _asmfunc (*m_pBackgroundFunction)(struct MessageQueueDescriptor *);
                             1630 ; 166  |};
                             1631 ; 167  |
                             1632 ; 168  |union WaitMask{
                             1633 ; 169  |    struct B{
                             1634 ; 170  |        unsigned int m_bNone     :1;
                             1635 ; 171  |        unsigned int m_bMessage  :1;
                             1636 ; 172  |        unsigned int m_bTimer    :1;
                             1637 ; 173  |        unsigned int m_bButton   :1;
                             1638 ; 174  |    } B;
                             1639 ; 175  |    int I;
                             1640 ; 176  |} ;
                             1641 ; 177  |
                             1642 ; 178  |
                             1643 ; 179  |struct Button {
                             1644 ; 180  |        WORD wButtonEvent;
                             1645 ; 181  |        WORD wUnused[MAX_MSG_LENGTH];   
                             1646 ; 182  |};
                             1647 ; 183  |
                             1648 ; 184  |struct Message {
                             1649 ; 185  |        WORD wMsgLength;
                             1650 ; 186  |        WORD wMsgCommand;
                             1651 ; 187  |        WORD wMsgParms[MAX_MSG_LENGTH-1];
                             1652 ; 188  |};
                             1653 ; 189  |
                             1654 ; 190  |union EventTypes {
                             1655 ; 191  |        struct CMessage msg;
                             1656 ; 192  |        struct Button Button ;
                             1657 ; 193  |        struct Message Message;
                             1658 ; 194  |};
                             1659 ; 195  |
                             1660 ; 196  |// next 2 used to get updater build to return correct protocol ver in scsi response.
                             1661 ; 197  |#define BUILD_TYPE_UPDATER  0x100
                             1662 ; 198  |#define BUILD_TYPE_HOSTLINK 0x101
                             1663 ; 199  |#define BUILD_TYPE_PLAYER   0x102
                             1664 ; 200  |
                             1665 ; 201  |// Resets part if RETAIL build. DEBUG build executes debug instruction to halt.
                             1666 ; 202  |#define SystemHalt() __asm(" include 'sysmacro.asm' \n error") 
                             1667 ; 203  |#define assert(x)    if(!(x)) __asm(" include 'sysmacro.asm' \n error")
                             1668 ; 204  |
                             1669 ; 205  |#if DEBUG
                             1670 ; 206  |// For DEBUG builds, DebugBuildAssert(condition) halts if condition evaluates to FALSE. 
                             1671 ; 207  |#define DebugBuildAssert(x)    if(!(x)) __asm(" debug ")
                             1672 ; 208  |#else 
                             1673 ; 209  |// For RETAIL builds, DebugBuildAssert(condition) does nothing & execution continues rather than halt or reset. 
                             1674 ; 210  |#define DebugBuildAssert(x)    
                             1675 ; 211  |#endif
                             1676 ; 212  |
                             1677 ; 213  |// Do this in your C files to make a reminder that's displayed during the build.
                             1678 ; 214  |//  #pragma asm
                             1679 ; 215  |//  WARN 'Note to builder: reminder to do this after verifying that'
                             1680 ; 216  |//  #pragma endasm
                             1681 ; 217  |
                             1682 ; 218  |
                             1683 ; 219  |#ifdef COLOR_262K
                             1684 ; 220  |#define RGB(r,g,b)    ((0x0000FC & (r)) << 10) | ((0x0000FC & (g)) << 4) | ((0x0000FC & (b)) >> 2)    //262k
                             1685 ; 221  |#elif defined(COLOR_65K)
                             1686 ; 222  |#define RGB(r,g,b)    ((0x0000F8 & (r)) << 8) | ((0x0000FC & (g)) << 3) | ((0x0000F8 & (b)) >> 3)  //65k
                             1687 ; 223  |#else
                             1688 ; 224  |#define RGB(r,g,b)       ((0x0000F0 & (r)) << 4) | (0x0000F0 & (g)) | ((0x0000F0 & (b)) >> 4)
                             1689 ; 225  |#endif
                             1690 ; 226  |    
                             1691 ; 227  |#endif // #ifndef _TYPES_H
                             1692 
                             1694 
                             1695 ; 12   |
                             1696 ; 13   |_asmfunc void SetupSwizzleAddrXY(WORD _X *pwSource, WORD _Y *pwDest);
                             1697 ; 14   |_asmfunc void SetupSwizzleAddrYX(WORD _Y *pwSource, WORD _X *pwDest);
                             1698 ; 15   |
                             1699 ; 16   |#endif 
                             1700 
                             1702 
                             1703 ; 18   |#include "extern.h"
                             1704 
                             1706 
                             1707 ; 1    |#include "handletable.h"
                             1708 
                             1710 
                             1711 ; 1    |#include "types.h"
                             1712 
                             1714 
                             1715 ; 1    |////////////////////////////////////////////////////////////////////////////////
                             1716 ; 2    |// Copyright(C) SigmaTel, Inc. 2000-2004
                             1717 ; 3    |//
                             1718 ; 4    |// Filename: types.h
                             1719 ; 5    |// Description: Standard data types
                             1720 ; 6    |////////////////////////////////////////////////////////////////////////////////
                             1721 ; 7    |
                             1722 ; 8    |#ifndef _TYPES_H
                             1723 ; 9    |#define _TYPES_H
                             1724 ; 10   |
                             1725 ; 11   |// TODO:  move this outta here!
                             1726 ; 12   |#if !defined(NOERROR)
                             1727 ; 13   |#define NOERROR 0
                             1728 ; 14   |#define SUCCESS 0
                             1729 ; 15   |#endif 
                             1730 ; 16   |#if !defined(SUCCESS)
                             1731 ; 17   |#define SUCCESS  0
                             1732 ; 18   |#endif
                             1733 ; 19   |#if !defined(ERROR)
                             1734 ; 20   |#define ERROR   -1
                             1735 ; 21   |#endif
                             1736 ; 22   |#if !defined(FALSE)
                             1737 ; 23   |#define FALSE 0
                             1738 ; 24   |#endif
                             1739 ; 25   |#if !defined(TRUE)
                             1740 ; 26   |#define TRUE  1
                             1741 ; 27   |#endif
                             1742 ; 28   |
                             1743 ; 29   |#if !defined(NULL)
                             1744 ; 30   |#define NULL 0
                             1745 ; 31   |#endif
                             1746 ; 32   |
                             1747 ; 33   |#define MAX_INT     0x7FFFFF
                             1748 ; 34   |#define MAX_LONG    0x7FFFFFffffff
                             1749 ; 35   |        // max positive unsigned long value: -1 == 0xFFFFFFffffff
                             1750 ; 36   |#define MAX_ULONG   (-1) 
                             1751 ; 37   |
                             1752 ; 38   |#define WORD_SIZE   24              // word size in bits
                             1753 ; 39   |#define BYTES_PER_WORD 3            // 8 bit bytes
                             1754 ; 40   |
                             1755 ; 41   |
                             1756 ; 42   |#define BYTE    unsigned char       // btVarName
                             1757 ; 43   |#define CHAR    signed char         // cVarName
                             1758 ; 44   |#define USHORT  unsigned short      // usVarName
                             1759 ; 45   |#define SHORT   unsigned short      // sVarName
                             1760 ; 46   |#define WORD    unsigned int        // wVarName
                             1761 ; 47   |#define INT     signed int          // iVarName
                             1762 ; 48   |#define DWORD   unsigned long       // dwVarName
                             1763 ; 49   |#define LONG    signed long         // lVarName
                             1764 ; 50   |#define BOOL    unsigned int        // bVarName
                             1765 ; 51   |#define FRACT   _fract              // frVarName
                             1766 ; 52   |#define LFRACT  long _fract         // lfrVarName
                             1767 ; 53   |#define CIRC    _circ               // cp<type prefix>VarName (see below)
                             1768 ; 54   |#define FLOAT   float               // fVarName
                             1769 ; 55   |#define DBL     double              // dVarName
                             1770 ; 56   |#define ENUM    enum                // eVarName
                             1771 ; 57   |#define CMX     _complex            // cmxVarName
                             1772 ; 58   |typedef WORD UCS3;                   // 
                             1773 ; 59   |
                             1774 ; 60   |#define UINT16  unsigned short
                             1775 ; 61   |#define UINT8   unsigned char   
                             1776 ; 62   |#define UINT32  unsigned long
                             1777 ; 63   |#define UINT64  unsigned long   // need to figure out how to do 64 bit values.  Or port exisiting code to only use 48 bit
                             1778 ; 64   |#define INT64   unsigned long   // need to figure out how to do 64 bit values.  Or port exisiting code to only use 48 bit
                             1779 ; 65   |#define WCHAR   UINT16
                             1780 ; 66   |
                             1781 ; 67   |//UINT128 is 16 bytes or 6 words
                             1782 ; 68   |typedef struct UINT128_3500 {   
                             1783 ; 69   |    int val[6];     
                             1784 ; 70   |} UINT128_3500;
                             1785 ; 71   |
                             1786 ; 72   |#define UINT128   UINT128_3500
                             1787 ; 73   |
                             1788 ; 74   |// Little endian word packed byte strings:   
                             1789 ; 75   |//      _packed BYTE bTextVarName[]="a string";  bText is a packed byte string prefix
                             1790 ; 76   |// Convert to big endian words by reordering bytes from high to low using swizzle.
                             1791 ; 77   |// Little endian word packed byte strings:   
                             1792 ; 78   |//      _packed BYTE bTextVarName[]="a string";  bText is a packed byte string prefix
                             1793 ; 79   |// Convert to big endian words by reordering bytes from high to low using swizzle.
                             1794 ; 80   |
                             1795 ; 81   |// Declare Memory Spaces To Use When Coding
                             1796 ; 82   |// A. Sector Buffers
                             1797 ; 83   |#define SECTOR_BUFFER_MEM_X _X
                             1798 ; 84   |#define SECTOR_BUFFER_MEM_Y _Y
                             1799 ; 85   |#define SECTOR_BUFFER_MEM SECTOR_BUFFER_MEM_X
                             1800 ; 86   |typedef WORD SECTOR_BUFFER_MEM SECTOR_BUFFER;
                             1801 ; 87   |typedef SECTOR_BUFFER * P_SECTOR_BUFFER;
                             1802 ; 88   |// B. Media DDI Memory
                             1803 ; 89   |#define MEDIA_DDI_MEM _Y
                             1804 ; 90   |
                             1805 ; 91   |
                             1806 ; 92   |
                             1807 ; 93   |// Pointers to linear structures are labeled as: p<type prefix>VarName
                             1808 ; 94   |// Examples of circular pointers:
                             1809 ; 95   |//    INT CIRC cpiVarName
                             1810 ; 96   |//    DWORD CIRC cpdwVarName
                             1811 ; 97   |
                             1812 ; 98   |#define RETCODE INT                 // rcVarName
                             1813 ; 99   |
                             1814 ; 100  |// generic bitfield structure
                             1815 ; 101  |struct Bitfield {
                             1816 ; 102  |    unsigned int B0  :1;
                             1817 ; 103  |    unsigned int B1  :1;
                             1818 ; 104  |    unsigned int B2  :1;
                             1819 ; 105  |    unsigned int B3  :1;
                             1820 ; 106  |    unsigned int B4  :1;
                             1821 ; 107  |    unsigned int B5  :1;
TASKING DSP2410 assembler v1.5r1 Build 138 SN 00100122
                                                                                                                                                                                                                                                       Page   8

M:ADDR CODE           CYCLES LINE SOURCELINE
                             1822 ; 108  |    unsigned int B6  :1;
                             1823 ; 109  |    unsigned int B7  :1;
                             1824 ; 110  |    unsigned int B8  :1;
                             1825 ; 111  |    unsigned int B9  :1;
                             1826 ; 112  |    unsigned int B10 :1;
                             1827 ; 113  |    unsigned int B11 :1;
                             1828 ; 114  |    unsigned int B12 :1;
                             1829 ; 115  |    unsigned int B13 :1;
                             1830 ; 116  |    unsigned int B14 :1;
                             1831 ; 117  |    unsigned int B15 :1;
                             1832 ; 118  |    unsigned int B16 :1;
                             1833 ; 119  |    unsigned int B17 :1;
                             1834 ; 120  |    unsigned int B18 :1;
                             1835 ; 121  |    unsigned int B19 :1;
                             1836 ; 122  |    unsigned int B20 :1;
                             1837 ; 123  |    unsigned int B21 :1;
                             1838 ; 124  |    unsigned int B22 :1;
                             1839 ; 125  |    unsigned int B23 :1;
                             1840 ; 126  |};
                             1841 ; 127  |
                             1842 ; 128  |union BitInt {
                             1843 ; 129  |        struct Bitfield B;
                             1844 ; 130  |        int        I;
                             1845 ; 131  |};
                             1846 ; 132  |
                             1847 ; 133  |#define MAX_MSG_LENGTH 10
                             1848 ; 134  |struct CMessage
                             1849 ; 135  |{
                             1850 ; 136  |        unsigned int m_uLength;
                             1851 ; 137  |        unsigned int m_uMsg[MAX_MSG_LENGTH];
                             1852 ; 138  |};
                             1853 ; 139  |
                             1854 ; 140  |typedef struct {
                             1855 ; 141  |    WORD m_wLength;
                             1856 ; 142  |    WORD m_wMessage;
                             1857 ; 143  |    WORD m_wParams[MAX_MSG_LENGTH];
                             1858 ; 144  |} Message;
                             1859 ; 145  |
                             1860 ; 146  |struct MessageQueueDescriptor
                             1861 ; 147  |{
                             1862 ; 148  |        int *m_pBase;
                             1863 ; 149  |        int m_iModulo;
                             1864 ; 150  |        int m_iSize;
                             1865 ; 151  |        int *m_pHead;
                             1866 ; 152  |        int *m_pTail;
                             1867 ; 153  |};
                             1868 ; 154  |
                             1869 ; 155  |struct ModuleEntry
                             1870 ; 156  |{
                             1871 ; 157  |    int m_iSignaledEventMask;
                             1872 ; 158  |    int m_iWaitEventMask;
                             1873 ; 159  |    int m_iResourceOfCode;
                             1874 ; 160  |    struct MessageQueueDescriptor *m_pMessageQueue;
                             1875 ; 161  |    int _asmfunc (*m_pProcessEntryPoint)(union WaitMask Signals,struct MessageQueueDescriptor *);
                             1876 ; 162  |    int _asmfunc (*m_pInitFunction)(struct MessageQueueDescriptor *);
                             1877 ; 163  |    int m_uTimeOutHigh;
                             1878 ; 164  |    int m_uTimeOutLow;
                             1879 ; 165  |    int _asmfunc (*m_pBackgroundFunction)(struct MessageQueueDescriptor *);
                             1880 ; 166  |};
                             1881 ; 167  |
                             1882 ; 168  |union WaitMask{
                             1883 ; 169  |    struct B{
                             1884 ; 170  |        unsigned int m_bNone     :1;
                             1885 ; 171  |        unsigned int m_bMessage  :1;
                             1886 ; 172  |        unsigned int m_bTimer    :1;
                             1887 ; 173  |        unsigned int m_bButton   :1;
                             1888 ; 174  |    } B;
                             1889 ; 175  |    int I;
                             1890 ; 176  |} ;
                             1891 ; 177  |
                             1892 ; 178  |
                             1893 ; 179  |struct Button {
                             1894 ; 180  |        WORD wButtonEvent;
                             1895 ; 181  |        WORD wUnused[MAX_MSG_LENGTH];   
                             1896 ; 182  |};
                             1897 ; 183  |
                             1898 ; 184  |struct Message {
                             1899 ; 185  |        WORD wMsgLength;
                             1900 ; 186  |        WORD wMsgCommand;
                             1901 ; 187  |        WORD wMsgParms[MAX_MSG_LENGTH-1];
                             1902 ; 188  |};
                             1903 ; 189  |
                             1904 ; 190  |union EventTypes {
                             1905 ; 191  |        struct CMessage msg;
                             1906 ; 192  |        struct Button Button ;
                             1907 ; 193  |        struct Message Message;
                             1908 ; 194  |};
                             1909 ; 195  |
                             1910 ; 196  |// next 2 used to get updater build to return correct protocol ver in scsi response.
                             1911 ; 197  |#define BUILD_TYPE_UPDATER  0x100
                             1912 ; 198  |#define BUILD_TYPE_HOSTLINK 0x101
                             1913 ; 199  |#define BUILD_TYPE_PLAYER   0x102
                             1914 ; 200  |
                             1915 ; 201  |// Resets part if RETAIL build. DEBUG build executes debug instruction to halt.
                             1916 ; 202  |#define SystemHalt() __asm(" include 'sysmacro.asm' \n error") 
                             1917 ; 203  |#define assert(x)    if(!(x)) __asm(" include 'sysmacro.asm' \n error")
                             1918 ; 204  |
                             1919 ; 205  |#if DEBUG
                             1920 ; 206  |// For DEBUG builds, DebugBuildAssert(condition) halts if condition evaluates to FALSE. 
                             1921 ; 207  |#define DebugBuildAssert(x)    if(!(x)) __asm(" debug ")
                             1922 ; 208  |#else 
                             1923 ; 209  |// For RETAIL builds, DebugBuildAssert(condition) does nothing & execution continues rather than halt or reset. 
                             1924 ; 210  |#define DebugBuildAssert(x)    
                             1925 ; 211  |#endif
                             1926 ; 212  |
                             1927 ; 213  |// Do this in your C files to make a reminder that's displayed during the build.
                             1928 ; 214  |//  #pragma asm
                             1929 ; 215  |//  WARN 'Note to builder: reminder to do this after verifying that'
                             1930 ; 216  |//  #pragma endasm
                             1931 ; 217  |
                             1932 ; 218  |
                             1933 ; 219  |#ifdef COLOR_262K
                             1934 ; 220  |#define RGB(r,g,b)    ((0x0000FC & (r)) << 10) | ((0x0000FC & (g)) << 4) | ((0x0000FC & (b)) >> 2)    //262k
                             1935 ; 221  |#elif defined(COLOR_65K)
                             1936 ; 222  |#define RGB(r,g,b)    ((0x0000F8 & (r)) << 8) | ((0x0000FC & (g)) << 3) | ((0x0000F8 & (b)) >> 3)  //65k
                             1937 ; 223  |#else
                             1938 ; 224  |#define RGB(r,g,b)       ((0x0000F0 & (r)) << 4) | (0x0000F0 & (g)) | ((0x0000F0 & (b)) >> 4)
                             1939 ; 225  |#endif
                             1940 ; 226  |    
                             1941 ; 227  |#endif // #ifndef _TYPES_H
                             1942 
                             1944 
                             1945 ; 2    |#include "fstypes.h"
                             1946 
                             1948 
                             1949 ; 1    |#ifndef _FS_TYPE_H_
                             1950 ; 2    |#define _FS_TYPE_H_
                             1951 ; 3    |
                             1952 ; 4    |#include   "types.h"
                             1953 
                             1955 
                             1956 ; 1    |////////////////////////////////////////////////////////////////////////////////
                             1957 ; 2    |// Copyright(C) SigmaTel, Inc. 2000-2004
                             1958 ; 3    |//
                             1959 ; 4    |// Filename: types.h
                             1960 ; 5    |// Description: Standard data types
                             1961 ; 6    |////////////////////////////////////////////////////////////////////////////////
                             1962 ; 7    |
                             1963 ; 8    |#ifndef _TYPES_H
                             1964 ; 9    |#define _TYPES_H
                             1965 ; 10   |
                             1966 ; 11   |// TODO:  move this outta here!
                             1967 ; 12   |#if !defined(NOERROR)
                             1968 ; 13   |#define NOERROR 0
                             1969 ; 14   |#define SUCCESS 0
                             1970 ; 15   |#endif 
                             1971 ; 16   |#if !defined(SUCCESS)
                             1972 ; 17   |#define SUCCESS  0
                             1973 ; 18   |#endif
                             1974 ; 19   |#if !defined(ERROR)
                             1975 ; 20   |#define ERROR   -1
                             1976 ; 21   |#endif
                             1977 ; 22   |#if !defined(FALSE)
                             1978 ; 23   |#define FALSE 0
                             1979 ; 24   |#endif
                             1980 ; 25   |#if !defined(TRUE)
                             1981 ; 26   |#define TRUE  1
                             1982 ; 27   |#endif
                             1983 ; 28   |
                             1984 ; 29   |#if !defined(NULL)
                             1985 ; 30   |#define NULL 0
                             1986 ; 31   |#endif
                             1987 ; 32   |
                             1988 ; 33   |#define MAX_INT     0x7FFFFF
                             1989 ; 34   |#define MAX_LONG    0x7FFFFFffffff
                             1990 ; 35   |        // max positive unsigned long value: -1 == 0xFFFFFFffffff
                             1991 ; 36   |#define MAX_ULONG   (-1) 
                             1992 ; 37   |
                             1993 ; 38   |#define WORD_SIZE   24              // word size in bits
                             1994 ; 39   |#define BYTES_PER_WORD 3            // 8 bit bytes
                             1995 ; 40   |
                             1996 ; 41   |
                             1997 ; 42   |#define BYTE    unsigned char       // btVarName
                             1998 ; 43   |#define CHAR    signed char         // cVarName
                             1999 ; 44   |#define USHORT  unsigned short      // usVarName
                             2000 ; 45   |#define SHORT   unsigned short      // sVarName
                             2001 ; 46   |#define WORD    unsigned int        // wVarName
                             2002 ; 47   |#define INT     signed int          // iVarName
                             2003 ; 48   |#define DWORD   unsigned long       // dwVarName
                             2004 ; 49   |#define LONG    signed long         // lVarName
                             2005 ; 50   |#define BOOL    unsigned int        // bVarName
                             2006 ; 51   |#define FRACT   _fract              // frVarName
                             2007 ; 52   |#define LFRACT  long _fract         // lfrVarName
                             2008 ; 53   |#define CIRC    _circ               // cp<type prefix>VarName (see below)
                             2009 ; 54   |#define FLOAT   float               // fVarName
                             2010 ; 55   |#define DBL     double              // dVarName
                             2011 ; 56   |#define ENUM    enum                // eVarName
                             2012 ; 57   |#define CMX     _complex            // cmxVarName
                             2013 ; 58   |typedef WORD UCS3;                   // 
                             2014 ; 59   |
                             2015 ; 60   |#define UINT16  unsigned short
                             2016 ; 61   |#define UINT8   unsigned char   
                             2017 ; 62   |#define UINT32  unsigned long
                             2018 ; 63   |#define UINT64  unsigned long   // need to figure out how to do 64 bit values.  Or port exisiting code to only use 48 bit
                             2019 ; 64   |#define INT64   unsigned long   // need to figure out how to do 64 bit values.  Or port exisiting code to only use 48 bit
                             2020 ; 65   |#define WCHAR   UINT16
                             2021 ; 66   |
                             2022 ; 67   |//UINT128 is 16 bytes or 6 words
                             2023 ; 68   |typedef struct UINT128_3500 {   
                             2024 ; 69   |    int val[6];     
                             2025 ; 70   |} UINT128_3500;
                             2026 ; 71   |
                             2027 ; 72   |#define UINT128   UINT128_3500
                             2028 ; 73   |
                             2029 ; 74   |// Little endian word packed byte strings:   
                             2030 ; 75   |//      _packed BYTE bTextVarName[]="a string";  bText is a packed byte string prefix
                             2031 ; 76   |// Convert to big endian words by reordering bytes from high to low using swizzle.
                             2032 ; 77   |// Little endian word packed byte strings:   
                             2033 ; 78   |//      _packed BYTE bTextVarName[]="a string";  bText is a packed byte string prefix
                             2034 ; 79   |// Convert to big endian words by reordering bytes from high to low using swizzle.
                             2035 ; 80   |
                             2036 ; 81   |// Declare Memory Spaces To Use When Coding
                             2037 ; 82   |// A. Sector Buffers
                             2038 ; 83   |#define SECTOR_BUFFER_MEM_X _X
                             2039 ; 84   |#define SECTOR_BUFFER_MEM_Y _Y
                             2040 ; 85   |#define SECTOR_BUFFER_MEM SECTOR_BUFFER_MEM_X
                             2041 ; 86   |typedef WORD SECTOR_BUFFER_MEM SECTOR_BUFFER;
                             2042 ; 87   |typedef SECTOR_BUFFER * P_SECTOR_BUFFER;
                             2043 ; 88   |// B. Media DDI Memory
                             2044 ; 89   |#define MEDIA_DDI_MEM _Y
                             2045 ; 90   |
                             2046 ; 91   |
                             2047 ; 92   |
                             2048 ; 93   |// Pointers to linear structures are labeled as: p<type prefix>VarName
                             2049 ; 94   |// Examples of circular pointers:
                             2050 ; 95   |//    INT CIRC cpiVarName
                             2051 ; 96   |//    DWORD CIRC cpdwVarName
                             2052 ; 97   |
                             2053 ; 98   |#define RETCODE INT                 // rcVarName
                             2054 ; 99   |
                             2055 ; 100  |// generic bitfield structure
                             2056 ; 101  |struct Bitfield {
                             2057 ; 102  |    unsigned int B0  :1;
                             2058 ; 103  |    unsigned int B1  :1;
                             2059 ; 104  |    unsigned int B2  :1;
                             2060 ; 105  |    unsigned int B3  :1;
                             2061 ; 106  |    unsigned int B4  :1;
                             2062 ; 107  |    unsigned int B5  :1;
                             2063 ; 108  |    unsigned int B6  :1;
                             2064 ; 109  |    unsigned int B7  :1;
                             2065 ; 110  |    unsigned int B8  :1;
                             2066 ; 111  |    unsigned int B9  :1;
                             2067 ; 112  |    unsigned int B10 :1;
                             2068 ; 113  |    unsigned int B11 :1;
                             2069 ; 114  |    unsigned int B12 :1;
                             2070 ; 115  |    unsigned int B13 :1;
                             2071 ; 116  |    unsigned int B14 :1;
                             2072 ; 117  |    unsigned int B15 :1;
                             2073 ; 118  |    unsigned int B16 :1;
                             2074 ; 119  |    unsigned int B17 :1;
                             2075 ; 120  |    unsigned int B18 :1;
TASKING DSP2410 assembler v1.5r1 Build 138 SN 00100122
                                                                                                                                                                                                                                                       Page   9

M:ADDR CODE           CYCLES LINE SOURCELINE
                             2076 ; 121  |    unsigned int B19 :1;
                             2077 ; 122  |    unsigned int B20 :1;
                             2078 ; 123  |    unsigned int B21 :1;
                             2079 ; 124  |    unsigned int B22 :1;
                             2080 ; 125  |    unsigned int B23 :1;
                             2081 ; 126  |};
                             2082 ; 127  |
                             2083 ; 128  |union BitInt {
                             2084 ; 129  |        struct Bitfield B;
                             2085 ; 130  |        int        I;
                             2086 ; 131  |};
                             2087 ; 132  |
                             2088 ; 133  |#define MAX_MSG_LENGTH 10
                             2089 ; 134  |struct CMessage
                             2090 ; 135  |{
                             2091 ; 136  |        unsigned int m_uLength;
                             2092 ; 137  |        unsigned int m_uMsg[MAX_MSG_LENGTH];
                             2093 ; 138  |};
                             2094 ; 139  |
                             2095 ; 140  |typedef struct {
                             2096 ; 141  |    WORD m_wLength;
                             2097 ; 142  |    WORD m_wMessage;
                             2098 ; 143  |    WORD m_wParams[MAX_MSG_LENGTH];
                             2099 ; 144  |} Message;
                             2100 ; 145  |
                             2101 ; 146  |struct MessageQueueDescriptor
                             2102 ; 147  |{
                             2103 ; 148  |        int *m_pBase;
                             2104 ; 149  |        int m_iModulo;
                             2105 ; 150  |        int m_iSize;
                             2106 ; 151  |        int *m_pHead;
                             2107 ; 152  |        int *m_pTail;
                             2108 ; 153  |};
                             2109 ; 154  |
                             2110 ; 155  |struct ModuleEntry
                             2111 ; 156  |{
                             2112 ; 157  |    int m_iSignaledEventMask;
                             2113 ; 158  |    int m_iWaitEventMask;
                             2114 ; 159  |    int m_iResourceOfCode;
                             2115 ; 160  |    struct MessageQueueDescriptor *m_pMessageQueue;
                             2116 ; 161  |    int _asmfunc (*m_pProcessEntryPoint)(union WaitMask Signals,struct MessageQueueDescriptor *);
                             2117 ; 162  |    int _asmfunc (*m_pInitFunction)(struct MessageQueueDescriptor *);
                             2118 ; 163  |    int m_uTimeOutHigh;
                             2119 ; 164  |    int m_uTimeOutLow;
                             2120 ; 165  |    int _asmfunc (*m_pBackgroundFunction)(struct MessageQueueDescriptor *);
                             2121 ; 166  |};
                             2122 ; 167  |
                             2123 ; 168  |union WaitMask{
                             2124 ; 169  |    struct B{
                             2125 ; 170  |        unsigned int m_bNone     :1;
                             2126 ; 171  |        unsigned int m_bMessage  :1;
                             2127 ; 172  |        unsigned int m_bTimer    :1;
                             2128 ; 173  |        unsigned int m_bButton   :1;
                             2129 ; 174  |    } B;
                             2130 ; 175  |    int I;
                             2131 ; 176  |} ;
                             2132 ; 177  |
                             2133 ; 178  |
                             2134 ; 179  |struct Button {
                             2135 ; 180  |        WORD wButtonEvent;
                             2136 ; 181  |        WORD wUnused[MAX_MSG_LENGTH];   
                             2137 ; 182  |};
                             2138 ; 183  |
                             2139 ; 184  |struct Message {
                             2140 ; 185  |        WORD wMsgLength;
                             2141 ; 186  |        WORD wMsgCommand;
                             2142 ; 187  |        WORD wMsgParms[MAX_MSG_LENGTH-1];
                             2143 ; 188  |};
                             2144 ; 189  |
                             2145 ; 190  |union EventTypes {
                             2146 ; 191  |        struct CMessage msg;
                             2147 ; 192  |        struct Button Button ;
                             2148 ; 193  |        struct Message Message;
                             2149 ; 194  |};
                             2150 ; 195  |
                             2151 ; 196  |// next 2 used to get updater build to return correct protocol ver in scsi response.
                             2152 ; 197  |#define BUILD_TYPE_UPDATER  0x100
                             2153 ; 198  |#define BUILD_TYPE_HOSTLINK 0x101
                             2154 ; 199  |#define BUILD_TYPE_PLAYER   0x102
                             2155 ; 200  |
                             2156 ; 201  |// Resets part if RETAIL build. DEBUG build executes debug instruction to halt.
                             2157 ; 202  |#define SystemHalt() __asm(" include 'sysmacro.asm' \n error") 
                             2158 ; 203  |#define assert(x)    if(!(x)) __asm(" include 'sysmacro.asm' \n error")
                             2159 ; 204  |
                             2160 ; 205  |#if DEBUG
                             2161 ; 206  |// For DEBUG builds, DebugBuildAssert(condition) halts if condition evaluates to FALSE. 
                             2162 ; 207  |#define DebugBuildAssert(x)    if(!(x)) __asm(" debug ")
                             2163 ; 208  |#else 
                             2164 ; 209  |// For RETAIL builds, DebugBuildAssert(condition) does nothing & execution continues rather than halt or reset. 
                             2165 ; 210  |#define DebugBuildAssert(x)    
                             2166 ; 211  |#endif
                             2167 ; 212  |
                             2168 ; 213  |// Do this in your C files to make a reminder that's displayed during the build.
                             2169 ; 214  |//  #pragma asm
                             2170 ; 215  |//  WARN 'Note to builder: reminder to do this after verifying that'
                             2171 ; 216  |//  #pragma endasm
                             2172 ; 217  |
                             2173 ; 218  |
                             2174 ; 219  |#ifdef COLOR_262K
                             2175 ; 220  |#define RGB(r,g,b)    ((0x0000FC & (r)) << 10) | ((0x0000FC & (g)) << 4) | ((0x0000FC & (b)) >> 2)    //262k
                             2176 ; 221  |#elif defined(COLOR_65K)
                             2177 ; 222  |#define RGB(r,g,b)    ((0x0000F8 & (r)) << 8) | ((0x0000FC & (g)) << 3) | ((0x0000F8 & (b)) >> 3)  //65k
                             2178 ; 223  |#else
                             2179 ; 224  |#define RGB(r,g,b)       ((0x0000F0 & (r)) << 4) | (0x0000F0 & (g)) | ((0x0000F0 & (b)) >> 4)
                             2180 ; 225  |#endif
                             2181 ; 226  |    
                             2182 ; 227  |#endif // #ifndef _TYPES_H
                             2183 
                             2185 
                             2186 ; 5    |
                             2187 ; 6    |// move FSMEDIA_TABLE from devicetable.h  15Apr2005   First moved in SDK2.6.
                             2188 ; 7    |typedef struct
                             2189 ; 8    |{
                             2190 ; 9    |
                             2191 ; 10   |INT     _Y BytesPerSector;
                             2192 ; 11   |INT     _Y SectorsPerCluster;
                             2193 ; 12   |INT     _Y RsvdSectors;
                             2194 ; 13   |INT     _Y NoOfFATs;
                             2195 ; 14   |INT     _Y MaxRootDirEntries;
                             2196 ; 15   |LONG    _Y TotalSectors;
                             2197 ; 16   |LONG    _Y FATSize;
                             2198 ; 17   |LONG    _Y RootdirCluster;
                             2199 ; 18   |//INT   _Y FSInfoSector;
                             2200 ; 19   |//INT   _Y BkBootSector;
                             2201 ; 20   |LONG    _Y NextFreeCluster;
                             2202 ; 21   |LONG    _Y TotalFreeClusters;
                             2203 ; 22   |INT     _Y RootDirSectors;
                             2204 ; 23   |INT     _Y FIRSTDataSector;
                             2205 ; 24   |INT    _Y FATType;
                             2206 ; 25   |LONG   _Y TotalNoofclusters;
                             2207 ; 26   |INT    _Y ClusterMask;
                             2208 ; 27   |INT    _Y ClusterShift;
                             2209 ; 28   |INT    _Y SectorShift;
                             2210 ; 29   |INT    _Y SectorMask;
                             2211 ; 30   |INT    _Y DevicePresent;
                             2212 ; 31   |LONG   _Y FirRootdirsec;
                             2213 ; 32   |INT             _Y FSInfoSector;
                             2214 ; 33   |}FSMEDIA_TABLE;
                             2215 ; 34   |
                             2216 ; 35   |
                             2217 ; 36   |#define         MAXDEVICES              2
                             2218 ; 37   |//#define       NUMCACHES               8  // this is already in fsproj.h (2 for player 2 for mtp as of 28jun2005) TOVERIFY 2 ok for player and mtp. 
                             2219 ; 38   |
                             2220 ; 39   |// NOTE:  This offset is the same no matter what the sector actual size!  
                             2221 ; 40   |//        TOVERIFY 3.0 doesn't have this defined but uses it in filesystempresent.c. lbmlc def'd it here so I insert it here.
                             2222 ; 41   |#define         FATFS_SIGNATURE_OFFSET  510
                             2223 ; 42   |#define         BOOTSECTOR              0
                             2224 ; 43   |#define     FSINFOSECTOR        1
                             2225 ; 44   |
                             2226 ; 45   |#define     READ_MODE           1
                             2227 ; 46   |#define     WRITE_MODE          2
                             2228 ; 47   |#define     APPEND_MODE         4
                             2229 ; 48   |#define     SEQ_WRITE_MODE      8
                             2230 ; 49   |#define     DIRECTORY_MODE         16
                             2231 ; 50   |#define     CREATE_MODE        32
                             2232 ; 51   |
                             2233 ; 52   |#define     RPLUS               5
                             2234 ; 53   |#define     WPLUS                   6
                             2235 ; 54   |#define     APLUS               7
                             2236 ; 55   |
                             2237 ; 56   |
                             2238 ; 57   |
                             2239 ; 58   |#define     X_MEMORY            0
                             2240 ; 59   |#define     Y_MEMORY            2
                             2241 ; 60   |#define     P_MEMORY            4
                             2242 ; 61   |
                             2243 ; 62   |#define     FAT12               0 
                             2244 ; 63   |#define     FAT16               1   
                             2245 ; 64   |#define     FAT32               2 
                             2246 ; 65   |
                             2247 ; 66   |
                             2248 ; 67   |#define FAT12EOF            0x0FFF
                             2249 ; 68   |#define FAT16EOF            0xFFFF
                             2250 ; 69   |#define FAT32EOF            0x0FFFFFFF
                             2251 ; 70   |
                             2252 ; 71   |
                             2253 ; 72   |
                             2254 ; 73   |#define FAT12FREECX         0x000
                             2255 ; 74   |#define FAT16FREECX         0x0000
                             2256 ; 75   |#define FAT32FREECX         0x00000000
                             2257 ; 76   |
                             2258 ; 77   |
                             2259 ; 78   |#define  DBCS               1
                             2260 ; 79   |#define  UNICODE            2
                             2261 ; 80   |
                             2262 ; 81   |
                             2263 ; 82   |#define     CREATION_DATE       1
                             2264 ; 83   |#define     CREATION_TIME       2
                             2265 ; 84   |#define     MODIFICATION_DATE   3
                             2266 ; 85   |#define     MODIFICATION_TIME   4
                             2267 ; 86   |
                             2268 ; 87   |
                             2269 ; 88   |#define     READ_ONLY      0X01
                             2270 ; 89   |#define     HIDDEN         0X02
                             2271 ; 90   |#define     SYSTEM         0X04
                             2272 ; 91   |#define     VOLUME_ID      0X08
                             2273 ; 92   |#define     DIRECTORY      0X10
                             2274 ; 93   |#define     ARCHIVE        0X20
                             2275 ; 94   |
                             2276 ; 95   |#define READCOUNTER         105
                             2277 ; 96   |#define WRITECOUNTER        100
                             2278 ; 97   |#define FLUSHCOUNTER        200
                             2279 ; 98   |
                             2280 ; 99   |
                             2281 ; 100  |#define DEFAULT_MEMORY      Y_MEMORY
                             2282 ; 101  |
                             2283 ; 102  |#define  CWD_HANDLE           0
                             2284 ; 103  |#define  DIRECTORY_HANDLE     1
                             2285 ; 104  |#define  FIRST_VALID_HANDLE   2
                             2286 ; 105  |#define  END_OF_DIR_PATH      3
                             2287 ; 106  |
                             2288 ; 107  |//Constants for Sector read and write (Normal and FAT 
                             2289 ; 108  |#define         NORMALTYPE              0
                             2290 ; 109  |#define         FATTYPE                 1
                             2291 ; 110  |#define     RAWTYPE         2
                             2292 ; 111  |
                             2293 ; 112  |#define  SHORTNAMERES_CH      6
                             2294 ; 113  |#define  LONGNAMERES_CH       9
                             2295 ; 114  |#define  MAXFILENAME_CH       260
                             2296 ; 115  |
                             2297 ; 116  |#define VOLUME_TYPE          0
                             2298 ; 117  |#define DIR_TYPE             1
                             2299 ; 118  |#define FILE_TYPE            2
                             2300 ; 119  |                                           
                             2301 ; 120  |#define WRITE_TYPE_RANDOM               0
                             2302 ; 121  |#define WRITE_TYPE_SEQ_FIRST    1
                             2303 ; 122  |#define WRITE_TYPE_SEQ_NEXT             2
                             2304 ; 123  |#define WRITE_TYPE_NOREADBACK   3
                             2305 ; 124  |                  
                             2306 ; 125  |
                             2307 ; 126  |#define     HANDLEENTRYSIZE         19
                             2308 ; 127  |
                             2309 ; 128  |// DEVICERECORDSIZE is now only defined in cachedef.h so deleted from here in first 3.1 prelim 
                             2310 ; 129  |
                             2311 ; 130  |#define     CACHEDESCRSIZE          8
                             2312 ; 131  |#define     CACHEBUFSIZE            705
                             2313 ; 132  |
                             2314 ; 133  |#define     UCS2s                     0
                             2315 ; 134  |#define     UCS3s                     1
                             2316 ; 135  |
                             2317 ; 136  |#define     FAT32FSIFREECOUNTSIZE       4
                             2318 ; 137  |
                             2319 ; 138  |#endif // _FS_TYPE_H_
                             2320 ; 139  |
                             2321 
                             2323 
                             2324 ; 3    |typedef struct  
                             2325 ; 4    |{
                             2326 ; 5    |INT             HandleActive;
                             2327 ; 6    |INT             Device;
                             2328 ; 7    |INT             Mode;
TASKING DSP2410 assembler v1.5r1 Build 138 SN 00100122
                                                                                                                                                                                                                                                       Page  10

M:ADDR CODE           CYCLES LINE SOURCELINE
                             2329 ; 8    |LONG       StartingCluster;
                             2330 ; 9    |LONG            CurrentOffset;
                             2331 ; 10   |LONG            CurrentCluster;
                             2332 ; 11   |LONG            CurrentSector;
                             2333 ; 12   |INT             BytePosInSector;
                             2334 ; 13   |INT             SectorPosInCluster;
                             2335 ; 14   |LONG            DirSector;
                             2336 ; 15   |INT             DirOffset;
                             2337 ; 16   |INT             ErrorCode;
                             2338 ; 17   |LONG            FileSize;
                             2339 ; 18   |}HANDLETABLE;
                             2340 ; 19   |
                             2341 ; 20   |
                             2342 ; 21   |
                             2343 ; 22   |
                             2344 ; 23   |
                             2345 ; 24   |
                             2346 ; 25   |
                             2347 
                             2349 
                             2350 ; 2    |#include "devicetable.h"
                             2351 
                             2353 
                             2354 ; 1    |#include "types.h"
                             2355 
                             2357 
                             2358 ; 1    |////////////////////////////////////////////////////////////////////////////////
                             2359 ; 2    |// Copyright(C) SigmaTel, Inc. 2000-2004
                             2360 ; 3    |//
                             2361 ; 4    |// Filename: types.h
                             2362 ; 5    |// Description: Standard data types
                             2363 ; 6    |////////////////////////////////////////////////////////////////////////////////
                             2364 ; 7    |
                             2365 ; 8    |#ifndef _TYPES_H
                             2366 ; 9    |#define _TYPES_H
                             2367 ; 10   |
                             2368 ; 11   |// TODO:  move this outta here!
                             2369 ; 12   |#if !defined(NOERROR)
                             2370 ; 13   |#define NOERROR 0
                             2371 ; 14   |#define SUCCESS 0
                             2372 ; 15   |#endif 
                             2373 ; 16   |#if !defined(SUCCESS)
                             2374 ; 17   |#define SUCCESS  0
                             2375 ; 18   |#endif
                             2376 ; 19   |#if !defined(ERROR)
                             2377 ; 20   |#define ERROR   -1
                             2378 ; 21   |#endif
                             2379 ; 22   |#if !defined(FALSE)
                             2380 ; 23   |#define FALSE 0
                             2381 ; 24   |#endif
                             2382 ; 25   |#if !defined(TRUE)
                             2383 ; 26   |#define TRUE  1
                             2384 ; 27   |#endif
                             2385 ; 28   |
                             2386 ; 29   |#if !defined(NULL)
                             2387 ; 30   |#define NULL 0
                             2388 ; 31   |#endif
                             2389 ; 32   |
                             2390 ; 33   |#define MAX_INT     0x7FFFFF
                             2391 ; 34   |#define MAX_LONG    0x7FFFFFffffff
                             2392 ; 35   |        // max positive unsigned long value: -1 == 0xFFFFFFffffff
                             2393 ; 36   |#define MAX_ULONG   (-1) 
                             2394 ; 37   |
                             2395 ; 38   |#define WORD_SIZE   24              // word size in bits
                             2396 ; 39   |#define BYTES_PER_WORD 3            // 8 bit bytes
                             2397 ; 40   |
                             2398 ; 41   |
                             2399 ; 42   |#define BYTE    unsigned char       // btVarName
                             2400 ; 43   |#define CHAR    signed char         // cVarName
                             2401 ; 44   |#define USHORT  unsigned short      // usVarName
                             2402 ; 45   |#define SHORT   unsigned short      // sVarName
                             2403 ; 46   |#define WORD    unsigned int        // wVarName
                             2404 ; 47   |#define INT     signed int          // iVarName
                             2405 ; 48   |#define DWORD   unsigned long       // dwVarName
                             2406 ; 49   |#define LONG    signed long         // lVarName
                             2407 ; 50   |#define BOOL    unsigned int        // bVarName
                             2408 ; 51   |#define FRACT   _fract              // frVarName
                             2409 ; 52   |#define LFRACT  long _fract         // lfrVarName
                             2410 ; 53   |#define CIRC    _circ               // cp<type prefix>VarName (see below)
                             2411 ; 54   |#define FLOAT   float               // fVarName
                             2412 ; 55   |#define DBL     double              // dVarName
                             2413 ; 56   |#define ENUM    enum                // eVarName
                             2414 ; 57   |#define CMX     _complex            // cmxVarName
                             2415 ; 58   |typedef WORD UCS3;                   // 
                             2416 ; 59   |
                             2417 ; 60   |#define UINT16  unsigned short
                             2418 ; 61   |#define UINT8   unsigned char   
                             2419 ; 62   |#define UINT32  unsigned long
                             2420 ; 63   |#define UINT64  unsigned long   // need to figure out how to do 64 bit values.  Or port exisiting code to only use 48 bit
                             2421 ; 64   |#define INT64   unsigned long   // need to figure out how to do 64 bit values.  Or port exisiting code to only use 48 bit
                             2422 ; 65   |#define WCHAR   UINT16
                             2423 ; 66   |
                             2424 ; 67   |//UINT128 is 16 bytes or 6 words
                             2425 ; 68   |typedef struct UINT128_3500 {   
                             2426 ; 69   |    int val[6];     
                             2427 ; 70   |} UINT128_3500;
                             2428 ; 71   |
                             2429 ; 72   |#define UINT128   UINT128_3500
                             2430 ; 73   |
                             2431 ; 74   |// Little endian word packed byte strings:   
                             2432 ; 75   |//      _packed BYTE bTextVarName[]="a string";  bText is a packed byte string prefix
                             2433 ; 76   |// Convert to big endian words by reordering bytes from high to low using swizzle.
                             2434 ; 77   |// Little endian word packed byte strings:   
                             2435 ; 78   |//      _packed BYTE bTextVarName[]="a string";  bText is a packed byte string prefix
                             2436 ; 79   |// Convert to big endian words by reordering bytes from high to low using swizzle.
                             2437 ; 80   |
                             2438 ; 81   |// Declare Memory Spaces To Use When Coding
                             2439 ; 82   |// A. Sector Buffers
                             2440 ; 83   |#define SECTOR_BUFFER_MEM_X _X
                             2441 ; 84   |#define SECTOR_BUFFER_MEM_Y _Y
                             2442 ; 85   |#define SECTOR_BUFFER_MEM SECTOR_BUFFER_MEM_X
                             2443 ; 86   |typedef WORD SECTOR_BUFFER_MEM SECTOR_BUFFER;
                             2444 ; 87   |typedef SECTOR_BUFFER * P_SECTOR_BUFFER;
                             2445 ; 88   |// B. Media DDI Memory
                             2446 ; 89   |#define MEDIA_DDI_MEM _Y
                             2447 ; 90   |
                             2448 ; 91   |
                             2449 ; 92   |
                             2450 ; 93   |// Pointers to linear structures are labeled as: p<type prefix>VarName
                             2451 ; 94   |// Examples of circular pointers:
                             2452 ; 95   |//    INT CIRC cpiVarName
                             2453 ; 96   |//    DWORD CIRC cpdwVarName
                             2454 ; 97   |
                             2455 ; 98   |#define RETCODE INT                 // rcVarName
                             2456 ; 99   |
                             2457 ; 100  |// generic bitfield structure
                             2458 ; 101  |struct Bitfield {
                             2459 ; 102  |    unsigned int B0  :1;
                             2460 ; 103  |    unsigned int B1  :1;
                             2461 ; 104  |    unsigned int B2  :1;
                             2462 ; 105  |    unsigned int B3  :1;
                             2463 ; 106  |    unsigned int B4  :1;
                             2464 ; 107  |    unsigned int B5  :1;
                             2465 ; 108  |    unsigned int B6  :1;
                             2466 ; 109  |    unsigned int B7  :1;
                             2467 ; 110  |    unsigned int B8  :1;
                             2468 ; 111  |    unsigned int B9  :1;
                             2469 ; 112  |    unsigned int B10 :1;
                             2470 ; 113  |    unsigned int B11 :1;
                             2471 ; 114  |    unsigned int B12 :1;
                             2472 ; 115  |    unsigned int B13 :1;
                             2473 ; 116  |    unsigned int B14 :1;
                             2474 ; 117  |    unsigned int B15 :1;
                             2475 ; 118  |    unsigned int B16 :1;
                             2476 ; 119  |    unsigned int B17 :1;
                             2477 ; 120  |    unsigned int B18 :1;
                             2478 ; 121  |    unsigned int B19 :1;
                             2479 ; 122  |    unsigned int B20 :1;
                             2480 ; 123  |    unsigned int B21 :1;
                             2481 ; 124  |    unsigned int B22 :1;
                             2482 ; 125  |    unsigned int B23 :1;
                             2483 ; 126  |};
                             2484 ; 127  |
                             2485 ; 128  |union BitInt {
                             2486 ; 129  |        struct Bitfield B;
                             2487 ; 130  |        int        I;
                             2488 ; 131  |};
                             2489 ; 132  |
                             2490 ; 133  |#define MAX_MSG_LENGTH 10
                             2491 ; 134  |struct CMessage
                             2492 ; 135  |{
                             2493 ; 136  |        unsigned int m_uLength;
                             2494 ; 137  |        unsigned int m_uMsg[MAX_MSG_LENGTH];
                             2495 ; 138  |};
                             2496 ; 139  |
                             2497 ; 140  |typedef struct {
                             2498 ; 141  |    WORD m_wLength;
                             2499 ; 142  |    WORD m_wMessage;
                             2500 ; 143  |    WORD m_wParams[MAX_MSG_LENGTH];
                             2501 ; 144  |} Message;
                             2502 ; 145  |
                             2503 ; 146  |struct MessageQueueDescriptor
                             2504 ; 147  |{
                             2505 ; 148  |        int *m_pBase;
                             2506 ; 149  |        int m_iModulo;
                             2507 ; 150  |        int m_iSize;
                             2508 ; 151  |        int *m_pHead;
                             2509 ; 152  |        int *m_pTail;
                             2510 ; 153  |};
                             2511 ; 154  |
                             2512 ; 155  |struct ModuleEntry
                             2513 ; 156  |{
                             2514 ; 157  |    int m_iSignaledEventMask;
                             2515 ; 158  |    int m_iWaitEventMask;
                             2516 ; 159  |    int m_iResourceOfCode;
                             2517 ; 160  |    struct MessageQueueDescriptor *m_pMessageQueue;
                             2518 ; 161  |    int _asmfunc (*m_pProcessEntryPoint)(union WaitMask Signals,struct MessageQueueDescriptor *);
                             2519 ; 162  |    int _asmfunc (*m_pInitFunction)(struct MessageQueueDescriptor *);
                             2520 ; 163  |    int m_uTimeOutHigh;
                             2521 ; 164  |    int m_uTimeOutLow;
                             2522 ; 165  |    int _asmfunc (*m_pBackgroundFunction)(struct MessageQueueDescriptor *);
                             2523 ; 166  |};
                             2524 ; 167  |
                             2525 ; 168  |union WaitMask{
                             2526 ; 169  |    struct B{
                             2527 ; 170  |        unsigned int m_bNone     :1;
                             2528 ; 171  |        unsigned int m_bMessage  :1;
                             2529 ; 172  |        unsigned int m_bTimer    :1;
                             2530 ; 173  |        unsigned int m_bButton   :1;
                             2531 ; 174  |    } B;
                             2532 ; 175  |    int I;
                             2533 ; 176  |} ;
                             2534 ; 177  |
                             2535 ; 178  |
                             2536 ; 179  |struct Button {
                             2537 ; 180  |        WORD wButtonEvent;
                             2538 ; 181  |        WORD wUnused[MAX_MSG_LENGTH];   
                             2539 ; 182  |};
                             2540 ; 183  |
                             2541 ; 184  |struct Message {
                             2542 ; 185  |        WORD wMsgLength;
                             2543 ; 186  |        WORD wMsgCommand;
                             2544 ; 187  |        WORD wMsgParms[MAX_MSG_LENGTH-1];
                             2545 ; 188  |};
                             2546 ; 189  |
                             2547 ; 190  |union EventTypes {
                             2548 ; 191  |        struct CMessage msg;
                             2549 ; 192  |        struct Button Button ;
                             2550 ; 193  |        struct Message Message;
                             2551 ; 194  |};
                             2552 ; 195  |
                             2553 ; 196  |// next 2 used to get updater build to return correct protocol ver in scsi response.
                             2554 ; 197  |#define BUILD_TYPE_UPDATER  0x100
                             2555 ; 198  |#define BUILD_TYPE_HOSTLINK 0x101
                             2556 ; 199  |#define BUILD_TYPE_PLAYER   0x102
                             2557 ; 200  |
                             2558 ; 201  |// Resets part if RETAIL build. DEBUG build executes debug instruction to halt.
                             2559 ; 202  |#define SystemHalt() __asm(" include 'sysmacro.asm' \n error") 
                             2560 ; 203  |#define assert(x)    if(!(x)) __asm(" include 'sysmacro.asm' \n error")
                             2561 ; 204  |
                             2562 ; 205  |#if DEBUG
                             2563 ; 206  |// For DEBUG builds, DebugBuildAssert(condition) halts if condition evaluates to FALSE. 
                             2564 ; 207  |#define DebugBuildAssert(x)    if(!(x)) __asm(" debug ")
                             2565 ; 208  |#else 
                             2566 ; 209  |// For RETAIL builds, DebugBuildAssert(condition) does nothing & execution continues rather than halt or reset. 
                             2567 ; 210  |#define DebugBuildAssert(x)    
                             2568 ; 211  |#endif
                             2569 ; 212  |
                             2570 ; 213  |// Do this in your C files to make a reminder that's displayed during the build.
                             2571 ; 214  |//  #pragma asm
                             2572 ; 215  |//  WARN 'Note to builder: reminder to do this after verifying that'
                             2573 ; 216  |//  #pragma endasm
                             2574 ; 217  |
                             2575 ; 218  |
                             2576 ; 219  |#ifdef COLOR_262K
                             2577 ; 220  |#define RGB(r,g,b)    ((0x0000FC & (r)) << 10) | ((0x0000FC & (g)) << 4) | ((0x0000FC & (b)) >> 2)    //262k
                             2578 ; 221  |#elif defined(COLOR_65K)
                             2579 ; 222  |#define RGB(r,g,b)    ((0x0000F8 & (r)) << 8) | ((0x0000FC & (g)) << 3) | ((0x0000F8 & (b)) >> 3)  //65k
                             2580 ; 223  |#else
                             2581 ; 224  |#define RGB(r,g,b)       ((0x0000F0 & (r)) << 4) | (0x0000F0 & (g)) | ((0x0000F0 & (b)) >> 4)
                             2582 ; 225  |#endif
TASKING DSP2410 assembler v1.5r1 Build 138 SN 00100122
                                                                                                                                                                                                                                                       Page  11

M:ADDR CODE           CYCLES LINE SOURCELINE
                             2583 ; 226  |    
                             2584 ; 227  |#endif // #ifndef _TYPES_H
                             2585 
                             2587 
                             2588 ; 2    |#include "fstypes.h"
                             2589 
                             2591 
                             2592 ; 1    |#ifndef _FS_TYPE_H_
                             2593 ; 2    |#define _FS_TYPE_H_
                             2594 ; 3    |
                             2595 ; 4    |#include   "types.h"
                             2596 ; 5    |
                             2597 ; 6    |// move FSMEDIA_TABLE from devicetable.h  15Apr2005   First moved in SDK2.6.
                             2598 ; 7    |typedef struct
                             2599 ; 8    |{
                             2600 ; 9    |
                             2601 ; 10   |INT     _Y BytesPerSector;
                             2602 ; 11   |INT     _Y SectorsPerCluster;
                             2603 ; 12   |INT     _Y RsvdSectors;
                             2604 ; 13   |INT     _Y NoOfFATs;
                             2605 ; 14   |INT     _Y MaxRootDirEntries;
                             2606 ; 15   |LONG    _Y TotalSectors;
                             2607 ; 16   |LONG    _Y FATSize;
                             2608 ; 17   |LONG    _Y RootdirCluster;
                             2609 ; 18   |//INT   _Y FSInfoSector;
                             2610 ; 19   |//INT   _Y BkBootSector;
                             2611 ; 20   |LONG    _Y NextFreeCluster;
                             2612 ; 21   |LONG    _Y TotalFreeClusters;
                             2613 ; 22   |INT     _Y RootDirSectors;
                             2614 ; 23   |INT     _Y FIRSTDataSector;
                             2615 ; 24   |INT    _Y FATType;
                             2616 ; 25   |LONG   _Y TotalNoofclusters;
                             2617 ; 26   |INT    _Y ClusterMask;
                             2618 ; 27   |INT    _Y ClusterShift;
                             2619 ; 28   |INT    _Y SectorShift;
                             2620 ; 29   |INT    _Y SectorMask;
                             2621 ; 30   |INT    _Y DevicePresent;
                             2622 ; 31   |LONG   _Y FirRootdirsec;
                             2623 ; 32   |INT             _Y FSInfoSector;
                             2624 ; 33   |}FSMEDIA_TABLE;
                             2625 ; 34   |
                             2626 ; 35   |
                             2627 ; 36   |#define         MAXDEVICES              2
                             2628 ; 37   |//#define       NUMCACHES               8  // this is already in fsproj.h (2 for player 2 for mtp as of 28jun2005) TOVERIFY 2 ok for player and mtp. 
                             2629 ; 38   |
                             2630 ; 39   |// NOTE:  This offset is the same no matter what the sector actual size!  
                             2631 ; 40   |//        TOVERIFY 3.0 doesn't have this defined but uses it in filesystempresent.c. lbmlc def'd it here so I insert it here.
                             2632 ; 41   |#define         FATFS_SIGNATURE_OFFSET  510
                             2633 ; 42   |#define         BOOTSECTOR              0
                             2634 ; 43   |#define     FSINFOSECTOR        1
                             2635 ; 44   |
                             2636 ; 45   |#define     READ_MODE           1
                             2637 ; 46   |#define     WRITE_MODE          2
                             2638 ; 47   |#define     APPEND_MODE         4
                             2639 ; 48   |#define     SEQ_WRITE_MODE      8
                             2640 ; 49   |#define     DIRECTORY_MODE         16
                             2641 ; 50   |#define     CREATE_MODE        32
                             2642 ; 51   |
                             2643 ; 52   |#define     RPLUS               5
                             2644 ; 53   |#define     WPLUS                   6
                             2645 ; 54   |#define     APLUS               7
                             2646 ; 55   |
                             2647 ; 56   |
                             2648 ; 57   |
                             2649 ; 58   |#define     X_MEMORY            0
                             2650 ; 59   |#define     Y_MEMORY            2
                             2651 ; 60   |#define     P_MEMORY            4
                             2652 ; 61   |
                             2653 ; 62   |#define     FAT12               0 
                             2654 ; 63   |#define     FAT16               1   
                             2655 ; 64   |#define     FAT32               2 
                             2656 ; 65   |
                             2657 ; 66   |
                             2658 ; 67   |#define FAT12EOF            0x0FFF
                             2659 ; 68   |#define FAT16EOF            0xFFFF
                             2660 ; 69   |#define FAT32EOF            0x0FFFFFFF
                             2661 ; 70   |
                             2662 ; 71   |
                             2663 ; 72   |
                             2664 ; 73   |#define FAT12FREECX         0x000
                             2665 ; 74   |#define FAT16FREECX         0x0000
                             2666 ; 75   |#define FAT32FREECX         0x00000000
                             2667 ; 76   |
                             2668 ; 77   |
                             2669 ; 78   |#define  DBCS               1
                             2670 ; 79   |#define  UNICODE            2
                             2671 ; 80   |
                             2672 ; 81   |
                             2673 ; 82   |#define     CREATION_DATE       1
                             2674 ; 83   |#define     CREATION_TIME       2
                             2675 ; 84   |#define     MODIFICATION_DATE   3
                             2676 ; 85   |#define     MODIFICATION_TIME   4
                             2677 ; 86   |
                             2678 ; 87   |
                             2679 ; 88   |#define     READ_ONLY      0X01
                             2680 ; 89   |#define     HIDDEN         0X02
                             2681 ; 90   |#define     SYSTEM         0X04
                             2682 ; 91   |#define     VOLUME_ID      0X08
                             2683 ; 92   |#define     DIRECTORY      0X10
                             2684 ; 93   |#define     ARCHIVE        0X20
                             2685 ; 94   |
                             2686 ; 95   |#define READCOUNTER         105
                             2687 ; 96   |#define WRITECOUNTER        100
                             2688 ; 97   |#define FLUSHCOUNTER        200
                             2689 ; 98   |
                             2690 ; 99   |
                             2691 ; 100  |#define DEFAULT_MEMORY      Y_MEMORY
                             2692 ; 101  |
                             2693 ; 102  |#define  CWD_HANDLE           0
                             2694 ; 103  |#define  DIRECTORY_HANDLE     1
                             2695 ; 104  |#define  FIRST_VALID_HANDLE   2
                             2696 ; 105  |#define  END_OF_DIR_PATH      3
                             2697 ; 106  |
                             2698 ; 107  |//Constants for Sector read and write (Normal and FAT 
                             2699 ; 108  |#define         NORMALTYPE              0
                             2700 ; 109  |#define         FATTYPE                 1
                             2701 ; 110  |#define     RAWTYPE         2
                             2702 ; 111  |
                             2703 ; 112  |#define  SHORTNAMERES_CH      6
                             2704 ; 113  |#define  LONGNAMERES_CH       9
                             2705 ; 114  |#define  MAXFILENAME_CH       260
                             2706 ; 115  |
                             2707 ; 116  |#define VOLUME_TYPE          0
                             2708 ; 117  |#define DIR_TYPE             1
                             2709 ; 118  |#define FILE_TYPE            2
                             2710 ; 119  |                                           
                             2711 ; 120  |#define WRITE_TYPE_RANDOM               0
                             2712 ; 121  |#define WRITE_TYPE_SEQ_FIRST    1
                             2713 ; 122  |#define WRITE_TYPE_SEQ_NEXT             2
                             2714 ; 123  |#define WRITE_TYPE_NOREADBACK   3
                             2715 ; 124  |                  
                             2716 ; 125  |
                             2717 ; 126  |#define     HANDLEENTRYSIZE         19
                             2718 ; 127  |
                             2719 ; 128  |// DEVICERECORDSIZE is now only defined in cachedef.h so deleted from here in first 3.1 prelim 
                             2720 ; 129  |
                             2721 ; 130  |#define     CACHEDESCRSIZE          8
                             2722 ; 131  |#define     CACHEBUFSIZE            705
                             2723 ; 132  |
                             2724 ; 133  |#define     UCS2s                     0
                             2725 ; 134  |#define     UCS3s                     1
                             2726 ; 135  |
                             2727 ; 136  |#define     FAT32FSIFREECOUNTSIZE       4
                             2728 ; 137  |
                             2729 ; 138  |#endif // _FS_TYPE_H_
                             2730 ; 139  |
                             2731 
                             2733 
                             2734 ; 3    |
                             2735 ; 4    |/* moved FSMEDIA_TABLE to fstypes.h   15Apr2005 */
                             2736 ; 5    |/*
                             2737 ; 6    |typedef struct
                             2738 ; 7    |{
                             2739 ; 8    |
                             2740 ; 9    |INT     _Y BytesPerSector;
                             2741 ; 10   |INT     _Y SectorsPerCluster;
                             2742 ; 11   |INT     _Y RsvdSectors;
                             2743 ; 12   |INT     _Y NoOfFATs;
                             2744 ; 13   |INT     _Y MaxRootDirEntries;
                             2745 ; 14   |LONG    _Y TotalSectors;
                             2746 ; 15   |LONG    _Y FATSize;
                             2747 ; 16   |LONG    _Y RootdirCluster;
                             2748 ; 17   |//INT   _Y FSInfoSector;
                             2749 ; 18   |//INT   _Y BkBootSector;
                             2750 ; 19   |LONG    _Y NextFreeCluster;
                             2751 ; 20   |LONG    _Y TotalFreeClusters;
                             2752 ; 21   |INT     _Y RootDirSectors;
                             2753 ; 22   |INT     _Y FIRSTDataSector;
                             2754 ; 23   |INT    _Y FATType;
                             2755 ; 24   |LONG   _Y TotalNoofclusters;
                             2756 ; 25   |INT    _Y ClusterMask;
                             2757 ; 26   |INT    _Y ClusterShift;
                             2758 ; 27   |INT    _Y SectorShift;
                             2759 ; 28   |INT    _Y SectorMask;
                             2760 ; 29   |INT    _Y DevicePresent;
                             2761 ; 30   |LONG   _Y FirRootdirsec;
                             2762 ; 31   |INT             _Y FSInfoSector;
                             2763 ; 32   |}FSMEDIA_TABLE;
                             2764 ; 33   |*/
                             2765 ; 34   |
                             2766 ; 35   |
                             2767 
                             2769 
                             2770 ; 3    |#include "cachemem.h"
                             2771 
                             2773 
                             2774 ; 1    |#include "types.h"
                             2775 
                             2777 
                             2778 ; 1    |////////////////////////////////////////////////////////////////////////////////
                             2779 ; 2    |// Copyright(C) SigmaTel, Inc. 2000-2004
                             2780 ; 3    |//
                             2781 ; 4    |// Filename: types.h
                             2782 ; 5    |// Description: Standard data types
                             2783 ; 6    |////////////////////////////////////////////////////////////////////////////////
                             2784 ; 7    |
                             2785 ; 8    |#ifndef _TYPES_H
                             2786 ; 9    |#define _TYPES_H
                             2787 ; 10   |
                             2788 ; 11   |// TODO:  move this outta here!
                             2789 ; 12   |#if !defined(NOERROR)
                             2790 ; 13   |#define NOERROR 0
                             2791 ; 14   |#define SUCCESS 0
                             2792 ; 15   |#endif 
                             2793 ; 16   |#if !defined(SUCCESS)
                             2794 ; 17   |#define SUCCESS  0
                             2795 ; 18   |#endif
                             2796 ; 19   |#if !defined(ERROR)
                             2797 ; 20   |#define ERROR   -1
                             2798 ; 21   |#endif
                             2799 ; 22   |#if !defined(FALSE)
                             2800 ; 23   |#define FALSE 0
                             2801 ; 24   |#endif
                             2802 ; 25   |#if !defined(TRUE)
                             2803 ; 26   |#define TRUE  1
                             2804 ; 27   |#endif
                             2805 ; 28   |
                             2806 ; 29   |#if !defined(NULL)
                             2807 ; 30   |#define NULL 0
                             2808 ; 31   |#endif
                             2809 ; 32   |
                             2810 ; 33   |#define MAX_INT     0x7FFFFF
                             2811 ; 34   |#define MAX_LONG    0x7FFFFFffffff
                             2812 ; 35   |        // max positive unsigned long value: -1 == 0xFFFFFFffffff
                             2813 ; 36   |#define MAX_ULONG   (-1) 
                             2814 ; 37   |
                             2815 ; 38   |#define WORD_SIZE   24              // word size in bits
                             2816 ; 39   |#define BYTES_PER_WORD 3            // 8 bit bytes
                             2817 ; 40   |
                             2818 ; 41   |
                             2819 ; 42   |#define BYTE    unsigned char       // btVarName
                             2820 ; 43   |#define CHAR    signed char         // cVarName
                             2821 ; 44   |#define USHORT  unsigned short      // usVarName
                             2822 ; 45   |#define SHORT   unsigned short      // sVarName
                             2823 ; 46   |#define WORD    unsigned int        // wVarName
                             2824 ; 47   |#define INT     signed int          // iVarName
                             2825 ; 48   |#define DWORD   unsigned long       // dwVarName
                             2826 ; 49   |#define LONG    signed long         // lVarName
                             2827 ; 50   |#define BOOL    unsigned int        // bVarName
                             2828 ; 51   |#define FRACT   _fract              // frVarName
                             2829 ; 52   |#define LFRACT  long _fract         // lfrVarName
                             2830 ; 53   |#define CIRC    _circ               // cp<type prefix>VarName (see below)
                             2831 ; 54   |#define FLOAT   float               // fVarName
                             2832 ; 55   |#define DBL     double              // dVarName
                             2833 ; 56   |#define ENUM    enum                // eVarName
                             2834 ; 57   |#define CMX     _complex            // cmxVarName
                             2835 ; 58   |typedef WORD UCS3;                   // 
                             2836 ; 59   |
                             2837 ; 60   |#define UINT16  unsigned short
                             2838 ; 61   |#define UINT8   unsigned char   
                             2839 ; 62   |#define UINT32  unsigned long
TASKING DSP2410 assembler v1.5r1 Build 138 SN 00100122
                                                                                                                                                                                                                                                       Page  12

M:ADDR CODE           CYCLES LINE SOURCELINE
                             2840 ; 63   |#define UINT64  unsigned long   // need to figure out how to do 64 bit values.  Or port exisiting code to only use 48 bit
                             2841 ; 64   |#define INT64   unsigned long   // need to figure out how to do 64 bit values.  Or port exisiting code to only use 48 bit
                             2842 ; 65   |#define WCHAR   UINT16
                             2843 ; 66   |
                             2844 ; 67   |//UINT128 is 16 bytes or 6 words
                             2845 ; 68   |typedef struct UINT128_3500 {   
                             2846 ; 69   |    int val[6];     
                             2847 ; 70   |} UINT128_3500;
                             2848 ; 71   |
                             2849 ; 72   |#define UINT128   UINT128_3500
                             2850 ; 73   |
                             2851 ; 74   |// Little endian word packed byte strings:   
                             2852 ; 75   |//      _packed BYTE bTextVarName[]="a string";  bText is a packed byte string prefix
                             2853 ; 76   |// Convert to big endian words by reordering bytes from high to low using swizzle.
                             2854 ; 77   |// Little endian word packed byte strings:   
                             2855 ; 78   |//      _packed BYTE bTextVarName[]="a string";  bText is a packed byte string prefix
                             2856 ; 79   |// Convert to big endian words by reordering bytes from high to low using swizzle.
                             2857 ; 80   |
                             2858 ; 81   |// Declare Memory Spaces To Use When Coding
                             2859 ; 82   |// A. Sector Buffers
                             2860 ; 83   |#define SECTOR_BUFFER_MEM_X _X
                             2861 ; 84   |#define SECTOR_BUFFER_MEM_Y _Y
                             2862 ; 85   |#define SECTOR_BUFFER_MEM SECTOR_BUFFER_MEM_X
                             2863 ; 86   |typedef WORD SECTOR_BUFFER_MEM SECTOR_BUFFER;
                             2864 ; 87   |typedef SECTOR_BUFFER * P_SECTOR_BUFFER;
                             2865 ; 88   |// B. Media DDI Memory
                             2866 ; 89   |#define MEDIA_DDI_MEM _Y
                             2867 ; 90   |
                             2868 ; 91   |
                             2869 ; 92   |
                             2870 ; 93   |// Pointers to linear structures are labeled as: p<type prefix>VarName
                             2871 ; 94   |// Examples of circular pointers:
                             2872 ; 95   |//    INT CIRC cpiVarName
                             2873 ; 96   |//    DWORD CIRC cpdwVarName
                             2874 ; 97   |
                             2875 ; 98   |#define RETCODE INT                 // rcVarName
                             2876 ; 99   |
                             2877 ; 100  |// generic bitfield structure
                             2878 ; 101  |struct Bitfield {
                             2879 ; 102  |    unsigned int B0  :1;
                             2880 ; 103  |    unsigned int B1  :1;
                             2881 ; 104  |    unsigned int B2  :1;
                             2882 ; 105  |    unsigned int B3  :1;
                             2883 ; 106  |    unsigned int B4  :1;
                             2884 ; 107  |    unsigned int B5  :1;
                             2885 ; 108  |    unsigned int B6  :1;
                             2886 ; 109  |    unsigned int B7  :1;
                             2887 ; 110  |    unsigned int B8  :1;
                             2888 ; 111  |    unsigned int B9  :1;
                             2889 ; 112  |    unsigned int B10 :1;
                             2890 ; 113  |    unsigned int B11 :1;
                             2891 ; 114  |    unsigned int B12 :1;
                             2892 ; 115  |    unsigned int B13 :1;
                             2893 ; 116  |    unsigned int B14 :1;
                             2894 ; 117  |    unsigned int B15 :1;
                             2895 ; 118  |    unsigned int B16 :1;
                             2896 ; 119  |    unsigned int B17 :1;
                             2897 ; 120  |    unsigned int B18 :1;
                             2898 ; 121  |    unsigned int B19 :1;
                             2899 ; 122  |    unsigned int B20 :1;
                             2900 ; 123  |    unsigned int B21 :1;
                             2901 ; 124  |    unsigned int B22 :1;
                             2902 ; 125  |    unsigned int B23 :1;
                             2903 ; 126  |};
                             2904 ; 127  |
                             2905 ; 128  |union BitInt {
                             2906 ; 129  |        struct Bitfield B;
                             2907 ; 130  |        int        I;
                             2908 ; 131  |};
                             2909 ; 132  |
                             2910 ; 133  |#define MAX_MSG_LENGTH 10
                             2911 ; 134  |struct CMessage
                             2912 ; 135  |{
                             2913 ; 136  |        unsigned int m_uLength;
                             2914 ; 137  |        unsigned int m_uMsg[MAX_MSG_LENGTH];
                             2915 ; 138  |};
                             2916 ; 139  |
                             2917 ; 140  |typedef struct {
                             2918 ; 141  |    WORD m_wLength;
                             2919 ; 142  |    WORD m_wMessage;
                             2920 ; 143  |    WORD m_wParams[MAX_MSG_LENGTH];
                             2921 ; 144  |} Message;
                             2922 ; 145  |
                             2923 ; 146  |struct MessageQueueDescriptor
                             2924 ; 147  |{
                             2925 ; 148  |        int *m_pBase;
                             2926 ; 149  |        int m_iModulo;
                             2927 ; 150  |        int m_iSize;
                             2928 ; 151  |        int *m_pHead;
                             2929 ; 152  |        int *m_pTail;
                             2930 ; 153  |};
                             2931 ; 154  |
                             2932 ; 155  |struct ModuleEntry
                             2933 ; 156  |{
                             2934 ; 157  |    int m_iSignaledEventMask;
                             2935 ; 158  |    int m_iWaitEventMask;
                             2936 ; 159  |    int m_iResourceOfCode;
                             2937 ; 160  |    struct MessageQueueDescriptor *m_pMessageQueue;
                             2938 ; 161  |    int _asmfunc (*m_pProcessEntryPoint)(union WaitMask Signals,struct MessageQueueDescriptor *);
                             2939 ; 162  |    int _asmfunc (*m_pInitFunction)(struct MessageQueueDescriptor *);
                             2940 ; 163  |    int m_uTimeOutHigh;
                             2941 ; 164  |    int m_uTimeOutLow;
                             2942 ; 165  |    int _asmfunc (*m_pBackgroundFunction)(struct MessageQueueDescriptor *);
                             2943 ; 166  |};
                             2944 ; 167  |
                             2945 ; 168  |union WaitMask{
                             2946 ; 169  |    struct B{
                             2947 ; 170  |        unsigned int m_bNone     :1;
                             2948 ; 171  |        unsigned int m_bMessage  :1;
                             2949 ; 172  |        unsigned int m_bTimer    :1;
                             2950 ; 173  |        unsigned int m_bButton   :1;
                             2951 ; 174  |    } B;
                             2952 ; 175  |    int I;
                             2953 ; 176  |} ;
                             2954 ; 177  |
                             2955 ; 178  |
                             2956 ; 179  |struct Button {
                             2957 ; 180  |        WORD wButtonEvent;
                             2958 ; 181  |        WORD wUnused[MAX_MSG_LENGTH];   
                             2959 ; 182  |};
                             2960 ; 183  |
                             2961 ; 184  |struct Message {
                             2962 ; 185  |        WORD wMsgLength;
                             2963 ; 186  |        WORD wMsgCommand;
                             2964 ; 187  |        WORD wMsgParms[MAX_MSG_LENGTH-1];
                             2965 ; 188  |};
                             2966 ; 189  |
                             2967 ; 190  |union EventTypes {
                             2968 ; 191  |        struct CMessage msg;
                             2969 ; 192  |        struct Button Button ;
                             2970 ; 193  |        struct Message Message;
                             2971 ; 194  |};
                             2972 ; 195  |
                             2973 ; 196  |// next 2 used to get updater build to return correct protocol ver in scsi response.
                             2974 ; 197  |#define BUILD_TYPE_UPDATER  0x100
                             2975 ; 198  |#define BUILD_TYPE_HOSTLINK 0x101
                             2976 ; 199  |#define BUILD_TYPE_PLAYER   0x102
                             2977 ; 200  |
                             2978 ; 201  |// Resets part if RETAIL build. DEBUG build executes debug instruction to halt.
                             2979 ; 202  |#define SystemHalt() __asm(" include 'sysmacro.asm' \n error") 
                             2980 ; 203  |#define assert(x)    if(!(x)) __asm(" include 'sysmacro.asm' \n error")
                             2981 ; 204  |
                             2982 ; 205  |#if DEBUG
                             2983 ; 206  |// For DEBUG builds, DebugBuildAssert(condition) halts if condition evaluates to FALSE. 
                             2984 ; 207  |#define DebugBuildAssert(x)    if(!(x)) __asm(" debug ")
                             2985 ; 208  |#else 
                             2986 ; 209  |// For RETAIL builds, DebugBuildAssert(condition) does nothing & execution continues rather than halt or reset. 
                             2987 ; 210  |#define DebugBuildAssert(x)    
                             2988 ; 211  |#endif
                             2989 ; 212  |
                             2990 ; 213  |// Do this in your C files to make a reminder that's displayed during the build.
                             2991 ; 214  |//  #pragma asm
                             2992 ; 215  |//  WARN 'Note to builder: reminder to do this after verifying that'
                             2993 ; 216  |//  #pragma endasm
                             2994 ; 217  |
                             2995 ; 218  |
                             2996 ; 219  |#ifdef COLOR_262K
                             2997 ; 220  |#define RGB(r,g,b)    ((0x0000FC & (r)) << 10) | ((0x0000FC & (g)) << 4) | ((0x0000FC & (b)) >> 2)    //262k
                             2998 ; 221  |#elif defined(COLOR_65K)
                             2999 ; 222  |#define RGB(r,g,b)    ((0x0000F8 & (r)) << 8) | ((0x0000FC & (g)) << 3) | ((0x0000F8 & (b)) >> 3)  //65k
                             3000 ; 223  |#else
                             3001 ; 224  |#define RGB(r,g,b)       ((0x0000F0 & (r)) << 4) | (0x0000F0 & (g)) | ((0x0000F0 & (b)) >> 4)
                             3002 ; 225  |#endif
                             3003 ; 226  |    
                             3004 ; 227  |#endif // #ifndef _TYPES_H
                             3005 
                             3007 
                             3008 ; 2    |#include "fstypes.h"
                             3009 
                             3011 
                             3012 ; 1    |#ifndef _FS_TYPE_H_
                             3013 ; 2    |#define _FS_TYPE_H_
                             3014 ; 3    |
                             3015 ; 4    |#include   "types.h"
                             3016 ; 5    |
                             3017 ; 6    |// move FSMEDIA_TABLE from devicetable.h  15Apr2005   First moved in SDK2.6.
                             3018 ; 7    |typedef struct
                             3019 ; 8    |{
                             3020 ; 9    |
                             3021 ; 10   |INT     _Y BytesPerSector;
                             3022 ; 11   |INT     _Y SectorsPerCluster;
                             3023 ; 12   |INT     _Y RsvdSectors;
                             3024 ; 13   |INT     _Y NoOfFATs;
                             3025 ; 14   |INT     _Y MaxRootDirEntries;
                             3026 ; 15   |LONG    _Y TotalSectors;
                             3027 ; 16   |LONG    _Y FATSize;
                             3028 ; 17   |LONG    _Y RootdirCluster;
                             3029 ; 18   |//INT   _Y FSInfoSector;
                             3030 ; 19   |//INT   _Y BkBootSector;
                             3031 ; 20   |LONG    _Y NextFreeCluster;
                             3032 ; 21   |LONG    _Y TotalFreeClusters;
                             3033 ; 22   |INT     _Y RootDirSectors;
                             3034 ; 23   |INT     _Y FIRSTDataSector;
                             3035 ; 24   |INT    _Y FATType;
                             3036 ; 25   |LONG   _Y TotalNoofclusters;
                             3037 ; 26   |INT    _Y ClusterMask;
                             3038 ; 27   |INT    _Y ClusterShift;
                             3039 ; 28   |INT    _Y SectorShift;
                             3040 ; 29   |INT    _Y SectorMask;
                             3041 ; 30   |INT    _Y DevicePresent;
                             3042 ; 31   |LONG   _Y FirRootdirsec;
                             3043 ; 32   |INT             _Y FSInfoSector;
                             3044 ; 33   |}FSMEDIA_TABLE;
                             3045 ; 34   |
                             3046 ; 35   |
                             3047 ; 36   |#define         MAXDEVICES              2
                             3048 ; 37   |//#define       NUMCACHES               8  // this is already in fsproj.h (2 for player 2 for mtp as of 28jun2005) TOVERIFY 2 ok for player and mtp. 
                             3049 ; 38   |
                             3050 ; 39   |// NOTE:  This offset is the same no matter what the sector actual size!  
                             3051 ; 40   |//        TOVERIFY 3.0 doesn't have this defined but uses it in filesystempresent.c. lbmlc def'd it here so I insert it here.
                             3052 ; 41   |#define         FATFS_SIGNATURE_OFFSET  510
                             3053 ; 42   |#define         BOOTSECTOR              0
                             3054 ; 43   |#define     FSINFOSECTOR        1
                             3055 ; 44   |
                             3056 ; 45   |#define     READ_MODE           1
                             3057 ; 46   |#define     WRITE_MODE          2
                             3058 ; 47   |#define     APPEND_MODE         4
                             3059 ; 48   |#define     SEQ_WRITE_MODE      8
                             3060 ; 49   |#define     DIRECTORY_MODE         16
                             3061 ; 50   |#define     CREATE_MODE        32
                             3062 ; 51   |
                             3063 ; 52   |#define     RPLUS               5
                             3064 ; 53   |#define     WPLUS                   6
                             3065 ; 54   |#define     APLUS               7
                             3066 ; 55   |
                             3067 ; 56   |
                             3068 ; 57   |
                             3069 ; 58   |#define     X_MEMORY            0
                             3070 ; 59   |#define     Y_MEMORY            2
                             3071 ; 60   |#define     P_MEMORY            4
                             3072 ; 61   |
                             3073 ; 62   |#define     FAT12               0 
                             3074 ; 63   |#define     FAT16               1   
                             3075 ; 64   |#define     FAT32               2 
                             3076 ; 65   |
                             3077 ; 66   |
                             3078 ; 67   |#define FAT12EOF            0x0FFF
                             3079 ; 68   |#define FAT16EOF            0xFFFF
                             3080 ; 69   |#define FAT32EOF            0x0FFFFFFF
                             3081 ; 70   |
                             3082 ; 71   |
                             3083 ; 72   |
                             3084 ; 73   |#define FAT12FREECX         0x000
                             3085 ; 74   |#define FAT16FREECX         0x0000
                             3086 ; 75   |#define FAT32FREECX         0x00000000
                             3087 ; 76   |
                             3088 ; 77   |
                             3089 ; 78   |#define  DBCS               1
                             3090 ; 79   |#define  UNICODE            2
                             3091 ; 80   |
                             3092 ; 81   |
TASKING DSP2410 assembler v1.5r1 Build 138 SN 00100122
                                                                                                                                                                                                                                                       Page  13

M:ADDR CODE           CYCLES LINE SOURCELINE
                             3093 ; 82   |#define     CREATION_DATE       1
                             3094 ; 83   |#define     CREATION_TIME       2
                             3095 ; 84   |#define     MODIFICATION_DATE   3
                             3096 ; 85   |#define     MODIFICATION_TIME   4
                             3097 ; 86   |
                             3098 ; 87   |
                             3099 ; 88   |#define     READ_ONLY      0X01
                             3100 ; 89   |#define     HIDDEN         0X02
                             3101 ; 90   |#define     SYSTEM         0X04
                             3102 ; 91   |#define     VOLUME_ID      0X08
                             3103 ; 92   |#define     DIRECTORY      0X10
                             3104 ; 93   |#define     ARCHIVE        0X20
                             3105 ; 94   |
                             3106 ; 95   |#define READCOUNTER         105
                             3107 ; 96   |#define WRITECOUNTER        100
                             3108 ; 97   |#define FLUSHCOUNTER        200
                             3109 ; 98   |
                             3110 ; 99   |
                             3111 ; 100  |#define DEFAULT_MEMORY      Y_MEMORY
                             3112 ; 101  |
                             3113 ; 102  |#define  CWD_HANDLE           0
                             3114 ; 103  |#define  DIRECTORY_HANDLE     1
                             3115 ; 104  |#define  FIRST_VALID_HANDLE   2
                             3116 ; 105  |#define  END_OF_DIR_PATH      3
                             3117 ; 106  |
                             3118 ; 107  |//Constants for Sector read and write (Normal and FAT 
                             3119 ; 108  |#define         NORMALTYPE              0
                             3120 ; 109  |#define         FATTYPE                 1
                             3121 ; 110  |#define     RAWTYPE         2
                             3122 ; 111  |
                             3123 ; 112  |#define  SHORTNAMERES_CH      6
                             3124 ; 113  |#define  LONGNAMERES_CH       9
                             3125 ; 114  |#define  MAXFILENAME_CH       260
                             3126 ; 115  |
                             3127 ; 116  |#define VOLUME_TYPE          0
                             3128 ; 117  |#define DIR_TYPE             1
                             3129 ; 118  |#define FILE_TYPE            2
                             3130 ; 119  |                                           
                             3131 ; 120  |#define WRITE_TYPE_RANDOM               0
                             3132 ; 121  |#define WRITE_TYPE_SEQ_FIRST    1
                             3133 ; 122  |#define WRITE_TYPE_SEQ_NEXT             2
                             3134 ; 123  |#define WRITE_TYPE_NOREADBACK   3
                             3135 ; 124  |                  
                             3136 ; 125  |
                             3137 ; 126  |#define     HANDLEENTRYSIZE         19
                             3138 ; 127  |
                             3139 ; 128  |// DEVICERECORDSIZE is now only defined in cachedef.h so deleted from here in first 3.1 prelim 
                             3140 ; 129  |
                             3141 ; 130  |#define     CACHEDESCRSIZE          8
                             3142 ; 131  |#define     CACHEBUFSIZE            705
                             3143 ; 132  |
                             3144 ; 133  |#define     UCS2s                     0
                             3145 ; 134  |#define     UCS3s                     1
                             3146 ; 135  |
                             3147 ; 136  |#define     FAT32FSIFREECOUNTSIZE       4
                             3148 ; 137  |
                             3149 ; 138  |#endif // _FS_TYPE_H_
                             3150 ; 139  |
                             3151 
                             3153 
                             3154 ; 3    |
                             3155 ; 4    |typedef struct {
                             3156 ; 5    |        INT CacheValid;
                             3157 ; 6    |    INT DeviceNum;
                             3158 ; 7    |        LONG SectorNumber;
                             3159 ; 8    |        INT WriteAttribute;
                             3160 ; 9    |        INT Mode;
                             3161 ; 10   |        INT CacheCounter;
                             3162 ; 11   |        INT _X *CacheMem;
                             3163 ; 12   |} tCACHEDESCR;
                             3164 ; 13   |
                             3165 
                             3167 
                             3168 ; 4    |//#include "dirrecord.h"
                             3169 ; 5    |
                             3170 ; 6    |extern INT maxhandles;
                             3171 ; 7    |extern INT maxdevices;
                             3172 ; 8    |extern INT maxcaches;
                             3173 ; 9    |extern INT device[];
                             3174 ; 10   |extern INT gCurrentRecord;
                             3175 
                             3191 
                             3192 ; 11   |extern HANDLETABLE *Handle;
                             3193 
                             3217 
                             3218 ; 12   |extern FSMEDIA_TABLE *MediaTable;
                             3219 ; 13   |extern _packed char gCurrentWorkingdirectory[]; // use blank instead of 80 here. actually 256 multiple now
                             3220 
                             3232 
                             3233 ; 14   |extern tCACHEDESCR *CacheDesc;
                             3234 ; 15   |extern ss_FsCopyBuffer;
                             3235 ; 16   |
                             3236 ; 17   |//Non-reentrant
                             3237 ; 18   |
                             3238 ; 19   |        //      SGTL-HK 27-05-2005
                             3239 ; 20   |extern _reentrant INT CreateDirectory(INT HandleNumber,_packed char *Buffer,INT length,INT index,INT stringtype);
                             3240 ; 21   |
                             3241 ; 22   |extern _reentrant LONG Ftell(INT HandleNumber);//Non _reentrant 
                             3242 ; 23   |extern _reentrant INT Fcreate(INT HandleNumber,_packed char *FileName,INT stringtype,INT length,INT index);
                             3243 ; 24   |extern _reentrant LONG GetFileSize(INT HandleNumber);
                             3244 ; 25   |extern _reentrant INT UpdateFileSize(INT HandleNumber,INT flag);
                             3245 ; 26   |extern _reentrant INT GetNewcluster(INT Handlenumber);
                             3246 ; 27   |extern _reentrant INT IsHandleWriteAllocated(INT HandleNumber);
                             3247 ; 28   |extern _reentrant INT Searchfreehandleallocate(void);
                             3248 ; 29   |extern _reentrant LONG FirstfreeAndallocate(INT DeviceNum);
                             3249 ; 30   |extern _reentrant LONG FindnextFreecurrentcluster(INT DeviceNum,LONG clusterno);
                             3250 ; 31   |extern _reentrant INT _X *FirstfreeAndallocateFAT32(INT DeviceNum,LONG FATsectrono,INT FAToffset ,INT _X *buf, LONG *ClusterNo);
                             3251 ; 32   |extern _reentrant INT  WriteFATentry(INT DeviceNum,LONG FATsector,INT FATNtryoffset,LONG clusterno,LONG writentry);
                             3252 ; 33   |extern _reentrant INT WriteSector(INT deviceNumber, LONG sectorNumber, INT Offset, INT *Sourcebuffer,INT SourceOffset,INT size,INT Source_Memory, INT SectorType,INT Modulo);
                             3253 ; 34   |extern _reentrant INT FlushSector(INT deviceNumber, LONG sectorNumber,INT SectorType);
                             3254 ; 35   |#ifdef k_opt_dynamic_cache
                             3255 ; 36   |extern _reentrant INT _X *ReadSector(INT DeviceNum, LONG sectorNum,INT SectorType);
                             3256 ; 37   |#else
                             3257 ; 38   |extern INT _X *ReadSector(INT DeviceNum, LONG sectorNum,INT SectorType);
                             3258 ; 39   |#endif
                             3259 ; 40   |extern _reentrant INT EraseSector(INT deviceNumber, LONG sectorNumber);
                             3260 ; 41   |
                             3261 ; 42   |
                             3262 ; 43   |//extern INT filesetattrib(INT HandleNumber,INT dirattribute); TOVERIFY2. 3.05 commented this ln out. 2.600 had is present.
                             3263 ; 44   |//extern INT filesetdate(INT HandleNumber,INT crt_mod_date_time_para,DIR_DATE *dirdate,DIR_TIME *dirtime);
                             3264 ; 45   |//Reentrant
                             3265 ; 46   |//extern INT ReleaseBuffer(INT deviceNumber, LONG sectorNumber);
                             3266 ; 47   |extern _reentrant LONG Firstsectorofcluster(INT DeviceNum,LONG clusterno);
                             3267 ; 48   |extern _reentrant LONG ReadFATentry(INT Devicenum,LONG FATsector,INT FATNtryoffset,LONG clusterno);
                             3268 ; 49   |extern _reentrant INT _X *ReadFAT12Entry(INT DeviceNum,INT *FATsectorNo,INT FATntryoffset,LONG clusterNum,INT _X *buf,INT *FATentry);
                             3269 ; 50   |extern INT  FSInit(INT _X *bufx, INT _Y *bufy, INT maxdevices, INT maxhandles, INT maxcaches);
                             3270 ; 51   |
                             3271 ; 52   |extern RETCODE _reentrant MediaInit(WORD wLogMediaNumber);
                             3272 ; 53   |extern _reentrant INT Handleactive(INT HandleNumber);
                             3273 ; 54   |extern INT DriveLetter[];
                             3274 ; 55   |extern _reentrant LONG Findnextcluster(INT DeviceNum,LONG clusterno);
                             3275 ; 56   |
                             3276 ; 57   |extern _reentrant INT UpdateHandleOffsets(INT HandleNumber);
                             3277 ; 58   |extern _reentrant INT FindNextSector(INT Device,INT HandleNumber);
                             3278 ; 59   |extern _reentrant INT Updatehandlemode(INT HandleNumber,INT Mode);
                             3279 ; 60   |
                             3280 ; 61   |extern _reentrant LONG Feof(INT HandleNumber);
                             3281 ; 62   |extern _reentrant INT *Fputs(INT HandleNumber,INT *Buffer);
                             3282 ; 63   |extern _reentrant LONG Fread(INT HandleNumber,INT *Buffer,LONG NumBytesToRead,INT Source_Memory, INT modulo);
                             3283 ; 64   |extern  _reentrant INT Fgetc(INT HandleNumber);
                             3284 ; 65   |extern _reentrant INT Fputc(INT HandleNumber,INT ByteToWrite);
                             3285 ; 66   |extern _reentrant INT Stringlength(INT *Buffer);
                             3286 ; 67   |extern _reentrant LONG ReadDirectoryRecord(INT HandleNumber,INT RecordNumber,INT *Buffer);
                             3287 ; 68   |extern _reentrant INT Fseek(INT HandleNumber,LONG NumBytesToSeek,INT SeekPosition);
                             3288 ; 69   |extern _reentrant INT CreateDirRecord(_packed char *Buffer,INT HandleNumber,LONG ClusterNumber,INT DirAttr,INT stringtype,INT length,INT index,INT *unicodebuffer);
                             3289 ; 70   |extern _reentrant INT FindfreeRecord(INT Handlenumber,INT count);
                             3290 ; 71   |extern _reentrant LONG Firstrootdirsector(INT DeviceNum);
                             3291 ; 72   |//extern _reentrant INT Searchfreerecord(INT DeviceNum ,LONG sectorNum);
                             3292 ; 73   |
                             3293 ; 74   |extern _reentrant INT  Readdevicerecord(INT DeviceNum);
                             3294 ; 75   |extern INT MediaRead(INT deviceNumber, LONG sectorNumber,int _X *readbuf,INT SectorType);
                             3295 ; 76   |extern INT MediaWrite(INT deviceNumber,LONG sectorNumber, int _X *readbuf,INT SectorType);
                             3296 ; 77   |extern _reentrant INT Shortdirmatch(INT HandleNumber,INT RecordNo,_packed char *shortname,_packed char *file,INT *buf,INT Flag,INT lenght,INT index,INT *Buffer);
                             3297 ; 78   |extern _reentrant INT UpdateHandle(INT HandleNumber,LONG clusterno);
                             3298 ; 79   |extern _reentrant void Uppercase(_packed char *file); 
                             3299 ; 80   |extern _reentrant void ArrangeFileName(INT *Buffer,INT *ShortFileName);
                             3300 ; 81   |extern _reentrant INT ClearCluster(INT HandleNumber);
                             3301 ; 82   |
                             3302 ; 83   |extern _reentrant INT Fopen(_packed char *filepath,_packed char *mode);
                             3303 ; 84   |extern _reentrant LONG FATsectorno(INT DeviceNum,LONG clusterno,INT *FATNtryoffset);
                             3304 ; 85   |
                             3305 ; 86   |extern _reentrant LONG Fwrite(INT HandleNumber,INT  *Buffer,LONG NumBytesToWrite,INT Source_Memory,INT modulo);
                             3306 ; 87   |
                             3307 ; 88   |extern _reentrant INT ExtractPath(_packed char *filepath,INT *index);
                             3308 ; 89   |extern _reentrant INT ExtractPathW(_packed char *filepath,INT *index);
                             3309 ; 90   |extern _reentrant INT SetHandleforsearch(INT HandleNumber,_packed char *filepath,INT stringtype,INT *index);
                             3310 ; 91   |extern _reentrant INT Changepath(INT HandleNumber,_packed char *filepath,INT stringtype,INT startposition,INT index,INT RecordNumber);
                             3311 ; 92   |extern _reentrant INT Longdirmatch(INT HandleNumber,INT RecordNo,_packed char *file,INT length,INT index,INT stringtype);
                             3312 ; 93   |extern _reentrant INT Getname(_packed char *filepath, INT currentPosition);
                             3313 ; 94   |extern _reentrant INT Strlength(_packed char *filepath);
                             3314 ; 95   |extern _reentrant INT StrlengthW(_packed char *filepath);                        
                             3315 ; 96   |extern _reentrant INT MatchdirRecordW(INT HandleNumber,INT RecordNo,_packed char *file,INT *buf,INT length,INT index);
                             3316 ; 97   |extern _reentrant INT MatchdirRecord(INT HandleNumber,INT RecordNo,_packed char *file,INT *buf,INT Flag,INT lenght,INT index,INT *Buffer);
                             3317 ; 98   |extern _reentrant LONG Searchdirectory(INT HandleNumber,_packed char *file,INT stringtype,INT Flag,INT lenght,INT index,INT *Buffer,BOOL *Ptr); // sdk3.05 ver at left; ,BOOL bInputIsSFN,BOOL *Ptr); extra end param
                                   in 2.600 ver. TOVERIFY2
                             3318 ; 99   |extern _reentrant INT GetnameW(_packed char *filepath,INT currentPosition);
                             3319 ; 100  |extern _reentrant INT Extractfilename(_packed char *filepath,INT length, INT *index);
                             3320 ; 101  |extern _reentrant INT Changecase(INT wordno);
                             3321 ; 102  |extern _reentrant INT ReadRootdirRecord(INT HandleNumber,INT RecordNumber,INT *Buffer);
                             3322 ; 103  |extern _reentrant LONG Totalfreecluster(INT DeviceNum);
                             3323 ; 104  |
                             3324 ; 105  |extern INT maxhandles;
                             3325 ; 106  |extern INT maxdevices;
                             3326 ; 107  |
                             3327 ; 108  |extern _reentrant INT Isfileopen(INT HandleNumber);
                             3328 ; 109  |extern _reentrant INT Freehandle(INT HandleNumber);
                             3329 ; 110  |extern _reentrant INT DeleteRecord(INT HandleNumber, INT RecordNo);
                             3330 ; 111  |extern _reentrant INT Isdirectoryempty( INT Handlenumber);
                             3331 ; 112  |extern _reentrant INT Strcpy(_packed char *filepath, _packed char *file_path1,INT length, INT index);
                             3332 ; 113  |extern _reentrant INT Strcpyw(_packed char *filepath, _packed char *file_path1,INT length, INT index);
                             3333 ; 114  |extern _reentrant void Setfilename(_packed char *buf, _packed char *buffer_1);
                             3334 ; 115  |extern _reentrant INT Chdir(_packed char *filepath);
                             3335 ; 116  |extern _reentrant INT Rmdir(_packed char *filepath);
                             3336 ; 117  |extern _reentrant INT Rmdirw(_packed char *filepath);
                             3337 ; 118  |
                             3338 ; 119  |extern _reentrant INT Mkdir(_packed char *filepath);
                             3339 
                             3341 
                             3342 ; 120  |
                             3343 ; 121  |        //      SGTL-HK 27-05-2005
                             3344 ; 122  |extern _reentrant INT Mkdirw(UCS3 *filepath);
                             3345 ; 123  |
                             3346 ; 124  |extern _reentrant INT Setcwd(_packed char *filepath, _packed char *gCworkingDir,INT index,INT length);
                             3347 ; 125  |extern _reentrant INT DeleteContent(INT HandleNumber, INT flag);
                             3348 ; 126  |
                             3349 ; 127  |extern _reentrant _packed char *Getcwd(void);
                             3350 ; 128  |
                             3351 ; 129  |extern _reentrant _packed char *Fgets(INT HandleNumber,INT NumBytes,_packed char *Buffer);
                             3352 ; 130  |extern _reentrant INT Fopenw(INT  *filepath,_packed char *mode);
                             3353 ; 131  |extern _reentrant INT SetcurrentPos(INT HandleNumber,INT RecordNumber);
                             3354 ; 132  |extern _reentrant INT Fremove(_packed char *filepath);
                             3355 ; 133  |extern _reentrant INT Fremovew(_packed char *filepath);
                             3356 ; 134  |
                             3357 ; 135  |extern  _reentrant  INT ChangeToRootdirectory(INT HandleNumber);
                             3358 ; 136  |                                                  
                             3359 ; 137  |extern _reentrant void DBCSToUnicode(_packed unsigned char *pDBCS, WORD *pUnicode,INT iLength);
                             3360 ; 138  |extern _reentrant LONG TotalfreeclusterFAT16(INT DeviceNum);
                             3361 ; 139  |extern _reentrant Ferror(INT HandleNumber);
                             3362 ; 140  |extern _reentrant INT Fclose(INT HandleNumber);
                             3363 ; 141  |extern _reentrant Fflush(INT HandleNumber);
                             3364 ; 142  |extern _reentrant INT FastOpen(LONG Key,_packed char *mode);
                             3365 ; 143  |//extern _reentrant INT filegetdate(INT HandleNumber,INT crt_mod_date_time_para,DIR_DATE *dirdate,DIR_TIME *dirtime);
                             3366 ; 144  |extern _reentrant INT filegetattrib(_packed char *FilePath);
                             3367 ; 145  |extern _reentrant INT FileSystemPresent(INT DeviceNum);
                             3368 ; 146  |extern _reentrant INT CheckspaceinRootdir(INT Handlenumber,INT count);
                             3369 ; 147  |extern _reentrant LONG FgetFastHandle(INT HandleNumber);
                             3370 ; 148  |
                             3371 ; 149  |extern  _reentrant void Setshortfilename(INT HandleNumber,INT *Buffer,_packed char *shortfilename);
                             3372 ; 150  |extern _reentrant INT ArrangeLongFileName(INT HandleNumber,_packed char *filename,INT count,INT chksum);
                             3373 ; 151  |extern  _reentrant INT IsShortNameValid(_packed char *Buffer,INT length,INT index);
                             3374 ; 152  |
                             3375 ; 153  |extern _reentrant INT ChkSum(_packed char *filename);
                             3376 ; 154  |extern INT Short_NameRes_Ch[];  // sdk3.05 moved these from explicit _X to default Y mem space. TOVERIFY2 ensure that references don't refer to _X now.
                             3377 ; 155  |extern INT Long_NameRes_Ch[];   // "
                             3378 ; 156  |extern _reentrant void UnicodeToOEM(_packed char *file,_packed char *shortname,INT length,INT index);
                             3379 ; 157  |
                             3380 ; 158  |extern _reentrant INT getcontentcode(INT Type,_packed char *filepath,INT OUTcode);
                             3381 ; 159  |
                             3382 ; 160  |extern _reentrant INT Checkcode(_packed char *buf,INT Count);
                             3383 ; 161  |extern _reentrant INT CreateShortDirRecord(INT *filename,INT HandleNumber,LONG ClusterNumber,INT DirAttr);
                             3384 ; 162  |extern _reentrant INT CheckVolumeCode(INT HandleNumber);
                             3385 ; 163  |extern _reentrant INT Convert_itoa(INT Number,_packed char *string);
                             3386 ; 164  |extern _reentrant INT GetChar(_packed char *Buffer,INT *offset);
                             3387 ; 165  |extern _reentrant void PutChar(_packed char *Buffer,INT *offset,INT Char);
                             3388 ; 166  |extern _reentrant void DBCStoTwoByteString(_packed char *filename,INT *string,INT length,INT index);
                             3389 ; 167  |extern _reentrant INT DiscardTrailigPeriods(_packed char *Buffer,INT length,INT index,INT flag);
                             3390 ; 168  |extern _reentrant void GetDBCSstring(_packed char *filename,INT *string);
                             3391 ; 169  |extern _reentrant INT  DiscardTrailigPeriodsw(_packed char *Buffer,INT length,INT index);
                             3392 ; 170  |extern _reentrant  INT Extractfilenamew(_packed char *filepath, INT *index);
                             3393 ; 171  |extern _reentrant INT IsCurrWorkDir(INT HandleNumber);
                             3394 ; 172  |extern INT _reentrant ConstructLongFileName(INT HandleNumber, INT RecordNumber, INT *LFNBuffer);
TASKING DSP2410 assembler v1.5r1 Build 138 SN 00100122
                                                                                                                                                                                                                                                       Page  14

M:ADDR CODE           CYCLES LINE SOURCELINE
                             3395 ; 173  |extern _reentrant INT GetUnicodeWord(INT *Buffer,INT LFNOffset);
                             3396 ; 174  |extern _reentrant INT GetShortfilename(LONG Key,INT *Buffer);
                             3397 ; 175  |extern _reentrant LONG GetRootdirkey(INT DeviceNumber);
                             3398 ; 176  |extern _reentrant INT strcpyUCS3_2(INT *filepath_UCS3,INT *filepath_UCS2, INT index, INT length);
                             3399 ; 177  |extern _reentrant INT StrlengthUCS3(_packed char *filepath);
                             3400 ; 178  |extern _reentrant INT  DiscardTrailigPeriodsUCS3(_packed char *Buffer,INT length,INT index);
                             3401 ; 179  |extern  INT _reentrant  GetVolumeLabel(_packed char *Buffer,INT DeviceNum);
                             3402 ; 180  |extern _reentrant INT SetVolumeLabel(_packed char *Buffer,INT DeviceNum);
                             3403 ; 181  |
                             3404 ; 182  |extern _reentrant void UpdateFSInfo (void); // sdk2.600 had this line but sdk3.05 did not. New func from TH.
                             3405 
                             3407 
                             3408 ; 19   |#include "filesystem.h"
                             3409 
                             3411 
                             3412 ; 1    |////////////////////////////////////////////////////////////////////////////////
                             3413 ; 2    |//  Copyright(C) SigmaTel, Inc. 2001
                             3414 ; 3    |//
                             3415 ; 4    |//  File        : FileSystem.h
                             3416 ; 5    |//  Description : Header File for File System
                             3417 ; 6    |////////////////////////////////////////////////////////////////////////////////
                             3418 ; 7    |
                             3419 ; 8    |#ifndef _FILESYSTEM_H
                             3420 ; 9    |#define _FILESYSTEM_H
                             3421 ; 10   |
                             3422 ; 11   |#include "types.h"
                             3423 
                             3425 
                             3426 ; 1    |////////////////////////////////////////////////////////////////////////////////
                             3427 ; 2    |// Copyright(C) SigmaTel, Inc. 2000-2004
                             3428 ; 3    |//
                             3429 ; 4    |// Filename: types.h
                             3430 ; 5    |// Description: Standard data types
                             3431 ; 6    |////////////////////////////////////////////////////////////////////////////////
                             3432 ; 7    |
                             3433 ; 8    |#ifndef _TYPES_H
                             3434 ; 9    |#define _TYPES_H
                             3435 ; 10   |
                             3436 ; 11   |// TODO:  move this outta here!
                             3437 ; 12   |#if !defined(NOERROR)
                             3438 ; 13   |#define NOERROR 0
                             3439 ; 14   |#define SUCCESS 0
                             3440 ; 15   |#endif 
                             3441 ; 16   |#if !defined(SUCCESS)
                             3442 ; 17   |#define SUCCESS  0
                             3443 ; 18   |#endif
                             3444 ; 19   |#if !defined(ERROR)
                             3445 ; 20   |#define ERROR   -1
                             3446 ; 21   |#endif
                             3447 ; 22   |#if !defined(FALSE)
                             3448 ; 23   |#define FALSE 0
                             3449 ; 24   |#endif
                             3450 ; 25   |#if !defined(TRUE)
                             3451 ; 26   |#define TRUE  1
                             3452 ; 27   |#endif
                             3453 ; 28   |
                             3454 ; 29   |#if !defined(NULL)
                             3455 ; 30   |#define NULL 0
                             3456 ; 31   |#endif
                             3457 ; 32   |
                             3458 ; 33   |#define MAX_INT     0x7FFFFF
                             3459 ; 34   |#define MAX_LONG    0x7FFFFFffffff
                             3460 ; 35   |        // max positive unsigned long value: -1 == 0xFFFFFFffffff
                             3461 ; 36   |#define MAX_ULONG   (-1) 
                             3462 ; 37   |
                             3463 ; 38   |#define WORD_SIZE   24              // word size in bits
                             3464 ; 39   |#define BYTES_PER_WORD 3            // 8 bit bytes
                             3465 ; 40   |
                             3466 ; 41   |
                             3467 ; 42   |#define BYTE    unsigned char       // btVarName
                             3468 ; 43   |#define CHAR    signed char         // cVarName
                             3469 ; 44   |#define USHORT  unsigned short      // usVarName
                             3470 ; 45   |#define SHORT   unsigned short      // sVarName
                             3471 ; 46   |#define WORD    unsigned int        // wVarName
                             3472 ; 47   |#define INT     signed int          // iVarName
                             3473 ; 48   |#define DWORD   unsigned long       // dwVarName
                             3474 ; 49   |#define LONG    signed long         // lVarName
                             3475 ; 50   |#define BOOL    unsigned int        // bVarName
                             3476 ; 51   |#define FRACT   _fract              // frVarName
                             3477 ; 52   |#define LFRACT  long _fract         // lfrVarName
                             3478 ; 53   |#define CIRC    _circ               // cp<type prefix>VarName (see below)
                             3479 ; 54   |#define FLOAT   float               // fVarName
                             3480 ; 55   |#define DBL     double              // dVarName
                             3481 ; 56   |#define ENUM    enum                // eVarName
                             3482 ; 57   |#define CMX     _complex            // cmxVarName
                             3483 ; 58   |typedef WORD UCS3;                   // 
                             3484 ; 59   |
                             3485 ; 60   |#define UINT16  unsigned short
                             3486 ; 61   |#define UINT8   unsigned char   
                             3487 ; 62   |#define UINT32  unsigned long
                             3488 ; 63   |#define UINT64  unsigned long   // need to figure out how to do 64 bit values.  Or port exisiting code to only use 48 bit
                             3489 ; 64   |#define INT64   unsigned long   // need to figure out how to do 64 bit values.  Or port exisiting code to only use 48 bit
                             3490 ; 65   |#define WCHAR   UINT16
                             3491 ; 66   |
                             3492 ; 67   |//UINT128 is 16 bytes or 6 words
                             3493 ; 68   |typedef struct UINT128_3500 {   
                             3494 ; 69   |    int val[6];     
                             3495 ; 70   |} UINT128_3500;
                             3496 ; 71   |
                             3497 ; 72   |#define UINT128   UINT128_3500
                             3498 ; 73   |
                             3499 ; 74   |// Little endian word packed byte strings:   
                             3500 ; 75   |//      _packed BYTE bTextVarName[]="a string";  bText is a packed byte string prefix
                             3501 ; 76   |// Convert to big endian words by reordering bytes from high to low using swizzle.
                             3502 ; 77   |// Little endian word packed byte strings:   
                             3503 ; 78   |//      _packed BYTE bTextVarName[]="a string";  bText is a packed byte string prefix
                             3504 ; 79   |// Convert to big endian words by reordering bytes from high to low using swizzle.
                             3505 ; 80   |
                             3506 ; 81   |// Declare Memory Spaces To Use When Coding
                             3507 ; 82   |// A. Sector Buffers
                             3508 ; 83   |#define SECTOR_BUFFER_MEM_X _X
                             3509 ; 84   |#define SECTOR_BUFFER_MEM_Y _Y
                             3510 ; 85   |#define SECTOR_BUFFER_MEM SECTOR_BUFFER_MEM_X
                             3511 ; 86   |typedef WORD SECTOR_BUFFER_MEM SECTOR_BUFFER;
                             3512 ; 87   |typedef SECTOR_BUFFER * P_SECTOR_BUFFER;
                             3513 ; 88   |// B. Media DDI Memory
                             3514 ; 89   |#define MEDIA_DDI_MEM _Y
                             3515 ; 90   |
                             3516 ; 91   |
                             3517 ; 92   |
                             3518 ; 93   |// Pointers to linear structures are labeled as: p<type prefix>VarName
                             3519 ; 94   |// Examples of circular pointers:
                             3520 ; 95   |//    INT CIRC cpiVarName
                             3521 ; 96   |//    DWORD CIRC cpdwVarName
                             3522 ; 97   |
                             3523 ; 98   |#define RETCODE INT                 // rcVarName
                             3524 ; 99   |
                             3525 ; 100  |// generic bitfield structure
                             3526 ; 101  |struct Bitfield {
                             3527 ; 102  |    unsigned int B0  :1;
                             3528 ; 103  |    unsigned int B1  :1;
                             3529 ; 104  |    unsigned int B2  :1;
                             3530 ; 105  |    unsigned int B3  :1;
                             3531 ; 106  |    unsigned int B4  :1;
                             3532 ; 107  |    unsigned int B5  :1;
                             3533 ; 108  |    unsigned int B6  :1;
                             3534 ; 109  |    unsigned int B7  :1;
                             3535 ; 110  |    unsigned int B8  :1;
                             3536 ; 111  |    unsigned int B9  :1;
                             3537 ; 112  |    unsigned int B10 :1;
                             3538 ; 113  |    unsigned int B11 :1;
                             3539 ; 114  |    unsigned int B12 :1;
                             3540 ; 115  |    unsigned int B13 :1;
                             3541 ; 116  |    unsigned int B14 :1;
                             3542 ; 117  |    unsigned int B15 :1;
                             3543 ; 118  |    unsigned int B16 :1;
                             3544 ; 119  |    unsigned int B17 :1;
                             3545 ; 120  |    unsigned int B18 :1;
                             3546 ; 121  |    unsigned int B19 :1;
                             3547 ; 122  |    unsigned int B20 :1;
                             3548 ; 123  |    unsigned int B21 :1;
                             3549 ; 124  |    unsigned int B22 :1;
                             3550 ; 125  |    unsigned int B23 :1;
                             3551 ; 126  |};
                             3552 ; 127  |
                             3553 ; 128  |union BitInt {
                             3554 ; 129  |        struct Bitfield B;
                             3555 ; 130  |        int        I;
                             3556 ; 131  |};
                             3557 ; 132  |
                             3558 ; 133  |#define MAX_MSG_LENGTH 10
                             3559 ; 134  |struct CMessage
                             3560 ; 135  |{
                             3561 ; 136  |        unsigned int m_uLength;
                             3562 ; 137  |        unsigned int m_uMsg[MAX_MSG_LENGTH];
                             3563 ; 138  |};
                             3564 ; 139  |
                             3565 ; 140  |typedef struct {
                             3566 ; 141  |    WORD m_wLength;
                             3567 ; 142  |    WORD m_wMessage;
                             3568 ; 143  |    WORD m_wParams[MAX_MSG_LENGTH];
                             3569 ; 144  |} Message;
                             3570 ; 145  |
                             3571 ; 146  |struct MessageQueueDescriptor
                             3572 ; 147  |{
                             3573 ; 148  |        int *m_pBase;
                             3574 ; 149  |        int m_iModulo;
                             3575 ; 150  |        int m_iSize;
                             3576 ; 151  |        int *m_pHead;
                             3577 ; 152  |        int *m_pTail;
                             3578 ; 153  |};
                             3579 ; 154  |
                             3580 ; 155  |struct ModuleEntry
                             3581 ; 156  |{
                             3582 ; 157  |    int m_iSignaledEventMask;
                             3583 ; 158  |    int m_iWaitEventMask;
                             3584 ; 159  |    int m_iResourceOfCode;
                             3585 ; 160  |    struct MessageQueueDescriptor *m_pMessageQueue;
                             3586 ; 161  |    int _asmfunc (*m_pProcessEntryPoint)(union WaitMask Signals,struct MessageQueueDescriptor *);
                             3587 ; 162  |    int _asmfunc (*m_pInitFunction)(struct MessageQueueDescriptor *);
                             3588 ; 163  |    int m_uTimeOutHigh;
                             3589 ; 164  |    int m_uTimeOutLow;
                             3590 ; 165  |    int _asmfunc (*m_pBackgroundFunction)(struct MessageQueueDescriptor *);
                             3591 ; 166  |};
                             3592 ; 167  |
                             3593 ; 168  |union WaitMask{
                             3594 ; 169  |    struct B{
                             3595 ; 170  |        unsigned int m_bNone     :1;
                             3596 ; 171  |        unsigned int m_bMessage  :1;
                             3597 ; 172  |        unsigned int m_bTimer    :1;
                             3598 ; 173  |        unsigned int m_bButton   :1;
                             3599 ; 174  |    } B;
                             3600 ; 175  |    int I;
                             3601 ; 176  |} ;
                             3602 ; 177  |
                             3603 ; 178  |
                             3604 ; 179  |struct Button {
                             3605 ; 180  |        WORD wButtonEvent;
                             3606 ; 181  |        WORD wUnused[MAX_MSG_LENGTH];   
                             3607 ; 182  |};
                             3608 ; 183  |
                             3609 ; 184  |struct Message {
                             3610 ; 185  |        WORD wMsgLength;
                             3611 ; 186  |        WORD wMsgCommand;
                             3612 ; 187  |        WORD wMsgParms[MAX_MSG_LENGTH-1];
                             3613 ; 188  |};
                             3614 ; 189  |
                             3615 ; 190  |union EventTypes {
                             3616 ; 191  |        struct CMessage msg;
                             3617 ; 192  |        struct Button Button ;
                             3618 ; 193  |        struct Message Message;
                             3619 ; 194  |};
                             3620 ; 195  |
                             3621 ; 196  |// next 2 used to get updater build to return correct protocol ver in scsi response.
                             3622 ; 197  |#define BUILD_TYPE_UPDATER  0x100
                             3623 ; 198  |#define BUILD_TYPE_HOSTLINK 0x101
                             3624 ; 199  |#define BUILD_TYPE_PLAYER   0x102
                             3625 ; 200  |
                             3626 ; 201  |// Resets part if RETAIL build. DEBUG build executes debug instruction to halt.
                             3627 ; 202  |#define SystemHalt() __asm(" include 'sysmacro.asm' \n error") 
                             3628 ; 203  |#define assert(x)    if(!(x)) __asm(" include 'sysmacro.asm' \n error")
                             3629 ; 204  |
                             3630 ; 205  |#if DEBUG
                             3631 ; 206  |// For DEBUG builds, DebugBuildAssert(condition) halts if condition evaluates to FALSE. 
                             3632 ; 207  |#define DebugBuildAssert(x)    if(!(x)) __asm(" debug ")
                             3633 ; 208  |#else 
                             3634 ; 209  |// For RETAIL builds, DebugBuildAssert(condition) does nothing & execution continues rather than halt or reset. 
                             3635 ; 210  |#define DebugBuildAssert(x)    
                             3636 ; 211  |#endif
                             3637 ; 212  |
                             3638 ; 213  |// Do this in your C files to make a reminder that's displayed during the build.
                             3639 ; 214  |//  #pragma asm
                             3640 ; 215  |//  WARN 'Note to builder: reminder to do this after verifying that'
                             3641 ; 216  |//  #pragma endasm
                             3642 ; 217  |
                             3643 ; 218  |
                             3644 ; 219  |#ifdef COLOR_262K
                             3645 ; 220  |#define RGB(r,g,b)    ((0x0000FC & (r)) << 10) | ((0x0000FC & (g)) << 4) | ((0x0000FC & (b)) >> 2)    //262k
                             3646 ; 221  |#elif defined(COLOR_65K)
                             3647 ; 222  |#define RGB(r,g,b)    ((0x0000F8 & (r)) << 8) | ((0x0000FC & (g)) << 3) | ((0x0000F8 & (b)) >> 3)  //65k
                             3648 ; 223  |#else
TASKING DSP2410 assembler v1.5r1 Build 138 SN 00100122
                                                                                                                                                                                                                                                       Page  15

M:ADDR CODE           CYCLES LINE SOURCELINE
                             3649 ; 224  |#define RGB(r,g,b)       ((0x0000F0 & (r)) << 4) | (0x0000F0 & (g)) | ((0x0000F0 & (b)) >> 4)
                             3650 ; 225  |#endif
                             3651 ; 226  |    
                             3652 ; 227  |#endif // #ifndef _TYPES_H
                             3653 
                             3655 
                             3656 ; 12   |
                             3657 ; 13   |
                             3658 ; 14   |// File attributes
                             3659 ; 15   |#ifndef _FS_ATTRIBUTES
                             3660 ; 16   |#define _FS_ATTRIBUTES
                             3661 ; 17   |#define READ        1
                             3662 ; 18   |#define WRITE       2
                             3663 ; 19   |#define WRITE_PLUS  3
                             3664 ; 20   |#define APPEND      4
                             3665 ; 21   |#define TRUNCATE    8
                             3666 ; 22   |#define CREATE      16
                             3667 ; 23   |#endif
                             3668 ; 24   |
                             3669 ; 25   |//#ifndef FAT12
                             3670 ; 26   |//#define FAT12   1
                             3671 ; 27   |//#endif
                             3672 ; 28   |//
                             3673 ; 29   |#ifndef FAT16
                             3674 ; 30   |#define FAT16   2
                             3675 ; 31   |#endif
                             3676 ; 32   |
                             3677 ; 33   |#define MEM_SPACE_P 0x100000
                             3678 ; 34   |#define MEM_SPACE_Y 0x400000
                             3679 ; 35   |#define MEM_SPACE_X 0x800000
                             3680 ; 36   |
                             3681 ; 37   |#define FILE_SYS_MODE_READ  0
                             3682 ; 38   |#define FILE_SYS_MODE_WRITE 1
                             3683 ; 39   | 
                             3684 ; 40   |#define ATTR_READ_ONLY      0x01
                             3685 ; 41   |#define ATTR_HIDDEN         0x02
                             3686 ; 42   |#define ATTR_SYSTEM         0x04
                             3687 ; 43   |#define ATTR_VOLUME_ID      0x08
                             3688 ; 44   |#define ATTR_DIRECTORY      0x10
                             3689 ; 45   |#define ATTR_ARCHIVE        0x20
                             3690 ; 46   |#define ATTR_LONG_NAME      ATTR_READ_ONLY|ATTR_HIDDEN|ATTR_SYSTEM|ATTR_VOLUME_ID
                             3691 ; 47   |
                             3692 ; 48   |#define SEEK_SET           -1
                             3693 ; 49   |#define SEEK_CUR            0
                             3694 ; 50   |#define SEEK_END            1
                             3695 ; 51   |
                             3696 ; 52   |#define DEVICE_INSTALLED              (WORD)(0)
                             3697 ; 53   |#define DEVICE_NOT_FOUND              (WORD)(2)
                             3698 ; 54   |#define INVALID_FILESYSTEM                        (WORD)(3)
                             3699 ; 55   |#define DEVICE_INVALID                (WORD)(-1)
                             3700 ; 56   |#define DEVICE_ERROR_WRITE_PROTECTED  (WORD)(-2)
                             3701 ; 57   |
                             3702 ; 58   |#define MEDIA_SIZE_TOTAL_SECTORS    0
                             3703 ; 59   |#define MEDIA_SIZE_TOTAL_BYTES      1
                             3704 ; 60   |#define MEDIA_SIZE_BYTES_PER_SECTOR 2
                             3705 ; 61   |#define MEDIA_SIZE_IN_MEGABYTES     3     
                             3706 ; 62   |
                             3707 ; 63   |#define READ_TYPE_NORMAL            0
                             3708 ; 64   |#define READ_TYPE_FAT               1
                             3709 ; 65   |#define READ_TYPE_RAW               2
                             3710 ; 66   |
                             3711 ; 67   |
                             3712 ; 68   |#ifdef MEDIA_DDI_PARTIAL_SEQ_ENABLE
                             3713 ; 69   |    #define WRITE_TYPE_RANDOM                   0
                             3714 ; 70   |    #define WRITE_TYPE_SEQ_FIRST                1
                             3715 ; 71   |    #define WRITE_TYPE_SEQ_NEXT                 2
                             3716 ; 72   |    #define WRITE_TYPE_RESET_CLEAN_UP           3
                             3717 ; 73   |    #define WRITE_TYPE_PARTIAL_SEQ_FIRST        4
                             3718 ; 74   |    #define WRITE_TYPE_PARTIAL_SEQ_NEXT         5
                             3719 ; 75   |    #define WRITE_TYPE_PARTIAL_SEQ_LAST         6
                             3720 ; 76   |    #ifdef MEDIA_DDI_RAW_SECTOR_SERVER_ENABLE
                             3721 ; 77   |        #define WRITE_TYPE_RANDOM_RAW               7
                             3722 ; 78   |        #define WRITE_TYPE_SEQ_FIRST_RAW            8
                             3723 ; 79   |        #define WRITE_TYPE_SEQ_NEXT_RAW             9
                             3724 ; 80   |        #define WRITE_TYPE_PARTIAL_SEQ_FIRST_RAW    10
                             3725 ; 81   |        #define WRITE_TYPE_PARTIAL_SEQ_NEXT_RAW     11
                             3726 ; 82   |        #define WRITE_TYPE_PARTIAL_SEQ_LAST_RAW     12
                             3727 ; 83   |    #endif
                             3728 ; 84   |#else
                             3729 ; 85   |    #define WRITE_TYPE_RANDOM                   0
                             3730 ; 86   |    #define WRITE_TYPE_SEQ_FIRST                1
                             3731 ; 87   |    #define WRITE_TYPE_SEQ_NEXT                 2
                             3732 ; 88   |    #ifdef MEDIA_DDI_RAW_SECTOR_SERVER_ENABLE
                             3733 ; 89   |        #define WRITE_TYPE_RANDOM_RAW               3
                             3734 ; 90   |        #define WRITE_TYPE_SEQ_FIRST_RAW            4
                             3735 ; 91   |        #define WRITE_TYPE_SEQ_NEXT_RAW             5
                             3736 ; 92   |    #endif
                             3737 ; 93   |#endif
                             3738 ; 94   |    #define WRITE_TYPE_UNDEFINED 0xFFFFFF
                             3739 ; 95   |
                             3740 ; 96   |
                             3741 ; 97   |#ifndef MAX_FILENAME_LENGTH
                             3742 ; 98   |#define MAX_FILENAME_LENGTH 256
                             3743 ; 99   |#endif
                             3744 ; 100  |
                             3745 ; 101  |typedef struct {
                             3746 ; 102  |    WORD wNumberOfZones;
                             3747 ; 103  |    WORD wSizeInMegaBytes;
                             3748 ; 104  |} SMARTMEDIA_CHIP_INFO;
                             3749 ; 105  |
                             3750 ; 106  |typedef struct {
                             3751 ; 107  |    WORD wBootIdentification;
                             3752 ; 108  |    WORD wStartHeadNumber;
                             3753 ; 109  |    WORD wStartSectorNumber;
                             3754 ; 110  |    WORD wStartCylinderNumber;
                             3755 ; 111  |    WORD wSystemIdentification;
                             3756 ; 112  |    WORD wEndHeadNumber;
                             3757 ; 113  |    WORD wEndSectorNumber;
                             3758 ; 114  |    WORD wEndCylinderNumber;
                             3759 ; 115  |    WORD wStartLogicalSectorNumberHigh;
                             3760 ; 116  |    WORD wStartLogicalSectorNumberLow;
                             3761 ; 117  |    WORD wPartitionSizeHigh;
                             3762 ; 118  |    WORD wPartitionSizeLow;
                             3763 ; 119  |} SMARTMEDIA_PARTITION_TABLE;
                             3764 ; 120  |
                             3765 ; 121  |typedef struct {
                             3766 ; 122  |    WORD wWord0;
                             3767 ; 123  |    WORD wWord1;
                             3768 ; 124  |    WORD wWord2;
                             3769 ; 125  |} SMARTMEDIA_CIS_IDI_MANUFACTURER_NAME;
                             3770 ; 126  |
                             3771 ; 127  |typedef struct {
                             3772 ; 128  |    WORD wWord0;
                             3773 ; 129  |    WORD wWord1;
                             3774 ; 130  |} SMARTMEDIA_CIS_IDI_PRODUCT_NAME;
                             3775 ; 131  |
                             3776 ; 132  |typedef struct {
                             3777 ; 133  |    WORD wWord0;
                             3778 ; 134  |    WORD wWord1;
                             3779 ; 135  |} SMARTMEDIA_CIS_IDI_PRODUCT_VERSION;
                             3780 ; 136  |
                             3781 ; 137  |typedef struct {
                             3782 ; 138  |    WORD wWord0;
                             3783 ; 139  |    WORD wWord1;
                             3784 ; 140  |    WORD wWord2;
                             3785 ; 141  |    WORD wWord3;
                             3786 ; 142  |} SMARTMEDIA_CIS_IDI_SERIAL_NUMBER;
                             3787 ; 143  |
                             3788 ; 144  |typedef struct {
                             3789 ; 145  |    WORD wWord0;
                             3790 ; 146  |} SMARTMEDIA_CIS_IDI_MODEL_NUMBER;
                             3791 
                             3814 
                             3815 ; 147  |
                             3816 ; 148  |typedef struct {
                             3817 ; 149  |    SMARTMEDIA_CIS_IDI_MANUFACTURER_NAME ManufacturerName;
                             3818 ; 150  |    SMARTMEDIA_CIS_IDI_PRODUCT_NAME ProductName;
                             3819 ; 151  |    SMARTMEDIA_CIS_IDI_PRODUCT_VERSION ProductVersion;
                             3820 ; 152  |    SMARTMEDIA_CIS_IDI_SERIAL_NUMBER SerialNumber;
                             3821 ; 153  |    SMARTMEDIA_CIS_IDI_MODEL_NUMBER ModelNumber;
                             3822 ; 154  |} SMARTMEDIA_CIS_IDI_TABLE;
                             3823 
                             3845 
                             3846 ; 155  |   
                             3847 ; 156  |typedef struct {
                             3848 ; 157  |    WORD wPageSizeInBytes;
                             3849 ; 158  |    WORD wRedundantAreaSizeInBytes;
                             3850 ; 159  |    WORD wNumberOfPagesPerBlock;
                             3851 ; 160  |    WORD wNumberOfBlocksPerZone;
                             3852 ; 161  |    WORD wNumberOfZonesInMedia;
                             3853 ; 162  |    WORD wMediaSizeInMBytes;
                             3854 ; 163  |    SMARTMEDIA_PARTITION_TABLE * pPartitionTable;
                             3855 ; 164  |    SMARTMEDIA_CIS_IDI_TABLE * pCisIdiTable;
                             3856 ; 165  |    WORD wMediaFlagStatus;
                             3857 ; 166  |    WORD wNumberOfBlocksToTheCisIdiBlock;
                             3858 ; 167  |    WORD wTotalNumberOfPhysicalBlocks;
                             3859 ; 168  |    WORD wNumberOfSystemBlocks;
                             3860 ; 169  |} SMARTMEDIA_ENTRY_TABLE;
                             3861 ; 170  |
                             3862 ; 171  |typedef struct {
                             3863 ; 172  |    WORD wDevice;        
                             3864 ; 173  |    WORD wDirtyBlockFlag;
                             3865 ; 174  |    WORD wCleanTailFlag; 
                             3866 ; 175  |    WORD wLogDOSPage;    
                             3867 ; 176  |    WORD wSrcLogBlock;   
                             3868 ; 177  |    WORD wSrcPhyBlock;   
                             3869 ; 178  |    WORD wDestPhyBlock;  
                             3870 ; 179  |    WORD wStartSrcPage;  
                             3871 ; 180  |    WORD wStartDestPage; 
                             3872 ; 181  |    WORD wPagesToCopy;   
                             3873 ; 182  |    WORD wReplaceBuff;   
                             3874 ; 183  |    WORD wReplaceRdnt;
                             3875 ; 184  |    #ifdef MEDIA_DDI_PARTIAL_SEQ_ENABLE
                             3876 ; 185  |        WORD wFirstCount;
                             3877 ; 186  |        WORD wNextCount;
                             3878 ; 187  |        WORD wLastCount;
                             3879 ; 188  |    #endif
                             3880 ; 189  |} SMARTMEDIA_FWPPS_TABLE;
                             3881 ; 190  |
                             3882 ; 191  |typedef struct {
                             3883 ; 192  |    WORD wWord0;
                             3884 ; 193  |    WORD wWord1;
                             3885 ; 194  |    WORD wWord2;
                             3886 ; 195  |    WORD wWord3;
                             3887 ; 196  |} DIRECTORY_NAME;
                             3888 ; 197  |
                             3889 ; 198  |typedef struct {
                             3890 ; 199  |    WORD wWord0;
                             3891 ; 200  |    WORD wWord1;
                             3892 ; 201  |} DIRECTORY_EXTENSION;
                             3893 ; 202  |
                             3894 ; 203  |typedef struct {
                             3895 ; 204  |    WORD wWord0;
                             3896 ; 205  |    WORD wWord1;
                             3897 ; 206  |} DIRECTORY_SIZE;
                             3898 
                             3913 
                             3914 ; 207  |
                             3915 ; 208  |typedef struct {
                             3916 ; 209  |    DIRECTORY_NAME Name;
                             3917 ; 210  |    DIRECTORY_EXTENSION Extension;
                             3918 ; 211  |    WORD wAttribute;
                             3919 ; 212  |    WORD wReserved[4];
                             3920 ; 213  |    WORD wCreationTime;
                             3921 ; 214  |    WORD wCreationData;
                             3922 ; 215  |    WORD wFirstCluster;
                             3923 ; 216  |    DIRECTORY_SIZE Size;
                             3924 ; 217  |    WORD wCurrentCluster;
                             3925 ; 218  |    WORD wPointer;
                             3926 ; 219  |    WORD wRecord;
                             3927 ; 220  |    WORD wRd;
                             3928 ; 221  |} DIRECTORY_FILE_CONTROL_BLOCK;
                             3929 ; 222  |
                             3930 ; 223  |// TODO:  clean this up.  There are two versions.
                             3931 ; 224  |struct FCB
                             3932 ; 225  |{
                             3933 ; 226  |    _packed BYTE m_szFileName[9];       //0-2
                             3934 ; 227  |    int     m_wReserved;                //3
                             3935 ; 228  |    _packed BYTE m_szExt[4];            //4-5
                             3936 ; 229  |    int     m_wAttributes;              //6
                             3937 ; 230  |    int     m_wReserved2[4];            //7,8,9,a
                             3938 ; 231  |    int     m_wTimeofCreation;          //b
                             3939 ; 232  |    int     m_wDateofCreation;          //c
                             3940 ; 233  |    int     m_wFirstCluster;            //d
                             3941 ; 234  |    int     m_wFileSizeHigh;            //e
                             3942 ; 235  |    int     m_wFileSizeLow;             //f
                             3943 ; 236  |};
                             3944 
                             3960 
                             3961 ; 237  |
                             3962 ; 238  |
                             3963 ; 239  |typedef struct {
                             3964 ; 240  |    WORD wFirstClusterCurrentDirectory;
                             3965 ; 241  |    WORD wFirstClusterParentDirectory;
                             3966 ; 242  |    WORD wAbsSectorCurrentlyCached;
                             3967 ; 243  |    WORD wCurrentRelativeSector;
                             3968 ; 244  |    WORD wNumberOfSectors;
                             3969 ; 245  |    WORD wCurrentRecordLoadedInDcb;
                             3970 ; 246  |    WORD wBufferedRecord;
                             3971 ; 247  |    WORD wMaxNumberRecordsCurrentDirectory;
                             3972 ; 248  |    WORD * pwPointerToBuffer;
TASKING DSP2410 assembler v1.5r1 Build 138 SN 00100122
                                                                                                                                                                                                                                                       Page  16

M:ADDR CODE           CYCLES LINE SOURCELINE
                             3973 ; 249  |    WORD * pwPointerToPath;
                             3974 ; 250  |    DIRECTORY_FILE_CONTROL_BLOCK * pDirFcb;
                             3975 ; 251  |} DIRECTORY_CONTROL_BLOCK;
                             3976 ; 252  |
                             3977 ; 253  |typedef struct {
                             3978 ; 254  |    WORD wWord0;
                             3979 ; 255  |    WORD wWord1;
                             3980 ; 256  |    WORD wWord2;
                             3981 ; 257  |    WORD wWord3;
                             3982 ; 258  |} FILE_NAME;
                             3983 ; 259  |
                             3984 ; 260  |typedef struct {
                             3985 ; 261  |    WORD wWord0;
                             3986 ; 262  |    WORD wWord1;
                             3987 ; 263  |} FILE_EXTENSION;
                             3988 ; 264  |
                             3989 ; 265  |typedef struct {
                             3990 ; 266  |    WORD wWord0;
                             3991 ; 267  |    WORD wWord1;
                             3992 ; 268  |} FILE_SIZE;
                             3993 ; 269  |
                             3994 ; 270  |typedef union {
                             3995 ; 271  |    struct {
                             3996 ; 272  |        int Read        :1;
                             3997 ; 273  |        int Write       :1;
                             3998 ; 274  |        int Append      :1;
                             3999 ; 275  |        int Truncate    :1;
                             4000 ; 276  |        int Create      :1;
                             4001 ; 277  |        int Rsrv        :3;
                             4002 ; 278  |        int Mode        :8;
                             4003 ; 279  |        int Device      :8;
                             4004 ; 280  |    } B;
                             4005 ; 281  |    int I;
                             4006 ; 282  |} FILE_FLAGS;
                             4007 ; 283  |
                             4008 ; 284  |typedef struct {
                             4009 ; 285  |    WORD wWord0;
                             4010 ; 286  |    WORD wWord1;
                             4011 ; 287  |} FILE_BYTE_CURRENT;
                             4012 
                             4052 
                             4053 ; 288  |
                             4054 ; 289  |typedef struct {
                             4055 ; 290  |    FILE_NAME Name;
                             4056 ; 291  |    FILE_EXTENSION Extension;
                             4057 ; 292  |    WORD wAttributes;
                             4058 ; 293  |    WORD wReserved[4];
                             4059 ; 294  |    WORD wCreationTime;
                             4060 ; 295  |    WORD wCreationData;
                             4061 ; 296  |    WORD wFirstCluster;
                             4062 ; 297  |    FILE_SIZE Size;
                             4063 ; 298  |    WORD wCurrentCluster;
                             4064 ; 299  |    WORD wPointer;
                             4065 ; 300  |    WORD wRecord;
                             4066 ; 301  |    WORD wRd;
                             4067 ; 302  |    FILE_FLAGS Flags;
                             4068 ; 303  |    FILE_BYTE_CURRENT FcbByteCurrent;
                             4069 ; 304  |    WORD wFcbFlagEndOfCx;
                             4070 ; 305  |} FILE_CONTROL_BLOCK;    
                             4071 ; 306  |
                             4072 ; 307  |typedef struct {
                             4073 ; 308  |    WORD wWord0;
                             4074 ; 309  |    WORD wWord1;
                             4075 ; 310  |    WORD wWord2;
                             4076 ; 311  |    WORD wWord3;
                             4077 ; 312  |} VOLUME_LABEL;
                             4078 ; 313  |
                             4079 ; 314  |typedef struct {
                             4080 ; 315  |    WORD wFATPhysicalBlock1;
                             4081 ; 316  |    WORD wFATPhysicalBlock2;
                             4082 ; 317  |    WORD wFATPhysicalBlock3;
                             4083 ; 318  |    WORD wFATPhysicalBlock4;
                             4084 ; 319  |} FAT_PHYSICAL_BLOCK_LIST;
                             4085 
                             4092 
                             4093 ; 320  |
                             4094 ; 321  |typedef struct {
                             4095 ; 322  |    WORD wFATSectorInCache;
                             4096 ; 323  |    WORD wLastClusterFree;
                             4097 ; 324  |    WORD wNumberOfUsedClusters;
                             4098 ; 325  |    WORD wNumberOfFreeClusters;
                             4099 ; 326  |    WORD wNumberOfBadClusters;
                             4100 ; 327  |    WORD wNumberOfReservedClusters;
                             4101 ; 328  |    WORD wControl;
                             4102 ; 329  |    WORD * pwSectorCache;
                             4103 ; 330  |    FAT_PHYSICAL_BLOCK_LIST FATPhysicalLocationList;
                             4104 ; 331  |} FAT_TABLE;
                             4105 
                             4112 
                             4113 ; 332  |
                             4114 ; 333  |typedef struct {
                             4115 ; 334  |    WORD wStateMediaTable;
                             4116 ; 335  |    WORD wTypeFs;
                             4117 ; 336  |    WORD wBytesPerSector;
                             4118 ; 337  |    WORD wSectorsPerCluster;
                             4119 ; 338  |    WORD wNumberOfReservedSectors;
                             4120 ; 339  |    WORD wMaximumNumberOfFATs;
                             4121 ; 340  |    WORD wMaxRootDirectoryEntries;
                             4122 ; 341  |    WORD wTotalSectors;
                             4123 ; 342  |    WORD wNumberOfFATSectors;
                             4124 ; 343  |    WORD wNumberOfSectorsPerTrack;
                             4125 ; 344  |    WORD wNumberOfHeads;
                             4126 ; 345  |    WORD wNumberOfHiddenSectorsMSB;
                             4127 ; 346  |    WORD wNumberOfHiddenSectorsLSB;
                             4128 ; 347  |    WORD wTotalSectors32MSB;
                             4129 ; 348  |    WORD wTotalSectors32LSB;
                             4130 ; 349  |    WORD wDriverNumber;
                             4131 ; 350  |    WORD wExtendedBootSignature;
                             4132 ; 351  |    WORD wVolumeIDMSB;
                             4133 ; 352  |    WORD wVolumeIDLSB;
                             4134 ; 353  |    VOLUME_LABEL VolumeLabel;
                             4135 ; 354  |    WORD * pwWriteBuffer;
                             4136 ; 355  |    WORD wPrimaryFATRelativeSector;
                             4137 ; 356  |    WORD wSecondaryFATRelativeSector;
                             4138 ; 357  |    WORD wRootDirectoryRelativeSector;
                             4139 ; 358  |    WORD wFirstSectorNumberDataZone;
                             4140 ; 359  |    WORD wMaxNumberOfFATEntries;
                             4141 ; 360  |    WORD wRootDirectorySizeInSectors;
                             4142 ; 361  |    WORD wDataAreaSizeInSectors;
                             4143 ; 362  |} MEDIA_TABLE;
                             4144 
                             4203 
                             4204 ; 363  |
                             4205 ; 364  |typedef struct {
                             4206 ; 365  |    MEDIA_TABLE * pMediaTable;
                             4207 ; 366  |    DIRECTORY_CONTROL_BLOCK * pDirectoryControlBlock;
                             4208 ; 367  |    FAT_TABLE * pFATTable;
                             4209 ; 368  |} DEVICE_CONTROL_TABLE;
                             4210 ; 369  |    
                             4211 ; 370  |typedef struct {
                             4212 ; 371  |    WORD dwTotalSizeInMegaBytes;        // dwTotalSizeInMegaBytes is limited
                             4213 ; 372  |                                        //  to 2-bytes for compatibility with
                             4214 ; 373  |                                        //  older host drivers.
                             4215 ; 374  |    DWORD dwTotalNumberOfSectors;
                             4216 ; 375  |    DWORD dwTotalNumberOfBytes;
                             4217 ; 376  |    WORD wSectorSizeInBytes;
                             4218 ; 377  |} MEDIA_SIZE;
                             4219 ; 378  |
                             4220 ; 379  |typedef struct {
                             4221 ; 380  |    BOOL    bInstalled;
                             4222 ; 381  |    INT     iPbsSectorOffset;   // from the beginning of the data drive 
                             4223 ; 382  |    DWORD   dwSize;
                             4224 ; 383  |} DATA_DRIVE_PBS_LOC;
                             4225 ; 384  |extern  INT _reentrant FSFileOpen(_packed BYTE *fname,INT attribute, INT DeviceNumber);
                             4226 ; 385  |extern  INT _reentrant FSFastOpen(DWORD Key, INT attribute);
                             4227 ; 386  |extern  INT FSFileDelete(_packed BYTE *fname,INT DeviceNumber);
                             4228 ; 387  |extern  INT FSFileCreate(_packed BYTE *fname,INT DeviceNumber);
                             4229 ; 388  |extern  INT _reentrant FSChangeDir(_packed BYTE *dirname,INT DeviceNumber);
                             4230 ; 389  |extern  INT _reentrant FSCreateDir(_packed BYTE *dirname,INT DeviceNumber);
                             4231 ; 390  |extern  INT _reentrant FSDeleteDir(_packed BYTE *dirname,INT DeviceNumber);
                             4232 ; 391  |extern  INT _reentrant FSFileAppend(_packed BYTE *fname,INT DeviceNumber);
                             4233 ; 392  |extern  INT _reentrant FSFileRead(INT BytestoRead, INT Handle, INT memory_type, INT modulo, WORD *buffer);
                             4234 ; 393  |extern  INT _reentrant FSFileWrite(INT wNumberBytes, INT Handle, INT memory_type, INT iModulo, WORD *buffer);
                             4235 ; 394  |extern  INT _reentrant FSFileClose(INT Handle);
                             4236 ; 395  |extern  LONG _reentrant FSFileSize(INT HandleNumber);
                             4237 ; 396  |extern  LONG  FSSize(INT DeviceNum, INT TYPE);   
                             4238 ; 397  |extern  INT FSFreeClusters(INT Device);
                             4239 ; 398  |extern  INT BytesPerCluster(INT Device);
                             4240 ; 399  |
                             4241 ; 400  |
                             4242 ; 401  |
                             4243 ; 402  |//extern  INT FSFileCreate(_packed BYTE *pbFileName, BYTE bDevice);
                             4244 ; 403  |//extern  INT FSFileDelete(_packed BYTE *pbFileName, BYTE bDevice);
                             4245 ; 404  |extern  INT FSFileRename(_packed BYTE *pbCurFilename, _packed BYTE *pbNewFilename, BYTE bDevice);
                             4246 ; 405  |//extern  INT _reentrant FSFileAttribute(_packed BYTE *pbFilename, WORD wAttributes, BYTE bDevice);
                             4247 ; 406  |//extern  INT FSFileAppend(_packed BYTE *pbFileName, BYTE bDevice);
                             4248 ; 407  |//extern  INT FSFileOpen(_packed BYTE *pbFileName, WORD wAttributes, BYTE bDevice);
                             4249 ; 408  |//extern  INT FSFileClose(INT bHandle);
                             4250 ; 409  |//extern  INT FSFileRead(WORD wNumberBytes, BYTE bHandle, WORD wMemSpace, INT iModulo, WORD *pwBuffer);
                             4251 ; 410  |//extern  INT FSFileWrite(WORD wNumberBytes, BYTE bHandle, WORD wMemSpace, INT iModulo, WORD *pwBuffer);
                             4252 ; 411  |extern  INT _reentrant fseek( INT handle , LONG offset, INT iOrigin );
                             4253 ; 412  |extern  INT _reentrant FSFileEof(INT Handle);
                             4254 ; 413  |extern INT _reentrant FSFileAttribute(INT Attributes, _packed BYTE *fname, INT DeviceNumber);
                             4255 ; 414  |extern INT _reentrant FSFileAttributeClear(INT Attributes, _packed BYTE *fname, INT DeviceNumber);
                             4256 ; 415  |//extern  LONG FSFileSize(INT bHandle);
                             4257 ; 416  |extern _asmfunc INT FSPresent(BYTE bDevice);
                             4258 ; 417  |extern _asmfunc INT FSType(BYTE bDevice);
                             4259 ; 418  |//extern LONG FSSize(WORD wDevice, WORD wReturnType);
                             4260 ; 419  |//extern INT FSChangeDir(_packed BYTE *pbDirName, BYTE bDevice);
                             4261 ; 420  |//extern INT FSCreateDir(_packed BYTE *pbDirName, BYTE bDevice);
                             4262 ; 421  |//extern INT FSDeleteDir(_packed BYTE *pbDirName, BYTE bDevice);
                             4263 ; 422  |extern _asmfunc void SysLoadFATWrite(void);
                             4264 ; 423  |extern _asmfunc INT SysUnLoadFATWrite(void);
                             4265 ; 424  |extern LONG _reentrant ftell(INT iHandle);
                             4266 ; 425  |extern _asmfunc struct FCB * ReadDirectory(int iDevice, int iEntry);
                             4267 ; 426  |
                             4268 ; 427  |#endif
                             4269 
                             4288 
                             4289 ; 20   |
                             4290 ; 21   |extern PARTITION_BOOT_SECTOR stPartitionBootSector;
                             4291 
                             4300 
                             4301 ; 22   |extern FAT_STRUCT stFat;
                             4302 ; 23   |
                             4303 ; 24   |// TOVERIFY made this ptr to SECTOR_BUFFER like the define was (instead of just extern WORD _X MediaBuffer). 
                             4304 ; 25   |extern SECTOR_BUFFER * MediaBuffer;
                             4305 ; 26   |
                             4306 ; 27   |extern WORD _X FatBuffer[];
                             4307 ; 28   |extern tCACHEDESCR_checkdisk CacheDesc_chkdsk[MAX_CACHES];
                             4308 ; 29   |extern WORD _X *CacheMem_chkdsk[MAX_CACHES];        // This table will be used for FAT32
                             4309 ; 30   |extern WORD MaskArray[24];
                             4310 ; 31   |void _reentrant IncrementCacheCounters_chkdsk(void);
                             4311 ; 32   |
                             4312 ; 33   |extern RETCODE _reentrant DriveReadSector(WORD wLogDriveNumber, DWORD dwSectorNumber,
                             4313 
                             4317 
                             4318 ; 34   |    P_SECTOR_BUFFER pSectorData);
                             4319 ; 35   |extern RETCODE _reentrant DriveWriteSector(WORD wLogDriveNumber, DWORD dwSectorNumber,
                             4320 ; 36   |    P_SECTOR_BUFFER pSectorData);
                             4321 ; 37   |
                             4322 ; 38   |extern LONG (*GetNextCxFromFat) (DWORD wCurCx);     // pointer to function
                             4323 ; 39   |extern LONG GetDWordY(void *buffer, INT Offset,INT MemoryType);
                             4324 
                             4330 
                             4331 ; 40   |extern DATA_DRIVE_PBS_LOC DataDriveStatus[];
                             4332 ; 41   |
                             4333 ; 42   |
                             4334 ; 43   |
                             4335 ; 44   |///////////////////////////////////////////////////////////////////////////////
                             4336 ; 45   |//
                             4337 ; 46   |//>  Name:           LoadFatSector
                             4338 ; 47   |//
                             4339 ; 48   |//   Type:           Function
                             4340 ; 49   |//
                             4341 ; 50   |//   Description:    Loads 3 sectors of FAT into the FAT buffer specified by stFat structure
                             4342 ; 51   |//                   
                             4343 ; 52   |//
                             4344 ; 53   |//   Inputs:         Sect               : Starting Sector
                             4345 ; 54   |//                   *pwBuffer          : Pointer to buffer in X memory. This buffer 
                             4346 ; 55   |//                                          is a temporarely buffer.
                             4347 ; 56   |//
                             4348 ; 57   |//   Outputs:        
                             4349 ; 58   |//                     NOERROR -> Operation successful
                             4350 ; 59   |//                     !NOERROR -> Impossible to read the sector 
                             4351 ; 60   |//                   
                             4352 ; 61   |//   Notes:          
                             4353 ; 62   |//<
                             4354 ; 63   |///////////////////////////////////////////////////////////////////////////////
                             4355 ; 64   |BOOL _reentrant LoadFatSector(DWORD Sect, WORD _X *pwBuffer)
                             4356 ; 65   |{
                             4357 
P:0000                       4358         org     p,".ptextfatutils":
                             4427 FLoadFatSector:
P:0000 055F7C         2    2 4428         movec   ssh,y:(r7)+
P:0001 3F0300         2    4 4431         move    #3,n7
P:0002 000000         2    6 4432         nop
P:0003 204F00         2    8 4433         move    (r7)+n7
P:0004 045FA0         2   10 4439         movec   m0,n7
P:0005 000000         2   12 4440         nop
P:0006 686F00         4   16 4441         move    r0,y:(r7+n7)
TASKING DSP2410 assembler v1.5r1 Build 138 SN 00100122
                                                                                                                                                                                                                                                       Page  17

M:ADDR CODE           CYCLES LINE SOURCELINE
                             4444 
                             4445 ; 66   |   // if(Sect <= 0 || Sect > stPartitionBootSector.wNumberFatSectors)
                             4446 ; 67   |     //   return(!NOERROR);
                             4447 ; 68   |    
                             4448 ; 69   |    if(Sect < stPartitionBootSector.wStartSectPrimaryFat || Sect > (stPartitionBootSector.wStartSectSecondaryFat-1))
                             4449 
P:0007 5FF000 rrrrrr  3   19 4451         move    y:FstPartitionBootSector+9,b
P:0009 59F000 rrrrrr  3   22 4452         move    y:FstPartitionBootSector+8,b0
P:000B 2B0000         2   24 4453         move    #0,b2
P:000C 2A0000         2   26 4454         move    #0,a2
P:000D 200005         2   28 4455         cmp     b,a
P:000E 0AF0A9 rrrrrr  6   34 4456         jlt     L27
P:0010 5FF000 rrrrrr  3   37 4457         move    y:FstPartitionBootSector+11,b
P:0012 59F000 rrrrrr  3   40 4458         move    y:FstPartitionBootSector+10,b0
P:0014 00000B         2   42 4459         dec     b
P:0015 2B0000         2   44 4460         move    #0,b2
P:0016 200005         2   46 4461         cmp     b,a
P:0017 0AF0A7 rrrrrr  6   52 4462         jgt     L27
                             4463 
                             4464 ; 70   |             return (!NOERROR);
                             4465 ; 71   |
                             4466 ; 72   |    // Needs to check if already loaded
                             4467 ; 73   |    if(Sect == stFat.FatSectorCached)
                             4468 
P:0019 59F000 rrrrrr  3   55 4470         move    y:FstFat+1,b0
P:001B 2D0000         2   57 4471         move    #0,b1
P:001C 77F400 FFFFFD  3   60 4472         move    #-3,n7
P:001E 205F00         2   62 4473         move    (r7)+
P:001F 5C6F00         4   66 4475         move    a1,y:(r7+n7)
P:0020 205700         2   68 4476         move    (r7)-
P:0021 586F00         4   72 4478         move    a0,y:(r7+n7)
P:0022 200005         2   74 4479         cmp     b,a
P:0023 0AF0AA rrrrrr  6   80 4482         jeq     L30
                             4483 
                             4484 ; 74   |        return(NOERROR);
                             4485 ; 75   |    
                             4486 ; 76   |    // Needs to check if current group dirty and save fat if so
                             4487 ; 77   |    if(stFat.Control != CLEAN)
                             4488 
P:0025 5EF000 rrrrrr  3   83 4490         move    y:FstFat+2,a
P:0027 200003         2   85 4491         tst     a
P:0028 0AF0AA rrrrrr  6   91 4492         jeq     L20
                             4493 
                             4494 ; 78   |        if(WriteFatSector(stFat.FatSectorCached, FatBuffer) != NOERROR)
                             4495 
P:002A 200001         2   93 4497         tfr     b,a
P:002B 60F400 rrrrrr  3   96 4498         move    #FFatBuffer,r0
P:002D 0BF080 rrrrrr  6  102 4499         jsr     FWriteFatSector
P:002F 2A0000         2  104 4500         move    #0,a2
P:0030 200003         2  106 4501         tst     a
P:0031 0AF0A2 rrrrrr  6  112 4502         jne     L27
                             4503 
                             4504 ; 79   |            return(!NOERROR);
                             4505 ; 80   |        
                             4506 ; 81   | 
                             4507 ; 82   |    /* Read the 1st Sector*/ 
                             4508 ; 83   |
                             4509 ; 84   |   if(DriveReadSector(stFat.Device, (DWORD)Sect+DataDriveStatus[stFat.Device].iPbsSectorOffset, pwBuffer) != NOERROR)
                             4510 
P:0033 5FF000 rrrrrr  3  115 4512 L20:    move    y:FstFat,b
P:0035 21A600         2  117 4513         move    b1,y0
P:0036 0116E0         2  119 4514         mpy     y0,#22,a
P:0037 211D00         2  121 4515         move    a0,n5
P:0038 65F400 rrrrrr  3  124 4516         move    #FDataDriveStatus+1,r5
P:003A 000000         2  126 4517         nop
P:003B 044D16         4  130 4518         lua     (r5)+n5,r6
P:003C 000000         2  132 4519         nop
P:003D 5EE600         2  134 4520         move    y:(r6),a
P:003E 218800         2  136 4521         move    a1,a0
P:003F 214C00         2  138 4522         move    a2,a1
P:0040 77F400 FFFFFD  3  141 4523         move    #-3,n7
P:0042 205F00         2  143 4524         move    (r7)+
P:0043 4FEF00         4  147 4526         move    y:(r7+n7),y1
P:0044 205700         2  149 4527         move    (r7)-
P:0045 4EEF00         4  153 4529         move    y:(r7+n7),y0
P:0046 200030         2  155 4530         add     y,a
P:0047 045FA0         2  157 4531         movec   m0,n7
P:0048 000000         2  159 4532         nop
P:0049 68EF00         4  163 4533         move    y:(r7+n7),r0
P:004A 0BF080 rrrrrr  6  169 4536         jsr     FDriveReadSector
P:004C 200003         2  171 4539         tst     a
P:004D 0AF0A2 rrrrrr  6  177 4540         jne     L27
                             4541 
                             4542 ; 85   |        return(!NOERROR);
                             4543 ; 86   |   
                             4544 ; 87   |    
                             4545 ; 88   |   // Get 1st Sector Fat Buffer using swizzle block
                             4546 ; 89   |    HW_SWIZZLECS1R.I = 0x501;         // Manipulates data in memory and places it in memory
                             4547 
P:004F 46F400 000501  3  180 4549         move    #1281,y0
P:0051 467000 00F380  3  183 4550         move    y0,x:$F380
                             4551 
                             4552 ; 90   |    HW_SWIZZLESIZER.U = cachedSectorSizeInWords;        // Data Size
                             4553 
P:0053 57F000 rrrrrr  3  186 4555         move    x:FcachedSectorSizeInWords,b
P:0055 557000 00F382  3  189 4556         move    b1,x:$F382
                             4557 
                             4558 ; 91   |    SetupSwizzleAddrXY(MediaBuffer, stFat.pwBuffer);
                             4559 
P:0057 68F000 rrrrrr  3  192 4561         move    y:FMediaBuffer,r0
P:0059 6CF000 rrrrrr  3  195 4562         move    y:FstFat+7,r4
P:005B 0BF080 rrrrrr  6  201 4563         jsr     SetupSwizzleAddrXY
                             4564 
                             4565 ; 92   |
                             4566 ; 93   |    HW_SWIZZLECS2R.I = 9;         // Kick it, Source in Xmem, Dest in Ymem
                             4567 
P:005D 46F400 000009  3  204 4569         move    #>9,y0
P:005F 467000 00F381  3  207 4570         move    y0,x:$F381
                             4571 
                             4572 ; 94   |    
                             4573 ; 95   |    // Wait for swizzle completed
                             4574 ; 96   |    while(HW_SWIZZLECS2R.I & 0x1);
                             4575 
P:0061 46F400 000001  3  210 4577         move    #>1,y0
P:0063 55F000 00F381  3  213 4578 L21:    move    x:$F381,b1
P:0065 20005E         2  215 4579         and     y0,b
P:0066 21AF00         2  217 4580         move    b1,b
P:0067 2B0000         2  219 4581         move    #0,b2
P:0068 20000B         2  221 4582         tst     b
P:0069 0AF0A2 rrrrrr  6  227 4583         jne     L21
                             4584 
                             4585 ; 97   |    
                             4586 ; 98   |
                             4587 ; 99   |    
                             4588 ; 100  |    if ( DriveReadSector(stFat.Device, (DWORD)(Sect+1)+DataDriveStatus[stFat.Device].iPbsSectorOffset, pwBuffer) != NOERROR )
                             4589 
P:006B 4FF000 rrrrrr  3  230 4591         move    y:FstFat,y1
P:006D 0116C0         2  232 4592         mpy     y1,#22,a
P:006E 211E00         2  234 4593         move    a0,n6
P:006F 66F400 rrrrrr  3  237 4594         move    #FDataDriveStatus+1,r6
P:0071 000000         2  239 4595         nop
P:0072 204E00         2  241 4596         move    (r6)+n6
P:0073 5EE600         2  243 4597         move    y:(r6),a
P:0074 218800         2  245 4598         move    a1,a0
P:0075 214C00         2  247 4599         move    a2,a1
P:0076 77F400 FFFFFD  3  250 4600         move    #-3,n7
P:0078 205F00         2  252 4601         move    (r7)+
P:0079 4DEF00         4  256 4603         move    y:(r7+n7),x1
P:007A 205700         2  258 4604         move    (r7)-
P:007B 4CEF00         4  262 4606         move    y:(r7+n7),x0
P:007C 200020         2  264 4607         add     x,a
P:007D 000008         2  266 4608         inc     a
P:007E 045FA0         2  268 4609         movec   m0,n7
P:007F 000000         2  270 4610         nop
P:0080 68EF00         4  274 4611         move    y:(r7+n7),r0
P:0081 200079         2  276 4614         tfr     y1,b
P:0082 0BF080 rrrrrr  6  282 4615         jsr     FDriveReadSector
P:0084 200003         2  284 4618         tst     a
P:0085 0AF0A2 rrrrrr  6  290 4619         jne     L27
                             4620 
                             4621 ; 101  |         return(!NOERROR);
                             4622 ; 102  |    
                             4623 ; 103  |
                             4624 ; 104  |    // Get 2nd Sector Fat Buffer using swizzle block
                             4625 ; 105  |    HW_SWIZZLECS1R.I = 0x501;         // Manipulates data in memory and places it in memory
                             4626 
P:0087 44F400 000501  3  293 4628         move    #1281,x0
P:0089 447000 00F380  3  296 4629         move    x0,x:$F380
                             4630 
                             4631 ; 106  |    HW_SWIZZLESIZER.U = cachedSectorSizeInWords;        // Data Size
                             4632 
P:008B 44F000 rrrrrr  3  299 4634         move    x:FcachedSectorSizeInWords,x0
P:008D 447000 00F382  3  302 4635         move    x0,x:$F382
                             4636 
                             4637 ; 107  |
                             4638 ; 108  |    SetupSwizzleAddrXY(pwBuffer, stFat.pwBuffer+cachedSectorSizeInWords-1);
                             4639 
P:008F 6BF000 rrrrrr  3  305 4641         move    y:FstFat+7,r3
P:0091 209B00         2  307 4642         move    x0,n3
P:0092 000000         2  309 4643         nop
P:0093 044B14         4  313 4644         lua     (r3)+n3,r4
P:0094 000000         2  315 4645         nop
P:0095 205400         2  317 4646         move    (r4)-
P:0096 045FA0         2  319 4647         movec   m0,n7
P:0097 000000         2  321 4648         nop
P:0098 68EF00         4  325 4649         move    y:(r7+n7),r0
P:0099 0BF080 rrrrrr  6  331 4652         jsr     SetupSwizzleAddrXY
                             4655 
                             4656 ; 109  |
                             4657 ; 110  |    HW_SWIZZLECS2R.I = 0x4009;         // Kick it, Source in Xmem, Dest in Ymem
                             4658 
P:009B 44F400 004009  3  334 4660         move    #16393,x0
P:009D 447000 00F381  3  337 4661         move    x0,x:$F381
P:009F 47F400 000001  3  340 4662         move    #>1,y1
                             4663 
                             4664 ; 111  |
                             4665 ; 112  |    // Wait for swizzle completed
                             4666 ; 113  |    while ( HW_SWIZZLECS2R.I & 0x1 );
                             4667 
P:00A1 55F000 00F381  3  343 4669 L22:    move    x:$F381,b1
P:00A3 20007E         2  345 4670         and     y1,b
P:00A4 21AF00         2  347 4671         move    b1,b
P:00A5 2B0000         2  349 4672         move    #0,b2
P:00A6 20000B         2  351 4673         tst     b
P:00A7 0AF0A2 rrrrrr  6  357 4674         jne     L22
                             4675 
                             4676 ; 114  |
                             4677 ; 115  |        
                             4678 ; 116  |    if ( DriveReadSector(stFat.Device, (DWORD)(Sect+2)+DataDriveStatus[stFat.Device].iPbsSectorOffset, pwBuffer) != NOERROR )
                             4679 
P:00A9 4EF000 rrrrrr  3  360 4681         move    y:FstFat,y0
P:00AB 200059         2  362 4682         tfr     y0,b
P:00AC 0116E0         2  364 4683         mpy     y0,#22,a
P:00AD 211C00         2  366 4684         move    a0,n4
P:00AE 64F400 rrrrrr  3  369 4685         move    #FDataDriveStatus+1,r4
P:00B0 000000         2  371 4686         nop
P:00B1 044C16         4  375 4687         lua     (r4)+n4,r6
P:00B2 000000         2  377 4688         nop
P:00B3 5EE600         2  379 4689         move    y:(r6),a
P:00B4 218800         2  381 4690         move    a1,a0
P:00B5 214C00         2  383 4691         move    a2,a1
P:00B6 77F400 FFFFFD  3  386 4692         move    #-3,n7
P:00B8 205F00         2  388 4693         move    (r7)+
P:00B9 4DEF00         4  392 4695         move    y:(r7+n7),x1
P:00BA 205700         2  394 4696         move    (r7)-
P:00BB 4CEF00         4  398 4698         move    y:(r7+n7),x0
P:00BC 200020         2  400 4699         add     x,a
P:00BD 270000         2  402 4700         move    #0,y1
P:00BE 46F400 000002  3  405 4701         move    #>2,y0
P:00C0 200030         2  407 4702         add     y,a
P:00C1 045FA0         2  409 4703         movec   m0,n7
P:00C2 000000         2  411 4704         nop
P:00C3 68EF00         4  415 4705         move    y:(r7+n7),r0
P:00C4 0BF080 rrrrrr  6  421 4708         jsr     FDriveReadSector
P:00C6 200003         2  423 4711         tst     a
P:00C7 0AF0AA rrrrrr  6  429 4712         jeq     L28
                             4713 
                             4714 ; 117  |       return(!NOERROR);
                             4715 
P:00C9 56F400 000001  3  432 4717 L27:    move    #>1,a
P:00CB 0AF080 rrrrrr  6  438 4718         jmp     L31
                             4719 
                             4720 ; 118  |        
                             4721 ; 119  |    // Get 3rd Sector Fat Buffer using swizzle block
                             4722 ; 120  |    HW_SWIZZLECS1R.I = 0x501;         // Manipulates data in memory and places it in memory
                             4723 
P:00CD 55F400 000501  3  441 4725 L28:    move    #1281,b1
P:00CF 557000 00F380  3  444 4726         move    b1,x:$F380
                             4727 
                             4728 ; 121  |    HW_SWIZZLESIZER.U = cachedSectorSizeInWords;        // Data Size
                             4729 
P:00D1 57F000 rrrrrr  3  447 4731         move    x:FcachedSectorSizeInWords,b
P:00D3 557000 00F382  3  450 4732         move    b1,x:$F382
                             4733 
                             4734 ; 122  |
                             4735 ; 123  |    SetupSwizzleAddrXY(pwBuffer, stFat.pwBuffer+cachedSectorSizeInWords+cachedSectorSizeInWords-1);
                             4736 
P:00D5 20003A         2  452 4738         asl     b
P:00D6 21BC00         2  454 4739         move    b1,n4
P:00D7 6CF000 rrrrrr  3  457 4740         move    y:FstFat+7,r4
P:00D9 000000         2  459 4741         nop
TASKING DSP2410 assembler v1.5r1 Build 138 SN 00100122
                                                                                                                                                                                                                                                       Page  18

M:ADDR CODE           CYCLES LINE SOURCELINE
P:00DA 204C00         2  461 4742         move    (r4)+n4
P:00DB 205400         2  463 4743         move    (r4)-
P:00DC 045FA0         2  465 4744         movec   m0,n7
P:00DD 000000         2  467 4745         nop
P:00DE 68EF00         4  471 4746         move    y:(r7+n7),r0
P:00DF 0BF080 rrrrrr  6  477 4747         jsr     SetupSwizzleAddrXY
                             4751 
                             4752 ; 124  |
                             4753 ; 125  |    HW_SWIZZLECS2R.I = 0x2009;         // Kick it, Source in Xmem, Dest in Ymem
                             4754 
P:00E1 54F400 002009  3  480 4756         move    #8201,a1
P:00E3 547000 00F381  3  483 4757         move    a1,x:$F381
P:00E5 45F400 000001  3  486 4758         move    #>1,x1
                             4759 
                             4760 ; 126  |
                             4761 ; 127  |    // Wait for swizzle completed
                             4762 ; 128  |    while ( HW_SWIZZLECS2R.I & 0x1 );
                             4763 
P:00E7 55F000 00F381  3  489 4765 L29:    move    x:$F381,b1
P:00E9 20006E         2  491 4766         and     x1,b
P:00EA 21AF00         2  493 4767         move    b1,b
P:00EB 2B0000         2  495 4768         move    #0,b2
P:00EC 20000B         2  497 4769         tst     b
P:00ED 0AF0A2 rrrrrr  6  503 4770         jne     L29
                             4771 
                             4772 ; 129  |    
                             4773 ; 130  |    stFat.FatSectorCached = Sect;
                             4774 
P:00EF 77F400 FFFFFD  3  506 4776         move    #-3,n7
P:00F1 205F00         2  508 4777         move    (r7)+
P:00F2 5FEF00         4  512 4779         move    y:(r7+n7),b
P:00F3 205700         2  514 4780         move    (r7)-
P:00F4 59EF00         4  518 4782         move    y:(r7+n7),b0
P:00F5 597000 rrrrrr  3  521 4786         move    b0,y:FstFat+1
                             4787 
                             4788 ; 131  |
                             4789 ; 132  |    return(NOERROR);
                             4790 
P:00F7 200013         2  523 4792 L30:    clr     a   
                             4793 
                             4794 ; 133  |
                             4795 ; 134  |}
                             4796 
P:00F8 77F400 FFFFFC  3  526 4798 L31:    move    #-4,n7
P:00FA 000000         2  528 4799         nop
P:00FB 05EF7C         4  532 4800         movec   y:(r7+n7),ssh
P:00FC 204F00         2  534 4802         move    (r7)+n7
P:00FD 00000C         4  538 4804         rts
                             4806 
                             4807 ; 135  |
                             4808 ; 136  |
                             4809 ; 137  |
                             4810 ; 138  |
                             4811 ; 139  |///////////////////////////////////////////////////////////////////////////////
                             4812 ; 140  |//
                             4813 ; 141  |//>  Name:           WriteFatSector
                             4814 ; 142  |//
                             4815 ; 143  |//   Type:           Function
                             4816 ; 144  |//
                             4817 ; 145  |//   Description:    Writes 3 sectors of FAT. Data to write is specified by stFat structure
                             4818 ; 146  |//                   
                             4819 ; 147  |//
                             4820 ; 148  |//   Inputs:         Sect               : Starting Sector
                             4821 ; 149  |//                   *pwBuffer          : Pointer to buffer in X memory. This buffer 
                             4822 ; 150  |//                                          is a temporarely buffer.
                             4823 ; 151  |//
                             4824 ; 152  |//   Outputs:        
                             4825 ; 153  |//                     NOERROR -> Operation successful
                             4826 ; 154  |//                     !NOERROR -> Impossible to write the sector 
                             4827 ; 155  |//                   
                             4828 ; 156  |//   Notes:          
                             4829 ; 157  |//<
                             4830 ; 158  |///////////////////////////////////////////////////////////////////////////////
                             4831 ; 159  |BOOL _reentrant WriteFatSector(DWORD Sect, WORD _X *pwBuffer)
                             4832 ; 160  |{
                             4833 
                             4838 FWriteFatSector:
P:00FE 055F7C         2  540 4839         movec   ssh,y:(r7)+
P:00FF 3F0500         2  542 4842         move    #5,n7
P:0100 000000         2  544 4843         nop
P:0101 204F00         2  546 4844         move    (r7)+n7
                             4854 
                             4855 ; 161  |    WORD wTemp;
                             4856 ; 162  |    DWORD wSectSecFat;
                             4857 
P:0102 77F400 FFFFFB  3  549 4859         move    #-5,n7
P:0104 205F00         2  551 4860         move    (r7)+
P:0105 5C6F00         4  555 4862         move    a1,y:(r7+n7)
P:0106 205700         2  557 4863         move    (r7)-
P:0107 586F00         4  561 4865         move    a0,y:(r7+n7)
                             4868 
                             4869 ; 163  |
                             4870 ; 164  |    // Get 1st Sector Fat Buffer using swizzle block
                             4871 ; 165  |    HW_SWIZZLECS1R.I = 0x501;     // Manipulates data in memory and places it in memory
                             4872 
P:0108 46F400 000501  3  564 4874         move    #1281,y0
P:010A 467000 00F380  3  567 4875         move    y0,x:$F380
                             4876 
                             4877 ; 166  |    HW_SWIZZLESIZER.U = cachedSectorSizeInWords;        // Data Size
                             4878 
P:010C 56F000 rrrrrr  3  570 4880         move    x:FcachedSectorSizeInWords,a
P:010E 547000 00F382  3  573 4881         move    a1,x:$F382
                             4882 
                             4883 ; 167  |    
                             4884 ; 168  |    
                             4885 ; 169  |    SetupSwizzleAddrYX(stFat.pwBuffer, pwBuffer);
                             4886 
P:0110 59F000 rrrrrr  3  576 4888         move    y:FstFat+7,b0
P:0112 77F400 FFFFFD  3  579 4889         move    #-3,n7
P:0114 000000         2  581 4890         nop
P:0115 686F00         4  585 4891         move    r0,y:(r7+n7)
P:0116 221400         2  587 4892         move    r0,r4
P:0117 213000         2  589 4897         move    b0,r0
P:0118 0BF080 rrrrrr  6  595 4898         jsr     SetupSwizzleAddrYX
                             4901 
                             4902 ; 170  |
                             4903 ; 171  |    HW_SWIZZLECS2R.I = 3;         // Kick it, Source in Ymem, Dest in Xmem
                             4904 
P:011A 47F400 000003  3  598 4906         move    #>3,y1
P:011C 477000 00F381  3  601 4907         move    y1,x:$F381
                             4908 
                             4909 ; 172  |    
                             4910 ; 173  |    // Wait for swizzle completed
                             4911 ; 174  |    while ( HW_SWIZZLECS2R.I & 0x1 );
                             4912 
P:011E 47F400 000001  3  604 4914         move    #>1,y1
P:0120 55F000 00F381  3  607 4915 L62:    move    x:$F381,b1
P:0122 20007E         2  609 4916         and     y1,b
P:0123 21AF00         2  611 4917         move    b1,b
P:0124 2B0000         2  613 4918         move    #0,b2
P:0125 20000B         2  615 4919         tst     b
P:0126 0AF0A2 rrrrrr  6  621 4920         jne     L62
                             4921 
                             4922 ; 175  |    
                             4923 ; 176  |    // Write 1st sector in Primary FAT
                             4924 ; 177  |    if ( Sect < stPartitionBootSector.wStartSectSecondaryFat )
                             4925 
P:0128 5EF000 rrrrrr  3  624 4927         move    y:FstPartitionBootSector+11,a
P:012A 58F000 rrrrrr  3  627 4928         move    y:FstPartitionBootSector+10,a0
P:012C 77F400 FFFFFB  3  630 4929         move    #-5,n7
P:012E 205F00         2  632 4930         move    (r7)+
P:012F 5FEF00         4  636 4932         move    y:(r7+n7),b
P:0130 205700         2  638 4933         move    (r7)-
P:0131 59EF00         4  642 4935         move    y:(r7+n7),b0
P:0132 212600         2  644 4936         move    b0,y0
P:0133 21A700         2  646 4937         move    b1,y1
P:0134 2A0000         2  648 4938         move    #0,a2
P:0135 2B0000         2  650 4939         move    #0,b2
P:0136 20000D         2  652 4940         cmp     a,b
P:0137 0AF0A1 rrrrrr  6  658 4943         jge     L70
                             4944 
                             4945 ; 178  |    {    
                             4946 ; 179  |        if ( DriveWriteSector(stFat.Device, (DWORD)Sect+DataDriveStatus[stFat.Device].iPbsSectorOffset, pwBuffer) != NOERROR )
                             4947 
P:0139 5FF000 rrrrrr  3  661 4949         move    y:FstFat,b
P:013B 21A400         2  663 4950         move    b1,x0
P:013C 0116D0         2  665 4951         mpy     x0,#22,a
P:013D 211E00         2  667 4952         move    a0,n6
P:013E 66F400 rrrrrr  3  670 4953         move    #FDataDriveStatus+1,r6
P:0140 000000         2  672 4954         nop
P:0141 204E00         2  674 4955         move    (r6)+n6
P:0142 5EE600         2  676 4956         move    y:(r6),a
P:0143 218800         2  678 4957         move    a1,a0
P:0144 214C00         2  680 4958         move    a2,a1
P:0145 200030         2  682 4959         add     y,a
P:0146 77F400 FFFFFD  3  685 4962         move    #-3,n7
P:0148 000000         2  687 4963         nop
P:0149 68EF00         4  691 4964         move    y:(r7+n7),r0
P:014A 0BF080 rrrrrr  6  697 4967         jsr     FDriveWriteSector
P:014C 200003         2  699 4970         tst     a
P:014D 0AF0A2 rrrrrr  6  705 4971         jne     L66
                             4972 
                             4973 ; 180  |                return(!NOERROR);
                             4974 ; 181  |    }
                             4975 ; 182  |    else
                             4976 ; 183  |    {
                             4977 ; 184  |        stFat.Control = CLEAN;            
                             4978 ; 185  |        return(NOERROR);
                             4979 ; 186  |    }        
                             4980 ; 187  |                
                             4981 ; 188  |    
                             4982 ; 189  |    wSectSecFat = (Sect - stFat.FirstPrimaryFatSect) + stFat.FirstSecondaryFatSect;
                             4983 ; 190  |     
                             4984 ; 191  |    // Get 2nd Sector Fat Buffer using swizzle block
                             4985 ; 192  |    HW_SWIZZLECS1R.I = 0x501;       // Manipulates data in memory and places it in memory
                             4986 
P:014F 45F400 000501  3  708 4988         move    #1281,x1
P:0151 457000 00F380  3  711 4989         move    x1,x:$F380
                             4990 
                             4991 ; 193  |    HW_SWIZZLESIZER.U = cachedSectorSizeInWords+1;        // Data Size
                             4992 
P:0153 56F000 rrrrrr  3  714 4994         move    x:FcachedSectorSizeInWords,a
P:0155 218F00         2  716 4995         move    a1,b
P:0156 47F400 000001  3  719 4996         move    #>1,y1
P:0158 200070         2  721 4997         add     y1,a
P:0159 547000 00F382  3  724 4998         move    a1,x:$F382
                             4999 
                             5000 ; 194  |
                             5001 ; 195  |
                             5002 ; 196  |    wTemp = *(pwBuffer-1);
                             5003 
P:015B 77F400 FFFFFD  3  727 5005         move    #-3,n7
P:015D 000000         2  729 5006         nop
P:015E 6EEF00         4  733 5007         move    y:(r7+n7),r6
P:015F 000000         2  735 5008         nop
P:0160 045613         4  739 5009         lua     (r6)-,r3
P:0161 000000         2  741 5010         nop
P:0162 44E300         2  743 5011         move    x:(r3),x0
P:0163 045FA0         2  745 5012         movec   m0,n7
P:0164 000000         2  747 5013         nop
P:0165 4C6F00         4  751 5014         move    x0,y:(r7+n7)
                             5016 
                             5017 ; 197  |    SetupSwizzleAddrYX(stFat.pwBuffer+cachedSectorSizeInWords-1, pwBuffer-1);
                             5018 
P:0166 6EF000 rrrrrr  3  754 5020         move    y:FstFat+7,r6
P:0168 21BE00         2  756 5021         move    b1,n6
P:0169 000000         2  758 5022         nop
P:016A 044E10         4  762 5023         lua     (r6)+n6,r0
P:016B 000000         2  764 5024         nop
P:016C 205000         2  766 5025         move    (r0)-
P:016D 77F400 FFFFFE  3  769 5026         move    #-2,n7
P:016F 000000         2  771 5027         nop
P:0170 6B6F00         4  775 5028         move    r3,y:(r7+n7)
P:0171 227400         2  777 5029         move    r3,r4
P:0172 0BF080 rrrrrr  6  783 5030         jsr     SetupSwizzleAddrYX
                             5031 
                             5032 ; 198  |
                             5033 ; 199  |    HW_SWIZZLECS2R.I = 0x2003;         // Kick it, Source in Ymem, Dest in Xmem
                             5034 
P:0174 50F400 002003  3  786 5036         move    #8195,a0
P:0176 507000 00F381  3  789 5037         move    a0,x:$F381
                             5038 
                             5039 ; 200  |
                             5040 ; 201  |    // Wait for swizzle completed
                             5041 ; 202  |    while ( HW_SWIZZLECS2R.I & 0x1 );
                             5042 
P:0178 57F000 00F381  3  792 5044 L63:    move    x:$F381,b
P:017A 45F400 000001  3  795 5045         move    #>1,x1
P:017C 20006E         2  797 5046         and     x1,b
P:017D 2B0000         2  799 5047         move    #0,b2
P:017E 20000B         2  801 5048         tst     b
P:017F 0AF0A2 rrrrrr  6  807 5049         jne     L63
                             5050 
                             5051 ; 203  |
                             5052 ; 204  |    *(pwBuffer-1) = wTemp;
                             5053 
P:0181 045FA0         2  809 5055         movec   m0,n7
P:0182 000000         2  811 5056         nop
P:0183 4CEF00         4  815 5057         move    y:(r7+n7),x0
P:0184 77F400 FFFFFE  3  818 5058         move    #-2,n7
P:0186 000000         2  820 5059         nop
TASKING DSP2410 assembler v1.5r1 Build 138 SN 00100122
                                                                                                                                                                                                                                                       Page  19

M:ADDR CODE           CYCLES LINE SOURCELINE
P:0187 6BEF00         4  824 5060         move    y:(r7+n7),r3
P:0188 000000         2  826 5061         nop
P:0189 446300         2  828 5062         move    x0,x:(r3)
                             5065 
                             5066 ; 205  |
                             5067 ; 206  |    if ( (Sect + 1) < stPartitionBootSector.wStartSectSecondaryFat )
                             5068 
P:018A 77F400 FFFFFB  3  831 5070         move    #-5,n7
P:018C 205F00         2  833 5071         move    (r7)+
P:018D 5EEF00         4  837 5073         move    y:(r7+n7),a
P:018E 205700         2  839 5074         move    (r7)-
P:018F 58EF00         4  843 5076         move    y:(r7+n7),a0
P:0190 210600         2  845 5077         move    a0,y0
P:0191 218700         2  847 5078         move    a1,y1
P:0192 000008         2  849 5079         inc     a
P:0193 5FF000 rrrrrr  3  852 5082         move    y:FstPartitionBootSector+11,b
P:0195 59F000 rrrrrr  3  855 5083         move    y:FstPartitionBootSector+10,b0
P:0197 2B0000         2  857 5084         move    #0,b2
P:0198 2A0000         2  859 5085         move    #0,a2
P:0199 200005         2  861 5086         cmp     b,a
P:019A 0AF0A1 rrrrrr  6  867 5087         jge     L70
                             5088 
                             5089 ; 207  |    {    
                             5090 ; 208  |       // Write 2nd sector
                             5091 ; 209  |        if ( DriveWriteSector(stFat.Device, Sect+1+DataDriveStatus[stFat.Device].iPbsSectorOffset, pwBuffer) != NOERROR )
                             5092 
P:019C 4CF000 rrrrrr  3  870 5094         move    y:FstFat,x0
P:019E 0116D0         2  872 5096         mpy     x0,#22,a
P:019F 211E00         2  874 5097         move    a0,n6
P:01A0 66F400 rrrrrr  3  877 5098         move    #FDataDriveStatus+1,r6
P:01A2 000000         2  879 5099         nop
P:01A3 204E00         2  881 5100         move    (r6)+n6
P:01A4 5EE600         2  883 5101         move    y:(r6),a
P:01A5 218800         2  885 5102         move    a1,a0
P:01A6 214C00         2  887 5103         move    a2,a1
P:01A7 200030         2  889 5104         add     y,a
P:01A8 000008         2  891 5107         inc     a
P:01A9 77F400 FFFFFD  3  894 5108         move    #-3,n7
P:01AB 000000         2  896 5109         nop
P:01AC 68EF00         4  900 5110         move    y:(r7+n7),r0
P:01AD 200049         2  902 5113         tfr     x0,b
P:01AE 0BF080 rrrrrr  6  908 5114         jsr     FDriveWriteSector
P:01B0 200003         2  910 5117         tst     a
P:01B1 0AF0A2 rrrrrr  6  916 5118         jne     L66
                             5119 
                             5120 ; 210  |                return(!NOERROR);
                             5121 ; 211  |       
                             5122 ; 212  |    }
                             5123 ; 213  |    else
                             5124 ; 214  |    {
                             5125 ; 215  |        stFat.Control = CLEAN;            
                             5126 ; 216  |        return(NOERROR);
                             5127 ; 217  |    }        
                             5128 ; 218  |    
                             5129 ; 219  |
                             5130 ; 220  |    // Get 3rd Sector Fat Buffer using swizzle block
                             5131 ; 221  |    HW_SWIZZLECS1R.I = 0x501;         // Manipulates data in memory and places it in memory
                             5132 
P:01B3 46F400 000501  3  919 5134         move    #1281,y0
P:01B5 467000 00F380  3  922 5135         move    y0,x:$F380
                             5136 
                             5137 ; 222  |    HW_SWIZZLESIZER.U = cachedSectorSizeInWords+1;        // Data Size
                             5138 
P:01B7 57F000 rrrrrr  3  925 5140         move    x:FcachedSectorSizeInWords,b
P:01B9 21AE00         2  927 5141         move    b1,a
P:01BA 46F400 000001  3  930 5142         move    #>1,y0
P:01BC 200050         2  932 5143         add     y0,a
P:01BD 547000 00F382  3  935 5144         move    a1,x:$F382
                             5145 
                             5146 ; 223  |
                             5147 ; 224  |    wTemp = *(pwBuffer-1);
                             5148 
P:01BF 77F400 FFFFFE  3  938 5150         move    #-2,n7
P:01C1 000000         2  940 5151         nop
P:01C2 6BEF00         4  944 5152         move    y:(r7+n7),r3
P:01C3 000000         2  946 5153         nop
P:01C4 44E300         2  948 5154         move    x:(r3),x0
P:01C5 045FA0         2  950 5155         movec   m0,n7
P:01C6 000000         2  952 5156         nop
P:01C7 4C6F00         4  956 5157         move    x0,y:(r7+n7)
                             5159 
                             5160 ; 225  |    SetupSwizzleAddrYX(stFat.pwBuffer+cachedSectorSizeInWords+cachedSectorSizeInWords-1, pwBuffer-1);
                             5161 
P:01C8 20003A         2  958 5163         asl     b
P:01C9 21BE00         2  960 5164         move    b1,n6
P:01CA 6EF000 rrrrrr  3  963 5165         move    y:FstFat+7,r6
P:01CC 000000         2  965 5166         nop
P:01CD 044E10         4  969 5167         lua     (r6)+n6,r0
P:01CE 000000         2  971 5168         nop
P:01CF 205000         2  973 5169         move    (r0)-
P:01D0 227400         2  975 5170         move    r3,r4
P:01D1 0BF080 rrrrrr  6  981 5171         jsr     SetupSwizzleAddrYX
                             5172 
                             5173 ; 226  |
                             5174 ; 227  |    HW_SWIZZLECS2R.I = 0x4003;         // Kick it, Source in Xmem, Dest in Ymem
                             5175 
P:01D3 51F400 004003  3  984 5177         move    #16387,b0
P:01D5 517000 00F381  3  987 5178         move    b0,x:$F381
                             5179 
                             5180 ; 228  |
                             5181 ; 229  |    // Wait for swizzle completed
                             5182 ; 230  |    while ( HW_SWIZZLECS2R.I & 0x1 );
                             5183 
P:01D7 55F000 00F381  3  990 5185 L64:    move    x:$F381,b1
P:01D9 46F400 000001  3  993 5186         move    #>1,y0
P:01DB 20005E         2  995 5187         and     y0,b
P:01DC 21AF00         2  997 5188         move    b1,b
P:01DD 2B0000         2  999 5189         move    #0,b2
P:01DE 20000B         2 1001 5190         tst     b
P:01DF 0AF0A2 rrrrrr  6 1007 5191         jne     L64
                             5192 
                             5193 ; 231  |    
                             5194 ; 232  |    *(pwBuffer-1) = wTemp;
                             5195 
P:01E1 045FA0         2 1009 5197         movec   m0,n7
P:01E2 000000         2 1011 5198         nop
P:01E3 4EEF00         4 1015 5199         move    y:(r7+n7),y0
P:01E4 77F400 FFFFFE  3 1018 5200         move    #-2,n7
P:01E6 000000         2 1020 5201         nop
P:01E7 6BEF00         4 1024 5202         move    y:(r7+n7),r3
P:01E8 000000         2 1026 5203         nop
P:01E9 466300         2 1028 5204         move    y0,x:(r3)
                             5207 
                             5208 ; 233  |
                             5209 ; 234  |    // Write 3rd sector
                             5210 ; 235  |    if ( (Sect + 2) < stPartitionBootSector.wStartSectSecondaryFat )
                             5211 
P:01EA 77F400 FFFFFB  3 1031 5213         move    #-5,n7
P:01EC 205F00         2 1033 5214         move    (r7)+
P:01ED 4FEF00         4 1037 5216         move    y:(r7+n7),y1
P:01EE 205700         2 1039 5217         move    (r7)-
P:01EF 4EEF00         4 1043 5219         move    y:(r7+n7),y0
P:01F0 20001B         2 1045 5220         clr     b   
P:01F1 290200         2 1047 5221         move    #2,b0
P:01F2 212400         2 1049 5222         move    b0,x0
P:01F3 21A500         2 1051 5223         move    b1,x1
P:01F4 200038         2 1053 5224         add     y,b
P:01F5 5EF000 rrrrrr  3 1056 5225         move    y:FstPartitionBootSector+11,a
P:01F7 58F000 rrrrrr  3 1059 5226         move    y:FstPartitionBootSector+10,a0
P:01F9 2A0000         2 1061 5227         move    #0,a2
P:01FA 2B0000         2 1063 5228         move    #0,b2
P:01FB 20000D         2 1065 5229         cmp     a,b
P:01FC 0AF0A1 rrrrrr  6 1071 5230         jge     L70
                             5231 
                             5232 ; 236  |    {    
                             5233 ; 237  |        if ( DriveWriteSector(stFat.Device, Sect+2+DataDriveStatus[stFat.Device].iPbsSectorOffset, pwBuffer) != NOERROR )
                             5234 
P:01FE 4EF000 rrrrrr  3 1074 5236         move    y:FstFat,y0
P:0200 200059         2 1076 5238         tfr     y0,b
P:0201 0116E0         2 1078 5239         mpy     y0,#22,a
P:0202 211E00         2 1080 5240         move    a0,n6
P:0203 66F400 rrrrrr  3 1083 5241         move    #FDataDriveStatus+1,r6
P:0205 000000         2 1085 5242         nop
P:0206 204E00         2 1087 5243         move    (r6)+n6
P:0207 5EE600         2 1089 5244         move    y:(r6),a
P:0208 218800         2 1091 5245         move    a1,a0
P:0209 214C00         2 1093 5246         move    a2,a1
P:020A 205F00         2 1095 5247         move    (r7)+
P:020B 4FEF00         4 1099 5249         move    y:(r7+n7),y1
P:020C 205700         2 1101 5250         move    (r7)-
P:020D 4EEF00         4 1105 5252         move    y:(r7+n7),y0
P:020E 200030         2 1107 5253         add     y,a
P:020F 200020         2 1109 5256         add     x,a
P:0210 77F400 FFFFFD  3 1112 5257         move    #-3,n7
P:0212 000000         2 1114 5258         nop
P:0213 68EF00         4 1118 5259         move    y:(r7+n7),r0
P:0214 0BF080 rrrrrr  6 1124 5260         jsr     FDriveWriteSector
P:0216 200003         2 1126 5265         tst     a
P:0217 0AF0AA rrrrrr  6 1132 5266         jeq     L70
                             5267 
                             5268 ; 238  |                return(!NOERROR);
                             5269 
P:0219 56F400 000001  3 1135 5271 L66:    move    #>1,a
P:021B 0AF080 rrrrrr  6 1141 5272         jmp     L71
                             5273 
                             5274 ; 239  |     }
                             5275 ; 240  |    else
                             5276 ; 241  |    {
                             5277 ; 242  |        stFat.Control = CLEAN;            
                             5278 ; 243  |        return(NOERROR);
                             5279 ; 244  |    }        
                             5280 ; 245  |
                             5281 ; 246  |        stFat.Control = CLEAN;            
                             5282 
P:021D 200013         2 1143 5284 L70:    clr     a   
P:021E 5E7000 rrrrrr  3 1146 5285         move    a,y:FstFat+2
                             5286 
                             5287 ; 247  |
                             5288 ; 248  |    return(NOERROR);
                             5289 ; 249  |
                             5290 ; 250  |}
                             5291 
P:0220 77F400 FFFFFA  3 1149 5293 L71:    move    #-6,n7
P:0222 000000         2 1151 5294         nop
P:0223 05EF7C         4 1155 5295         movec   y:(r7+n7),ssh
P:0224 204F00         2 1157 5297         move    (r7)+n7
P:0225 00000C         4 1161 5299         rts
                             5301 
                             5302 ; 251  |
                             5303 ; 252  |
                             5304 ; 253  |
                             5305 ; 254  |LONG _reentrant GetNextCxFat12(DWORD wCurCx)
                             5306 ; 255  |{
                             5307 
                             5312 FGetNextCxFat12:
P:0226 055F7C         2 1163 5313         movec   ssh,y:(r7)+
P:0227 3F0500         2 1165 5316         move    #5,n7
P:0228 000000         2 1167 5317         nop
P:0229 204F00         2 1169 5318         move    (r7)+n7
                             5326 
                             5327 ; 256  |    DWORD wStartSect;
                             5328 ; 257  |    WORD   wOffCx;
                             5329 
P:022A 77F400 FFFFFB  3 1172 5331         move    #-5,n7
P:022C 205F00         2 1174 5332         move    (r7)+
P:022D 5C6F00         4 1178 5334         move    a1,y:(r7+n7)
P:022E 205700         2 1180 5335         move    (r7)-
P:022F 586F00         4 1184 5337         move    a0,y:(r7+n7)
                             5340 
                             5341 ; 258  |    // Calculates start sector of group of 3 buffer sectors for FAT
                             5342 ; 259  |    wStartSect = wCurCx / FAT12_ENTRIES_PER_SECT_GROUP;
                             5343 
P:0230 44F000 rrrrrr  3 1187 5345         move    x:FcachedSectorSize,x0
P:0232 46F400 000006  3 1190 5346         move    #>6,y0
P:0234 2000D0         2 1192 5347         mpy     x0,y0,a
P:0235 200022         2 1194 5348         asr     a
P:0236 210E00         2 1196 5349         move    a0,a
P:0237 57F400 000003  3 1199 5350         move    #>3,b
P:0239 0BF080 rrrrrr  6 1205 5351         jsr     Rdiv_uiuiui
P:023B 210600         2 1207 5352         move    a0,y0
P:023C 270000         2 1209 5353         move    #0,y1
P:023D 205F00         2 1211 5354         move    (r7)+
P:023E 5EEF00         4 1215 5356         move    y:(r7+n7),a
P:023F 205700         2 1217 5357         move    (r7)-
P:0240 58EF00         4 1221 5359         move    y:(r7+n7),a0
P:0241 0BF080 rrrrrr  6 1227 5360         jsr     Rdiv_ululul
                             5362 
                             5363 ; 260  |
                             5364 ; 261  |    // Calculates the cluster offset in the Fat buffer
                             5365 ; 262  |    wOffCx = wCurCx - (wStartSect*FAT12_ENTRIES_PER_SECT_GROUP);
                             5366 
P:0243 210400         2 1229 5368         move    a0,x0
P:0244 218500         2 1231 5369         move    a1,x1
P:0245 77F400 FFFFFD  3 1234 5370         move    #-3,n7
P:0247 205F00         2 1236 5371         move    (r7)+
P:0248 4D6F00         4 1240 5373         move    x1,y:(r7+n7)
P:0249 205700         2 1242 5374         move    (r7)-
P:024A 4C6F00         4 1246 5376         move    x0,y:(r7+n7)
P:024B 0040F8         2 1248 5377         ori     #$40,mr
P:024C 000000         2 1250 5378         nop
P:024D 2000D0         2 1252 5379         mpy     y0,x0,a
TASKING DSP2410 assembler v1.5r1 Build 138 SN 00100122
                                                                                                                                                                                                                                                       Page  20

M:ADDR CODE           CYCLES LINE SOURCELINE
P:024E 2109E2         2 1254 5380         mac     x1,y0,a a0,b0
P:024F 2000C2         2 1256 5381         mac     x0,y1,a
P:0250 00BFB8         2 1258 5382         andi    #$BF,mr
P:0251 210D00         2 1260 5383         move    a0,b1
P:0252 218B00         2 1262 5384         move    a1,b2
P:0253 20002A         2 1264 5385         asr     b
P:0254 212400         2 1266 5388         move    b0,x0
P:0255 21A500         2 1268 5389         move    b1,x1
P:0256 77F400 FFFFFB  3 1271 5390         move    #-5,n7
P:0258 205F00         2 1273 5391         move    (r7)+
P:0259 5FEF00         4 1277 5393         move    y:(r7+n7),b
P:025A 205700         2 1279 5394         move    (r7)-
P:025B 59EF00         4 1283 5396         move    y:(r7+n7),b0
P:025C 20002C         2 1285 5397         sub     x,b
P:025D 045FA0         2 1287 5401         movec   m0,n7
P:025E 000000         2 1289 5402         nop
P:025F 596F00         4 1293 5403         move    b0,y:(r7+n7)
                             5405 
                             5406 ; 263  |    
                             5407 ; 264  |    // Loads the fat sector group into fat buffer if needed
                             5408 ; 265  |    // Each Fat buffer group is 3 sectors
                             5409 ; 266  |    if ( ((wStartSect * 3)  + stFat.FirstPrimaryFatSect) != stFat.FatSectorCached )
                             5410 
P:0260 270000         2 1295 5412         move    #0,y1
P:0261 46F400 000003  3 1298 5413         move    #>3,y0
P:0263 77F400 FFFFFD  3 1301 5414         move    #-3,n7
P:0265 205F00         2 1303 5415         move    (r7)+
P:0266 4DEF00         4 1307 5417         move    y:(r7+n7),x1
P:0267 205700         2 1309 5418         move    (r7)-
P:0268 4CEF00         4 1313 5420         move    y:(r7+n7),x0
P:0269 0040F8         2 1315 5421         ori     #$40,mr
P:026A 000000         2 1317 5422         nop
P:026B 2000D0         2 1319 5423         mpy     y0,x0,a
P:026C 2109E2         2 1321 5424         mac     x1,y0,a a0,b0
P:026D 2000C2         2 1323 5425         mac     x0,y1,a
P:026E 00BFB8         2 1325 5426         andi    #$BF,mr
P:026F 210D00         2 1327 5427         move    a0,b1
P:0270 218B00         2 1329 5428         move    a1,b2
P:0271 20002A         2 1331 5429         asr     b
P:0272 5EF000 rrrrrr  3 1334 5432         move    y:FstFat+4,a
P:0274 58F000 rrrrrr  3 1337 5433         move    y:FstFat+3,a0
P:0276 200010         2 1339 5434         add     b,a
P:0277 59F000 rrrrrr  3 1342 5435         move    y:FstFat+1,b0
P:0279 2D0000         2 1344 5436         move    #0,b1
P:027A 2B0000         2 1346 5437         move    #0,b2
P:027B 2A0000         2 1348 5438         move    #0,a2
P:027C 200005         2 1350 5439         cmp     b,a
P:027D 0AF0AA rrrrrr  6 1356 5440         jeq     L73
                             5441 
                             5442 ; 267  |        if ( LoadFatSector(((wStartSect * 3) + stFat.FirstPrimaryFatSect), MediaBuffer) != NOERROR )
                             5443 
P:027F 68F000 rrrrrr  3 1359 5445         move    y:FMediaBuffer,r0
P:0281 0BF080 rrrrrr  6 1365 5446         jsr     FLoadFatSector
P:0283 2A0000         2 1367 5448         move    #0,a2
P:0284 200003         2 1369 5449         tst     a
P:0285 0AF0AA rrrrrr  6 1375 5450         jeq     L73
                             5451 
                             5452 ; 268  |            return(-1);
                             5453 
P:0287 200013         2 1377 5455         clr     a   
P:0288 00000A         2 1379 5456         dec     a
P:0289 0AF080 rrrrrr  6 1385 5457         jmp     L74
                             5458 
                             5459 ; 269  |            
                             5460 ; 270  |    return(FetchCxFat12(wOffCx));
                             5461 
                             5463 L73:
P:028B 045FA0         2 1387 5465         movec   m0,n7
P:028C 000000         2 1389 5466         nop
P:028D 58EF00         4 1393 5467         move    y:(r7+n7),a0
P:028E 2C0000         2 1395 5468         move    #0,a1
P:028F 2A0000         2 1397 5469         move    #0,a2
P:0290 0BF080 rrrrrr  6 1403 5470         jsr     FFetchCxFat12
                             5471 
                             5472 ; 271  |}
                             5473 
P:0292 77F400 FFFFFA  3 1406 5475 L74:    move    #-6,n7
P:0294 000000         2 1408 5476         nop
P:0295 05EF7C         4 1412 5477         movec   y:(r7+n7),ssh
P:0296 204F00         2 1414 5479         move    (r7)+n7
P:0297 00000C         4 1418 5481         rts
                             5483 
                             5484 ; 272  |
                             5485 ; 273  |
                             5486 ; 274  |LONG _reentrant GetNextCxFat16(DWORD wCurCx)
                             5487 ; 275  |{
                             5488 
                             5493 FGetNextCxFat16:
P:0298 055F7C         2 1420 5494         movec   ssh,y:(r7)+
P:0299 3F0500         2 1422 5497         move    #5,n7
P:029A 000000         2 1424 5498         nop
P:029B 204F00         2 1426 5499         move    (r7)+n7
                             5507 
                             5508 ; 276  |    DWORD wStartSect;
                             5509 ; 277  |    WORD   wOffCx;
                             5510 ; 278  |    // Calculates start sector of group of 3 buffer sectors for FAT
                             5511 ; 279  |    wStartSect = wCurCx / FAT16_ENTRIES_PER_SECT_GROUP;
                             5512 
P:029C 46F000 rrrrrr  3 1429 5514         move    x:FcachedSectorSize,y0
P:029E 47F400 000003  3 1432 5515         move    #>3,y1
P:02A0 2000B8         2 1434 5516         mpy     y0,y1,b
P:02A1 20002A         2 1436 5517         asr     b
P:02A2 212F00         2 1438 5518         move    b0,b
P:02A3 20002B         2 1440 5519         lsr     b
P:02A4 21A600         2 1442 5520         move    b1,y0
P:02A5 270000         2 1444 5521         move    #0,y1
P:02A6 77F400 FFFFFB  3 1447 5522         move    #-5,n7
P:02A8 205F00         2 1449 5523         move    (r7)+
P:02A9 5C6F00         4 1453 5525         move    a1,y:(r7+n7)
P:02AA 205700         2 1455 5526         move    (r7)-
P:02AB 586F00         4 1459 5528         move    a0,y:(r7+n7)
P:02AC 0BF080 rrrrrr  6 1465 5529         jsr     Rdiv_ululul
                             5533 
                             5534 ; 280  |
                             5535 ; 281  |    // Calculates the cluster offset in the Fat buffer
                             5536 ; 282  |    wOffCx = wCurCx - (wStartSect*FAT16_ENTRIES_PER_SECT_GROUP);
                             5537 
P:02AE 210400         2 1467 5539         move    a0,x0
P:02AF 218500         2 1469 5540         move    a1,x1
P:02B0 77F400 FFFFFD  3 1472 5541         move    #-3,n7
P:02B2 205F00         2 1474 5542         move    (r7)+
P:02B3 4D6F00         4 1478 5544         move    x1,y:(r7+n7)
P:02B4 205700         2 1480 5545         move    (r7)-
P:02B5 4C6F00         4 1484 5547         move    x0,y:(r7+n7)
P:02B6 0040F8         2 1486 5548         ori     #$40,mr
P:02B7 000000         2 1488 5549         nop
P:02B8 2000D0         2 1490 5550         mpy     y0,x0,a
P:02B9 2109E2         2 1492 5551         mac     x1,y0,a a0,b0
P:02BA 2000C2         2 1494 5552         mac     x0,y1,a
P:02BB 00BFB8         2 1496 5553         andi    #$BF,mr
P:02BC 210D00         2 1498 5554         move    a0,b1
P:02BD 218B00         2 1500 5555         move    a1,b2
P:02BE 20002A         2 1502 5556         asr     b
P:02BF 212400         2 1504 5559         move    b0,x0
P:02C0 21A500         2 1506 5560         move    b1,x1
P:02C1 77F400 FFFFFB  3 1509 5561         move    #-5,n7
P:02C3 205F00         2 1511 5562         move    (r7)+
P:02C4 5FEF00         4 1515 5564         move    y:(r7+n7),b
P:02C5 205700         2 1517 5565         move    (r7)-
P:02C6 59EF00         4 1521 5567         move    y:(r7+n7),b0
P:02C7 20002C         2 1523 5568         sub     x,b
P:02C8 045FA0         2 1525 5572         movec   m0,n7
P:02C9 000000         2 1527 5573         nop
P:02CA 596F00         4 1531 5574         move    b0,y:(r7+n7)
                             5576 
                             5577 ; 283  |    
                             5578 ; 284  |    // Loads the fat sector group into fat buffer if needed
                             5579 ; 285  |    // Each Fat buffer group is 3 sectors
                             5580 ; 286  |    if ( ((wStartSect * 3) + stFat.FirstPrimaryFatSect) != stFat.FatSectorCached )
                             5581 
P:02CB 270000         2 1533 5583         move    #0,y1
P:02CC 46F400 000003  3 1536 5584         move    #>3,y0
P:02CE 77F400 FFFFFD  3 1539 5585         move    #-3,n7
P:02D0 205F00         2 1541 5586         move    (r7)+
P:02D1 4DEF00         4 1545 5588         move    y:(r7+n7),x1
P:02D2 205700         2 1547 5589         move    (r7)-
P:02D3 4CEF00         4 1551 5591         move    y:(r7+n7),x0
P:02D4 0040F8         2 1553 5592         ori     #$40,mr
P:02D5 000000         2 1555 5593         nop
P:02D6 2000D0         2 1557 5594         mpy     y0,x0,a
P:02D7 2109E2         2 1559 5595         mac     x1,y0,a a0,b0
P:02D8 2000C2         2 1561 5596         mac     x0,y1,a
P:02D9 00BFB8         2 1563 5597         andi    #$BF,mr
P:02DA 210D00         2 1565 5598         move    a0,b1
P:02DB 218B00         2 1567 5599         move    a1,b2
P:02DC 20002A         2 1569 5600         asr     b
P:02DD 5EF000 rrrrrr  3 1572 5603         move    y:FstFat+4,a
P:02DF 58F000 rrrrrr  3 1575 5604         move    y:FstFat+3,a0
P:02E1 200010         2 1577 5605         add     b,a
P:02E2 59F000 rrrrrr  3 1580 5606         move    y:FstFat+1,b0
P:02E4 2D0000         2 1582 5607         move    #0,b1
P:02E5 2B0000         2 1584 5608         move    #0,b2
P:02E6 2A0000         2 1586 5609         move    #0,a2
P:02E7 200005         2 1588 5610         cmp     b,a
P:02E8 0AF0AA rrrrrr  6 1594 5611         jeq     L76
                             5612 
                             5613 ; 287  |        if ( LoadFatSector(((wStartSect * 3) + stFat.FirstPrimaryFatSect), MediaBuffer) != NOERROR )
                             5614 
P:02EA 68F000 rrrrrr  3 1597 5616         move    y:FMediaBuffer,r0
P:02EC 0BF080 rrrrrr  6 1603 5617         jsr     FLoadFatSector
P:02EE 2A0000         2 1605 5619         move    #0,a2
P:02EF 200003         2 1607 5620         tst     a
P:02F0 0AF0AA rrrrrr  6 1613 5621         jeq     L76
                             5622 
                             5623 ; 288  |            return(-1);
                             5624 
P:02F2 200013         2 1615 5626         clr     a   
P:02F3 00000A         2 1617 5627         dec     a
P:02F4 0AF080 rrrrrr  6 1623 5628         jmp     L77
                             5629 
                             5630 ; 289  |            
                             5631 ; 290  |    return(FSGetWord(stFat.pwBuffer,(wOffCx*2), Y_MEMORY));
                             5632 
                             5634 L76:
P:02F6 68F000 rrrrrr  3 1626 5636         move    y:FstFat+7,r0
P:02F8 045FA0         2 1628 5637         movec   m0,n7
P:02F9 000000         2 1630 5638         nop
P:02FA 5EEF00         4 1634 5639         move    y:(r7+n7),a
P:02FB 57F400 000002  3 1637 5640         move    #>2,b
P:02FD 200033         2 1639 5641         lsl     a
P:02FE 218E00         2 1641 5642         move    a1,a
P:02FF 0BF080 rrrrrr  6 1647 5643         jsr     FFSGetWord
P:0301 218800         2 1649 5644         move    a1,a0
P:0302 214C00         2 1651 5645         move    a2,a1
                             5646 
                             5647 ; 291  |
                             5648 ; 292  |}        
                             5649 
P:0303 77F400 FFFFFA  3 1654 5651 L77:    move    #-6,n7
P:0305 000000         2 1656 5652         nop
P:0306 05EF7C         4 1660 5653         movec   y:(r7+n7),ssh
P:0307 204F00         2 1662 5655         move    (r7)+n7
P:0308 00000C         4 1666 5657         rts
                             5659 
                             5660 ; 293  |
                             5661 ; 294  |
                             5662 ; 295  |LONG _reentrant GetNextCxFat32(DWORD wCurCx)
                             5663 ; 296  |{
                             5664 
                             5669 FGetNextCxFat32:
P:0309 055F7C         2 1668 5670         movec   ssh,y:(r7)+
P:030A 3F0500         2 1670 5673         move    #5,n7
P:030B 000000         2 1672 5674         nop
P:030C 204F00         2 1674 5675         move    (r7)+n7
                             5683 
                             5684 ; 297  |   WORD  wOffCx;
                             5685 ; 298  |   DWORD  wStartSect;
                             5686 ; 299  |    
                             5687 ; 300  |    // Calculates start sector of group of 3 buffer sectors for FAT
                             5688 ; 301  |//    wStartSect = Getsectorno(wCurCx);
                             5689 ; 302  |    wStartSect = wCurCx / FAT32_ENTRIES_PER_SECT_GROUP;
                             5690 
P:030D 47F000 rrrrrr  3 1677 5692         move    x:FcachedSectorSize,y1
P:030F 45F400 000003  3 1680 5693         move    #>3,x1
P:0311 2000F8         2 1682 5694         mpy     y1,x1,b
P:0312 20002A         2 1684 5695         asr     b
P:0313 212500         2 1686 5696         move    b0,x1
P:0314 0102F8         2 1688 5697         mpy     x1,#2,b
P:0315 21A600         2 1690 5698         move    b1,y0
P:0316 270000         2 1692 5699         move    #0,y1
P:0317 77F400 FFFFFB  3 1695 5700         move    #-5,n7
P:0319 205F00         2 1697 5701         move    (r7)+
P:031A 5C6F00         4 1701 5703         move    a1,y:(r7+n7)
P:031B 205700         2 1703 5704         move    (r7)-
P:031C 586F00         4 1707 5706         move    a0,y:(r7+n7)
P:031D 0BF080 rrrrrr  6 1713 5707         jsr     Rdiv_ululul
                             5711 
                             5712 ; 303  |    // Calculates the cluster offset in the Fat buffer
                             5713 ; 304  |    wOffCx = wCurCx - (wStartSect*FAT32_ENTRIES_PER_SECT_GROUP);
                             5714 
P:031F 210400         2 1715 5716         move    a0,x0
TASKING DSP2410 assembler v1.5r1 Build 138 SN 00100122
                                                                                                                                                                                                                                                       Page  21

M:ADDR CODE           CYCLES LINE SOURCELINE
P:0320 218500         2 1717 5717         move    a1,x1
P:0321 77F400 FFFFFD  3 1720 5718         move    #-3,n7
P:0323 205F00         2 1722 5719         move    (r7)+
P:0324 4D6F00         4 1726 5721         move    x1,y:(r7+n7)
P:0325 205700         2 1728 5722         move    (r7)-
P:0326 4C6F00         4 1732 5724         move    x0,y:(r7+n7)
P:0327 0040F8         2 1734 5725         ori     #$40,mr
P:0328 000000         2 1736 5726         nop
P:0329 2000D0         2 1738 5727         mpy     y0,x0,a
P:032A 2109E2         2 1740 5728         mac     x1,y0,a a0,b0
P:032B 2000C2         2 1742 5729         mac     x0,y1,a
P:032C 00BFB8         2 1744 5730         andi    #$BF,mr
P:032D 210D00         2 1746 5731         move    a0,b1
P:032E 218B00         2 1748 5732         move    a1,b2
P:032F 20002A         2 1750 5733         asr     b
P:0330 212400         2 1752 5736         move    b0,x0
P:0331 21A500         2 1754 5737         move    b1,x1
P:0332 77F400 FFFFFB  3 1757 5738         move    #-5,n7
P:0334 205F00         2 1759 5739         move    (r7)+
P:0335 5FEF00         4 1763 5741         move    y:(r7+n7),b
P:0336 205700         2 1765 5742         move    (r7)-
P:0337 59EF00         4 1769 5744         move    y:(r7+n7),b0
P:0338 20002C         2 1771 5745         sub     x,b
P:0339 045FA0         2 1773 5749         movec   m0,n7
P:033A 000000         2 1775 5750         nop
P:033B 596F00         4 1779 5751         move    b0,y:(r7+n7)
                             5753 
                             5754 ; 305  |    
                             5755 ; 306  |    // Loads the fat sector group into fat buffer if needed
                             5756 ; 307  |    // Each Fat buffer group is 3 sectors
                             5757 ; 308  |    if ( ((wStartSect * 3) + stFat.FirstPrimaryFatSect) != stFat.FatSectorCached )
                             5758 
P:033C 270000         2 1781 5760         move    #0,y1
P:033D 46F400 000003  3 1784 5761         move    #>3,y0
P:033F 77F400 FFFFFD  3 1787 5762         move    #-3,n7
P:0341 205F00         2 1789 5763         move    (r7)+
P:0342 4DEF00         4 1793 5765         move    y:(r7+n7),x1
P:0343 205700         2 1795 5766         move    (r7)-
P:0344 4CEF00         4 1799 5768         move    y:(r7+n7),x0
P:0345 0040F8         2 1801 5769         ori     #$40,mr
P:0346 000000         2 1803 5770         nop
P:0347 2000D0         2 1805 5771         mpy     y0,x0,a
P:0348 2109E2         2 1807 5772         mac     x1,y0,a a0,b0
P:0349 2000C2         2 1809 5773         mac     x0,y1,a
P:034A 00BFB8         2 1811 5774         andi    #$BF,mr
P:034B 210D00         2 1813 5775         move    a0,b1
P:034C 218B00         2 1815 5776         move    a1,b2
P:034D 20002A         2 1817 5777         asr     b
P:034E 5EF000 rrrrrr  3 1820 5780         move    y:FstFat+4,a
P:0350 58F000 rrrrrr  3 1823 5781         move    y:FstFat+3,a0
P:0352 200010         2 1825 5782         add     b,a
P:0353 59F000 rrrrrr  3 1828 5783         move    y:FstFat+1,b0
P:0355 2D0000         2 1830 5784         move    #0,b1
P:0356 2B0000         2 1832 5785         move    #0,b2
P:0357 2A0000         2 1834 5786         move    #0,a2
P:0358 200005         2 1836 5787         cmp     b,a
P:0359 0AF0AA rrrrrr  6 1842 5788         jeq     L79
                             5789 
                             5790 ; 309  |        if ( LoadFatSector(((wStartSect * 3) + stFat.FirstPrimaryFatSect), MediaBuffer) != NOERROR )
                             5791 
P:035B 68F000 rrrrrr  3 1845 5793         move    y:FMediaBuffer,r0
P:035D 0BF080 rrrrrr  6 1851 5794         jsr     FLoadFatSector
P:035F 2A0000         2 1853 5796         move    #0,a2
P:0360 200003         2 1855 5797         tst     a
P:0361 0AF0AA rrrrrr  6 1861 5798         jeq     L79
                             5799 
                             5800 ; 310  |            return(-1);
                             5801 
P:0363 200013         2 1863 5803         clr     a   
P:0364 00000A         2 1865 5804         dec     a
P:0365 0AF080 rrrrrr  6 1871 5805         jmp     L80
                             5806 
                             5807 ; 311  |            
                             5808 ; 312  |    return(GetDWordY(stFat.pwBuffer,(wOffCx*4), Y_MEMORY));
                             5809 
                             5811 L79:
P:0367 68F000 rrrrrr  3 1874 5813         move    y:FstFat+7,r0
P:0369 045FA0         2 1876 5814         movec   m0,n7
P:036A 000000         2 1878 5815         nop
P:036B 4EEF00         4 1882 5816         move    y:(r7+n7),y0
P:036C 0116E0         2 1884 5817         mpy     y0,#22,a
P:036D 210E00         2 1886 5818         move    a0,a
P:036E 57F400 000002  3 1889 5819         move    #>2,b
P:0370 0BF080 rrrrrr  6 1895 5820         jsr     FGetDWordY
                             5821 
                             5822 ; 313  |
                             5823 ; 314  |}        
                             5824 
P:0372 77F400 FFFFFA  3 1898 5826 L80:    move    #-6,n7
P:0374 000000         2 1900 5827         nop
P:0375 05EF7C         4 1904 5828         movec   y:(r7+n7),ssh
P:0376 204F00         2 1906 5830         move    (r7)+n7
P:0377 00000C         4 1910 5832         rts
                             5834 
                             5835 ; 315  |
                             5836 ; 316  |
                             5837 ; 317  |
                             5838 ; 318  |///////////////////////////////////////////////////////////////////////////////
                             5839 ; 319  |//
                             5840 ; 320  |//>  Name:           FetchCxFat12
                             5841 ; 321  |//
                             5842 ; 322  |//   Type:           Function
                             5843 ; 323  |//
                             5844 ; 324  |//   Description:    Fetches a FAT entry from the current FAT buffer
                             5845 ; 325  |//                   
                             5846 ; 326  |//
                             5847 ; 327  |//   Inputs:         wCurCx             : Fat Entry to fetch
                             5848 ; 328  |//
                             5849 ; 329  |//   Outputs:        
                             5850 ; 330  |//                     contents of FAT entry
                             5851 ; 331  |//                   
                             5852 ; 332  |//   Notes:          
                             5853 ; 333  |//                  The FAT entry wCurCx is referenced to the FAT sector 
                             5854 ; 334  |//                  buffered. Use GetNextCxFat12() if FAT entry is an
                             5855 ; 335  |//                  absolute number. 
                             5856 ; 336  |//<
                             5857 ; 337  |///////////////////////////////////////////////////////////////////////////////
                             5858 ; 338  |LONG _reentrant FetchCxFat12(DWORD wCurCx)
                             5859 ; 339  |{
                             5860 
                             5865 FFetchCxFat12:
                             5870 
                             5871 ; 340  |    DWORD    wTemp = wCurCx/2;
                             5872 
P:0378 200009         2 1912 5874         tfr     a,b
P:0379 2B0000         2 1914 5875         move    #0,b2
P:037A 20002A         2 1916 5876         asr     b
                             5880 
                             5881 ; 341  |    WORD    wResult=0;
                             5882 ; 342  |    
                             5883 ; 343  |    if ( wTemp*2 != wCurCx )
                             5884 
P:037B 212600         2 1918 5886         move    b0,y0
P:037C 21A700         2 1920 5887         move    b1,y1
P:037D 20003A         2 1922 5888         asl     b
P:037E 2B0000         2 1924 5891         move    #0,b2
P:037F 20000D         2 1926 5892         cmp     a,b
P:0380 0AF0AA rrrrrr  6 1932 5893         jeq     L83
                             5894 
                             5895 ; 344  |        // Fecth MS 12-bit word from entry
                             5896 ; 345  |        return((LONG)(*(stFat.pwBuffer + wTemp) >> 12));
                             5897 
P:0382 6EF000 rrrrrr  3 1935 5899         move    y:FstFat+7,r6
P:0384 200079         2 1937 5900         tfr     y1,b
P:0385 20C900         2 1939 5901         move    y0,b0
P:0386 213E00         2 1941 5902         move    b0,n6
P:0387 000000         2 1943 5905         nop
P:0388 204E00         2 1945 5906         move    (r6)+n6
P:0389 5FE600         2 1947 5907         move    y:(r6),b
P:038A 060C80 rrrrrr  6 1953 5909         do      #12,L85
P:038C 20002B         2 1955 5911         lsr     b
P:038D 000000         2 1957 5912         nop
                         (4) 5913 L85:
P:038E 21A900         2 1959 5915         move    b1,b0
P:038F 200013         2 1961 5916         clr     a   
P:0390 212800         2 1963 5917         move    b0,a0
P:0391 00000C         4 1967 5919         rts
                             5920 
                             5921 ; 346  |    else
                             5922 ; 347  |        // Fecth LS 12-bit word from entry
                             5923 ; 348  |        return((LONG)(*(stFat.pwBuffer +  wTemp) & 0x000fff));
                             5924 
P:0392 6DF000 rrrrrr  3 1970 5926 L83:    move    y:FstFat+7,r5
P:0394 200079         2 1972 5927         tfr     y1,b
P:0395 20C900         2 1974 5928         move    y0,b0
P:0396 213D00         2 1976 5929         move    b0,n5
P:0397 000000         2 1978 5930         nop
P:0398 044D16         4 1982 5931         lua     (r5)+n5,r6
P:0399 000000         2 1984 5932         nop
P:039A 5FE600         2 1986 5933         move    y:(r6),b
P:039B 44F400 000FFF  3 1989 5934         move    #$FFF,x0
P:039D 20004E         2 1991 5935         and     x0,b
P:039E 21A900         2 1993 5936         move    b1,b0
P:039F 200013         2 1995 5937         clr     a   
P:03A0 212800         2 1997 5938         move    b0,a0
                             5939 
                             5940 ; 349  |}                
                             5941 
P:03A1 00000C         4 2001 5943         rts
                             5945 
                             5946 ; 350  |        
                             5947 ; 351  |
                             5948 ; 352  |
                             5949 ; 353  |
                             5950 ; 354  |
                             5951 ; 355  |///////////////////////////////////////////////////////////////////////////////
                             5952 ; 356  |//
                             5953 ; 357  |//>  Name:           FreeCxFat
                             5954 ; 358  |//
                             5955 ; 359  |//   Type:           Function
                             5956 ; 360  |//
                             5957 ; 361  |//   Description:    Frees the specified FAT entry.
                             5958 ; 362  |//                   
                             5959 ; 363  |//
                             5960 ; 364  |//   Inputs:         wFatEntry  : Fat Entry to free up
                             5961 ; 365  |//
                             5962 ; 366  |//   Outputs:        
                             5963 ; 367  |//                     NOERROR -> Operation successful
                             5964 ; 368  |//                     !NOERROR -> File System FAT not supported
                             5965 ; 369  |//                              or FAT outside of boundaries
                             5966 ; 370  |//                              or impossible to read a sector
                             5967 ; 371  |//                   
                             5968 ; 372  |//   Notes:          
                             5969 ; 373  |//                  Depending of the file system FAT, this function calls 
                             5970 ; 374  |//                      FreeCxFat12 or FreeCxFat16
                             5971 ; 375  |//<
                             5972 ; 376  |///////////////////////////////////////////////////////////////////////////////
                             5973 ; 377  |BOOL _reentrant FreeCxFat(DWORD wFatEntry)
                             5974 ; 378  |{
                             5975 
                             5980 FFreeCxFat:
P:03A2 055F7C         2 2003 5981         movec   ssh,y:(r7)+
P:03A3 205F00         2 2005 5984         move    (r7)+
P:03A4 205F00         2 2007 5985         move    (r7)+
                             5996 
                             5997 ; 379  |    BOOL (*FreeCxFromFat) (DWORD wCurCx);     // pointer to function
                             5998 ; 380  |    LONG wFatEntryValue; 
                             5999 ; 381  |    
                             6000 ; 382  |    // Read content of Fat Entry
                             6001 ; 383  |    wFatEntryValue = GetNextCxFromFat(wFatEntry);
                             6002 
P:03A5 6EF000 rrrrrr  3 2010 6004         move    y:FGetNextCxFromFat,r6
P:03A7 77F400 FFFFFE  3 2013 6005         move    #-2,n7
P:03A9 205F00         2 2015 6006         move    (r7)+
P:03AA 5C6F00         4 2019 6008         move    a1,y:(r7+n7)
P:03AB 205700         2 2021 6009         move    (r7)-
P:03AC 586F00         4 2025 6011         move    a0,y:(r7+n7)
P:03AD 0BE680         4 2029 6016         jsr     (r6)
                             6020 
                             6021 ; 384  |
                             6022 ; 385  |    // If -1, the FAT is not supported => catastrophic
                             6023 ; 386  |    if ( wFatEntryValue == -1 )
                             6024 
P:03AE 20001B         2 2031 6026         clr     b   
P:03AF 00000B         2 2033 6027         dec     b
P:03B0 200005         2 2035 6028         cmp     b,a
P:03B1 0AF0AA rrrrrr  6 2041 6029         jeq     L99
                             6030 
                             6031 ; 387  |        return(!NOERROR);
                             6032 ; 388  |    
                             6033 ; 389  |    // If 0, the FAT entry is already free
                             6034 ; 390  |    if ( wFatEntryValue == 0x0 )
                             6035 
P:03B3 200003         2 2043 6037         tst     a
P:03B4 0AF0A2 rrrrrr  6 2049 6038         jne     L96
                             6039 
                             6040 ; 391  |        return(NOERROR);        
                             6041 
P:03B6 200013         2 2051 6043         clr     a   
P:03B7 0AF080 rrrrrr  6 2057 6045         jmp     L104
                             6046 
TASKING DSP2410 assembler v1.5r1 Build 138 SN 00100122
                                                                                                                                                                                                                                                       Page  22

M:ADDR CODE           CYCLES LINE SOURCELINE
                             6047 ; 392  |    
                             6048 ; 393  |    if ( stPartitionBootSector.TypeFileSystem == FS_FAT12 )
                             6049 
P:03B9 5FF000 rrrrrr  3 2060 6051 L96:    move    y:FstPartitionBootSector,b
P:03BB 20000B         2 2062 6052         tst     b
P:03BC 0AF0A2 rrrrrr  6 2068 6053         jne     L97
                             6054 
                             6055 ; 394  |        FreeCxFromFat = &FreeCxFat12;
                             6056 
P:03BE 66F400 rrrrrr  3 2071 6058         move    #FFreeCxFat12,r6
P:03C0 0AF080 rrrrrr  6 2077 6060         jmp     L102
                             6061 
                             6062 ; 395  |        
                             6063 ; 396  |    else if(stPartitionBootSector.TypeFileSystem == FS_FAT16)
                             6064 
P:03C2 46F400 000001  3 2080 6066 L97:    move    #>1,y0
P:03C4 20005D         2 2082 6067         cmp     y0,b
P:03C5 0AF0A2 rrrrrr  6 2088 6068         jne     L98
                             6069 
                             6070 ; 397  |        FreeCxFromFat = &FreeCxFat16;
                             6071 
P:03C7 66F400 rrrrrr  3 2091 6073         move    #FFreeCxFat16,r6
P:03C9 0AF080 rrrrrr  6 2097 6074         jmp     L102
                             6075 
                             6076 ; 398  | 
                             6077 ; 399  |    else if ( stPartitionBootSector.TypeFileSystem == FS_FAT32 )
                             6078 
P:03CB 47F400 000002  3 2100 6080 L98:    move    #>2,y1
P:03CD 20007D         2 2102 6081         cmp     y1,b
P:03CE 0AF0AA rrrrrr  6 2108 6082         jeq     L100
                             6083 
                             6084 ; 400  |        FreeCxFromFat = &FreeCxFat32;
                             6085 ; 401  | 
                             6086 ; 402  |    else
                             6087 ; 403  |        return(!NOERROR);
                             6088 
P:03D0 56F400 000001  3 2111 6090 L99:    move    #>1,a
P:03D2 0AF080 rrrrrr  6 2117 6091         jmp     L104
P:03D4 66F400 rrrrrr  3 2120 6093 L100:   move    #FFreeCxFat32,r6
                             6094 
                             6095 ; 404  |        
                             6096 ; 405  |    return((*FreeCxFromFat)(wFatEntry));            
                             6097 
P:03D6 77F400 FFFFFE  3 2123 6099 L102:   move    #-2,n7
P:03D8 205F00         2 2125 6100         move    (r7)+
P:03D9 5EEF00         4 2129 6102         move    y:(r7+n7),a
P:03DA 205700         2 2131 6103         move    (r7)-
P:03DB 58EF00         4 2135 6105         move    y:(r7+n7),a0
P:03DC 0BE680         4 2139 6106         jsr     (r6)
                             6111 
                             6112 ; 406  |
                             6113 ; 407  |}
                             6114 
P:03DD 205700         2 2141 6116 L104:   move    (r7)-
P:03DE 205700         2 2143 6117         move    (r7)-
P:03DF 05FF7C         4 2147 6119         movec   y:-(r7),ssh
P:03E0 000000         2 2149 6122         nop
P:03E1 00000C         4 2153 6123         rts
                             6125 
                             6126 ; 408  |
                             6127 ; 409  |
                             6128 ; 410  |BOOL _reentrant FreeCxFat12(DWORD wCluster)
                             6129 ; 411  |{
                             6130 
                             6135 FFreeCxFat12:
P:03E2 055F7C         2 2155 6136         movec   ssh,y:(r7)+
P:03E3 3F0600         2 2157 6139         move    #6,n7
P:03E4 000000         2 2159 6140         nop
P:03E5 204F00         2 2161 6141         move    (r7)+n7
                             6151 
                             6152 ; 412  |    DWORD wStartSect, wOffCx, wTemp;
                             6153 
P:03E6 77F400 FFFFFA  3 2164 6155         move    #-6,n7
P:03E8 205F00         2 2166 6156         move    (r7)+
P:03E9 5C6F00         4 2170 6158         move    a1,y:(r7+n7)
P:03EA 205700         2 2172 6159         move    (r7)-
P:03EB 586F00         4 2176 6161         move    a0,y:(r7+n7)
                             6164 
                             6165 ; 413  |    
                             6166 ; 414  |    // Calculates start sector of group of 3 buffer sectors for FAT
                             6167 ; 415  |    wStartSect = wCluster / FAT12_ENTRIES_PER_SECT_GROUP;
                             6168 
P:03EC 46F000 rrrrrr  3 2179 6170         move    x:FcachedSectorSize,y0
P:03EE 47F400 000006  3 2182 6171         move    #>6,y1
P:03F0 2000B0         2 2184 6172         mpy     y0,y1,a
P:03F1 200022         2 2186 6173         asr     a
P:03F2 210E00         2 2188 6174         move    a0,a
P:03F3 57F400 000003  3 2191 6175         move    #>3,b
P:03F5 0BF080 rrrrrr  6 2197 6176         jsr     Rdiv_uiuiui
P:03F7 210600         2 2199 6177         move    a0,y0
P:03F8 270000         2 2201 6178         move    #0,y1
P:03F9 205F00         2 2203 6179         move    (r7)+
P:03FA 5EEF00         4 2207 6181         move    y:(r7+n7),a
P:03FB 205700         2 2209 6182         move    (r7)-
P:03FC 58EF00         4 2213 6184         move    y:(r7+n7),a0
P:03FD 0BF080 rrrrrr  6 2219 6185         jsr     Rdiv_ululul
                             6187 
                             6188 ; 416  |
                             6189 ; 417  |    // Calculates the cluster offset in the Fat buffer
                             6190 ; 418  |    wOffCx = wCluster - (wStartSect*FAT12_ENTRIES_PER_SECT_GROUP);
                             6191 
P:03FF 210400         2 2221 6193         move    a0,x0
P:0400 218500         2 2223 6194         move    a1,x1
P:0401 77F400 FFFFFC  3 2226 6195         move    #-4,n7
P:0403 205F00         2 2228 6196         move    (r7)+
P:0404 4D6F00         4 2232 6198         move    x1,y:(r7+n7)
P:0405 205700         2 2234 6199         move    (r7)-
P:0406 4C6F00         4 2238 6201         move    x0,y:(r7+n7)
P:0407 0040F8         2 2240 6202         ori     #$40,mr
P:0408 000000         2 2242 6203         nop
P:0409 2000D0         2 2244 6204         mpy     y0,x0,a
P:040A 2109E2         2 2246 6205         mac     x1,y0,a a0,b0
P:040B 2000C2         2 2248 6206         mac     x0,y1,a
P:040C 00BFB8         2 2250 6207         andi    #$BF,mr
P:040D 210D00         2 2252 6208         move    a0,b1
P:040E 218B00         2 2254 6209         move    a1,b2
P:040F 20002A         2 2256 6210         asr     b
P:0410 212400         2 2258 6213         move    b0,x0
P:0411 21A500         2 2260 6214         move    b1,x1
P:0412 77F400 FFFFFA  3 2263 6215         move    #-6,n7
P:0414 205F00         2 2265 6216         move    (r7)+
P:0415 5FEF00         4 2269 6218         move    y:(r7+n7),b
P:0416 205700         2 2271 6219         move    (r7)-
P:0417 59EF00         4 2275 6221         move    y:(r7+n7),b0
P:0418 20002C         2 2277 6222         sub     x,b
P:0419 77F400 FFFFFE  3 2280 6225         move    #-2,n7
P:041B 205F00         2 2282 6226         move    (r7)+
P:041C 5D6F00         4 2286 6228         move    b1,y:(r7+n7)
P:041D 205700         2 2288 6229         move    (r7)-
P:041E 596F00         4 2292 6231         move    b0,y:(r7+n7)
                             6233 
                             6234 ; 419  |
                             6235 ; 420  |    // Loads the fat sector group into fat buffer if needed
                             6236 ; 421  |    // Each Fat buffer group is 3 sectors
                             6237 ; 422  |    if ( ((wStartSect * 3)  + stFat.FirstPrimaryFatSect) != stFat.FatSectorCached )
                             6238 
P:041F 270000         2 2294 6240         move    #0,y1
P:0420 46F400 000003  3 2297 6241         move    #>3,y0
P:0422 77F400 FFFFFC  3 2300 6242         move    #-4,n7
P:0424 205F00         2 2302 6243         move    (r7)+
P:0425 4DEF00         4 2306 6245         move    y:(r7+n7),x1
P:0426 205700         2 2308 6246         move    (r7)-
P:0427 4CEF00         4 2312 6248         move    y:(r7+n7),x0
P:0428 0040F8         2 2314 6249         ori     #$40,mr
P:0429 000000         2 2316 6250         nop
P:042A 2000D0         2 2318 6251         mpy     y0,x0,a
P:042B 2109E2         2 2320 6252         mac     x1,y0,a a0,b0
P:042C 2000C2         2 2322 6253         mac     x0,y1,a
P:042D 00BFB8         2 2324 6254         andi    #$BF,mr
P:042E 210D00         2 2326 6255         move    a0,b1
P:042F 218B00         2 2328 6256         move    a1,b2
P:0430 20002A         2 2330 6257         asr     b
P:0431 5EF000 rrrrrr  3 2333 6261         move    y:FstFat+4,a
P:0433 58F000 rrrrrr  3 2336 6262         move    y:FstFat+3,a0
P:0435 200010         2 2338 6263         add     b,a
P:0436 59F000 rrrrrr  3 2341 6264         move    y:FstFat+1,b0
P:0438 2D0000         2 2343 6265         move    #0,b1
P:0439 2B0000         2 2345 6266         move    #0,b2
P:043A 2A0000         2 2347 6267         move    #0,a2
P:043B 200005         2 2349 6268         cmp     b,a
P:043C 0AF0AA rrrrrr  6 2355 6269         jeq     L106
                             6270 
                             6271 ; 423  |        if ( LoadFatSector(((wStartSect * 3) + stFat.FirstPrimaryFatSect), MediaBuffer) != NOERROR )
                             6272 
P:043E 68F000 rrrrrr  3 2358 6274         move    y:FMediaBuffer,r0
P:0440 0BF080 rrrrrr  6 2364 6275         jsr     FLoadFatSector
P:0442 2A0000         2 2366 6277         move    #0,a2
P:0443 200003         2 2368 6278         tst     a
P:0444 0AF0AA rrrrrr  6 2374 6279         jeq     L106
                             6280 
                             6281 ; 424  |            return(!NOERROR);
                             6282 
P:0446 56F400 000001  3 2377 6284         move    #>1,a
P:0448 0AF080 rrrrrr  6 2383 6285         jmp     L109
                             6286 
                             6287 ; 425  |
                             6288 ; 426  |    wTemp = wOffCx/2;
                             6289 
                             6291 L106:
P:044A 77F400 FFFFFE  3 2386 6293         move    #-2,n7
P:044C 205F00         2 2388 6294         move    (r7)+
P:044D 5FEF00         4 2392 6296         move    y:(r7+n7),b
P:044E 205700         2 2394 6297         move    (r7)-
P:044F 59EF00         4 2398 6299         move    y:(r7+n7),b0
P:0450 212600         2 2400 6300         move    b0,y0
P:0451 21A700         2 2402 6301         move    b1,y1
P:0452 2B0000         2 2404 6302         move    #0,b2
P:0453 20002A         2 2406 6303         asr     b
                             6305 
                             6306 ; 427  |    
                             6307 ; 428  |    if ( wTemp*2 != wOffCx )
                             6308 
P:0454 200001         2 2408 6310         tfr     b,a
P:0455 210400         2 2410 6311         move    a0,x0
P:0456 218500         2 2412 6312         move    a1,x1
P:0457 200032         2 2414 6313         asl     a
P:0458 200079         2 2416 6316         tfr     y1,b
P:0459 20C900         2 2418 6317         move    y0,b0
P:045A 2B0000         2 2420 6318         move    #0,b2
P:045B 2A0000         2 2422 6319         move    #0,a2
P:045C 200005         2 2424 6320         cmp     b,a
P:045D 0AF0AA rrrrrr  6 2430 6321         jeq     L107
                             6322 
                             6323 ; 429  |        // Cluster to free is in MS 12-bit word from entry
                             6324 ; 430  |        *(stFat.pwBuffer + wTemp) = *(stFat.pwBuffer + wTemp) & 0x000fff;
                             6325 
P:045F 6EF000 rrrrrr  3 2433 6327         move    y:FstFat+7,r6
P:0461 200069         2 2435 6328         tfr     x1,b
P:0462 208900         2 2437 6329         move    x0,b0
P:0463 213E00         2 2439 6330         move    b0,n6
P:0464 000000         2 2441 6333         nop
P:0465 204E00         2 2443 6334         move    (r6)+n6
P:0466 5FE600         2 2445 6335         move    y:(r6),b
P:0467 45F400 000FFF  3 2448 6337         move    #$FFF,x1
P:0469 20006E         2 2450 6338         and     x1,b
P:046A 0AF080 rrrrrr  6 2456 6339         jmp     L108
                             6340 
                             6341 ; 431  |    else
                             6342 ; 432  |        // Cluster to free is in LS 12-bit word from entry
                             6343 ; 433  |        *(stFat.pwBuffer + wTemp) = *(stFat.pwBuffer + wTemp) & 0xfff000;
                             6344 
P:046C 6EF000 rrrrrr  3 2459 6346 L107:   move    y:FstFat+7,r6
P:046E 200069         2 2461 6347         tfr     x1,b
P:046F 208900         2 2463 6348         move    x0,b0
P:0470 213E00         2 2465 6349         move    b0,n6
P:0471 000000         2 2467 6350         nop
P:0472 204E00         2 2469 6351         move    (r6)+n6
P:0473 5FE600         2 2471 6352         move    y:(r6),b
P:0474 46F400 FFF000  3 2474 6353         move    #$FFF000,y0
P:0476 20005E         2 2476 6354         and     y0,b
P:0477 5D6600         2 2478 6355 L108:   move    b1,y:(r6)
                             6356 
                             6357 ; 434  |        
                             6358 ; 435  |    // Mark the FAT sector group dirty
                             6359 ; 436  |    stFat.Control = DIRTY;
                             6360 
P:0478 44F400 000001  3 2481 6362         move    #>1,x0
P:047A 4C7000 rrrrrr  3 2484 6363         move    x0,y:FstFat+2
                             6364 
                             6365 ; 437  |    
                             6366 ; 438  |    return(NOERROR);        
                             6367 
P:047C 200013         2 2486 6369         clr     a   
                             6370 
                             6371 ; 439  |}
                             6372 
P:047D 77F400 FFFFF9  3 2489 6374 L109:   move    #-7,n7
P:047F 000000         2 2491 6375         nop
P:0480 05EF7C         4 2495 6376         movec   y:(r7+n7),ssh
P:0481 204F00         2 2497 6378         move    (r7)+n7
P:0482 00000C         4 2501 6380         rts
TASKING DSP2410 assembler v1.5r1 Build 138 SN 00100122
                                                                                                                                                                                                                                                       Page  23

M:ADDR CODE           CYCLES LINE SOURCELINE
                             6382 
                             6383 ; 440  |
                             6384 ; 441  |
                             6385 ; 442  |
                             6386 ; 443  |BOOL _reentrant FreeCxFat16(DWORD wCluster)
                             6387 ; 444  |{
                             6388 
                             6393 FFreeCxFat16:
P:0483 055F7C         2 2503 6394         movec   ssh,y:(r7)+
P:0484 3F0400         2 2505 6397         move    #4,n7
P:0485 000000         2 2507 6398         nop
P:0486 204F00         2 2509 6399         move    (r7)+n7
                             6407 
                             6408 ; 445  |    DWORD wStartSect, wOffCx;
                             6409 ; 446  |    
                             6410 ; 447  |    // Calculates start sector of group of 3 buffer sectors for FAT
                             6411 ; 448  |    wStartSect = wCluster / FAT16_ENTRIES_PER_SECT_GROUP;
                             6412 
P:0487 46F000 rrrrrr  3 2512 6414         move    x:FcachedSectorSize,y0
P:0489 47F400 000003  3 2515 6415         move    #>3,y1
P:048B 2000B8         2 2517 6416         mpy     y0,y1,b
P:048C 20002A         2 2519 6417         asr     b
P:048D 212F00         2 2521 6418         move    b0,b
P:048E 20002B         2 2523 6419         lsr     b
P:048F 21A900         2 2525 6420         move    b1,b0
P:0490 212600         2 2527 6421         move    b0,y0
P:0491 270000         2 2529 6422         move    #0,y1
P:0492 77F400 FFFFFC  3 2532 6423         move    #-4,n7
P:0494 205F00         2 2534 6424         move    (r7)+
P:0495 5C6F00         4 2538 6426         move    a1,y:(r7+n7)
P:0496 205700         2 2540 6427         move    (r7)-
P:0497 586F00         4 2544 6429         move    a0,y:(r7+n7)
P:0498 0BF080 rrrrrr  6 2550 6430         jsr     Rdiv_ululul
                             6434 
                             6435 ; 449  |
                             6436 ; 450  |    // Calculates the cluster offset in the Fat buffer
                             6437 ; 451  |    wOffCx = wCluster - (wStartSect*FAT16_ENTRIES_PER_SECT_GROUP);
                             6438 
P:049A 210400         2 2552 6440         move    a0,x0
P:049B 218500         2 2554 6441         move    a1,x1
P:049C 0040F8         2 2556 6442         ori     #$40,mr
P:049D 000000         2 2558 6443         nop
P:049E 2000D0         2 2560 6444         mpy     y0,x0,a
P:049F 2109E2         2 2562 6445         mac     x1,y0,a a0,b0
P:04A0 2000C2         2 2564 6446         mac     x0,y1,a
P:04A1 00BFB8         2 2566 6447         andi    #$BF,mr
P:04A2 210D00         2 2568 6448         move    a0,b1
P:04A3 218B00         2 2570 6449         move    a1,b2
P:04A4 20002A         2 2572 6450         asr     b
P:04A5 212600         2 2574 6453         move    b0,y0
P:04A6 21A700         2 2576 6454         move    b1,y1
P:04A7 205F00         2 2578 6455         move    (r7)+
P:04A8 5FEF00         4 2582 6457         move    y:(r7+n7),b
P:04A9 205700         2 2584 6458         move    (r7)-
P:04AA 59EF00         4 2588 6460         move    y:(r7+n7),b0
P:04AB 20003C         2 2590 6461         sub     y,b
P:04AC 77F400 FFFFFE  3 2593 6464         move    #-2,n7
P:04AE 205F00         2 2595 6465         move    (r7)+
P:04AF 5D6F00         4 2599 6467         move    b1,y:(r7+n7)
P:04B0 205700         2 2601 6468         move    (r7)-
P:04B1 596F00         4 2605 6470         move    b0,y:(r7+n7)
                             6472 
                             6473 ; 452  |    
                             6474 ; 453  |    // Loads the fat sector group into fat buffer if needed
                             6475 ; 454  |    // Each Fat buffer group is 3 sectors
                             6476 ; 455  |    if ( ((wStartSect * 3) + stFat.FirstPrimaryFatSect) != stFat.FatSectorCached )
                             6477 
P:04B2 270000         2 2607 6479         move    #0,y1
P:04B3 46F400 000003  3 2610 6480         move    #>3,y0
P:04B5 0040F8         2 2612 6481         ori     #$40,mr
P:04B6 000000         2 2614 6482         nop
P:04B7 2000D0         2 2616 6483         mpy     y0,x0,a
P:04B8 2109E2         2 2618 6484         mac     x1,y0,a a0,b0
P:04B9 2000C2         2 2620 6485         mac     x0,y1,a
P:04BA 00BFB8         2 2622 6486         andi    #$BF,mr
P:04BB 210D00         2 2624 6487         move    a0,b1
P:04BC 218B00         2 2626 6488         move    a1,b2
P:04BD 20002A         2 2628 6489         asr     b
P:04BE 5EF000 rrrrrr  3 2631 6491         move    y:FstFat+4,a
P:04C0 58F000 rrrrrr  3 2634 6492         move    y:FstFat+3,a0
P:04C2 200010         2 2636 6493         add     b,a
P:04C3 59F000 rrrrrr  3 2639 6494         move    y:FstFat+1,b0
P:04C5 2D0000         2 2641 6495         move    #0,b1
P:04C6 2B0000         2 2643 6496         move    #0,b2
P:04C7 2A0000         2 2645 6497         move    #0,a2
P:04C8 200005         2 2647 6498         cmp     b,a
P:04C9 0AF0AA rrrrrr  6 2653 6499         jeq     L111
                             6500 
                             6501 ; 456  |        if ( LoadFatSector(((wStartSect * 3) + stFat.FirstPrimaryFatSect), MediaBuffer) != NOERROR )
                             6502 
P:04CB 68F000 rrrrrr  3 2656 6504         move    y:FMediaBuffer,r0
P:04CD 0BF080 rrrrrr  6 2662 6505         jsr     FLoadFatSector
P:04CF 2A0000         2 2664 6507         move    #0,a2
P:04D0 200003         2 2666 6508         tst     a
P:04D1 0AF0AA rrrrrr  6 2672 6509         jeq     L111
                             6510 
                             6511 ; 457  |            return(!NOERROR);
                             6512 
P:04D3 56F400 000001  3 2675 6514         move    #>1,a
P:04D5 0AF080 rrrrrr  6 2681 6515         jmp     L112
                             6516 
                             6517 ; 458  |
                             6518 ; 459  |    PutWord(stFat.pwBuffer,0x0000,(wOffCx*2),DEFAULT_MEMORY);
                             6519 
                             6521 L111:
P:04D7 68F000 rrrrrr  3 2684 6523         move    y:FstFat+7,r0
P:04D9 77F400 FFFFFE  3 2687 6524         move    #-2,n7
P:04DB 205F00         2 2689 6525         move    (r7)+
P:04DC 5FEF00         4 2693 6527         move    y:(r7+n7),b
P:04DD 205700         2 2695 6528         move    (r7)-
P:04DE 59EF00         4 2699 6530         move    y:(r7+n7),b0
P:04DF 20003A         2 2701 6531         asl     b
P:04E0 200013         2 2703 6532         clr     a   
P:04E1 212F00         2 2705 6533         move    b0,b
P:04E2 44F400 000002  3 2708 6534         move    #>2,x0
P:04E4 0BF080 rrrrrr  6 2714 6535         jsr     FPutWord
                             6536 
                             6537 ; 460  |    
                             6538 ; 461  |    // Mark the FAT sector group dirty
                             6539 ; 462  |    stFat.Control = DIRTY;
                             6540 
P:04E6 57F400 000001  3 2717 6542         move    #>1,b
P:04E8 5F7000 rrrrrr  3 2720 6543         move    b,y:FstFat+2
                             6544 
                             6545 ; 463  |
                             6546 ; 464  |    return(NOERROR);
                             6547 
P:04EA 200013         2 2722 6549         clr     a   
                             6550 
                             6551 ; 465  |
                             6552 ; 466  |}
                             6553 
P:04EB 77F400 FFFFFB  3 2725 6555 L112:   move    #-5,n7
P:04ED 000000         2 2727 6556         nop
P:04EE 05EF7C         4 2731 6557         movec   y:(r7+n7),ssh
P:04EF 204F00         2 2733 6559         move    (r7)+n7
P:04F0 00000C         4 2737 6561         rts
                             6563 
                             6564 ; 467  |
                             6565 ; 468  |BOOL _reentrant FreeCxFat32(DWORD wCluster)
                             6566 ; 469  |{
                             6567 
                             6572 FFreeCxFat32:
P:04F1 055F7C         2 2739 6573         movec   ssh,y:(r7)+
P:04F2 3F0500         2 2741 6576         move    #5,n7
P:04F3 000000         2 2743 6577         nop
P:04F4 204F00         2 2745 6578         move    (r7)+n7
                             6586 
                             6587 ; 470  |    DWORD wStartSect ;
                             6588 ; 471  |    INT wOffCx;
                             6589 ; 472  |    // Calculates start sector of group of 3 buffer sectors for FAT
                             6590 ; 473  |//    wStartSect = Getsectorno(wCluster);
                             6591 ; 474  |    wStartSect = wCluster / FAT32_ENTRIES_PER_SECT_GROUP;
                             6592 
P:04F5 44F000 rrrrrr  3 2748 6594         move    x:FcachedSectorSize,x0
P:04F7 46F400 000003  3 2751 6595         move    #>3,y0
P:04F9 2000D8         2 2753 6596         mpy     x0,y0,b
P:04FA 20002A         2 2755 6597         asr     b
P:04FB 212500         2 2757 6598         move    b0,x1
P:04FC 0102F8         2 2759 6599         mpy     x1,#2,b
P:04FD 21A600         2 2761 6600         move    b1,y0
P:04FE 270000         2 2763 6601         move    #0,y1
P:04FF 77F400 FFFFFB  3 2766 6602         move    #-5,n7
P:0501 205F00         2 2768 6603         move    (r7)+
P:0502 5C6F00         4 2772 6605         move    a1,y:(r7+n7)
P:0503 205700         2 2774 6606         move    (r7)-
P:0504 586F00         4 2778 6608         move    a0,y:(r7+n7)
P:0505 0BF080 rrrrrr  6 2784 6609         jsr     Rdiv_ululul
                             6613 
                             6614 ; 475  |
                             6615 ; 476  |    // Calculates the cluster offset in the Fat buffer
                             6616 ; 477  |    wOffCx = wCluster - (wStartSect*FAT32_ENTRIES_PER_SECT_GROUP);
                             6617 
P:0507 210400         2 2786 6619         move    a0,x0
P:0508 218500         2 2788 6620         move    a1,x1
P:0509 77F400 FFFFFD  3 2791 6621         move    #-3,n7
P:050B 205F00         2 2793 6622         move    (r7)+
P:050C 4D6F00         4 2797 6624         move    x1,y:(r7+n7)
P:050D 205700         2 2799 6625         move    (r7)-
P:050E 4C6F00         4 2803 6627         move    x0,y:(r7+n7)
P:050F 0040F8         2 2805 6628         ori     #$40,mr
P:0510 000000         2 2807 6629         nop
P:0511 2000D0         2 2809 6630         mpy     y0,x0,a
P:0512 2109E2         2 2811 6631         mac     x1,y0,a a0,b0
P:0513 2000C2         2 2813 6632         mac     x0,y1,a
P:0514 00BFB8         2 2815 6633         andi    #$BF,mr
P:0515 210D00         2 2817 6634         move    a0,b1
P:0516 218B00         2 2819 6635         move    a1,b2
P:0517 20002A         2 2821 6636         asr     b
P:0518 212400         2 2823 6639         move    b0,x0
P:0519 21A500         2 2825 6640         move    b1,x1
P:051A 77F400 FFFFFB  3 2828 6641         move    #-5,n7
P:051C 205F00         2 2830 6642         move    (r7)+
P:051D 5FEF00         4 2834 6644         move    y:(r7+n7),b
P:051E 205700         2 2836 6645         move    (r7)-
P:051F 59EF00         4 2840 6647         move    y:(r7+n7),b0
P:0520 20002C         2 2842 6648         sub     x,b
P:0521 045FA0         2 2844 6652         movec   m0,n7
P:0522 000000         2 2846 6653         nop
P:0523 596F00         4 2850 6654         move    b0,y:(r7+n7)
                             6656 
                             6657 ; 478  |    
                             6658 ; 479  |    // Loads the fat sector group into fat buffer if needed
                             6659 ; 480  |    // Each Fat buffer group is 3 sectors
                             6660 ; 481  |    if ( ((wStartSect * 3) + stFat.FirstPrimaryFatSect) != stFat.FatSectorCached )
                             6661 
P:0524 270000         2 2852 6663         move    #0,y1
P:0525 46F400 000003  3 2855 6664         move    #>3,y0
P:0527 77F400 FFFFFD  3 2858 6665         move    #-3,n7
P:0529 205F00         2 2860 6666         move    (r7)+
P:052A 4DEF00         4 2864 6668         move    y:(r7+n7),x1
P:052B 205700         2 2866 6669         move    (r7)-
P:052C 4CEF00         4 2870 6671         move    y:(r7+n7),x0
P:052D 0040F8         2 2872 6672         ori     #$40,mr
P:052E 000000         2 2874 6673         nop
P:052F 2000D0         2 2876 6674         mpy     y0,x0,a
P:0530 2109E2         2 2878 6675         mac     x1,y0,a a0,b0
P:0531 2000C2         2 2880 6676         mac     x0,y1,a
P:0532 00BFB8         2 2882 6677         andi    #$BF,mr
P:0533 210D00         2 2884 6678         move    a0,b1
P:0534 218B00         2 2886 6679         move    a1,b2
P:0535 20002A         2 2888 6680         asr     b
P:0536 5EF000 rrrrrr  3 2891 6683         move    y:FstFat+4,a
P:0538 58F000 rrrrrr  3 2894 6684         move    y:FstFat+3,a0
P:053A 200010         2 2896 6685         add     b,a
P:053B 59F000 rrrrrr  3 2899 6686         move    y:FstFat+1,b0
P:053D 2D0000         2 2901 6687         move    #0,b1
P:053E 2B0000         2 2903 6688         move    #0,b2
P:053F 2A0000         2 2905 6689         move    #0,a2
P:0540 200005         2 2907 6690         cmp     b,a
P:0541 0AF0AA rrrrrr  6 2913 6691         jeq     L114
                             6692 
                             6693 ; 482  |        if ( LoadFatSector(((wStartSect * 3) + stFat.FirstPrimaryFatSect), MediaBuffer) != NOERROR )
                             6694 
P:0543 68F000 rrrrrr  3 2916 6696         move    y:FMediaBuffer,r0
P:0545 0BF080 rrrrrr  6 2922 6697         jsr     FLoadFatSector
P:0547 2A0000         2 2924 6699         move    #0,a2
P:0548 200003         2 2926 6700         tst     a
P:0549 0AF0AA rrrrrr  6 2932 6701         jeq     L114
                             6702 
                             6703 ; 483  |            return(!NOERROR);
                             6704 
P:054B 56F400 000001  3 2935 6706         move    #>1,a
P:054D 0AF080 rrrrrr  6 2941 6707         jmp     L115
                             6708 
                             6709 ; 484  |
                             6710 ; 485  |            PutDword(stFat.pwBuffer,0x0000,(wOffCx*4),DEFAULT_MEMORY);
                             6711 
                             6713 L114:
P:054F 68F000 rrrrrr  3 2944 6715         move    y:FstFat+7,r0
P:0551 045FA0         2 2946 6716         movec   m0,n7
TASKING DSP2410 assembler v1.5r1 Build 138 SN 00100122
                                                                                                                                                                                                                                                       Page  24

M:ADDR CODE           CYCLES LINE SOURCELINE
P:0552 000000         2 2948 6717         nop
P:0553 4EEF00         4 2952 6718         move    y:(r7+n7),y0
P:0554 0116E8         2 2954 6719         mpy     y0,#22,b
P:0555 212F00         2 2956 6720         move    b0,b
P:0556 200013         2 2958 6721         clr     a   
P:0557 44F400 000002  3 2961 6722         move    #>2,x0
P:0559 0BF080 rrrrrr  6 2967 6723         jsr     FPutDword
                             6724 
                             6725 ; 486  |    
                             6726 ; 487  |    // Mark the FAT sector group dirty
                             6727 ; 488  |    stFat.Control = DIRTY;
                             6728 
P:055B 290100         2 2969 6730         move    #1,b0
P:055C 597000 rrrrrr  3 2972 6731         move    b0,y:FstFat+2
                             6732 
                             6733 ; 489  |
                             6734 ; 490  |    return(NOERROR);
                             6735 
P:055E 200013         2 2974 6737         clr     a   
                             6738 
                             6739 ; 491  |
                             6740 ; 492  |}
                             6741 
P:055F 77F400 FFFFFA  3 2977 6743 L115:   move    #-6,n7
P:0561 000000         2 2979 6744         nop
P:0562 05EF7C         4 2983 6745         movec   y:(r7+n7),ssh
P:0563 204F00         2 2985 6747         move    (r7)+n7
P:0564 00000C         4 2989 6749         rts
                             6751 
                             6752 ; 493  |
                             6753 ; 494  |
                             6754 ; 495  |
                             6755 ; 496  |
                             6756 ; 497  |
                             6757 ; 498  |///////////////////////////////////////////////////////////////////////////////
                             6758 ; 499  |//
                             6759 ; 500  |//>  Name:           IsLastCx
                             6760 ; 501  |//
                             6761 ; 502  |//   Type:           Function
                             6762 ; 503  |//
                             6763 ; 504  |//   Description:    Checks if cluster is last of the chain
                             6764 ; 505  |//                      The chain ends with a cluster value of 0xfff (FAT12) 
                             6765 ; 506  |//                      or 0xffff (FAT16)
                             6766 ; 507  |//
                             6767 ; 508  |//   Inputs:         wCluster             : Cluster 
                             6768 ; 509  |//
                             6769 ; 510  |//   Outputs:        
                             6770 ; 511  |//                      TRUE, if last cluster
                             6771 ; 512  |//                      FALSE, otherwise.
                             6772 ; 513  |//                   
                             6773 ; 514  |//   Notes:          
                             6774 ; 515  |//                  none.
                             6775 ; 516  |//<
                             6776 ; 517  |///////////////////////////////////////////////////////////////////////////////
                             6777 ; 518  |BOOL _reentrant IsLastCx(DWORD wCluster)
                             6778 ; 519  |{
                             6779 
                             6784 FIsLastCx:
                             6787 
                             6788 ; 520  |    if ( stPartitionBootSector.TypeFileSystem == FS_FAT12 )
                             6789 
P:0565 5FF000 rrrrrr  3 2992 6791         move    y:FstPartitionBootSector,b
P:0567 20000B         2 2994 6792         tst     b
P:0568 0AF0A2 rrrrrr  6 3000 6793         jne     L116
                             6794 
                             6795 ; 521  |        return((wCluster==0x000fff ? TRUE : FALSE));
                             6796 
P:056A 20001B         2 3002 6798         clr     b   
P:056B 51F400 000FFF  3 3005 6799         move    #$FFF,b0
P:056D 2A0000         2 3007 6800         move    #0,a2
P:056E 200005         2 3009 6801         cmp     b,a
P:056F 56F400 000001  3 3012 6802         move    #>1,a
P:0571 0AF0AA rrrrrr  6 3018 6804         jeq     L121
P:0573 200013         2 3020 6805         clr     a   
P:0574 00000C         4 3024 6806 L121:   rts
                             6807 
                             6808 ; 522  |   
                             6809 ; 523  |    else if ( stPartitionBootSector.TypeFileSystem == FS_FAT16 )
                             6810 
                             6812 L116:
P:0575 47F400 000001  3 3027 6814         move    #>1,y1
P:0577 20007D         2 3029 6815         cmp     y1,b
P:0578 0AF0A2 rrrrrr  6 3035 6816         jne     L117
                             6817 
                             6818 ; 524  |        return((wCluster==0x00ffff ? TRUE : FALSE));
                             6819 
P:057A 20001B         2 3037 6821         clr     b   
P:057B 51F400 00FFFF  3 3040 6822         move    #$FFFF,b0
P:057D 2A0000         2 3042 6823         move    #0,a2
P:057E 200005         2 3044 6824         cmp     b,a
P:057F 2E0000         2 3046 6825         move    #0,a
P:0580 02A070         2 3048 6826         teq     y1,a
P:0581 00000C         4 3052 6828         rts
                             6829 
                             6830 ; 525  |    
                             6831 ; 526  |   
                             6832 ; 527  |    // Must be FAT32
                             6833 ; 528  |    return((wCluster==0x0fffffff ? TRUE : FALSE));
                             6834 
                             6836 L117:
P:0582 57F400 00000F  3 3055 6838         move    #>$F,b
P:0584 51F400 FFFFFF  3 3058 6839         move    #$FFFFFF,b0
P:0586 2A0000         2 3060 6840         move    #0,a2
P:0587 200005         2 3062 6841         cmp     b,a
P:0588 2E0000         2 3064 6842         move    #0,a
P:0589 02A070         2 3066 6843         teq     y1,a
                             6845 
                             6846 ; 529  |}
                             6847 
P:058A 00000C         4 3070 6849         rts
                             6851 
                             6852 ; 530  |
                             6853 ; 531  | 
                             6854 ; 532  |
                             6855 ; 533  |
                             6856 ; 534  |
                             6857 ; 535  |
                             6858 ; 536  |
                             6859 ; 537  |INT _reentrant FAT32_UpdateBit(INT DeviceNum, LONG sectorNumber, WORD wOffsetToWord, WORD wOffsetBit,WORD Bittype)
                             6860 ; 538  |{
                             6861 
                             6866 FFAT32_UpdateBit:
P:058B 055F7C         2 3072 6867         movec   ssh,y:(r7)+
P:058C 3F0A00         2 3074 6870         move    #10,n7
P:058D 000000         2 3076 6871         nop
P:058E 204F00         2 3078 6872         move    (r7)+n7
                             6894 
                             6895 ; 539  |        INT i=0,selection,Counter,index;
                             6896 ; 540  |        WORD temp;
                             6897 
P:058F 77F400 FFFFFB  3 3081 6899         move    #-5,n7
P:0591 000000         2 3083 6900         nop
P:0592 4D6F00         4 3087 6901         move    x1,y:(r7+n7)
P:0593 77F400 FFFFFA  3 3090 6904         move    #-6,n7
P:0595 000000         2 3092 6905         nop
P:0596 4E6F00         4 3096 6906         move    y0,y:(r7+n7)
P:0597 77F400 FFFFF9  3 3099 6909         move    #-7,n7
P:0599 000000         2 3101 6910         nop
P:059A 4C6F00         4 3105 6911         move    x0,y:(r7+n7)
P:059B 77F400 FFFFF6  3 3108 6914         move    #-10,n7
P:059D 000000         2 3110 6915         nop
P:059E 5D6F00         4 3114 6916         move    b1,y:(r7+n7)
                             6919 
                             6920 ; 541  |    // First Search if the buffer is available in the cache
                             6921 ; 542  |
                             6922 ; 543  |        index = SearchmatchingSector(sectorNumber,MAX_CACHES, &CacheDesc_chkdsk[0]);
                             6923 
P:059F 77F400 FFFFF7  3 3117 6925         move    #-9,n7
P:05A1 205F00         2 3119 6926         move    (r7)+
P:05A2 5C6F00         4 3123 6928         move    a1,y:(r7+n7)
P:05A3 205700         2 3125 6929         move    (r7)-
P:05A4 586F00         4 3129 6931         move    a0,y:(r7+n7)
P:05A5 57F400 000005  3 3132 6936         move    #>5,b
P:05A7 60F400 rrrrrr  3 3135 6937         move    #FCacheDesc_chkdsk,r0
P:05A9 0BF080 rrrrrr  6 3141 6938         jsr     FSearchmatchingSector
P:05AB 218F00         2 3143 6941         move    a1,b
                             6943 
                             6944 ; 544  |    if ( index>=0 )
                             6945 
P:05AC 21E600         2 3145 6947         move    b,y0
P:05AD 20000B         2 3147 6948         tst     b
P:05AE 0AF0A9 rrrrrr  6 3153 6949         jlt     L179
                             6950 
                             6951 ; 545  |                {
                             6952 ; 546  |        switch ( Bittype )
                             6953 
P:05B0 77F400 FFFFFB  3 3156 6955         move    #-5,n7
P:05B2 000000         2 3158 6956         nop
P:05B3 5FEF00         4 3162 6957         move    y:(r7+n7),b
P:05B4 56F400 000001  3 3165 6958         move    #>1,a
P:05B6 2B0000         2 3167 6959         move    #0,b2
P:05B7 56F40D 000002  3 3170 6960         cmp     a,b     #>2,a
P:05B9 0AF0AA rrrrrr  6 3176 6961         jeq     L177
P:05BB 20000D         2 3178 6962         cmp     a,b
P:05BC 0AF0AA rrrrrr  6 3184 6963         jeq     L192
P:05BE 20000B         2 3186 6964         tst     b
P:05BF 0AF0A2 rrrrrr  6 3192 6965         jne     L179
                             6966 
                             6967 ; 547  |                {
                             6968 ; 548  |                        case GET_BIT:
                             6969 ; 549  |                    CacheDesc_chkdsk[index].CacheCounter = READCOUNTER;
                             6970 
P:05C1 47F400 000005  3 3195 6972         move    #>5,y1
P:05C3 2000B8         2 3197 6973         mpy     y0,y1,b
P:05C4 20002A         2 3199 6974         asr     b
P:05C5 213E00         2 3201 6975         move    b0,n6
P:05C6 66F400 rrrrrr  3 3204 6976         move    #FCacheDesc_chkdsk+4,r6
P:05C8 000000         2 3206 6977         nop
P:05C9 204E00         2 3208 6978         move    (r6)+n6
P:05CA 296900         2 3210 6979         move    #105,b0
P:05CB 596600         2 3212 6980         move    b0,y:(r6)
                             6981 
                             6982 ; 550  |            return(CacheMem_chkdsk[index][wOffsetToWord] & MaskArray[wOffsetBit]);
                             6983 
P:05CC 20DE00         2 3214 6985         move    y0,n6
P:05CD 66F400 rrrrrr  3 3217 6986         move    #FCacheMem_chkdsk,r6
P:05CF 000000         2 3219 6987         nop
P:05D0 6BEE00         4 3223 6988         move    y:(r6+n6),r3
P:05D1 77F400 FFFFF9  3 3226 6989         move    #-7,n7
P:05D3 000000         2 3228 6990         nop
P:05D4 5CEF00         4 3232 6991         move    y:(r7+n7),a1
P:05D5 219B00         2 3234 6992         move    a1,n3
P:05D6 000000         2 3236 6995         nop
P:05D7 204B00         2 3238 6996         move    (r3)+n3
P:05D8 56E300         2 3240 6997         move    x:(r3),a
P:05D9 77F400 FFFFFA  3 3243 6999         move    #-6,n7
P:05DB 000000         2 3245 7000         nop
P:05DC 4EEF00         4 3249 7001         move    y:(r7+n7),y0
P:05DD 20DE00         2 3251 7002         move    y0,n6
P:05DE 66F400 rrrrrr  3 3254 7005         move    #FMaskArray,r6
P:05E0 000000         2 3256 7006         nop
P:05E1 204E00         2 3258 7007         move    (r6)+n6
P:05E2 4EE600         2 3260 7008         move    y:(r6),y0
P:05E3 200056         2 3262 7011         and     y0,a
P:05E4 218E00         2 3264 7012         move    a1,a
P:05E5 0AF080 rrrrrr  6 3270 7013         jmp     L198
                             7014 
                             7015 ; 551  |                        case SET_BIT:
                             7016 ; 552  |                    CacheDesc_chkdsk[index].CacheCounter = WRITECOUNTER;
                             7017 
                             7019 L177:
P:05E7 47F400 000005  3 3273 7023         move    #>5,y1
P:05E9 2000B8         2 3275 7024         mpy     y0,y1,b
P:05EA 20002A         2 3277 7025         asr     b
P:05EB 213D00         2 3279 7026         move    b0,n5
P:05EC 66F400 rrrrrr  3 3282 7027         move    #FCacheDesc_chkdsk+4,r6
P:05EE 23BE00         2 3284 7028         move    n5,n6
P:05EF 000000         2 3286 7029         nop
P:05F0 204E00         2 3288 7030         move    (r6)+n6
P:05F1 296400         2 3290 7031         move    #100,b0
P:05F2 596600         2 3292 7032         move    b0,y:(r6)
                             7033 
                             7034 ; 553  |                            CacheDesc_chkdsk[index].WriteAttribute = 1;
                             7035 
P:05F3 66F400 rrrrrr  3 3295 7037         move    #FCacheDesc_chkdsk+3,r6
P:05F5 000000         2 3297 7038         nop
P:05F6 204E00         2 3299 7039         move    (r6)+n6
P:05F7 290100         2 3301 7040         move    #1,b0
P:05F8 596600         2 3303 7041         move    b0,y:(r6)
                             7042 
                             7043 ; 554  |                                temp = (CacheMem_chkdsk[index][wOffsetToWord] & MaskArray[wOffsetBit]);
                             7044 
P:05F9 20DE00         2 3305 7046         move    y0,n6
P:05FA 66F400 rrrrrr  3 3308 7047         move    #FCacheMem_chkdsk,r6
P:05FC 000000         2 3310 7048         nop
P:05FD 6BEE00         4 3314 7049         move    y:(r6+n6),r3
P:05FE 77F400 FFFFF9  3 3317 7050         move    #-7,n7
P:0600 000000         2 3319 7051         nop
P:0601 4EEF00         4 3323 7052         move    y:(r7+n7),y0
P:0602 20DB00         2 3325 7053         move    y0,n3
P:0603 000000         2 3327 7056         nop
TASKING DSP2410 assembler v1.5r1 Build 138 SN 00100122
                                                                                                                                                                                                                                                       Page  25

M:ADDR CODE           CYCLES LINE SOURCELINE
P:0604 204B00         2 3329 7057         move    (r3)+n3
P:0605 57E300         2 3331 7058         move    x:(r3),b
P:0606 77F400 FFFFFA  3 3334 7059         move    #-6,n7
P:0608 000000         2 3336 7060         nop
P:0609 4FEF00         4 3340 7061         move    y:(r7+n7),y1
P:060A 20FE00         2 3342 7062         move    y1,n6
P:060B 66F400 rrrrrr  3 3345 7065         move    #FMaskArray,r6
P:060D 000000         2 3347 7066         nop
P:060E 204E00         2 3349 7067         move    (r6)+n6
P:060F 4EE600         2 3351 7068         move    y:(r6),y0
P:0610 21AC00         2 3353 7071         move    b1,a1
P:0611 200056         2 3355 7072         and     y0,a
P:0612 218E00         2 3357 7073         move    a1,a
                             7075 
                             7076 ; 555  |                    CacheMem_chkdsk[index][wOffsetToWord] = CacheMem_chkdsk[index][wOffsetToWord] | MaskArray[wOffsetBit];                
                             7077 
P:0613 20005A         2 3359 7079         or      y0,b
P:0614 556300         2 3361 7080         move    b1,x:(r3)
                             7081 
                             7082 ; 556  |                                return temp;
                             7083 
P:0615 0AF080 rrrrrr  6 3367 7085         jmp     L190
                             7086 
                             7087 ; 557  |                        case FREE_BIT:
                             7088 ; 558  |                    CacheDesc_chkdsk[index].CacheCounter = WRITECOUNTER;
                             7089 ; 559  |                            CacheDesc_chkdsk[index].WriteAttribute = 1;
                             7090 ; 560  |                                temp = 0xffffff ^ MaskArray[wOffsetBit];
                             7091 ; 561  |                                CacheMem_chkdsk[index][wOffsetToWord] = CacheMem_chkdsk[index][wOffsetToWord] & temp;
                             7092 ; 562  |                                return 0;                                               
                             7093 ; 563  |                }
                             7094 ; 564  |        }
                             7095 ; 565  |                                        
                             7096 ; 566  |        // Cache Miss, so must read.
                             7097 ; 567  |        // Now find the Least recently used Buffer
                             7098 ; 568  |        selection = 0;
                             7099 
                             7101 L179:
P:0617 240000         2 3369 7105         move    #0,x0
                             7107 
                             7108 ; 569  |        Counter = 0;
                             7109 
P:0618 270000         2 3371 7111         move    #0,y1
                             7113 
                             7114 ; 570  |    for ( i = 0; i < MAX_CACHES; i++ )
                             7115 
P:0619 45F400 000005  3 3374 7117         move    #>5,x1
P:061B 200061         2 3376 7118         tfr     x1,a
P:061C 20001B         2 3378 7120         clr     b   
P:061D 200003         2 3380 7122         tst     a
P:061E 0AF0AA rrrrrr  6 3386 7123         jeq     L199
P:0620 06CC00 rrrrrr  6 3392 7124         do      a1,L199
                             7126 
                             7127 ; 571  |        {
                             7128 ; 572  |        if ( CacheDesc_chkdsk[i].CacheValid )
                             7129 
P:0622 21A600         2 3394 7131         move    b1,y0
P:0623 2000E0         2 3396 7132         mpy     y0,x1,a
P:0624 200022         2 3398 7133         asr     a
P:0625 211C00         2 3400 7134         move    a0,n4
P:0626 64F400 rrrrrr  3 3403 7135         move    #FCacheDesc_chkdsk,r4
P:0628 000000         2 3405 7136         nop
P:0629 044C16         4 3409 7137         lua     (r4)+n4,r6
P:062A 000000         2 3411 7138         nop
P:062B 5EE600         2 3413 7139         move    y:(r6),a
P:062C 200003         2 3415 7140         tst     a
P:062D 0AF0AA rrrrrr  6 3421 7141         jeq     L181
                             7142 
                             7143 ; 573  |                {
                             7144 ; 574  |            if ( CacheDesc_chkdsk[i].CacheCounter > Counter )
                             7145 
P:062F 239E00         2 3423 7147         move    n4,n6
P:0630 66F400 rrrrrr  3 3426 7148         move    #FCacheDesc_chkdsk+4,r6
P:0632 000000         2 3428 7149         nop
P:0633 204E00         2 3430 7150         move    (r6)+n6
P:0634 5EE600         2 3432 7151         move    y:(r6),a
P:0635 200075         2 3434 7152         cmp     y1,a
P:0636 0AF0AF rrrrrr  6 3440 7153         jle     L183
                             7154 
                             7155 ; 575  |                        {
                             7156 ; 576  |                                selection = i;
                             7157 ; 577  |                                Counter = CacheDesc_chkdsk[i].CacheCounter;
                             7158 ; 578  |                        }
                             7159 ; 579  |                }
                             7160 
P:0638 0AF080 rrrrrr  6 3446 7162         jmp     L182
                             7163 
                             7164 ; 580  |                else
                             7165 ; 581  |                {
                             7166 ; 582  |                        selection = i;
                             7167 
P:063A 21A400         2 3448 7169 L181:   move    b1,x0
                             7170 
                             7171 ; 583  |                        CacheDesc_chkdsk[selection].CacheValid = 1;
                             7172 
P:063B 290100         2 3450 7174         move    #1,b0
P:063C 596600         2 3452 7175         move    b0,y:(r6)
                             7176 
                             7177 ; 584  |                        break;
                             7178 
P:063D 00008C         2 3454 7180         enddo
P:063E 0AF080 rrrrrr  6 3460 7182         jmp     L184
P:0640 21A400         2 3462 7184 L182:   move    b1,x0
P:0641 4FE600         2 3464 7186         move    y:(r6),y1
                             7187 
                             7188 ; 585  |                }
                             7189 
                             7191 L183:
P:0642 46F400 000001  3 3467 7193         move    #>1,y0
P:0644 200058         2 3469 7194         add     y0,b
                        (77) 7195 L199:
                             7197 
                             7198 ; 586  |        }
                             7199 ; 587  |        // Flush the sector to the disk, if write attribute was set.
                             7200 ; 588  |    if ( CacheDesc_chkdsk[selection].WriteAttribute == 1 )
                             7201 
P:0645 77F400 FFFFFC  3 3472 7203 L184:   move    #-4,n7
P:0647 000000         2 3474 7204         nop
P:0648 4C6F00         4 3478 7205         move    x0,y:(r7+n7)
P:0649 2000A8         2 3480 7206         mpy     x0,x1,b
P:064A 20002A         2 3482 7207         asr     b
P:064B 213E00         2 3484 7211         move    b0,n6
P:064C 77F400 FFFFFD  3 3487 7212         move    #-3,n7
P:064E 000000         2 3489 7213         nop
P:064F 7E6F00         4 3493 7214         move    n6,y:(r7+n7)
P:0650 66F400 rrrrrr  3 3496 7215         move    #FCacheDesc_chkdsk+3,r6
P:0652 000000         2 3498 7216         nop
P:0653 204E00         2 3500 7217         move    (r6)+n6
P:0654 77F400 FFFFFE  3 3503 7218         move    #-2,n7
P:0656 000000         2 3505 7219         nop
P:0657 6E6F00         4 3509 7220         move    r6,y:(r7+n7)
P:0658 5FE600         2 3511 7221         move    y:(r6),b
P:0659 46F400 000001  3 3514 7222         move    #>1,y0
P:065B 20005D         2 3516 7223         cmp     y0,b
P:065C 0AF0A2 rrrrrr  6 3522 7224         jne     L185
                             7225 
                             7226 ; 589  |        {
                             7227 ; 590  |        if ( (MediaWrite(DeviceNum, CacheDesc_chkdsk[selection].SectorNumber,(int _X *)CacheMem_chkdsk[selection],0)) <0 )
                             7228 
P:065E 66F400 rrrrrr  3 3525 7230         move    #FCacheDesc_chkdsk+1,r6
P:0660 000000         2 3527 7231         nop
P:0661 204E00         2 3529 7232         move    (r6)+n6
P:0662 205E00         2 3531 7233         move    (r6)+
P:0663 5ED600         2 3533 7234         move    y:(r6)-,a
P:0664 58E600         2 3535 7235         move    y:(r6),a0
P:0665 209E00         2 3537 7236         move    x0,n6
P:0666 66F400 rrrrrr  3 3540 7237         move    #FCacheMem_chkdsk,r6
P:0668 000000         2 3542 7238         nop
P:0669 204E00         2 3544 7239         move    (r6)+n6
P:066A 68E600         2 3546 7240         move    y:(r6),r0
P:066B 77F400 FFFFF6  3 3549 7241         move    #-10,n7
P:066D 000000         2 3551 7242         nop
P:066E 5FEF00         4 3555 7243         move    y:(r7+n7),b
P:066F 240000         2 3557 7246         move    #0,x0
P:0670 0BF080 rrrrrr  6 3563 7247         jsr     FMediaWrite
P:0672 200003         2 3565 7251         tst     a
P:0673 0AF0A9 rrrrrr  6 3571 7252         jlt     L186
                             7253 
                             7254 ; 591  |                        return -1;
                             7255 ; 592  |        }
                             7256 ; 593  |    if ( (MediaRead(DeviceNum, sectorNumber, (int _X *)CacheMem_chkdsk[selection],0)) <0 )
                             7257 
P:0675 77F400 FFFFFC  3 3574 7259 L185:   move    #-4,n7
P:0677 000000         2 3576 7260         nop
P:0678 4CEF00         4 3580 7261         move    y:(r7+n7),x0
P:0679 209E00         2 3582 7262         move    x0,n6
P:067A 66F400 rrrrrr  3 3585 7265         move    #FCacheMem_chkdsk,r6
P:067C 000000         2 3587 7266         nop
P:067D 204E00         2 3589 7267         move    (r6)+n6
P:067E 045FA0         2 3591 7268         movec   m0,n7
P:067F 000000         2 3593 7269         nop
P:0680 6E6F00         4 3597 7270         move    r6,y:(r7+n7)
P:0681 68E600         2 3599 7271         move    y:(r6),r0
P:0682 77F400 FFFFF7  3 3602 7272         move    #-9,n7
P:0684 205F00         2 3604 7273         move    (r7)+
P:0685 5EEF00         4 3608 7275         move    y:(r7+n7),a
P:0686 205700         2 3610 7276         move    (r7)-
P:0687 58EF00         4 3614 7278         move    y:(r7+n7),a0
P:0688 240000         2 3616 7281         move    #0,x0
P:0689 77F400 FFFFF6  3 3619 7283         move    #-10,n7
P:068B 000000         2 3621 7284         nop
P:068C 5FEF00         4 3625 7285         move    y:(r7+n7),b
P:068D 0BF080 rrrrrr  6 3631 7286         jsr     FMediaRead
P:068F 200003         2 3633 7292         tst     a
P:0690 0AF0A1 rrrrrr  6 3639 7293         jge     L187
                             7294 
                             7295 ; 594  |                        return -1;
                             7296 
P:0692 56F400 FFFFFF  3 3642 7298 L186:   move    #>-1,a
P:0694 0AF080 rrrrrr  6 3648 7299         jmp     L198
                             7300 
                             7301 ; 595  |                
                             7302 ; 596  |        CacheDesc_chkdsk[selection].SectorNumber = sectorNumber;
                             7303 
P:0696 77F400 FFFFFD  3 3651 7305 L187:   move    #-3,n7
P:0698 000000         2 3653 7306         nop
P:0699 7EEF00         4 3657 7307         move    y:(r7+n7),n6
P:069A 66F400 rrrrrr  3 3660 7308         move    #FCacheDesc_chkdsk+1,r6
P:069C 000000         2 3662 7309         nop
P:069D 204E00         2 3664 7310         move    (r6)+n6
P:069E 77F400 FFFFF7  3 3667 7311         move    #-9,n7
P:06A0 205F00         2 3669 7312         move    (r7)+
P:06A1 4FEF00         4 3673 7314         move    y:(r7+n7),y1
P:06A2 205700         2 3675 7315         move    (r7)-
P:06A3 4EEF00         4 3679 7317         move    y:(r7+n7),y0
P:06A4 4E5E00         2 3681 7318         move    y0,y:(r6)+
P:06A5 4F5600         2 3683 7319         move    y1,y:(r6)-
                             7322 
                             7323 ; 597  |        IncrementCacheCounters_chkdsk();
                             7324 
P:06A6 0BF080 rrrrrr  6 3689 7326         jsr     FIncrementCacheCounters_chkdsk
                             7328 
                             7329 ; 598  |    switch ( Bittype )
                             7330 
P:06A8 77F400 FFFFFB  3 3692 7332         move    #-5,n7
P:06AA 000000         2 3694 7333         nop
P:06AB 5FEF00         4 3698 7334         move    y:(r7+n7),b
P:06AC 56F400 000001  3 3701 7335         move    #>1,a
P:06AE 2B0000         2 3703 7336         move    #0,b2
P:06AF 56F40D 000002  3 3706 7337         cmp     a,b     #>2,a
P:06B1 0AF0AA rrrrrr  6 3712 7338         jeq     L189
P:06B3 20000D         2 3714 7339         cmp     a,b
P:06B4 0AF0AA rrrrrr  6 3720 7340         jeq     L191
P:06B6 20000B         2 3722 7341         tst     b
P:06B7 0AF0A2 rrrrrr  6 3728 7342         jne     L194
                             7343 
                             7344 ; 599  |                {
                             7345 ; 600  |                        case GET_BIT:
                             7346 ; 601  |                    CacheDesc_chkdsk[selection].CacheCounter = READCOUNTER;
                             7347 
P:06B9 77F400 FFFFFD  3 3731 7349         move    #-3,n7
P:06BB 000000         2 3733 7350         nop
P:06BC 7EEF00         4 3737 7351         move    y:(r7+n7),n6
P:06BD 66F400 rrrrrr  3 3740 7352         move    #FCacheDesc_chkdsk+4,r6
P:06BF 000000         2 3742 7353         nop
P:06C0 204E00         2 3744 7354         move    (r6)+n6
P:06C1 296900         2 3746 7355         move    #105,b0
P:06C2 596600         2 3748 7356         move    b0,y:(r6)
                             7358 
                             7359 ; 602  |        return(CacheMem_chkdsk[selection][wOffsetToWord] & MaskArray[wOffsetBit]);
                             7360 
P:06C3 045FA0         2 3750 7362         movec   m0,n7
P:06C4 000000         2 3752 7363         nop
P:06C5 6BEF00         4 3756 7364         move    y:(r7+n7),r3
P:06C6 000000         2 3758 7365         nop
P:06C7 6BE300         2 3760 7366         move    y:(r3),r3
P:06C8 77F400 FFFFF9  3 3763 7367         move    #-7,n7
P:06CA 000000         2 3765 7368         nop
P:06CB 4DEF00         4 3769 7369         move    y:(r7+n7),x1
P:06CC 20BB00         2 3771 7370         move    x1,n3
P:06CD 000000         2 3773 7373         nop
P:06CE 204B00         2 3775 7374         move    (r3)+n3
TASKING DSP2410 assembler v1.5r1 Build 138 SN 00100122
                                                                                                                                                                                                                                                       Page  26

M:ADDR CODE           CYCLES LINE SOURCELINE
P:06CF 56E300         2 3777 7375         move    x:(r3),a
P:06D0 77F400 FFFFFA  3 3780 7376         move    #-6,n7
P:06D2 000000         2 3782 7377         nop
P:06D3 59EF00         4 3786 7378         move    y:(r7+n7),b0
P:06D4 213E00         2 3788 7379         move    b0,n6
P:06D5 66F400 rrrrrr  3 3791 7382         move    #FMaskArray,r6
P:06D7 000000         2 3793 7383         nop
P:06D8 204E00         2 3795 7384         move    (r6)+n6
P:06D9 4EE600         2 3797 7385         move    y:(r6),y0
P:06DA 200056         2 3799 7386         and     y0,a
P:06DB 218E00         2 3801 7387         move    a1,a
P:06DC 0AF080 rrrrrr  6 3807 7388         jmp     L198
                             7389 
                             7390 ; 603  |                        case SET_BIT:
                             7391 ; 604  |                    CacheDesc_chkdsk[selection].CacheCounter = WRITECOUNTER;
                             7392 
                             7394 L189:
P:06DE 77F400 FFFFFD  3 3810 7399         move    #-3,n7
P:06E0 000000         2 3812 7400         nop
P:06E1 7EEF00         4 3816 7401         move    y:(r7+n7),n6
P:06E2 66F400 rrrrrr  3 3819 7402         move    #FCacheDesc_chkdsk+4,r6
P:06E4 000000         2 3821 7403         nop
P:06E5 204E00         2 3823 7404         move    (r6)+n6
P:06E6 296400         2 3825 7405         move    #100,b0
P:06E7 596600         2 3827 7406         move    b0,y:(r6)
                             7407 
                             7408 ; 605  |                            CacheDesc_chkdsk[selection].WriteAttribute = 1;
                             7409 
P:06E8 77F400 FFFFFE  3 3830 7411         move    #-2,n7
P:06EA 000000         2 3832 7412         nop
P:06EB 6EEF00         4 3836 7413         move    y:(r7+n7),r6
P:06EC 290100         2 3838 7414         move    #1,b0
P:06ED 596600         2 3840 7415         move    b0,y:(r6)
                             7416 
                             7417 ; 606  |                                temp = (CacheMem_chkdsk[selection][wOffsetToWord] & MaskArray[wOffsetBit]);
                             7418 
P:06EE 045FA0         2 3842 7420         movec   m0,n7
P:06EF 000000         2 3844 7421         nop
P:06F0 6BEF00         4 3848 7422         move    y:(r7+n7),r3
P:06F1 000000         2 3850 7423         nop
P:06F2 6BE300         2 3852 7424         move    y:(r3),r3
P:06F3 77F400 FFFFF9  3 3855 7425         move    #-7,n7
P:06F5 000000         2 3857 7426         nop
P:06F6 5DEF00         4 3861 7427         move    y:(r7+n7),b1
P:06F7 21BB00         2 3863 7428         move    b1,n3
P:06F8 000000         2 3865 7431         nop
P:06F9 204B00         2 3867 7432         move    (r3)+n3
P:06FA 57E300         2 3869 7433         move    x:(r3),b
P:06FB 77F400 FFFFFA  3 3872 7435         move    #-6,n7
P:06FD 000000         2 3874 7436         nop
P:06FE 5EEF00         4 3878 7437         move    y:(r7+n7),a
P:06FF 219E00         2 3880 7438         move    a1,n6
P:0700 66F400 rrrrrr  3 3883 7441         move    #FMaskArray,r6
P:0702 000000         2 3885 7442         nop
P:0703 204E00         2 3887 7443         move    (r6)+n6
P:0704 4EE600         2 3889 7444         move    y:(r6),y0
P:0705 21AC00         2 3891 7445         move    b1,a1
P:0706 200056         2 3893 7446         and     y0,a
P:0707 218E00         2 3895 7448         move    a1,a
                             7450 
                             7451 ; 607  |                    CacheMem_chkdsk[selection][wOffsetToWord] = CacheMem_chkdsk[selection][wOffsetToWord] | MaskArray[wOffsetBit];                
                             7452 
P:0708 20005A         2 3897 7454         or      y0,b
P:0709 556300         2 3899 7455         move    b1,x:(r3)
                             7456 
                             7457 ; 608  |                                return temp;
                             7458 
P:070A 218E00         2 3901 7460 L190:   move    a1,a
P:070B 0AF080 rrrrrr  6 3907 7461         jmp     L198
                             7462 
                             7463 ; 609  |                        case FREE_BIT:
                             7464 ; 610  |                    CacheDesc_chkdsk[selection].CacheCounter = WRITECOUNTER;
                             7465 
                             7467 L191:
P:070D 77F400 FFFFFD  3 3910 7470         move    #-3,n7
P:070F 000000         2 3912 7471         nop
P:0710 7EEF00         4 3916 7472         move    y:(r7+n7),n6
P:0711 66F400 rrrrrr  3 3919 7473         move    #FCacheDesc_chkdsk+4,r6
P:0713 000000         2 3921 7474         nop
P:0714 204E00         2 3923 7475         move    (r6)+n6
P:0715 296400         2 3925 7476         move    #100,b0
P:0716 596600         2 3927 7477         move    b0,y:(r6)
                             7478 
                             7479 ; 611  |                            CacheDesc_chkdsk[selection].WriteAttribute = 1;
                             7480 
P:0717 77F400 FFFFFE  3 3930 7482         move    #-2,n7
P:0719 000000         2 3932 7483         nop
P:071A 6EEF00         4 3936 7484         move    y:(r7+n7),r6
P:071B 290100         2 3938 7485         move    #1,b0
P:071C 596600         2 3940 7486         move    b0,y:(r6)
                             7487 
                             7488 ; 612  |                                temp = 0xffffff ^ MaskArray[wOffsetBit];
                             7489 
P:071D 77F400 FFFFFA  3 3943 7491         move    #-6,n7
P:071F 000000         2 3945 7492         nop
P:0720 58EF00         4 3949 7493         move    y:(r7+n7),a0
P:0721 211E00         2 3951 7494         move    a0,n6
P:0722 66F400 rrrrrr  3 3954 7497         move    #FMaskArray,r6
P:0724 000000         2 3956 7498         nop
P:0725 204E00         2 3958 7499         move    (r6)+n6
P:0726 5FE600         2 3960 7500         move    y:(r6),b
P:0727 46F400 FFFFFF  3 3963 7501         move    #$FFFFFF,y0
P:0729 20005B         2 3965 7502         eor     y0,b
                             7505 
                             7506 ; 613  |                                CacheMem_chkdsk[selection][wOffsetToWord] = CacheMem_chkdsk[selection][wOffsetToWord] & temp;
                             7507 
P:072A 20DF00         2 3967 7509         move    y0,n7
P:072B 000000         2 3969 7510         nop
P:072C 6BEF00         4 3973 7511         move    y:(r7+n7),r3
P:072D 000000         2 3975 7512         nop
P:072E 6BE300         2 3977 7513         move    y:(r3),r3
P:072F 77F400 FFFFF9  3 3980 7514         move    #-7,n7
P:0731 000000         2 3982 7515         nop
P:0732 4EEF00         4 3986 7516         move    y:(r7+n7),y0
P:0733 20DB00         2 3988 7517         move    y0,n3
P:0734 000000         2 3990 7520         nop
P:0735 204B00         2 3992 7521         move    (r3)+n3
P:0736 56E300         2 3994 7522         move    x:(r3),a
P:0737 21A700         2 3996 7524         move    b1,y1
P:0738 200076         2 3998 7525         and     y1,a
P:0739 546300         2 4000 7528         move    a1,x:(r3)
                             7529 
                             7530 ; 614  |                                return 0;                                               
                             7531 
P:073A 0AF080 rrrrrr  6 4006 7533         jmp     L194
                             7535 L192:
P:073C 45F400 000005  3 4009 7540         move    #>5,x1
P:073E 2000E8         2 4011 7541         mpy     y0,x1,b
P:073F 20002A         2 4013 7542         asr     b
P:0740 213E00         2 4015 7543         move    b0,n6
P:0741 213D00         2 4017 7544         move    b0,n5
P:0742 66F400 rrrrrr  3 4020 7545         move    #FCacheDesc_chkdsk+4,r6
P:0744 000000         2 4022 7546         nop
P:0745 204E00         2 4024 7547         move    (r6)+n6
P:0746 296400         2 4026 7548         move    #100,b0
P:0747 596600         2 4028 7549         move    b0,y:(r6)
P:0748 66F400 rrrrrr  3 4031 7551         move    #FCacheDesc_chkdsk+3,r6
P:074A 000000         2 4033 7552         nop
P:074B 204E00         2 4035 7553         move    (r6)+n6
P:074C 290100         2 4037 7554         move    #1,b0
P:074D 596600         2 4039 7555         move    b0,y:(r6)
P:074E 77F400 FFFFFA  3 4042 7557         move    #-6,n7
P:0750 000000         2 4044 7558         nop
P:0751 4FEF00         4 4048 7559         move    y:(r7+n7),y1
P:0752 20FE00         2 4050 7560         move    y1,n6
P:0753 66F400 rrrrrr  3 4053 7563         move    #FMaskArray,r6
P:0755 000000         2 4055 7564         nop
P:0756 204E00         2 4057 7565         move    (r6)+n6
P:0757 5FE600         2 4059 7566         move    y:(r6),b
P:0758 47F400 FFFFFF  3 4062 7567         move    #$FFFFFF,y1
P:075A 20007B         2 4064 7568         eor     y1,b
P:075B 20DE00         2 4066 7573         move    y0,n6
P:075C 66F400 rrrrrr  3 4069 7574         move    #FCacheMem_chkdsk,r6
P:075E 000000         2 4071 7575         nop
P:075F 6BEE00         4 4075 7576         move    y:(r6+n6),r3
P:0760 77F400 FFFFF9  3 4078 7577         move    #-7,n7
P:0762 000000         2 4080 7578         nop
P:0763 4FEF00         4 4084 7579         move    y:(r7+n7),y1
P:0764 20FB00         2 4086 7580         move    y1,n3
P:0765 000000         2 4088 7583         nop
P:0766 204B00         2 4090 7584         move    (r3)+n3
P:0767 56E300         2 4092 7585         move    x:(r3),a
P:0768 21A700         2 4094 7586         move    b1,y1
P:0769 200076         2 4096 7587         and     y1,a
P:076A 546300         2 4098 7591         move    a1,x:(r3)
                             7592 
                             7593 ; 615  |
                             7594 ; 616  |                }
                             7595 ; 617  |        return 0;
                             7596 
P:076B 200013         2 4100 7598 L194:   clr     a   
                             7599 
                             7600 ; 618  |}
                             7601 
P:076C 77F400 FFFFF5  3 4103 7603 L198:   move    #-11,n7
P:076E 000000         2 4105 7604         nop
P:076F 05EF7C         4 4109 7605         movec   y:(r7+n7),ssh
P:0770 204F00         2 4111 7607         move    (r7)+n7
P:0771 00000C         4 4115 7609         rts
                             7613 
                             7614 ; 619  |
                             7615 ; 620  |
                             7616 ; 621  |
                             7617 ; 622  |
                             7618 ; 623  |
                             7619 ; 624  |
                             7620 ; 625  |void _reentrant IncrementCacheCounters_chkdsk(void)
                             7621 ; 626  |{
                             7622 
                             7627 FIncrementCacheCounters_chkdsk:
                             7630 
                             7631 ; 627  |    INT i;
                             7632 ; 628  |    for ( i = 0; i< MAX_CACHES;i++ )
                             7633 
P:0772 260000         2 4117 7635         move    #0,y0
P:0773 57F400 000001  3 4120 7637         move    #>1,b
P:0775 45F400 000005  3 4123 7638         move    #>5,x1
P:0777 060580 rrrrrr  6 4129 7639         do      #5,L201
                             7641 
                             7642 ; 629  |        (CacheDesc_chkdsk[i].CacheCounter)++;
                             7643 
P:0779 2000E0         2 4131 7645         mpy     y0,x1,a
P:077A 200022         2 4133 7646         asr     a
P:077B 211E00         2 4135 7647         move    a0,n6
P:077C 66F400 rrrrrr  3 4138 7648         move    #FCacheDesc_chkdsk+4,r6
P:077E 000000         2 4140 7649         nop
P:077F 204E00         2 4142 7650         move    (r6)+n6
P:0780 5EE600         2 4144 7651         move    y:(r6),a
P:0781 200010         2 4146 7652         add     b,a
P:0782 5C6600         2 4148 7653         move    a1,y:(r6)
P:0783 200051         2 4150 7655         tfr     y0,a
P:0784 200010         2 4152 7656         add     b,a
P:0785 218600         2 4154 7659         move    a1,y0
                        (25) 7662 L201:
                             7664 
                             7665 ; 630  |}
                             7666 
P:0786 00000C         4 4158 7668         rts
                             7671 
                             7672 ; 631  |
                             7673 ; 632  |
                             7674 ; 633  |
                             7675 ; 634  |
                             7676 ; 635  |
                             7677 ; 636  |
                             7678 ; 637  |
                             7679 ; 638  |
                             7680 ; 639  |
                             7681 ; 640  |
                             7682 ; 641  |
                             7683 ; 642  |#pragma asm
                             7684 
                             7685 ;************************************************************************
                             7686 ;  Include files
                             7687 ;************************************************************************
                             7688 ; Use relative paths only
                             7691 ;************************************************************************
                             7692 ;       Global Variables
                             7693 ;************************************************************************
                             7694 
                             7695         
Y:0000                       7696     org y,".yStmpSearchmatchingSector":
                             7697 
                             7698 CACHEDECS_SECTORNO  equ   1
                             7699 
                             7700 ;************************************************************************
                             7701 ;  Code start
                             7702 ;************************************************************************
P:0000                       7703         org p,".pStmpSearchmatchingSector":
                             7704 
                             7705 ;////////////////////////////////////////////////////////////////////////
TASKING DSP2410 assembler v1.5r1 Build 138 SN 00100122
                                                                                                                                                                                                                                                       Page  27

M:ADDR CODE           CYCLES LINE SOURCELINE
                             7706 ;   Name:           SearchmatchingSector
                             7707 ;   Type:           Function
                             7708 ;   Inputs:         A =  sector number
                             7709 ;                                       ro = Cache descriptor address
                             7710 ;   Output:         index 
                             7711 ;   Registers Trashed : Assume all except r7
                             7712 ;   Notes:          
                             7713 ;////////////////////////////////////////////////////////////////////////
                             7714 
                             7715 FSearchmatchingSector
                             7716 SearchmatchingSector
                             7717     push ssh
P:0000 055F7C         2    2 7717     movec   ssh,y:(r7)+
P:0001 70F400 000001  3    5 7718     move #>CACHEDECS_SECTORNO,n0
P:0003 210600         2    7 7719     move  A0,y0
P:0004 044814         4   11 7720         lua   (r0)+n0,r4
P:0005 74F413 000005  3   14 7721         clr   A         #>5,n4
P:0007 239800         2   16 7722         move n4,n0 
P:0008 000000         2   18 7723         nop
P:0009 204000         2   20 7724         move (r0)-n0
P:000A 06CF00 rrrrrr  6   26 7725     do B,_END
P:000C 5FCC00         2   28 7726         move y:(r4)+n4,B 
P:000D 20485D         2   30 7727         cmp y0,B        (r0)+n0   
P:000E 0AF0A2 rrrrrr  6   36 7728                 jne _next
P:0010 5FE000         2   38 7729                 move y:(r0),B
P:0011 20000B         2   40 7730                 tst B
P:0012 0AF0AA rrrrrr  6   46 7731                 jeq _next
P:0014 00008C         2   48 7732                 Enddo
                             7733 
P:0015 0AF080 rrrrrr  6   54 7734                 jmp _EXIT
                             7735 
                             7736 _next    
P:0017 000008         2   56 7737                 inc  A
                             7738 
                        (30) 7739 _END
P:0018 50F400 FFFFFF  3   59 7740         move #>-1,A0
                             7741 
                             7742 _EXIT
                             7743         pop ssh
P:001A 05FF7C         4   63 7743     movec   y:-(r7),ssh
P:001B 210E00         2   65 7744         move A0,A
P:001C 00000C         4   69 7745     rts
                             7746 
                             7747              
                             7748   
                             7749 ; 708  |#pragma endasm   
                             7750 ; 709  |          
                             7751 ; 710  |
                             7752 ; 711  |
                             7753 ; 712  |
                             7754 ; 713  |
                             7755 ; 714  |
                             7756 ; 715  |//extern INT MediaRead(INT deviceNumber, LONG sectorNumber,int _X *readbuf,INT SectorType);
                             7757 ; 716  |
                             7758 ; 717  |
                             7759 
                             7802 
                             7803         extern  Rdiv_uiuiui, Rdiv_ululul, SetupSwizzleAddrXY
                             7804         extern  SetupSwizzleAddrYX, y:FCacheDesc_chkdsk
                             7805         extern  y:FCacheMem_chkdsk, y:FDataDriveStatus, FDriveReadSector
                             7806         extern  FDriveWriteSector, FFSGetWord, x:FFatBuffer, FGetDWordY
                             7807         extern  y:FGetNextCxFromFat, y:FMaskArray, y:FMediaBuffer
                             7808         extern  FMediaRead, FMediaWrite, FPutDword, FPutWord
                             7809         extern  FSearchmatchingSector, x:FcachedSectorSize
                             7810         extern  x:FcachedSectorSizeInWords, y:FstFat
                             7811         extern  y:FstPartitionBootSector
                             7812 
                             7813         global  FFAT32_UpdateBit, FFetchCxFat12, FFreeCxFat, FFreeCxFat12
                             7814         global  FFreeCxFat16, FFreeCxFat32, FGetNextCxFat12
                             7815         global  FGetNextCxFat16, FGetNextCxFat32
                             7816         global  FIncrementCacheCounters_chkdsk, FIsLastCx, FLoadFatSector
                             7817         global  FWriteFatSector
                             7818 
                             7819         local   L20, L21, L22, L27, L28, L29, L30, L31, L62, L63, L64, L66
                             7820         local   L70, L71, L73, L74, L76, L77, L79, L80, L83, L85, L96, L97
                             7821         local   L98, L99, L100, L102, L104, L106, L107, L108, L109, L111
                             7822         local   L112, L114, L115, L116, L117, L121, L177, L179, L181, L182
                             7823         local   L183, L184, L185, L186, L187, L189, L190, L191, L192, L194
                             7824         local   L198, L199, L201
                             7825 
                             7826         calls   "FAT32_UpdateBit", "IncrementCacheCounters_chkdsk"
                             7827         calls   "FAT32_UpdateBit", "MediaRead", "MediaWrite"
                             7828         calls   "FAT32_UpdateBit", "SearchmatchingSector"
                             7829         calls   "FreeCxFat12", "LoadFatSector", "Rdiv_uiuiui"
                             7830         calls   "FreeCxFat12", "Rdiv_ululul"
                             7831         calls   "FreeCxFat16", "LoadFatSector", "PutWord", "Rdiv_ululul"
                             7832         calls   "FreeCxFat32", "LoadFatSector", "PutDword", "Rdiv_ululul"
                             7833         calls   "GetNextCxFat12", "FetchCxFat12", "LoadFatSector"
                             7834         calls   "GetNextCxFat12", "Rdiv_uiuiui", "Rdiv_ululul"
                             7835         calls   "GetNextCxFat16", "FSGetWord", "LoadFatSector"
                             7836         calls   "GetNextCxFat16", "Rdiv_ululul"
                             7837         calls   "GetNextCxFat32", "GetDWordY", "LoadFatSector"
                             7838         calls   "GetNextCxFat32", "Rdiv_ululul"
                             7839         calls   "LoadFatSector", "DriveReadSector", "SetupSwizzleAddrXY"
                             7840         calls   "LoadFatSector", "WriteFatSector"
                             7841         calls   "WriteFatSector", "DriveWriteSector", "SetupSwizzleAddrYX"
                             7842 
