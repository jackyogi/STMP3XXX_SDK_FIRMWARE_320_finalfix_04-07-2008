TASKING DSP2410 assembler v1.5r1 Build 138 SN 00100122
                                                                                                                                                                                                                                                       Page   1
C:\STMP3XXX_SDK_FIRMWARE_320_finalfix\system\exec\c_menu_kernel\syswaitonevent.asm
M:ADDR CODE           CYCLES LINE SOURCELINE
                                1     section SYSWAITONEVENT
                                2     
                                3     include "msgequ.inc"
                                1 ;///////////////////////////////////////////////////////////////////////////////
                                2 ; Copyright(C) SigmaTel, Inc. 2000
                                3 ;
                                4 ; Message defs
                                5 ;///////////////////////////////////////////////////////////////////////////////
                                8 MSGEQU_INC equ 1
                               12 ;ASM Only
                               13     DEFINE MAX_MODULE_SIZE    '(F_lc_u_eP_Module_overlay-F_lc_u_bP_Module_overlay)*3'
                               14 ;endasm
                               16 ;C insert
                               17 ;#define MAX_MODULE_SIZE   (lc_u_eP_Module_overlay-lc_u_bP_Module_overlay)*3
                               18 ;endc
                               21 MSG_TYPE_DECODER            equ     $000000
                               22 MSG_TYPE_ENCODER            equ     $010000
                               23 MSG_TYPE_PARSER             equ     $020000
                               24 MSG_TYPE_LCD                equ     $030000
                               25 MSG_TYPE_MIXER              equ     $040000
                               26 MSG_TYPE_SYSTEM             equ     $050000
                               27 MSG_TYPE_MENU               equ     $060000
                               28 MSG_TYPE_LED                equ     $070000
                               29 MSG_TYPE_TUNER                equ     $080000
                               30 MSG_TYPE_CHARLCD            equ     $030000
                               31 MSG_TYPE_SOFT_TIMER         equ     $090000
                               32 MSG_TYPE_GEQ                equ     $0a0000             ; Equalizer and other effects
                               34 MSG_TYPE_MUSICLIB_PLAY      equ     $0b0000
                               35 MSG_TYPE_MUSICLIB_BROWSE    equ     $0c0000
                               36 MSG_TYPE_MUSICLIB_PLAYALLNEXT      equ     $0d0000
                               37 MSG_TYPE_MUSICLIB_PLAYALLPREV      equ     $0e0000
                               38 MSG_TYPE_MUSICLIB_SHUFFLE          equ     $0f0000
                               39 MSG_TYPE_MUSICLIB_VOICE    equ     $100000
                               40 MSG_TYPE_MUSICLIB_VOICEPLAY    equ     $110000
                               41 MSG_TYPE_MUSICLIB_MERGE     equ     $120000
                               48 ; Message Structure Offsets
                               49 MSG_Length              equ     0
                               50 MSG_ID                  equ     1
                               51 MSG_Argument1           equ     2
                               52 MSG_Argument2           equ     3
                               53 MSG_Argument3           equ     4
                               54 MSG_Argument4           equ     5
                               55 MSG_Argument5           equ     6
                               56 MSG_Argument6           equ     7
                               60 ; LCD Message IDs
                               61 LCD_FIRST_MSG_ID         equ     MSG_TYPE_LCD+0
                               62 LCD_CLEAR_RANGE          equ     MSG_TYPE_LCD+0
                               63 LCD_PRINT_RANGE_RSRC     equ     MSG_TYPE_LCD+1
                               64 LCD_PRINT_RANGE_ADDR     equ     MSG_TYPE_LCD+2
                               65 LCD_PRINT_RANGE_INV_RSRC equ     MSG_TYPE_LCD+3
                               66 LCD_PRINT_RANGE_INV_ADDR equ     MSG_TYPE_LCD+4
                               67 LCD_PRINT_RANGE_FILE     equ     MSG_TYPE_LCD+5
                               68 LCD_PRINT_RANGE_INV_FILE equ     MSG_TYPE_LCD+6
                               69 LCD_PRINT_STRING_RSRC    equ     MSG_TYPE_LCD+7
                               70 LCD_PRINT_STRING_ADDR    equ     MSG_TYPE_LCD+8
                               71 LCD_PRINT_STRING_INV_RSRC equ    MSG_TYPE_LCD+9
                               72 LCD_PRINT_STRING_INV_ADDR equ    MSG_TYPE_LCD+10
                               73 LCD_SCROLL_DISPLAY       equ     MSG_TYPE_LCD+11
                               74 LCD_READ_LCD_ADDR        equ     MSG_TYPE_LCD+12
                               75 LCD_SET_CONTRAST         equ     MSG_TYPE_LCD+13
                               76 LCD_INC_CONTRAST         equ     MSG_TYPE_LCD+14
                               77 LCD_DEC_CONTRAST         equ     MSG_TYPE_LCD+15
                               78 LCD_BACKLIGHT_ON                 equ     MSG_TYPE_LCD+16
                               79 LCD_BACKLIGHT_OFF                equ     MSG_TYPE_LCD+17
                               80 LCD_SET_FONT             equ     MSG_TYPE_LCD+18
                               81 LCD_PRINT_NUMBER         equ     MSG_TYPE_LCD+19
                               82 LCD_PRINT_TIME           equ     MSG_TYPE_LCD+20
                               83 LCD_PRINT_TIME_LONG      equ     MSG_TYPE_LCD+21
                               84 LCD_PRINT_STRING_UNICODE_INV_ADDR equ MSG_TYPE_LCD+22
                               85 LCD_PRINT_STRING_UNICODE_ADDR equ MSG_TYPE_LCD+23
                               86 LCD_PRINT_STRING_UNICODE_INV_RSRC equ MSG_TYPE_LCD+24
                               87 LCD_PRINT_STRING_UNICODE_RSRC equ MSG_TYPE_LCD+25
                               88 LCD_BEGIN_FRAME          equ     MSG_TYPE_LCD+26
                               89 LCD_END_FRAME            equ     MSG_TYPE_LCD+27
                               90 LCD_PRINT_NUMBER_INV     equ     MSG_TYPE_LCD+28
                               91 LCD_PRINT_TIME_INV       equ     MSG_TYPE_LCD+29
                               92 LCD_PRINT_TIME_LONG_INV  equ     MSG_TYPE_LCD+30
                               93 LCD_SET_FRAMEBUFFER      equ     MSG_TYPE_LCD+31
                               94 ;send a NULL as Param1 to return to root frame buffer
                               95 LCD_PUSH_MASK             equ     MSG_TYPE_LCD+32
                               96 ;Param1 = left
                               97 ;Param2 = top
                               98 ;Param3 = right
                               99 ;Param4 = bottom
                              100 LCD_POP_MASK                    equ     MSG_TYPE_LCD+33
                              101 LCD_PRINT_UNICODE_CHAR          equ     MSG_TYPE_LCD+34
                              102 LCD_PRINT_UNICODE_CHAR_INV      equ     MSG_TYPE_LCD+35
                              103 LCD_DISPLAY_HISTOGRAM    equ     MSG_TYPE_LCD+36
                              104 LCD_PRINT_TIME_L_1DIG_HR equ     MSG_TYPE_LCD+37
                              105 LCD_SET_ICON             equ     MSG_TYPE_LCD+38
                              107 LCD_CLEAR_RANGE_BUFFER                                          equ             MSG_TYPE_LCD+39
                              108 LCD_PRINT_RANGE_RSRC_BUFFER                                     equ             MSG_TYPE_LCD+40
                              109 LCD_PRINT_RANGE_INV_RSRC_BUFFER                         equ             MSG_TYPE_LCD+41
                              110 LCD_PRINT_RANGE_ADDR_BUFFER                                     equ             MSG_TYPE_LCD+42
                              111 LCD_PRINT_RANGE_INV_ADDR_BUFFER                         equ             MSG_TYPE_LCD+43
                              112 LCD_PRINT_STRING_RSRC_BUFFER                            equ             MSG_TYPE_LCD+44
                              113 LCD_PRINT_STRING_INV_RSRC_BUFFER                        equ             MSG_TYPE_LCD+45
                              114 LCD_PRINT_STRING_ADDR_BUFFER                            equ             MSG_TYPE_LCD+46
                              115 LCD_PRINT_STRING_INV_ADDR_BUFFER                        equ             MSG_TYPE_LCD+47
                              116 LCD_PRINT_NUMBER_BUFFER                                         equ             MSG_TYPE_LCD+48
                              117 LCD_PRINT_NUMBER_INV_BUFFER                                     equ             MSG_TYPE_LCD+49
                              118 LCD_PRINT_TIME_BUFFER                                           equ             MSG_TYPE_LCD+50
                              119 LCD_PRINT_TIME_INV_BUFFER                                       equ             MSG_TYPE_LCD+51
                              120 LCD_PRINT_TIME_LONG_BUFFER                                      equ             MSG_TYPE_LCD+52
                              121 LCD_PRINT_TIME_LONG_INV_BUFFER                          equ             MSG_TYPE_LCD+53
                              122 LCD_PRINT_STRING_UNICODE_ADDR_BUFFER            equ             MSG_TYPE_LCD+54
                              123 LCD_PRINT_STRING_UNICODE_INV_ADDR_BUFFER        equ             MSG_TYPE_LCD+55
                              124 LCD_PRINT_STRING_UNICODE_RSRC_BUFFER            equ             MSG_TYPE_LCD+56
                              125 LCD_PRINT_STRING_UNICODE_INV_RSRC_BUFFER        equ             MSG_TYPE_LCD+57
                              126 LCD_PRINT_UNICODE_CHAR_BUFFER                           equ             MSG_TYPE_LCD+58
                              127 LCD_PRINT_UNICODE_CHAR_INV_BUFFER                       equ             MSG_TYPE_LCD+59
                              128 LCD_PRINT_TIME_L_1DIG_HR_BUFFER                         equ             MSG_TYPE_LCD+60
                              129 LCD_SET_BUFFER_COLOR                                            equ             MSG_TYPE_LCD+61
                              130 LCD_FORCE_BUFFER_UPDATE                                         equ             MSG_TYPE_LCD+62
                              131 LCD_SET_BUFFER_WINDOW                                           equ             MSG_TYPE_LCD+63
                              132 LCD_SET_COLOR                                                           equ             MSG_TYPE_LCD+64
                              133 LCD_SET_BUFFER_POSITION                                         equ     MSG_TYPE_LCD+65
                              135 LCD_TEMP_CONTRAST        equ     MSG_TYPE_LCD+66
                              143 LCD_LAST_MSG_ID                                                 equ     MSG_TYPE_LCD+66
                              146 ; If you change the LCD message ID's then you must
                              147 ; also change the jump table in lcdapi.asm
                              149 ; Character LCD Message IDs
                              150 CHARLCD_FIRST_MSG_ID         equ     MSG_TYPE_CHARLCD+0
                              151 CHARLCD_CLEAR_RANGE          equ     MSG_TYPE_CHARLCD+0
                              152 CHARLCD_PRINT_RSRC           equ     MSG_TYPE_CHARLCD+1
                              153 CHARLCD_PRINT_INV_RSRC       equ     MSG_TYPE_CHARLCD+2
                              154 CHARLCD_PRINT_ASCII_CHAR     equ     MSG_TYPE_CHARLCD+3
                              155 CHARLCD_PRINT_ASCII_INV_CHAR equ     MSG_TYPE_CHARLCD+4
                              156 CHARLCD_PRINT_STRING_RSRC    equ     MSG_TYPE_CHARLCD+5
                              157 CHARLCD_PRINT_STRING_INV_RSRC equ    MSG_TYPE_CHARLCD+6
                              158 CHARLCD_PRINT_STRING_ADDR    equ     MSG_TYPE_CHARLCD+7
                              159 CHARLCD_PRINT_STRING_INV_ADDR equ    MSG_TYPE_CHARLCD+8
                              160 CHARLCD_SCROLL_DISPLAY       equ     MSG_TYPE_CHARLCD+9
                              161 CHARLCD_READ_LCD_ADDR        equ     MSG_TYPE_CHARLCD+10
                              162 CHARLCD_SET_CURSOR           equ     MSG_TYPE_CHARLCD+11
                              163 CHARLCD_SET_FONT             equ     MSG_TYPE_CHARLCD+12
                              164 CHARLCD_PRINT_NUMBER         equ     MSG_TYPE_CHARLCD+13
                              165 CHARLCD_PRINT_TIME           equ     MSG_TYPE_CHARLCD+14
                              166 CHARLCD_SET_BATTERY          equ     MSG_TYPE_CHARLCD+15
                              167 CHARLCD_SET_EQ               equ     MSG_TYPE_CHARLCD+16
                              168 CHARLCD_SET_ICON             equ     MSG_TYPE_CHARLCD+17
                              169 CHARLCD_SET_PLAYMODE         equ     MSG_TYPE_CHARLCD+18
                              170 CHARLCD_SET_PLAYSTATE        equ     MSG_TYPE_CHARLCD+19
                              171 CHARLCD_SET_VOLUME           equ     MSG_TYPE_CHARLCD+20
                              172 CHARLCD_CLEAR_DISPLAY        equ     MSG_TYPE_CHARLCD+21
                              173 CHARLCD_LAST_MSG_ID          equ     MSG_TYPE_CHARLCD+21
                              174 ; If you change the cHARACTER LCD message ID's then you must
                              175 ; also change the jump table in lcdapi.asm
                              177 ; Decoder Message IDs
                              178 DECODER_FIRST_MSG_ID     equ     MSG_TYPE_DECODER+0
                              179 DECODER_RESET            equ     MSG_TYPE_DECODER+0
                              180 DECODER_SET_DIR          equ     MSG_TYPE_DECODER+1
                              181 DECODER_PLAY             equ     MSG_TYPE_DECODER+2
                              182 DECODER_STOP             equ     MSG_TYPE_DECODER+3
                              183 DECODER_FFWD             equ     MSG_TYPE_DECODER+4
                              184 DECODER_RWND             equ     MSG_TYPE_DECODER+5
                              185 DECODER_NEXT_SONG        equ     MSG_TYPE_DECODER+6
                              186 DECODER_PREV_SONG        equ     MSG_TYPE_DECODER+7
                              187 DECODER_TIME_MODE        equ     MSG_TYPE_DECODER+8
                              188 DECODER_AB_MODE          equ     MSG_TYPE_DECODER+9
                              189 DECODER_SET_EQ           equ     MSG_TYPE_DECODER+10
                              190 DECODER_GET_SONG_INFO    equ     MSG_TYPE_DECODER+11
                              191 DECODER_NEXT_CHAPTER     equ     MSG_TYPE_DECODER+12
                              192 DECODER_PREV_CHAPTER     equ     MSG_TYPE_DECODER+13
                              193 DECODER_LAST_MSG_ID      equ     MSG_TYPE_DECODER+13
                              194 ; If you change the Decoder message ID's, then you must
                              195 ; also change the jump table in decoder_overlay.asm
                              196 ; and in dec_adpcm_overlay.asm.
                              198 ; Encoder Message IDs
                              199 ENCODER_FIRST_MSG_ID     equ     MSG_TYPE_ENCODER+0
                              200 ENCODER_RECORD           equ     MSG_TYPE_ENCODER+0
                              201 ENCODER_STOP             equ     MSG_TYPE_ENCODER+1
                              202 ENCODER_TIME_MODE        equ     MSG_TYPE_ENCODER+2
                              203 ENCODER_LAST_MSG_ID      equ     MSG_TYPE_ENCODER+3
                              204 ; If you change the Encoder message ID's, then you must
                              205 ; also change the jump table in all encoder overlay modules.
                              207 ; Parser Message IDs
                              208 PARSER_FIRST_MSG_ID     equ     MSG_TYPE_PARSER+0
                              209 PARSER_NEXT_SONG        equ     MSG_TYPE_PARSER+0
                              210 PARSER_PREV_SONG        equ     MSG_TYPE_PARSER+1
                              211 PARSER_REPEAT           equ     MSG_TYPE_PARSER+2
                              212 PARSER_RANDOM           equ     MSG_TYPE_PARSER+3
                              213 PARSER_STOP             equ     MSG_TYPE_PARSER+4
                              214 PARSER_DEVICE_ENUMERATE equ     MSG_TYPE_PARSER+5
                              215 PARSER_SET_CURRENT_SONG equ     MSG_TYPE_PARSER+6
                              216 PARSER_LAST_MSG_ID      equ     MSG_TYPE_PARSER+6
                              217 ; If you change the Parser message ID's, then you must
                              218 ; also change the jump table in parser.asm
                              220 ; Button Message IDs
                              221 ;BUTTON_FIRST_MSG_ID      equ     MSG_TYPE_BUTTON+0
                              222 ;BUTTON_BUTTONS_ON        equ     MSG_TYPE_BUTTON+0
                              223 ;BUTTON_BUTTONS_OFF       equ     MSG_TYPE_BUTTON+1
                              224 ;BUTTON_HOLD              equ     MSG_TYPE_BUTTON+2
                              225 ;BUTTON_HOLD_RELEASE      equ     MSG_TYPE_BUTTON+3
                              226 ;BUTTON_LAST_MSG_ID       equ     MSG_TYPE_BUTTON+3
                              228 ; Mixer Message IDs
                              229 MIXER_FIRST_MSG_ID       equ     MSG_TYPE_MIXER+0
                              230 MIXER_MASTER_INCR        equ     MSG_TYPE_MIXER+0
                              231 MIXER_MASTER_DECR        equ     MSG_TYPE_MIXER+1
                              232 MIXER_MASTER_SETLVL      equ     MSG_TYPE_MIXER+2
                              233 MIXER_MASTER_MUTE        equ     MSG_TYPE_MIXER+3
                              234 MIXER_MASTER_UNMUTE      equ     MSG_TYPE_MIXER+4
                              235 MIXER_MASTER_FADE_OUT    equ     MSG_TYPE_MIXER+5
                              236 MIXER_MASTER_FADE_IN     equ     MSG_TYPE_MIXER+6
                              237 MIXER_MASTER_BAL_RIGHT   equ     MSG_TYPE_MIXER+7
                              238 MIXER_MASTER_BAL_LEFT    equ     MSG_TYPE_MIXER+8
                              239 MIXER_MIC_INCR           equ     MSG_TYPE_MIXER+9
                              240 MIXER_MIC_DECR           equ     MSG_TYPE_MIXER+10
                              241 MIXER_MIC_SETLVL         equ     MSG_TYPE_MIXER+11
                              242 MIXER_MIC_MUTE           equ     MSG_TYPE_MIXER+12
                              243 MIXER_MIC_UNMUTE         equ     MSG_TYPE_MIXER+13
                              244 MIXER_MIC_BOOST          equ     MSG_TYPE_MIXER+14
                              245 MIXER_MIC_UNBOOST        equ     MSG_TYPE_MIXER+15
                              246 MIXER_LINE_INCR          equ     MSG_TYPE_MIXER+16
                              247 MIXER_LINE_DECR          equ     MSG_TYPE_MIXER+17
                              248 MIXER_LINE_SETLVL        equ     MSG_TYPE_MIXER+18
                              249 MIXER_LINE_MUTE          equ     MSG_TYPE_MIXER+19
                              250 MIXER_LINE_UNMUTE        equ     MSG_TYPE_MIXER+20
                              251 MIXER_FM_INCR            equ     MSG_TYPE_MIXER+21
                              252 MIXER_FM_DECR            equ     MSG_TYPE_MIXER+22
                              253 MIXER_FM_SETLVL          equ     MSG_TYPE_MIXER+23
                              254 MIXER_FM_MUTE            equ     MSG_TYPE_MIXER+24
                              255 MIXER_FM_UNMUTE          equ     MSG_TYPE_MIXER+25
                              256 MIXER_DAC_INCR           equ     MSG_TYPE_MIXER+26
                              257 MIXER_DAC_DECR           equ     MSG_TYPE_MIXER+27
                              258 MIXER_DAC_SETLVL         equ     MSG_TYPE_MIXER+28
                              259 MIXER_DAC_MUTE           equ     MSG_TYPE_MIXER+29
                              260 MIXER_DAC_UNMUTE         equ     MSG_TYPE_MIXER+30
                              261 MIXER_ADC_SELECT         equ     MSG_TYPE_MIXER+31
                              262 MIXER_ADC_INCR           equ     MSG_TYPE_MIXER+32
                              263 MIXER_ADC_DECR           equ     MSG_TYPE_MIXER+33
                              264 MIXER_ADC_SETLVL         equ     MSG_TYPE_MIXER+34
                              265 MIXER_ADC_MUTE           equ     MSG_TYPE_MIXER+35
                              266 MIXER_ADC_UNMUTE         equ     MSG_TYPE_MIXER+36
                              267 MIXER_REC_SELECT         equ     MSG_TYPE_MIXER+37
                              268 MIXER_POWER_DOWN         equ     MSG_TYPE_MIXER+38
                              269 ENABLE_RIGHT_CH              equ     MSG_TYPE_MIXER+39
                              270 DISABLE_RIGHT_CH                 equ     MSG_TYPE_MIXER+40
                              271 MIXER_LAST_MSG_ID        equ     MSG_TYPE_MIXER+40
                              272 ; If you change the mixer message ID's then you must
                              273 ; also change the jump table in mixer.asm
                              274 MIXER_ON                 equ     0
                              275 MIXER_OFF                equ     1
                              278 ; System Message IDs
                              279 SYSTEM_FIRST_MSG_ID      equ     MSG_TYPE_SYSTEM+0
                              280 SYSTEM_SHUTDOWN          equ     MSG_TYPE_SYSTEM+0
                              281 SYSTEM_SHUTDOWN_FALSE    equ     MSG_TYPE_SYSTEM+1
                              282 SYSTEM_SHUTDOWN_FINAL    equ     MSG_TYPE_SYSTEM+2
                              283 SYSTEM_LAST_MSG_ID       equ     MSG_TYPE_SYSTEM+2
                              284 ; If you change the system message ID's then you must
                              285 ; also change the jump table in systemapi.asm
TASKING DSP2410 assembler v1.5r1 Build 138 SN 00100122
                                                                                                                                                                                                                                                       Page   2

M:ADDR CODE           CYCLES LINE SOURCELINE
                              287 ; Menu IDs
                              288 MENU_FIRST_MSG_ID           equ     MSG_TYPE_MENU+0
                              289 MENU_BUTTON_EVENT           equ     MSG_TYPE_MENU+0
                              290 MENU_DECODER_STATE_CHNG     equ     MSG_TYPE_MENU+1
                              291 MENU_RECORDER_STATE_CHNG    equ     MSG_TYPE_MENU+2
                              292 ;sub parameters for this message:
                              293     RECORDER_START:             equ     0
                              294         RECORDER_PAUSE:             equ     $2000
                              295     RECORDER_RESUME:            equ     $4000
                              296     RECORDER_STOP_NORMAL:       equ     $8000
                              297     RECORDER_STOP_FILE_ERROR:   equ     $8001
                              298     RECORDER_STOP_OUT_OF_SPACE: equ     $8002
                              299     RECORDER_STOP_LOW_BATTERY:  equ     $8003
                              300 MENU_SONG_TIME_CHNG         equ     MSG_TYPE_MENU+3
                              301 MENU_AB_MODE_OFF            equ     MSG_TYPE_MENU+4
                              302 MENU_BATTERY_CHNG           equ     MSG_TYPE_MENU+5
                              303 MENU_SCROLL_TITLE           equ     MSG_TYPE_MENU+6
                              304 MENU_AUTO_SHUTDOWN          equ     MSG_TYPE_MENU+7
                              305 MENU_MSG_MEDIA_CHANGED      equ     MSG_TYPE_MENU+8
                              306 MENU_MSG_MEDIA_OVER_CUR         equ             MSG_TYPE_MENU+9
                              307 MENU_TUNER_TUNED            equ     MSG_TYPE_MENU+10
                              308 MENU_MSG_ENC_LOW_SPACE      equ     MSG_TYPE_MENU+11
                              309 MENU_MSG_EQ_SETTINGS        equ     MSG_TYPE_MENU+12
                              310 MENU_RECORDER_WRITE_DATA    equ     MSG_TYPE_MENU+13
                              311 MENU_SONG_TRACK_CHNG        equ     MSG_TYPE_MENU+14
                              312 MENU_SET_SONG_POSITION          equ             MSG_TYPE_MENU+15
                              313 MENU_UPDATE_CHAPTER_INFO        equ             MSG_TYPE_MENU+16
                              314 MENU_USB_CONNECTED          equ     MSG_TYPE_MENU+17
                              315 MENU_MSG_LYRICS_SYNC_AB         equ             MSG_TYPE_MENU+18
                              316 MENU_MSG_LYRICS_UPDATE          equ             MSG_TYPE_MENU+19
                              317 MENU_TUNER_REFRESH_DISPLAY  equ     MSG_TYPE_MENU+20
                              318 MENU_TUNER_DIRTY_FLASH      equ     MSG_TYPE_MENU+21
                              319 MENU_LAST_MSG_ID            equ     MSG_TYPE_MENU+21
                              321 ; Note that other versions of this file have different msg equates.
                              322 ; If you change the system message ID's then you must
                              323 ; also change the jump table in all menu *.asm
                              325 ; LED Message IDs
                              326 LED_FIRST_MSG_ID         equ     MSG_TYPE_LED+0
                              327 LED_CONTROL              equ     MSG_TYPE_LED+0
                              328 LED_RESET                equ     MSG_TYPE_LED+1
                              329 LED_DLY_ON_CONTROL           equ         MSG_TYPE_LED+2
                              330 LED_LAST_MSG_ID          equ     MSG_TYPE_LED+2
                              331 ; If you change the LeD message ID's then you must
                              332 ; also change the jump table in ledapi.asm
                              335 ; FM Tuner Message IDs
                              336 TUNER_FIRST_MSG_ID          equ     MSG_TYPE_TUNER+0
                              337 TUNER_TUNE_FREQUENCY        equ     MSG_TYPE_TUNER+0
                              338 TUNER_TUNE_MANUAL_UP        equ     MSG_TYPE_TUNER+1
                              339 TUNER_TUNE_MANUAL_DOWN      equ     MSG_TYPE_TUNER+2
                              340 TUNER_TUNE_SEARCH_UP        equ     MSG_TYPE_TUNER+3
                              341 TUNER_TUNE_SEARCH_DOWN      equ     MSG_TYPE_TUNER+4
                              342 TUNER_FORCED_MONO           equ     MSG_TYPE_TUNER+5
                              343 TUNER_RESET                 equ     MSG_TYPE_TUNER+6
                              344 TUNER_POWER_ON              equ     MSG_TYPE_TUNER+7
                              345 TUNER_POWER_OFF             equ     MSG_TYPE_TUNER+8
                              346 TUNER_SET_SENSITIVITY       equ     MSG_TYPE_TUNER+9
                              347 ;one parameter--the sensitivity in uV
                              348 TUNER_GET_STATES        equ     MSG_TYPE_TUNER+10
                              349 TUNER_MUTE_OUTPUTS      equ     MSG_TYPE_TUNER+11
                              350 TUNER_PRESET_STATION    equ     MSG_TYPE_TUNER+12
                              351 TUNER_TUNE_TO_PRESET    equ     MSG_TYPE_TUNER+13
                              352 TUNER_SET_PRESET        equ     MSG_TYPE_TUNER+14
                              353 TUNER_ERASE_PRESET      equ     MSG_TYPE_TUNER+15
                              354 TUNER_LAST_MSG_ID           equ     MSG_TYPE_TUNER+15
                              357 SOFT_TIMER_FIRST_MSG_ID equ     MSG_TYPE_SOFT_TIMER+0
                              358 SOFT_TIMER_SET_TIMER    equ     MSG_TYPE_SOFT_TIMER+1
                              359 SOFT_TIMER_KILL_TIMER   equ     MSG_TYPE_SOFT_TIMER+2
                              360 SOFT_TIMER_LAST_MSG_ID  equ     MSG_TYPE_SOFT_TIMER+2
                              363 GEQ_FIRST_MSG_ID        equ     MSG_TYPE_GEQ+0
                              364 GEQ_SET_EQ              equ     MSG_TYPE_GEQ+0
                              365 GEQ_SET_EQ_LEGACY       equ     MSG_TYPE_GEQ+1
                              366 GEQ_SET_ALL_BAND_GAINS  equ     MSG_TYPE_GEQ+2
                              367 GEQ_SET_GAIN            equ     MSG_TYPE_GEQ+3
                              368 GEQ_SET_COEFFICIENTS    equ     MSG_TYPE_GEQ+4
                              369 GEQ_SET_PARAM           equ     MSG_TYPE_GEQ+5
                              370 GEQ_GET_SETTINGS        equ     MSG_TYPE_GEQ+6
                              371 GEQ_LAST_MSG_ID         equ     MSG_TYPE_GEQ+6
                              374 ; Music Library
                              375 MUSICLIB_PLAY_FIRST_MSG_ID            equ     MSG_TYPE_MUSICLIB_PLAY+0
                              376 MUSICLIB_START_PLAY_SONG              equ     MSG_TYPE_MUSICLIB_PLAY+0
                              377 MUSICLIB_START_PLAY_ALL_SONG          equ     MSG_TYPE_MUSICLIB_PLAY+1
                              378 MUSICLIB_PLAY_SETSHUFFLE              equ     MSG_TYPE_MUSICLIB_PLAY+2
                              379 MUSICLIB_PLAY_RESUME                  equ     MSG_TYPE_MUSICLIB_PLAY+3
                              380 MUSICLIB_PLAY_CURRENT_SIZE                    equ     MSG_TYPE_MUSICLIB_PLAY+4
                              381 MUSICLIB_PLAY_LAST_MSG_ID             equ     MSG_TYPE_MUSICLIB_PLAY+4
                              383 MUSICLIB_BROWSE_FIRST_MSG_ID          equ     MSG_TYPE_MUSICLIB_BROWSE+0
                              384 MUSICLIB_BROWSE_SETROOT               equ     MSG_TYPE_MUSICLIB_BROWSE+0
                              385 MUSICLIB_BROWSE_BROWSEMENU            equ     MSG_TYPE_MUSICLIB_BROWSE+1
                              386 MUSICLIB_BROWSE_DOWNLIST              equ     MSG_TYPE_MUSICLIB_BROWSE+2
                              387 MUSICLIB_BROWSE_UPLIST                equ     MSG_TYPE_MUSICLIB_BROWSE+3
                              388 MUSICLIB_BROWSE_UPMENU                equ     MSG_TYPE_MUSICLIB_BROWSE+4
                              389 MUSICLIB_BROWSE_SONGNUMBER            equ     MSG_TYPE_MUSICLIB_BROWSE+5
                              390 MUSICLIB_BROWSE_ON_THE_FLY_GET_STATUS             equ     MSG_TYPE_MUSICLIB_BROWSE+6
                              391 MUSICLIB_BROWSE_ON_THE_FLY_ADD_ITEM           equ     MSG_TYPE_MUSICLIB_BROWSE+7
                              392 MUSICLIB_BROWSE_ON_THE_FLY_DELETE_ITEM        equ     MSG_TYPE_MUSICLIB_BROWSE+8
                              393 MUSICLIB_BROWSE_ON_THE_FLY_DELETE_ALL         equ     MSG_TYPE_MUSICLIB_BROWSE+9
                              394 MUSICLIB_BROWSE_LAST_MSG_ID           equ     MSG_TYPE_MUSICLIB_BROWSE+9
                              396 MUSICLIB_PLAYALLNEXT_FIRST_MSG_ID     equ     MSG_TYPE_MUSICLIB_PLAYALLNEXT+0
                              397 MUSICLIB_PLAYNEXTSONG                 equ     MSG_TYPE_MUSICLIB_PLAYALLNEXT+0
                              398 MUSICLIB_PLAYALLNEXT_LAST_MSG_ID      equ     MSG_TYPE_MUSICLIB_PLAYALLNEXT+0
                              400 MUSICLIB_PLAYALLPREV_FIRST_MSG_ID     equ     MSG_TYPE_MUSICLIB_PLAYALLPREV+0
                              401 MUSICLIB_PLAYPREVIOUSSONG             equ     MSG_TYPE_MUSICLIB_PLAYALLPREV+0
                              402 MUSICLIB_PLAYALLPREV_LAST_MSG_ID      equ     MSG_TYPE_MUSICLIB_PLAYALLPREV+0
                              404 MUSICLIB_SHUFFLE_FIRST_MSG_ID         equ     MSG_TYPE_MUSICLIB_SHUFFLE+0
                              405 MUSICLIB_SHUFFLE_NEXT                 equ     MSG_TYPE_MUSICLIB_SHUFFLE+0
                              406 MUSICLIB_SHUFFLE_LAST_MSG_ID          equ     MSG_TYPE_MUSICLIB_SHUFFLE+0
                              408 MUSICLIB_VOICE_FIRST_MSG_ID          equ     MSG_TYPE_MUSICLIB_VOICE+0
                              409 MUSICLIB_VOICE_BROWSEMENU            equ     MSG_TYPE_MUSICLIB_VOICE+0
                              410 MUSICLIB_VOICE_DOWNLIST              equ     MSG_TYPE_MUSICLIB_VOICE+1
                              411 MUSICLIB_VOICE_UPLIST                equ     MSG_TYPE_MUSICLIB_VOICE+2
                              412 MUSICLIB_VOICE_UPMENU                equ     MSG_TYPE_MUSICLIB_VOICE+3
                              413 MUSICLIB_VOICE_VOICENUMBER            equ     MSG_TYPE_MUSICLIB_VOICE+4
                              414 MUSICLIB_VOICE_LAST_MSG_ID           equ     MSG_TYPE_MUSICLIB_VOICE+4
                              416 MUSICLIB_VOICEPLAY_FIRST_MSG_ID      equ     MSG_TYPE_MUSICLIB_VOICEPLAY+0
                              417 MUSICLIB_START_PLAY_VOICE              equ     MSG_TYPE_MUSICLIB_VOICEPLAY+0
                              418 MUSICLIB_VOICEPLAY_LAST_MSG_ID       equ     MSG_TYPE_MUSICLIB_VOICEPLAY+0
                              420 MUSICLIB_MERGE_FIRST_MSG_ID            equ     MSG_TYPE_MUSICLIB_MERGE+0
                              421 MUSICLIB_MERGE_SONG                    equ     MSG_TYPE_MUSICLIB_MERGE+0
                              422 MUSICLIB_MERGE_ALL_SONG                equ     MSG_TYPE_MUSICLIB_MERGE+1
                              423 MUSICLIB_MERGE_RESUME                      equ     MSG_TYPE_MUSICLIB_MERGE+2
                              424 MUSICLIB_MERGE_LAST_MSG_ID             equ     MSG_TYPE_MUSICLIB_MERGE+2
                              451 ; Events
                              452 EVENT_NONE                  equ     $000001   ; No event
                              453 EVENT_MESSAGE               equ     $000002   ; A message has been posted
                              454 EVENT_TIMER                 equ     $000004   ; Run if wait time elapsed
                              455 EVENT_BUTTON                equ     $000008   ; Run if a button event occured
                              456 EVENT_BACKGROUND            equ     $000010   ; Run if a background event occured
                              457 EVENT_REPEAT                equ     $000020   ; The executive should immediately repeat this module
                              458 EVENT_INIT                  equ     $800000   ; Run the module's init routine
                              460 EVENT_NONE_BITPOS           equ     0
                              461 EVENT_MESSAGE_BITPOS        equ     1
                              462 EVENT_TIMER_BITPOS          equ     2
                              463 EVENT_BUTTON_BITPOS         equ     3
                              464 EVENT_BACKGROUND_BITPOS     equ     4
                              465 EVENT_REPEAT_BITPOS         equ     5
                              466 EVENT_INIT_BITPOS           equ     23
                              468 ; Parser Message Buffers
                              469 ParserPlayBit        equ     0
                              470 ButtonPressBit       equ     1
                              471 ParserRwndBit        equ     1
                              472 ParserFfwdBit        equ     2
                              474 ;NextSong Message Parameters
                              475 NEXT_SONG            equ     2          ; ButtonPressBit1 set to denote button was pressed.
                              476 NEXT_SONG_PLAY_EOF   equ     1          ; ButtonPressBit1 cleared
                              477 NEXT_SONG_PLAY_BUTTON equ    3          ; ButtonPressBit1 set
                              478 NEXT_SONG_FFWD       equ     4          ; NextSong + Ffwd
                              480 ;PrevSong Message Parameters
                              481 PREV_SONG            equ     0          ; PrevSong + Stopped
                              482 PREV_SONG_PLAY       equ     1          ; PrevSong + Play
                              483 PREV_SONG_RWND       equ     2          ; PrevSong + Rwnd
                                4     include "sysmacro.asm"
                                1 ;///////////////////////////////////////////////////////////////////////////////
                                2 ;  Copyright(C) SigmaTel, Inc. 2000-2001
                                3 ;
                                4 ;  File        : sysmacro.asm
                                5 ;  Description : Misc System Macros
                                6 ;///////////////////////////////////////////////////////////////////////////////
                                8     define   SysMacro_asm    '1'
                               10     page    255,255,0
                               12 ;///////////////////////////////////////////////////////////////////////////////
                               13 ;   Macros
                               14 ;///////////////////////////////////////////////////////////////////////////////
                               16 ;///////////////////////////////////////////////////////////////////////////////
                               17 ;   Includes
                               18 ;///////////////////////////////////////////////////////////////////////////////
                               20 ;///////////////////////////////////////////////////////////////////////////////
                               21 ;   External Definitions
                               22 ;///////////////////////////////////////////////////////////////////////////////
                               24 ;///////////////////////////////////////////////////////////////////////////////
                               25 ;   External References
                               26 ;///////////////////////////////////////////////////////////////////////////////
                               28 ;///////////////////////////////////////////////////////////////////////////////
                               29 ;   Equates
                               30 ;///////////////////////////////////////////////////////////////////////////////
                               31         
                               32 ;///////////////////////////////////////////////////////////////////////////////
                               33 ;   X Memory
                               34 ;///////////////////////////////////////////////////////////////////////////////
                               35         
                               36 ;///////////////////////////////////////////////////////////////////////////////
                               37 ;   Y Memory
                               38 ;///////////////////////////////////////////////////////////////////////////////
                               39         
                               40 ;///////////////////////////////////////////////////////////////////////////////
                               41 ;   P Memory
                               42 ;///////////////////////////////////////////////////////////////////////////////
                               44 ;///////////////////////////////////////////////////////////////////////////////
                               45 ;
                               46 ;>  Name:           push
                               47 ;
                               48 ;   Type:           Macro
                               49 ;
                               50 ;   Description:    Push a 24-bit value onto the data stack
                               51 ;
                               52 ;   Inputs:         Usage : push reg
                               53 ;                   reg = any core register that is 24-bits or less
                               54 ;
                               55 ;   Outputs:        none
                               56 ;                   
                               57 ;   Notes:          For every push, there must be a corresponding pop to keep
                               58 ;                   data stack balanced.
                               59 ;
                               60 ;   SeeAlso:        pop
                               61 ;<
                               62 ;///////////////////////////////////////////////////////////////////////////////
                               63 push    macro   reg
                               64     move    reg,y:(r7)+
                               65     endm
                               67 ;///////////////////////////////////////////////////////////////////////////////
                               68 ;
                               69 ;>  Name:           pop
                               70 ;
                               71 ;   Type:           Macro
                               72 ;
                               73 ;   Description:    Pop a 24-bit value from the data stack
                               74 ;
                               75 ;   Inputs:         Usage : pop reg
                               76 ;                   reg = any core register that is 24-bits or less
                               77 ;
                               78 ;   Outputs:        none
                               79 ;                   
                               80 ;   Notes:          For every pop, there must be a corresponding push to keep
                               81 ;                   data stack balanced.
                               82 ;
                               83 ;   SeeAlso:        push
                               84 ;<
                               85 ;///////////////////////////////////////////////////////////////////////////////
                               86 pop     macro   reg
                               87     move    y:-(r7),reg
                               88     endm
                               90 ;///////////////////////////////////////////////////////////////////////////////
                               91 ;
                               92 ;>  Name:           CallFunclet
                               93 ;
                               94 ;   Type:           Macro
                               95 ;
                               96 ;   Description:    Loads and Executes the funclet defined by the Resource argument
                               97 ;
                               98 ;   Inputs:         Resource = Resource number for the specific funclet.
                               99 ;
                              100 ;   Outputs:        none
                              101 ;                   
                              102 ;   Notes:          Jumps to SysCallFunclet.   TODO: change to a label instead of hard addresses like $80
                              103 ;<
                              104 ;///////////////////////////////////////////////////////////////////////////////
                              105 ; if ((@DEF('STMP_BUILD_PLAYER'))||(@DEF('PLAYER'))) ; sdk3.110 and before did this. 3.120 add short jump for mtp.
                              107 CallFunclet   macro Resource
                              108     jsr       $80
                              109     DC       Resource  ; 1 word
                              110  endm    
                              111 CallFunclet2   macro Resource
TASKING DSP2410 assembler v1.5r1 Build 138 SN 00100122
                                                                                                                                                                                                                                                       Page   3

M:ADDR CODE           CYCLES LINE SOURCELINE
                              112  if ((@DEF('STMP_BUILD_PLAYER'))||(@DEF('PLAYER')))
                              113     jsr       $82
                              114     DC       Resource  ; 1 word
                              115  else ;;; MTP
                              116     jsr       $80
                              117     DC       Resource  ; 1 word
                              118  endif
                              119     endm    
                              130 ;///////////////////////////////////////////////////////////////////////////////
                              131 ;
                              132 ;>  Name:           error
                              133 ;
                              134 ;   Type:           Macro
                              135 ;
                              136 ;   Description:    Fatal system error macro.  This macro works in conjunction
                              137 ;                   with contents of syserror.asm.  Depending upon the build
                              138 ;                   arguments DEBUG, BETA, or RETAIL, this will either produce
                              139 ;                   a "debug" statement or a JMP to an error handling reset routine.
                              140 ;
                              141 ;   Inputs:         none 
                              142 ;   Outputs:        none                   
                              143 ;   Notes:          Can use debugOrContinue or ccerror for conditional halts. 
                              144 ;                   SystemHalt() C macro uses this asm macro.
                              145 ;<
                              146 ;///////////////////////////////////////////////////////////////////////////////
                              147 error   macro
                              148   if (@DEF('BETA')||@DEF('RETAIL')||@DEF('TRACEBUFFER'))
                              149     jmp $000C ;Use vector at P:000C to shutdown & restart the STMP device. 
                              150               ; Jmp to addr in low 12 bits is 1 word smaller than jsr. (changed apr 6 '05)
                              151   else
                              152     debug
                              153   endif ; if ( @DEF('BETA')||@DEF('RETAIL') 
                              154     endm
                              156 ;///////////////////////////////////////////////////////////////////////////////
                              157 ;
                              158 ;   Name:           debugOrContinue
                              159 ;   Type:           Macro
                              160 ;   Description:    System error macro. Depending upon the build
                              161 ;                   arguments DEBUG, BETA, or RETAIL, this will either produce
                              162 ;                   a "debug" statement or nothing to allow continued execution.
                              163 ;   Inputs:         none 
                              164 ;   Outputs:        none
                              165 ;   Notes:          none
                              166 ;
                              167 ;///////////////////////////////////////////////////////////////////////////////
                              168 debugOrContinue   macro
                              169   if (@DEF('DEBUG'))
                              170     debug
                              171     nop
                              172   endif 
                              173     endm
                              175 ;///////////////////////////////////////////////////////////////////////////////
                              176 ;
                              177 ;   Name:           debugOrShutdown
                              178 ;   Type:           Macro
                              179 ;   Description:    System error macro. Depending upon the build
                              180 ;                   arguments DEBUG, BETA, or RETAIL, this will either produce
                              181 ;                   a "debug" statement or Prevent RETAIL build from hanging on 
                              182 ;                   debug line by attempting graceful shutdown.
                              183 ;   Inputs:         none 
                              184 ;   Outputs:        none
                              185 ;   Notes:          See SystemShutdownFinal in SystemAPI.asm
                              186 ;
                              187 ;///////////////////////////////////////////////////////////////////////////////
                              188 ;debugOrShutdown   macro
                              189 ;  if (@DEF('DEBUG'))
                              190 ;    debug
                              191 ;    nop
                              192 ;  else  ; ( @DEF('BETA')||@DEF('RETAIL')
                              193 ;    jmp SystemShutdownFinal                ; reference not resolved
                              194 ;  endif 
                              195 ;    endm
                              198 ;///////////////////////////////////////////////////////////////////////////////
                              199 ;> Name:            ccerror
                              200 ;
                              201 ;  Type:            Macro
                              202 ;  Description:     Conditional fatal system error macro.  If the indicated
                              203 ;                   condition code ("CC") is met, signal the error.  (See "error",
                              204 ;                   above for more info on error hanlding.)
                              205 ;                   The allowed condition condition codes are
                              206 ;
                              207 ;                       cc, cs, ec, eq, es, ge, gt, lc, le, ls, lt, 
                              208 ;                       mi, ne, nr, pl, nn 
                              209 ;
                              210 ;  Inputs:          condition
                              211 ;
                              212 ;  Outputs:         none
                              213 ;
                              214 ;  Notes:           The normal way of using these macros is shown below:
                              215 ;
                              216 ;                       <some operation which sets/clears a condition code>
                              217 ;                       ccerror cs             ; Error if carry is set
                              218 ;                       <normal continuation>
                              219 ;
                              220 ;                   This can replace old code of the form:
                              221 ;
                              222 ;                       <some operation which sets/clears a condition code>
                              223 ;                       jcc     _OK
                              224 ;                       error
                              225 ;                   _OK
                              226 ;                       <normal continuation>
                              227 ;
                              228 ;                   Depending on the BETA/RETAIL flags, the first operation can
                              229 ;                   save one or two words of program memory over the second method.
                              230 ;<
                              231 ;///////////////////////////////////////////////////////////////////////////////
                              232 ccerror macro   condition
                              233   if (@DEF('BETA')||@DEF('RETAIL'))
                              234     js\condition $000C
                              235   else
                              236     debug\condition
                              237   endif ; if ( @DEF('BETA')||@DEF('RETAIL') 
                              238     endm
                              240 ;///////////////////////////////////////////////////////////////////////////////
                              241 ;> Name: GetLogicalDriveNumForResourceBin
                              242 ;
                              243 ; Description: Used for our RestoreDriveFromBackup routine.
                              244 ; INPUT: 1 for primary resource.bin
                              245 ;        2 for secondary resource.bin
                              246 ;        3 for master redundant resource.bin that is used to restore 1 and 2 at power up if needed.
                              247 ;
                              248 ; NOTE: If the drive arrays is modified in ddiproject.c then the values below will
                              249 ;       have to change. Inspect that file to verify these values are correct.
                              250 ;
                              251 ;<
                              252 ;///////////////////////////////////////////////////////////////////////////////
                              253 GetLogicalDriveNumForResourceBin macro drive
                              254     if (drive==0)
                              255     fail    "drive=0 invalid value used in GetLogicalDriveNumForresourceBin macro"
                              256     endif
                              258     if (drive>3)
                              259     fail    "drive>3 invalid value used in GetLogicalDriveNumForresourceBin macro"
                              260     endif
                              262     if (@DEF('MMC'))
                              264         if drive==1
                              265              move   #>6,a
                              266         endif
                              267     
                              268         if drive==2
                              269              move   #>7,a
                              270         endif
                              272         if drive==3
                              273              move   #>8,a
                              274         endif
                              275     else
                              277         if drive==1
                              278              move   #>5,a
                              279         endif
                              280     
                              281         if drive==2
                              282              move   #>6,a
                              283         endif
                              285         if drive==3
                              286              move   #>7,a
                              287         endif
                              288     endif
                              289  endm
                              291 ;///////////////////////////////////////////////////////////////////////////////
                              292 ;
                              293 ;>  Name:           SaveRange
                              294 ;
                              295 ;   Type:           Macro
                              296 ;
                              297 ;   Description:    This is a supporting macro for saving memory locations to
                              298 ;                   the settings.dat file at shutdown, for later restoration
                              299 ;                   at system startup.
                              300 ;
                              301 ;   Inputs:         Usage : SaveRange Label,Length
                              302 ;                        
                              303 ;   Outputs:        
                              304 ;                   
                              305 ;   Notes:          This macro automatically determines the memory space of the
                              306 ;                   label specified.  It then constructs a command that is 
                              307 ;                   written to settings.dat by SysSaveSettings, and is
                              308 ;                   understood by the SysLoadSettings function to restore the
                              309 ;                   memory locations.  For the SaveRange macro to be recognized 
                              310 ;                   by the SysSaveSettings function.  The section name where the
                              311 ;                   SaveRange command is used, must be included in the 
                              312 ;                   Settings_Y cluster in the stmp3400.dsc file.  The makefile
                              313 ;                   will then extract these commands as a resource to be used
                              314 ;                   by SysSaveSettings and SysLoadSettings.
                              315 ;
                              316 ;   SeeAlso:        SysLoadSettings, SysSaveSettings, SaveRangeX, 
                              317 ;                   SaveRangeY, SaveRangeP, SaveRangeL
                              318 ;
                              319 ;<
                              320 ;///////////////////////////////////////////////////////////////////////////////
                              321 SaveRange macro Label,Length
                              322     if @MSP(Label)==0  ;None
                              323     fail    "Invalid label used in SaveRange macro"
                              324     dc      Label
                              325     endif ; if @MSP(Label)==0
                              327     if @MSP(Label)==1  ;X
                              328     dc      $800000|Label
                              329     endif ; if @MSP(Label)==1
                              331     if @MSP(Label)==2  ;Y
                              332     dc      $400000|Label
                              333     endif ; if @MSP(Label)==2
                              335     if @MSP(Label)==3  ;L
                              336     dc      $200000|Label
                              337     endif ; if @MSP(Label)==3
                              339     if @MSP(Label)==4  ;P
                              340     dc      $100000|Label
                              341     endif ; if @MSP(Label)==4
                              343     if @MSP(Label)==5  ;E
                              344     fail    "Invalid label used in SaveRange macro"
                              345     dc      Label
                              346     endif ; if @MSP(Label)==5
                              348     dc      Length*3
                              349     endm
                              351 ;///////////////////////////////////////////////////////////////////////////////
                              352 ;
                              353 ;>  Name:           SaveRangeY
                              354 ;
                              355 ;   Type:           Macro
                              356 ;
                              357 ;   Description:    This is a supporting macro for saving memory locations to
                              358 ;                   the settings.dat file at shutdown, for later restoration
                              359 ;                   at system startup.
                              360 ;
                              361 ;   Inputs:         Usage : SaveRangeY Label,Length
                              362 ;                        
                              363 ;   Outputs:        
                              364 ;                   
                              365 ;   Notes:          Refer to the SaveRange macro for more details.  This macro
                              366 ;                   can take a numeric address, or a label, but will only
                              367 ;                   create a save memory command that indicates Y memory
                              368 ;                   to be saved.
                              369 ;
                              370 ;   SeeAlso:        SysLoadSettings, SysSaveSettings, SaveRange, 
                              371 ;                   SaveRangeX, SaveRangeP, SaveRangeL
                              372 ;
                              373 ;<
                              374 ;///////////////////////////////////////////////////////////////////////////////
                              375 SaveRangeY macro Address,Length
                              376     dc      $400000|Address
                              377     dc      Length*3
                              378     endm
                              380 ;///////////////////////////////////////////////////////////////////////////////
                              381 ;
                              382 ;>  Name:           SaveRangeX
                              383 ;
                              384 ;   Type:           Macro
                              385 ;
                              386 ;   Description:    This is a supporting macro for saving memory locations to
                              387 ;                   the settings.dat file at shutdown, for later restoration
                              388 ;                   at system startup.
                              389 ;
                              390 ;   Inputs:         Usage : SaveRangeX Label,Length
                              391 ;                        
                              392 ;   Outputs:        
TASKING DSP2410 assembler v1.5r1 Build 138 SN 00100122
                                                                                                                                                                                                                                                       Page   4

M:ADDR CODE           CYCLES LINE SOURCELINE
                              393 ;                   
                              394 ;   Notes:          Refer to the SaveRange macro for more details.  This macro
                              395 ;                   can take a numeric address, or a label, but will only
                              396 ;                   create a save memory command that indicates X memory
                              397 ;                   to be saved.
                              398 ;
                              399 ;   See Also:       SysLoadSettings, SysSaveSettings, SaveRange, 
                              400 ;                   SaveRangeY, SaveRangeP, SaveRangeL
                              401 ;
                              402 ;<
                              403 ;///////////////////////////////////////////////////////////////////////////////
                              404 SaveRangeX macro Address,Length
                              405     dc      $800000|Address
                              406     dc      Length*3
                              407     endm
                              409 ;///////////////////////////////////////////////////////////////////////////////
                              410 ;
                              411 ;>  Name:           SaveRangeL
                              412 ;
                              413 ;   Type:           Macro
                              414 ;
                              415 ;   Description:    This is a supporting macro for saving memory locations to
                              416 ;                   the settings.dat file at shutdown, for later restoration
                              417 ;                   at system startup.
                              418 ;
                              419 ;   Inputs:         Usage : SaveRangeL Label,Length
                              420 ;                        
                              421 ;   Outputs:        
                              422 ;                   
                              423 ;   Notes:          Refer to the SaveRange macro for more details.  This macro
                              424 ;                   can take a numeric address, or a label, but will only
                              425 ;                   create a save memory command that indicates L memory
                              426 ;                   to be saved.
                              427 ;
                              428 ;   SeeAlso:        SysLoadSettings, SysSaveSettings, SaveRange, 
                              429 ;                   SaveRangeX, SaveRangeY, SaveRangeP
                              430 ;
                              431 ;<
                              432 ;///////////////////////////////////////////////////////////////////////////////
                              433 SaveRangeL macro Address,Length
                              434     dc      $200000|Address
                              435     dc      Length*3
                              436     endm
                              438 ;///////////////////////////////////////////////////////////////////////////////
                              439 ;
                              440 ;>  Name:           SaveRangeP
                              441 ;
                              442 ;   Type:           Macro
                              443 ;
                              444 ;   Description:    This is a supporting macro for saving memory locations to
                              445 ;                   the settings.dat file at shutdown, for later restoration
                              446 ;                   at system startup.
                              447 ;
                              448 ;   Inputs:         Usage : SaveRangeP Label,Length
                              449 ;                        
                              450 ;   Outputs:        
                              451 ;                   
                              452 ;   Notes:          Refer to the SaveRange macro for more details.  This macro
                              453 ;                   can take a numeric address, or a label, but will only
                              454 ;                   create a save memory command that indicates P memory
                              455 ;                   to be saved.
                              456 ;
                              457 ;   SeeAlso:        SysLoadSettings, SysSaveSettings, SaveRange, 
                              458 ;                   SaveRangeX, SaveRangeY, SaveRangeL
                              459 ;
                              460 ;<
                              461 ;///////////////////////////////////////////////////////////////////////////////
                              462 SaveRangeP macro Address,Length
                              463     dc      $100000|Address
                              464     dc      Length*3
                              465     endm
                              468 ;///////////////////////////////////////////////////////////////////////////////
                              469 ;       BUTTON MACROS
                              470 ;///////////////////////////////////////////////////////////////////////////////
                              472 ;///////////////////////////////////////////////////////////////////////////////
                              473 ;
                              474 ;>  Name:           DEFINE_ROW
                              475 ;
                              476 ;   Type:           Macro
                              477 ;
                              478 ;   Description:    This is a supporting macro for defining the GPIO setup for 
                              479 ;                   the scan matrix.
                              480 ;
                              481 ;   Inputs:         Usage : DEFINE_ROW RowNumber,WhichGPIORegister,WhichBit
                              482 ;                        
                              483 ;   Outputs:        Sets up equates required for data structures in button.asm
                              484 ;                   
                              485 ;   Notes:          Must be used in conjuction with DEFINE_COLUMN, DEFINE_SCAN_BUTTON_EVENT,
                              486 ;                   DEFINE_NON_SCAN_BUTTON,DEFINE_NON_SCAN_BUTTON_EVENT, and DEFINE_MAPPED_EVENT to
                              487 ;                   completely define the players button scan matrix, non scan buttons, and
                              488 ;                   how these buttons map to events as recieved by the menus.  There must be one of these
                              489 ;                   macro definitions for each row in the scan matrix.
                              490 ;
                              491 ;   SeeAlso:        DEFINE_COLUMN, DEFINE_SCAN_BUTTON_EVENT,DEFINE_NON_SCAN_BUTTON,
                              492 ;                   DEFINE_NON_SCAN_BUTTON_EVENT, and DEFINE_MAPPED_EVENT
                              493 ;
                              494 ;<
                              495 ;///////////////////////////////////////////////////////////////////////////////
                              497 DEFINE_ROW macro RowNumber,WhichGPIO,WhichBit
                              498     BUTTON_GPIO_ENABLE_ROW_\RowNumber:  equ HW_\WhichGPIO\ENR
                              499     BUTTON_GPIO_SENSE_ROW_\RowNumber:   equ HW_\WhichGPIO\DIR
                              500     BUTTON_BITPOS_ROW_\RowNumber:       equ 1<<\WhichBit
                              501     endm
                              503 ;///////////////////////////////////////////////////////////////////////////////
                              504 ;
                              505 ;>  Name:           DEFINE_COLUMN
                              506 ;
                              507 ;   Type:           Macro
                              508 ;
                              509 ;   Description:    This is a supporting macro for defining the GPIO setup for 
                              510 ;                   the scan matrix.
                              511 ;
                              512 ;   Inputs:         Usage : DEFINE_COLUMN ColumnNumber,WhichGPIORegister,WhichBit
                              513 ;                        
                              514 ;   Outputs:        Sets up equates required for data structures in button.asm
                              515 ;                   
                              516 ;   Notes:          Must be used in conjuction with DEFINE_COLUMN, DEFINE_SCAN_BUTTON_EVENT,
                              517 ;                   DEFINE_NON_SCAN_BUTTON,DEFINE_NON_SCAN_BUTTON_EVENT, and DEFINE_MAPPED_EVENT to
                              518 ;                   completely define the players button scan matrix, non scan buttons, and
                              519 ;                   how these buttons map to events as recieved by the menus.  There must be one
                              520 ;                   of these macro definitions for each column in the scan matrix.
                              521 ;
                              522 ;   SeeAlso:        DEFINE_COLUMN, DEFINE_SCAN_BUTTON_EVENT,DEFINE_NON_SCAN_BUTTON,
                              523 ;                   DEFINE_NON_SCAN_BUTTON_EVENT, and DEFINE_MAPPED_EVENT
                              524 ;
                              525 ;<
                              526 ;///////////////////////////////////////////////////////////////////////////////
                              527 DEFINE_COLUMN macro ColumnNumber,WhichGPIO,WhichBit
                              528     BUTTON_GPIO_ENABLE_COLUMN_\ColumnNumber:        equ HW_\WhichGPIO\ENR
                              529     BUTTON_GPIO_DATA_OUT_COLUMN_\ColumnNumber:      equ HW_\WhichGPIO\DOR
                              530     BUTTON_GPIO_OUTPUT_ENABLE_COLUMN_\ColumnNumber: equ HW_\WhichGPIO\DOER
                              531     BUTTON_BITPOS_COLUMN_\ColumnNumber:             equ 1<<\WhichBit
                              532     endm
                              534 ;///////////////////////////////////////////////////////////////////////////////
                              535 ;
                              536 ;>  Name:           DEFINE_SCAN_BUTTON_EVENT
                              537 ;
                              538 ;   Type:           Macro
                              539 ;
                              540 ;   Description:    This is a supporting macro for defining the mapping between a scan
                              541 ;                   matrix location and a button event.
                              542 ;
                              543 ;   Inputs:         Usage : DEFINE_SCAN_BUTTON_EVENT Column,Row,EventNumber,ButtonName.  
                              544 ;                       Column is in the format COL0,COL1,COL2, etc.  
                              545 ;                       Row is in the format ROW0,ROW1,etc. 
                              546 ;                       The EventNumber is an integer with a single bit set that is unique to all button events
                              547 ;                       ButtonName is a label by which this button event can be referenced in the event mapping.
                              548 ;                        
                              549 ;   Outputs:        Sets up equates required for data structures in button.asm
                              550 ;                   
                              551 ;   Notes:          Must be used in conjuction with DEFINE_COLUMN, DEFINE_SCAN_BUTTON_EVENT,
                              552 ;                   DEFINE_NON_SCAN_BUTTON,DEFINE_NON_SCAN_BUTTON_EVENT, and DEFINE_MAPPED_EVENT to
                              553 ;                   completely define the players button scan matrix, non scan buttons, and
                              554 ;                   how these buttons map to events as recieved by the menus. This macro sets up buttons for each
                              555 ;                   spot in the button scan matrix.  Each place in the matrix must be defined, even if no
                              556 ;                   physical button exists in it.  Use $000000 for placeholders.
                              557 ;
                              558 ;   SeeAlso:        DEFINE_COLUMN, DEFINE_SCAN_BUTTON_EVENT,DEFINE_NON_SCAN_BUTTON,
                              559 ;                   DEFINE_NON_SCAN_BUTTON_EVENT, and DEFINE_MAPPED_EVENT
                              560 ;
                              561 ;<
                              562 ;///////////////////////////////////////////////////////////////////////////////
                              563 DEFINE_SCAN_BUTTON_EVENT macro Column,Row,EventNumber,ButtonName
                              564     BUTTON_EVENT_\Column\Row:  equ \EventNumber
                              565     ButtonName: equ \EventNumber
                              566     endm 
                              568 ;///////////////////////////////////////////////////////////////////////////////
                              569 ;
                              570 ;>  Name:           DEFINE_NON_SCAN_BUTTON
                              571 ;
                              572 ;   Type:           Macro
                              573 ;
                              574 ;   Description:    This is a supporting macro for defining a non scan button.
                              575 ;
                              576 ;   Inputs:         Usage : DEFINE_NON_SCAN_BUTTON NSNumber,WhichGPIO,WhichBit.  
                              577 ;                       NSNumber is a unique number (starting at 0) and counting up to BUTTON_NON_SCAN_BUTTONS-1
                              578 ;                       WhichGPIO is the GPIO register used
                              579 ;                       WhichBit is the bit in this register.
                              580 ;                        
                              581 ;   Outputs:        Sets up equates required for data structures in button.asm
                              582 ;                   
                              583 ;   Notes:          Must be used in conjuction with DEFINE_COLUMN, DEFINE_SCAN_BUTTON_EVENT,
                              584 ;                   DEFINE_NON_SCAN_BUTTON,DEFINE_NON_SCAN_BUTTON_EVENT, and DEFINE_MAPPED_EVENT to
                              585 ;                   completely define the players button scan matrix, non scan buttons, and
                              586 ;                   how these buttons map to events as recieved by the menus. This macro sets up non scan
                              587 ;                   buttons.  Use DEFINE_NON_SCAN_BUTTON_EVENT to define the event generated by this non scan
                              588 ;                   button.
                              589 ;
                              590 ;   SeeAlso:        DEFINE_COLUMN, DEFINE_SCAN_BUTTON_EVENT,DEFINE_NON_SCAN_BUTTON,
                              591 ;                   DEFINE_NON_SCAN_BUTTON_EVENT, and DEFINE_MAPPED_EVENT
                              592 ;
                              593 ;<
                              594 ;///////////////////////////////////////////////////////////////////////////////
                              595 DEFINE_NON_SCAN_BUTTON macro NSNumber,WhichGPIO,WhichBit
                              596     BUTTON_GPIO_ENABLE_NON_SCAN_\NSNumber:  equ HW_\WhichGPIO\ENR
                              597     BUTTON_GPIO_SENSE_NON_SCAN_\NSNumber:   equ HW_\WhichGPIO\DIR
                              598     BUTTON_BITPOS_NON_SCAN_\NSNumber:       equ 1<<\WhichBit
                              599     BUTTON_REAL_BITPOS_NON_SCAN_\NSNumber:  equ \WhichBit
                              600     endm
                              602 ;///////////////////////////////////////////////////////////////////////////////
                              603 ;
                              604 ;>  Name:           DEFINE_NON_SCAN_BUTTON_EVENT
                              605 ;
                              606 ;   Type:           Macro
                              607 ;
                              608 ;   Description:    This is a supporting macro for defining a non scan button.
                              609 ;
                              610 ;   Inputs:         Usage : DEFINE_NON_SCAN_BUTTON_EVENT Number,EventNumber,ButtonName  
                              611 ;                       Number is a unique number (starting at 0) and counting up to BUTTON_NON_SCAN_BUTTONS-1
                              612 ;                       EventNumber is an integer with 1 bit set that is unique to all other buttons
                              613 ;                       ButtonName is a label later referenced in the event mapping
                              614 ;                        
                              615 ;   Outputs:        Sets up equates required for data structures in button.asm
                              616 ;                   
                              617 ;   Notes:          Must be used in conjuction with DEFINE_COLUMN, DEFINE_SCAN_BUTTON_EVENT,
                              618 ;                   DEFINE_NON_SCAN_BUTTON,DEFINE_NON_SCAN_BUTTON_EVENT, and DEFINE_MAPPED_EVENT to
                              619 ;                   completely define the players button scan matrix, non scan buttons, and
                              620 ;                   how these buttons map to events as recieved by the menus. This macro sets up non scan
                              621 ;                   buttons.  
                              622 ;
                              623 ;   SeeAlso:        DEFINE_COLUMN, DEFINE_SCAN_BUTTON_EVENT,DEFINE_NON_SCAN_BUTTON,
                              624 ;                   DEFINE_NON_SCAN_BUTTON_EVENT, and DEFINE_MAPPED_EVENT
                              625 ;
                              626 ;<
                              627 ;///////////////////////////////////////////////////////////////////////////////
                              628 DEFINE_NON_SCAN_BUTTON_EVENT macro Number,EventNumber,ButtonName
                              629     BUTTON_EVENT_NONSCAN\Number:  equ \EventNumber
                              630     ButtonName: equ \EventNumber
                              631     endm 
                              635 ;///////////////////////////////////////////////////////////////////////////////
                              636 ;> Name: DEFINE_LRADC_BUTTON
                              637 ;
                              638 ;  Type: Macro
                              639 ;
                              640 ;  Description: This is a supporting macro for defining an Low Resolution ADC (LRADC)-based button
                              641 ;
                              642 ;  Inputs:      Usage : DEFINE_LRADC_BUTTON LBNumber,UpperLimitVoltage
                              643 ;
                              644 ;  Outputs:     Sets up equates required for data structures in button.asm
                              645 ;
                              646 ;  Notes:       Must be used in conjuction with DEFINE_LRADC_BUTTON_EVENT, and DEFINE_MAPPED_EVENT to
                              647 ;                   completely define the player's LRADC buttons and how these buttons map to 
                              648 ;                   events as recieved by the menus. This macro sets up LRADC buttons.  Use 
                              649 ;                   DEFINE_LRADC_BUTTON_EVENT to define the event generated by this LRADC button.
                              650 ;
                              651 ;   SeeAlso:        DEFINE_LRADC_BUTTON_EVENT, DEFINE_COLUMN, DEFINE_SCAN_BUTTON_EVENT,
                              652 ;                   DEFINE_NON_SCAN_BUTTON, DEFINE_NON_SCAN_BUTTON_EVENT, and DEFINE_MAPPED_EVENT
                              653 ;<
                              654 ;///////////////////////////////////////////////////////////////////////////////
                              655 DEFINE_LRADC_BUTTON     macro   num,level
                              656     BUTTON_LRADC_LEVEL_\num:    equ level
TASKING DSP2410 assembler v1.5r1 Build 138 SN 00100122
                                                                                                                                                                                                                                                       Page   5

M:ADDR CODE           CYCLES LINE SOURCELINE
                              657     endm
                              661 ;///////////////////////////////////////////////////////////////////////////////
                              662 ;> Name: DEFINE_LRADC_BUTTON_EVENT
                              663 ;
                              664 ;  Type: Macro
                              665 ;
                              666 ;  Description:     This is a supporting macro for defining a Low Resolution ADC (LRADC)-based button.
                              667 ;
                              668 ;  Inputs:          Usage : DEFINE_LRADC_BUTTON_EVENT Number,EventNumber,ButtonName  
                              669 ;                       Number is a unique number (starting at 0) and counting up to BUTTON_LRADC_BUTTONS-1
                              670 ;                       EventNumber is an integer with 1 bit set that is unique to all other buttons
                              671 ;                       ButtonName is a label later referenced in the event mapping
                              672  
                              673 ;
                              674 ;  Outputs:         Sets up equates required for data structures in button.asm
                              675 ;
                              676 ;  Notes:           Must be used in conjuction with DEFINE_LRADC_BUTTON, and DEFINE_MAPPED_EVENT to
                              677 ;                   completely define the player's LRADC buttons and how these buttons map to events 
                              678 ;                   as recieved by the menus. This macro sets up LRADC buttons.
                              679 ;
                              680 ;
                              681 ;   SeeAlso:        DEFINE_LRADC_BUTTON, DEFINE_COLUMN, DEFINE_SCAN_BUTTON_EVENT,DEFINE_NON_SCAN_BUTTON,
                              682 ;                   DEFINE_NON_SCAN_BUTTON_EVENT, and DEFINE_MAPPED_EVENT
                              683 ;<
                              684 ;///////////////////////////////////////////////////////////////////////////////
                              685 DEFINE_LRADC_BUTTON_EVENT      macro   num,EventNumber,ButtonName
                              686     BUTTON_EVENT_LRADC_BUTTON\num: equ \EventNumber
                              687     ButtonName:     equ     \EventNumber   
                              688     endm
                              689   
                              692 ;///////////////////////////////////////////////////////////////////////////////
                              693 ;
                              694 ;>  Name:           DEFINE_MAPPED_EVENT
                              695 ;
                              696 ;   Type:           Macro
                              697 ;
                              698 ;   Description:    This is a supporting macro for defining button events.
                              699 ;
                              700 ;   Inputs:         Usage : DEFINE_MAPPED_EVENT Number,Action,ButtonNames 
                              701 ;                       Number is a unique number (starting at 0) and counting up to BUTTON_MAPPED_EVENTS-1
                              702 ;                       Action is either PRESS_RELEASE or PRESS_HOLD
                              703 ;                       ButtonNames is a collection of labels defined for scan or non scan buttons that relate
                              704 ;                           to this button event.
                              705 ;                        
                              706 ;   Outputs:        Sets up equates required for data structures in button.asm
                              707 ;                   
                              708 ;   Notes:          Must be used in conjuction with DEFINE_COLUMN, DEFINE_SCAN_BUTTON_EVENT,
                              709 ;                   DEFINE_NON_SCAN_BUTTON,DEFINE_NON_SCAN_BUTTON_EVENT, and DEFINE_MAPPED_EVENT to
                              710 ;                   completely define the players button scan matrix, non scan buttons, and
                              711 ;                   how these buttons map to events as recieved by the menus. This macro sets up the mapping
                              712 ;                   between scan and non scan buttons, and the eventual event number that is sent to the menus.
                              713 ;
                              714 ;   SeeAlso:        DEFINE_COLUMN, DEFINE_SCAN_BUTTON_EVENT,DEFINE_NON_SCAN_BUTTON,
                              715 ;                   DEFINE_NON_SCAN_BUTTON_EVENT, and DEFINE_MAPPED_EVENT
                              716 ;
                              717 ;<
                              718 ;///////////////////////////////////////////////////////////////////////////////
                              719 DEFINE_MAPPED_EVENT macro Number,Action,ButtonNames
                              720     
                              721   IF (@SCP("Action","PRESS_RELEASE"))
                              722     BUTTON_EVENT_\Number:  equ ButtonNames
                              723   else 
                              724     if (@SCP("Action","PRESS_HOLD"))
                              725         BUTTON_EVENT_\Number:  equ $800000|ButtonNames
                              726     else
                              727         ERROR "Unknown Action for DEFINE_MAPPED_EVENT" 
                              728     endif
                              729   endif 
                              730     endm
                              733 ;///////////////////////////////////////////////////////////////////////////////
                              734 ;
                              735 ;>  Name:           DEFINE_2BUTTON_MAPPED_EVENT
                              736 ;
                              737 ;   Type:           Macro
                              738 ;
                              739 ;   Description:    This is a supporting macro for defining button events.
                              740 ;
                              741 ;   Inputs:         Usage : DEFINE_2BUTTON_MAPPED_EVENT Number,Action,Event1,Event2 
                              742 ;                       Number is a unique number (starting at 0) and counting up to BUTTON_MAPPED_EVENTS-1
                              743 ;                       Action is either PRESS_RELEASE or PRESS_HOLD
                              744 ;                       Event1 is 1 of 2 previously defined button events
                              745 ;                       Event2 is 2 of 2 previously defined button events
                              746 ;                        
                              747 ;   Outputs:        Sets up equates required for data structures in button.asm
                              748 ;                   
                              749 ;   Notes:          Must be used in conjuction with DEFINE_COLUMN, DEFINE_SCAN_BUTTON_EVENT,
                              750 ;                   DEFINE_NON_SCAN_BUTTON,DEFINE_NON_SCAN_BUTTON_EVENT, and DEFINE_MAPPED_EVENT to
                              751 ;                   completely define the players button scan matrix, non scan buttons, and
                              752 ;                   how these buttons map to events as recieved by the menus. This macro sets up the mapping
                              753 ;                   between scan and non scan buttons, and the eventual event number that is sent to the menus.
                              754 ;
                              755 ;   SeeAlso:        DEFINE_COLUMN, DEFINE_SCAN_BUTTON_EVENT,DEFINE_NON_SCAN_BUTTON,
                              756 ;                   DEFINE_NON_SCAN_BUTTON_EVENT, and DEFINE_MAPPED_EVENT
                              757 ;
                              758 ;<
                              759 ;///////////////////////////////////////////////////////////////////////////////
                              760 DEFINE_2BUTTON_MAPPED_EVENT macro Number,Action,Event1,Event2
                              761     
                              762   IF (@SCP("Action","PRESS_RELEASE"))
                              763     BUTTON_EVENT_\Number:  equ BUTTON_EVENT_\Event1|BUTTON_EVENT_\Event2
                              764   else 
                              765     if (@SCP("Action","PRESS_HOLD"))
                              766         BUTTON_EVENT_\Number:  equ BUTTON_EVENT_\Event1|BUTTON_EVENT_\Event2|$800000
                              767     else
                              768         ERROR "Unknown Action for DEFINE_MAPPED_EVENT" 
                              769     endif
                              770   endif 
                              771   endm
                              773 ;///////////////////////////////////////////////////////////////////////////////
                              774 ;
                              775 ;>  Name:           StackCheckIn
                              776 ;
                              777 ;   Type:           Macro
                              778 ;
                              779 ;   Description:    Records the current stack pointer on the stack
                              780 ;
                              781 ;   Inputs:         none
                              782 ;                        
                              783 ;   Outputs:        places the current PC and the current software stack pointer on the stack
                              784 ;   
                              785 ;   Notes:          This does not modify any registers (except r7)                
                              786 ;
                              787 ;   SeeAlso:        FStackCheckIn
                              788 ;
                              789 ;<
                              790 ;///////////////////////////////////////////////////////////////////////////////
                              791 StackCheckIn macro
                              792   if (@DEF('DEBUG'))
                              793     extern FStackCheckIn
                              794     jsr FStackCheckIn
                              795   endif
                              796   endm
                              798 ;///////////////////////////////////////////////////////////////////////////////
                              799 ;
                              800 ;>  Name:           StackCheckOut
                              801 ;
                              802 ;   Type:           Macro
                              803 ;
                              804 ;   Description:    Verifies that the stack is still balanced
                              805 ;
                              806 ;   Inputs:         none
                              807 ;                        
                              808 ;   Outputs:        none (though hits a debug if the stack is unbalanced)
                              809 ;   
                              810 ;   Notes:          This does not modify any registers (except r7) 
                              811 ;
                              812 ;   SeeAlso:        FStackCheckOut
                              813 ;
                              814 ;<
                              815 ;///////////////////////////////////////////////////////////////////////////////
                              816 StackCheckOut macro
                              817   if (@DEF('DEBUG'))
                              818     extern FStackCheckOut
                              819     jsr FStackCheckOut
                              820   endif 
                              821   endm
                              824 ;///////////////////////////////////////////////////////////////////////////////
                              825 ;
                              826 ;>  Name:           InstrumentPushContext 
                              827 ;
                              828 ;   Type:           Macro
                              829 ;
                              830 ;   Description:    calls the instrument functions specified.
                              831 ;
                              832 ;   Inputs:         new context
                              833 ;                   new value
                              834 ;                        
                              835 ;   Outputs:        
                              836 ;   
                              837 ;   Notes:          This does not modify any registers  
                              838 ;
                              839 ;   SeeAlso:        
                              840 ;
                              841 ;<
                              842 ;///////////////////////////////////////////////////////////////////////////////
                              843 InstrumentPushContext macro context,value
                              844   if (@DEF('USE_INSTRUMENTATION'))
                              845     extern FInstrumentPushContext
                              846     extern PushAandB
                              847     extern PopAandB
                              848     jsr PushAandB
                              849     move    #>context,a
                              850     move    #>value,b
                              851     jsr FInstrumentPushContext
                              852     jsr PopAandB
                              853   endif 
                              854   endm
                              856 ;///////////////////////////////////////////////////////////////////////////////
                              857 ;
                              858 ;>  Name:           InstrumentPopContext 
                              859 ;
                              860 ;   Type:           Macro
                              861 ;
                              862 ;   Description:    calls the instrument functions specified.
                              863 ;
                              864 ;   Inputs:         none
                              865 ;                        
                              866 ;   Outputs:        none
                              867 ;   
                              868 ;   Notes:          This does not modify any registers  
                              869 ;
                              870 ;   SeeAlso:        
                              871 ;
                              872 ;<
                              873 ;///////////////////////////////////////////////////////////////////////////////
                              874 InstrumentPopContext macro 
                              875   if (@DEF('USE_INSTRUMENTATION'))
                              876     extern FInstrumentPopContext
                              877     jsr FInstrumentPopContext
                              878   endif 
                              879   endm
                              881 ;///////////////////////////////////////////////////////////////////////////////
                              882 ;
                              883 ;>  Name:           InstrumentSetValue 
                              884 ;
                              885 ;   Type:           Macro
                              886 ;
                              887 ;   Description:    calls the instrument functions specified.
                              888 ;
                              889 ;   Inputs:         Value
                              890 ;                        
                              891 ;   Outputs:        none
                              892 ;   
                              893 ;   Notes:          This does not modify any registers  
                              894 ;
                              895 ;   SeeAlso:        
                              896 ;
                              897 ;<
                              898 ;///////////////////////////////////////////////////////////////////////////////
                              899 InstrumentSetValue macro value
                              900   if (@DEF('USE_INSTRUMENTATION'))
                              901     extern FInstrumentSetValue
                              902     jsr PushA
                              903     move #>value,a
                              904     jsr FInstrumentSetValue
                              905     jsr PopA
                              906   endif 
                              907   endm
                              910 ;///////////////////////////////////////////////////////////////////////////////
                              911 ;
                              912 ;>  Name:           InstrumentSetEvent 
                              913 ;
                              914 ;   Type:           Macro
                              915 ;
                              916 ;   Description:    calls the instrument functions specified.
                              917 ;
                              918 ;   Inputs:         Value
                              919 ;                        
                              920 ;   Outputs:        none
                              921 ;   
                              922 ;   Notes:          This does not modify any registers  
TASKING DSP2410 assembler v1.5r1 Build 138 SN 00100122
                                                                                                                                                                                                                                                       Page   6

M:ADDR CODE           CYCLES LINE SOURCELINE
                              923 ;
                              924 ;   SeeAlso:        
                              925 ;
                              926 ;<
                              927 ;///////////////////////////////////////////////////////////////////////////////
                              928 InstrumentSetEvent macro event
                              929   if (@DEF('USE_INSTRUMENTATION'))
                              930     extern FInstrumentSetEvent
                              931     jsr PushA
                              932     move #>event,a
                              933     jsr FInstrumentSetEvent
                              934     jsr PopA
                              935   endif 
                              936   endm
                              938 ;///////////////////////////////////////////////////////////////////////////////
                              939 ;
                              940 ;>  Name:           InstrumentClearEvent 
                              941 ;
                              942 ;   Type:           Macro
                              943 ;
                              944 ;   Description:    calls the instrument functions specified.
                              945 ;
                              946 ;   Inputs:         event
                              947 ;                        
                              948 ;   Outputs:        none
                              949 ;   
                              950 ;   Notes:          This does not modify any registers  
                              951 ;
                              952 ;   SeeAlso:        
                              953 ;
                              954 ;<
                              955 ;///////////////////////////////////////////////////////////////////////////////
                              956 InstrumentClearEvent macro event
                              957   if (@DEF('USE_INSTRUMENTATION'))
                              958     extern FInstrumentClearEvent
                              959     jsr PushA
                              960     move #>event,a
                              961     jsr FInstrumentClearEvent
                              962     jsr PopA
                              963   endif 
                              964   endm
                              966 ;///////////////////////////////////////////////////////////////////////////////
                              967 ;
                              968 ;>  Name:           InstrumentToggleEvent 
                              969 ;
                              970 ;   Type:           Macro
                              971 ;
                              972 ;   Description:    calls the instrument functions specified.
                              973 ;
                              974 ;   Inputs:         event
                              975 ;                        
                              976 ;   Outputs:        none
                              977 ;   
                              978 ;   Notes:          This does not modify any registers  
                              979 ;
                              980 ;   SeeAlso:        
                              981 ;
                              982 ;<
                              983 ;///////////////////////////////////////////////////////////////////////////////
                              984 InstrumentToggleEvent macro event
                              985   if (@DEF('USE_INSTRUMENTATION'))
                              986     extern FInstrumentToggleEvent
                              987     jsr PushA
                              988     move #>event,a
                              989     jsr FInstrumentToggleEvent
                              990     jsr PopA
                              991   endif 
                              992   endm
                                5     include "const.xref"
                                1 ;******************************************************************************
                                2 ; Copyright(C) SigmaTel, Inc. 2000
                                3 ;
                                4 ; ST Mp3 const.EXTERN 
                                5 ;******************************************************************************
                                7    DEFINE   const_xref  '1'
                               42     ; Parthus compatability
                                8 ;Functions
                               13 ;Variables in Y
P:0000                         25     org p,"MenuManager_p":
                               27 ReturnFromWait
                               28     ;A1 is the event trigger mask
                               29     ;R0 points to the message queue descriptor
P:0000 4CF000 rrrrrr  3    3   30     move y:MenuEventWaitMask,x0               ;put our wait mask 
                               31     ;and it with the trigger mask 
                               32     ; (this will prevent message signals when we're not waiting on messages)
P:0002 200046         2    5   33     and  x0,a1                                  
P:0003 0ACC01 rrrrrr  6   11   34     jclr #>EVENT_MESSAGE_BITPOS,a1,_EVENT_BUTTON
                               35 ;    move #MenuQueueDescriptor,r0 ; Not needed, as the queue descriptor is passed in
P:0005 6CF000 rrrrrr  3   14   36     move y:MenuWaitingMsg,r4      ; Get the pointer to the message destination
P:0007 0BF080 rrrrrr  6   20   37     jsr GetMessage                            ;get the message
P:0009 56F400 000002  3   23   38     move #>EVENT_MESSAGE,a                    ;set the flag
P:000B 0AF080 rrrrrr  6   29   39     jmp _end                                  ;
                               40 _EVENT_BUTTON
P:000D 0ACC03 rrrrrr  6   35   41     jclr #EVENT_BUTTON_BITPOS,a1,_EVENT_TIMER ;if no button even, go check timer
P:000F 0BF080 rrrrrr  6   41   42     jsr SysGetButton                          ;get the button
P:0011 058060r        2   43   43     movec y:<Const_ffffff,m0                   ;because some @#$^!% doesn't 
                               44     ;get the pointer to the waiting message (its where we put the button event)
P:0012 69F000 rrrrrr  3   46   45     move y:MenuWaitingMsg,r1 
P:0014 222F00         2   48   46     move r1,b                           ;see if the pointer to the msg is NULL
P:0015 56F40B 000008  3   51   47     tst b #>EVENT_BUTTON,a              ;set the return value to be EVENT_BUTTON
P:0017 0AF0AA rrrrrr  6   57   48     jeq _error                          ;null pointer passed in for MSG
P:0019 4C6100         2   59   49     move x0,y:(r1)                      ;copy the button event into the message
P:001A 0AF080 rrrrrr  6   65   50     jmp _end                            ;go to the end.
                               51 _EVENT_TIMER
P:001C 56F400 000004  3   68   52     move #>EVENT_TIMER,a 
                               53 _end
                               54     pop SSH
P:001E 05FF7C         4   72   54     movec   y:-(r7),SSH
P:001F 000000         2   74   55     nop
P:0020 00000C         4   78   56     rts
                               57 _error
                               58     error
P:0021 000200         4   82   58     debug
                               61 SysGetLastTime
                               62 ;Returns last timeout value in a
P:0022 5EF000 rrrrrr  3   85   63     move y:MenuIntervalHigh,a
P:0024 58F000 rrrrrr  3   88   64     move y:MenuIntervalLow,a0
P:0026 00000C         4   92   65     rts
                               67 SysSetTimer
                               68 ;sets the timer of the menu module to the value in A
P:0027 5C7000 rrrrrr  3   95   69     move a1,y:MenuTimerHigh
P:0029 587000 rrrrrr  3   98   70     move a0,y:MenuTimerLow
P:002B 00000C         4  102   71     rts 
                               73 SysWaitOnEvent
                               74     ; When called from 'C':  
                               75     ; A1 is the mask, r0 is the pointer to the MSG, and B1 is the timer.
P:002C 0ACC42         4  106   76     bclr #EVENT_TIMER_BITPOS,a1   ; lets assume no timer
P:002D 218E00         2  108   77     move    a1,a
P:002E 200003         2  110   78     tst     a
P:002F 0AF0AA rrrrrr  6  116   79     jeq     _NoRepeat             ;no events listed, so don't repeat immediately
                               80     ; We are asking for either a button or a message, so lets repeat the module
P:0031 0ACC65         4  120   81     bset    #EVENT_REPEAT_BITPOS,a1  
                               82 _NoRepeat
P:0032 4E8000r        2  122   83     move y:<Const_ffffff,y0             ;move -1 into Y0
P:0033 68705D rrrrrr  3  125   84     cmp y0,b r0,y:MenuWaitingMsg    ;save off the pointer to the msg
P:0035 0AF0AA rrrrrr  6  131   85     jeq _NO_EVENT_TIMER         ;if the timer is set to -1, don't set the timer!
P:0037 21AF00         2  133   86     move b1,b
P:0038 20000B         2  135   87     tst b
P:0039 0AF0A2 rrrrrr  6  141   88     jne _TIMER_NOT_ZERO
                               89     ; Makes sure that we get called back immediately if somebody enters '0' wait
P:003B 0ACC60         4  145   90     bset #EVENT_NONE_BITPOS,a1      
P:003C 0AF080 rrrrrr  6  151   91     jmp _NO_EVENT_TIMER
                               92 _TIMER_NOT_ZERO
                               93     push a1                         ;save a1 since its our mask we're working with
P:003E 5C5F00         2  153   93     move    a1,y:(r7)+
                               94     push b1                         ;saves off the timer increment
P:003F 5D5F00         2  155   94     move    b1,y:(r7)+
P:0040 0BF080 rrrrrr  6  161   95     jsr SysGetCurrentTime           ;returns time in A
P:0042 20001B         2  163   96     clr b                                               ;clears B
                               97     ; put the timeout/interval into B0 for easy addition (was passed in B1)
                               98     pop b0                          
P:0043 59FF00         4  167   98     move    y:-(r7),b0
                               99     ; Add the timeout/interval to the time value in A 
                              100     ; (gotten from SysGetLastTime or SysGetTime)
P:0044 200010         2  169  101     add b,a                         
P:0045 0BF080 rrrrrr  6  175  102     jsr SysSetTimer ;Sets the Menu Module's timer value to the one calculated above.
P:0047 200013         2  177  103     clr  a
                              104     pop a1                          ;pops out the event mask passed in A1
P:0048 5CFF00         4  181  104     move    y:-(r7),a1
P:0049 0ACC62         4  185  105     bset #EVENT_TIMER_BITPOS,a1     ;set the event mask
                              106 _NO_EVENT_TIMER
                              107     push SSH                        ;push who called us on the stack
P:004A 055F7C         2  187  107     movec   SSH,y:(r7)+
P:004B 60F400 rrrrrr  3  190  108     move #ReturnFromWait,r0         ;push the ReturnFromWait on the stack
                              109     push r0                         ;
P:004D 685F00         2  192  109     move    r0,y:(r7)+
P:004E 0AF080 rrrrrr  6  198  110     jmp ContextSwitch               ;switch to the kernel
                              112     endsec 
