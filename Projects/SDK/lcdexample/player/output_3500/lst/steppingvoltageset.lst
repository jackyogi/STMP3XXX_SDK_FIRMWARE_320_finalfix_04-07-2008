TASKING DSP2410 assembler v1.5r1 Build 138 SN 00100122
                                                                                                                                                                                                                                                       Page   1
C:\STMP3XXX_SDK_FIRMWARE_320_finalfix\Projects\SDK\lcdexample\player\make\ccfc8c4b.src
M:ADDR CODE           CYCLES LINE SOURCELINE
                                1 ; TASKING DSP2410 C compiler v1.5r1 Build 208 SN 00100122
                                2 ; options: -OG -si -DPLAYER -DALL -DD3500 -DMMC -DLIION -DPL3_FB
                                3 ;          -DSTMP_BUILD_PLAYER -DPLAYER_BUILD -DPLAYER -DSTFM1000_LCD
                                4 ;          -DFULL_PLAYER_KERNEL -DDCDC_POWER_TRANSFER -DBACKLIGHT
                                5 ;          -DWMAAPI_NO_DRM -DREVB_ENGR_BD -DSED15XX_LCD -DSYNC_LYRICS
                                6 ;          -DTUNER_STFM1000 -DFM_EUROPE_REGION -DSD_USE_100KHZ_TUNING_GRID
                                7 ;          -DNEWSHINGYIH -DREAL_I2S_DATA -DFUNCLET
                                8 ;          -DMEDIA_DDI_COUNT_HIDDEN_SYSTEM_BLOCKS -DFMTUNER -DMP3_ENCODE
                                9 ;          -DCHKDSK -DFAT16 -DDEBUG -DDEVICE_3500 -DSDK2400 -DENGR_BD
                               10 ;          -DUSE_PLAYLIST3 -DBATTERY_TYPE_LI_ION -DBATTERY_CHARGE -w68 -w66
                               11 ;          -I..\output_3500\include
                               12 ;          -I..\..\..\..\..\Projects\sdk\lcdexample\Player
                               13 ;          -I..\..\..\..\..\Projects\sdk\lcdexample\Player\Menus -I..\..
                               14 ;          -I..\..\..\..\..\inc -I..\..\..\..\..\System\Common
                               15 ;          -I..\..\..\..\..\System\Common\symbols
                               16 ;          -I..\..\..\..\..\Projects\sdk\lcdexample\Player\Display
                               17 ;          -I..\..\..\..\..\Algorithms\DRM\janus\src\h
                               18 ;          -I..\..\..\..\..\FileSystem\Fat32\h
                               19 ;          -I..\..\..\..\..\FileSystem\Fat32\cmp\cmp_stdtype
                               20 ;          -I..\..\..\..\..\FileSystem\Fat32\cmp\cmp_debug
                               21 ;          -I..\..\..\..\..\FileSystem\Fat32\cmp\cmp_file_system
                               22 ;          -I..\..\..\..\..\DeviceDriver\Media\cmp\cmp_media_nand -I -I
                               23 ;          -I..\..\..\..\..\system\common\resourcemanager -I..\..\..\..\..\inc
                               24 ;          -I..\..\..\..\..\devicedriver\media\MediaTypeNAND\include
                               25 ;          -I..\..\..\..\..\devicedriver\media\MediaTypeNAND\DDI\DataDrive\include
                               26 ;          -I..\..\..\..\..\devicedriver\media\MediaTypeNAND\DDI\include
                               27 ;          -I..\..\..\..\..\devicedriver\media\MediaTypeNAND\HAL\include
                               28 ;          -I..\..\..\..\..\devicedriver\media\MediaTypeNAND\DDI\DataDrive
                               29 ;          -I..\..\..\..\..\devicedriver\media\ddildl\include
                               30 ;          -I..\..\..\..\..\FileSystem\Fat32\h
                               31 ;          -I..\..\..\..\..\FileSystem\Fat32\cmp\cmp_stdtype
                               32 ;          -I..\..\..\..\..\FileSystem\Fat32\cmp\cmp_debug
                               33 ;          -I..\..\..\..\..\FileSystem\Fat32\cmp\cmp_file_system
                               34 ;          -I..\..\..\..\..\DeviceDriver\Media\cmp\cmp_media_nand
                               35 ;          -I..\..\..\..\..\devicedriver\media\MediaTypeNAND\include
                               36 ;          -I..\..\..\..\..\devicedriver\media\MediaTypeNAND\DDI\Common\include
                               37 ;          -I..\..\..\..\..\devicedriver\media\MediaTypeNAND\DDI\include
                               38 ;          -I..\..\..\..\..\devicedriver\media\MediaTypeNAND\HAL\include
                               39 ;          -I..\..\..\..\..\devicedriver\media\MediaTypeNAND\DDI\Common
                               40 ;          -I..\..\..\..\..\devicedriver\media\MediaTypeNAND\include
                               41 ;          -I..\..\..\..\..\devicedriver\media\MediaTypeNAND\DDI\SystemDrive\include
                               42 ;          -I..\..\..\..\..\devicedriver\media\MediaTypeNAND\DDI\include
                               43 ;          -I..\..\..\..\..\devicedriver\media\MediaTypeNAND\HAL\include
                               44 ;          -I..\..\..\..\..\devicedriver\media\MediaTypeNAND\DDI\SystemDrive
                               45 ;          -I..\..\..\..\..\devicedriver\media\MediaTypeNAND\include
                               46 ;          -I..\..\..\..\..\devicedriver\media\MediaTypeNAND\DDI\Media\include
                               47 ;          -I..\..\..\..\..\devicedriver\media\MediaTypeNAND\DDI\include
                               48 ;          -I..\..\..\..\..\devicedriver\media\MediaTypeNAND\HAL\include
                               49 ;          -I..\..\..\..\..\devicedriver\media\MediaTypeNAND\DDI\Media
                               50 ;          -I..\..\..\..\..\devicedriver\media\include
                               51 ;          -I..\..\..\..\..\devicedriver\media\ddildl
                               52 ;          -I..\..\..\..\..\devicedriver\media\ddildl\include
                               53 ;          -I..\..\..\..\..\devicedriver\media\MediaTypeNAND\DDI\Common\include
                               54 ;          -I..\..\..\..\..\devicedriver\media\MediaTypeNAND\DDI\include
                               55 ;          -I..\..\..\..\..\DeviceDriver\Media\MediaTypeNAND\HAL
                               56 ;          -I..\..\..\..\..\DeviceDriver\Media\MediaTypeNAND\HAL\include
                               57 ;          -I..\..\..\..\..\DeviceDriver\Media\include
                               58 ;          -I..\..\..\..\..\DeviceDriver\Media\PortHIL\GPFlash\include
                               59 ;          -I..\..\..\..\..\DeviceDriver\Media\PortHIL\GPFlash
                               60 ;          -I..\..\..\..\..\devicedriver\media\ddildl
                               61 ;          -I..\..\..\..\..\devicedriver\media\ddildl\include
                               62 ;          -I..\..\..\..\..\libsource\sysserialnumber
                               63 ;          -I..\..\..\..\..\devicedriver\media\MediaTypeMMC\DDI\include
                               64 ;          -I..\..\..\..\..\devicedriver\media\ddildl\include
                               65 ;          -I..\..\..\..\..\devicedriver\media\MediaTypeMMC\DDI\include
                               66 ;          -I..\..\..\..\..\devicedriver\media\MediaTypeMMC\DDI\Media
                               67 ;          -I..\..\..\..\..\devicedriver\media\MediaTypeMMC\HAL\include
                               68 ;          -I..\..\..\..\..\FileSystem\Fat32\h
                               69 ;          -I..\..\..\..\..\FileSystem\Fat32\cmp\cmp_stdtype
                               70 ;          -I..\..\..\..\..\FileSystem\Fat32\cmp\cmp_debug
                               71 ;          -I..\..\..\..\..\FileSystem\Fat32\cmp\cmp_file_system
                               72 ;          -I..\..\..\..\..\DeviceDriver\Media\cmp\cmp_media_nand
                               73 ;          -I..\..\..\..\..\DeviceDriver\Media\MediaTypeNAND\HAL\include
                               74 ;          -I..\..\..\..\..\System\MsgModules\Software\Effects\srswow
                               75 ;          -I..\..\..\..\..\System\Common\rtcaccess
                               76 ;          -I..\..\..\..\..\System\Common\playlist3
                               77 ;          -I..\..\..\..\..\System\Common\record
                               78 ;          -I..\..\..\..\..\System\Common\mp3filename
                               79 ;          -I..\..\..\..\..\FileSystem\chkdsk\include
                               80 ;          -I..\..\..\..\..\FileSystem\Fat32\h -DFULL_PLAYER_KERNEL
                               81 ;          -DSYNC_LYRICS -DMP3_ENCODE -DBATTERY_TYPE_LI_ION -Dk_opt_single_fat
                               82 ;          -DPL3_FB -g -O2 -R -Cs -DMS_ADPCM -DIMA_ADPCM -DWINDOWS_PCM
                               83 ;          -I..\..\..\..\..\System\MsgModules\Software\musiclib\ghdr
                               84 ;          -I..\..\..\..\..\devicedriver\display
                               85 ;          -I..\..\..\..\..\System\MsgModules\Hardware\Display -MmyL
                               86 
                               94 
                               95 ;steppingvoltage:
                               96 ; 1    |////////////////////////////////////////////////////////////////////////////////
                               97 ; 2    |// Copyright(C) SigmaTel, Inc. 2004
                               98 ; 3    |//
                               99 ; 4    |// Filename:      SteppingVoltageSet.c
                              100 ; 5    |// Description :  Functions to step the voltage up and down. Use only SteppingVoltageSet().
                              101 ; 6    |// History & Notes: Supports 35xx VDDD & VDDIO voltage stepping (VDDIO mode not attempted yet). 
                              102 ; 7    |//                These functions make convergent V steps for either voltage type
                              103 ; 8    |//                in order to have reduced undershoot in the step down case and 
                              104 ; 9    |//                reduced overshoot in the step up case. 
                              105 ; 10   |////////////////////////////////////////////////////////////////////////////////
                              106 ; 11   |
                              107 ; 12   |#include "SteppingVoltageSet.h" // has input parameter macros, error codes, public prototypes. 
                              108 
                              110 
                              111 ; 1    |////////////////////////////////////////////////////////////////////////////////
                              112 ; 2    |// Copyright(C) SigmaTel, Inc. 2004
                              113 ; 3    |//
                              114 ; 4    |// Filename:      SteppingVoltageSet.h
                              115 ; 5    |// Description :  Functions to step the voltage up and down. 
                              116 ; 6    |// History & Notes: Supports STMP35xx VDDD voltage stepping initially. 
                              117 ; 7    |//                Others such as VDDIO stepping can be added to this API which
                              118 ; 8    |//                would make convergent V steps for voltage type specified
                              119 ; 9    |//                in order to have reduced undershoot in the step down case and 
                              120 ; 10   |//                reduced overshoot in the step up case. 
                              121 ; 11   |////////////////////////////////////////////////////////////////////////////////
                              122 ; 12   |
                              123 ; 13   |#include "types.h"
                              124 
                              126 
                              127 ; 1    |////////////////////////////////////////////////////////////////////////////////
                              128 ; 2    |// Copyright(C) SigmaTel, Inc. 2000-2004
                              129 ; 3    |//
                              130 ; 4    |// Filename: types.h
                              131 ; 5    |// Description: Standard data types
                              132 ; 6    |////////////////////////////////////////////////////////////////////////////////
                              133 ; 7    |
                              134 ; 8    |#ifndef _TYPES_H
                              135 ; 9    |#define _TYPES_H
                              136 ; 10   |
                              137 ; 11   |// TODO:  move this outta here!
                              138 ; 12   |#if !defined(NOERROR)
                              139 ; 13   |#define NOERROR 0
                              140 ; 14   |#define SUCCESS 0
                              141 ; 15   |#endif 
                              142 ; 16   |#if !defined(SUCCESS)
                              143 ; 17   |#define SUCCESS  0
                              144 ; 18   |#endif
                              145 ; 19   |#if !defined(ERROR)
                              146 ; 20   |#define ERROR   -1
                              147 ; 21   |#endif
                              148 ; 22   |#if !defined(FALSE)
                              149 ; 23   |#define FALSE 0
                              150 ; 24   |#endif
                              151 ; 25   |#if !defined(TRUE)
                              152 ; 26   |#define TRUE  1
                              153 ; 27   |#endif
                              154 ; 28   |
                              155 ; 29   |#if !defined(NULL)
                              156 ; 30   |#define NULL 0
                              157 ; 31   |#endif
                              158 ; 32   |
                              159 ; 33   |#define MAX_INT     0x7FFFFF
                              160 ; 34   |#define MAX_LONG    0x7FFFFFffffff
                              161 ; 35   |        // max positive unsigned long value: -1 == 0xFFFFFFffffff
                              162 ; 36   |#define MAX_ULONG   (-1) 
                              163 ; 37   |
                              164 ; 38   |#define WORD_SIZE   24              // word size in bits
                              165 ; 39   |#define BYTES_PER_WORD 3            // 8 bit bytes
                              166 ; 40   |
                              167 ; 41   |
                              168 ; 42   |#define BYTE    unsigned char       // btVarName
                              169 ; 43   |#define CHAR    signed char         // cVarName
                              170 ; 44   |#define USHORT  unsigned short      // usVarName
                              171 ; 45   |#define SHORT   unsigned short      // sVarName
                              172 ; 46   |#define WORD    unsigned int        // wVarName
                              173 ; 47   |#define INT     signed int          // iVarName
                              174 ; 48   |#define DWORD   unsigned long       // dwVarName
                              175 ; 49   |#define LONG    signed long         // lVarName
                              176 ; 50   |#define BOOL    unsigned int        // bVarName
                              177 ; 51   |#define FRACT   _fract              // frVarName
                              178 ; 52   |#define LFRACT  long _fract         // lfrVarName
                              179 ; 53   |#define CIRC    _circ               // cp<type prefix>VarName (see below)
                              180 ; 54   |#define FLOAT   float               // fVarName
                              181 ; 55   |#define DBL     double              // dVarName
                              182 ; 56   |#define ENUM    enum                // eVarName
                              183 ; 57   |#define CMX     _complex            // cmxVarName
                              184 ; 58   |typedef WORD UCS3;                   // 
                              185 ; 59   |
                              186 ; 60   |#define UINT16  unsigned short
                              187 ; 61   |#define UINT8   unsigned char   
                              188 ; 62   |#define UINT32  unsigned long
                              189 ; 63   |#define UINT64  unsigned long   // need to figure out how to do 64 bit values.  Or port exisiting code to only use 48 bit
                              190 ; 64   |#define INT64   unsigned long   // need to figure out how to do 64 bit values.  Or port exisiting code to only use 48 bit
                              191 ; 65   |#define WCHAR   UINT16
                              192 ; 66   |
                              193 ; 67   |//UINT128 is 16 bytes or 6 words
                              194 ; 68   |typedef struct UINT128_3500 {   
                              195 ; 69   |    int val[6];     
                              196 ; 70   |} UINT128_3500;
                              197 ; 71   |
                              198 ; 72   |#define UINT128   UINT128_3500
                              199 ; 73   |
                              200 ; 74   |// Little endian word packed byte strings:   
                              201 ; 75   |//      _packed BYTE bTextVarName[]="a string";  bText is a packed byte string prefix
                              202 ; 76   |// Convert to big endian words by reordering bytes from high to low using swizzle.
                              203 ; 77   |// Little endian word packed byte strings:   
                              204 ; 78   |//      _packed BYTE bTextVarName[]="a string";  bText is a packed byte string prefix
                              205 ; 79   |// Convert to big endian words by reordering bytes from high to low using swizzle.
                              206 ; 80   |
                              207 ; 81   |// Declare Memory Spaces To Use When Coding
                              208 ; 82   |// A. Sector Buffers
                              209 ; 83   |#define SECTOR_BUFFER_MEM_X _X
                              210 ; 84   |#define SECTOR_BUFFER_MEM_Y _Y
                              211 ; 85   |#define SECTOR_BUFFER_MEM SECTOR_BUFFER_MEM_X
                              212 ; 86   |typedef WORD SECTOR_BUFFER_MEM SECTOR_BUFFER;
                              213 
                              215 
                              216 ; 87   |typedef SECTOR_BUFFER * P_SECTOR_BUFFER;
                              217 ; 88   |// B. Media DDI Memory
                              218 ; 89   |#define MEDIA_DDI_MEM _Y
                              219 ; 90   |
                              220 ; 91   |
                              221 ; 92   |
                              222 ; 93   |// Pointers to linear structures are labeled as: p<type prefix>VarName
                              223 ; 94   |// Examples of circular pointers:
                              224 ; 95   |//    INT CIRC cpiVarName
                              225 ; 96   |//    DWORD CIRC cpdwVarName
                              226 ; 97   |
                              227 ; 98   |#define RETCODE INT                 // rcVarName
                              228 ; 99   |
                              229 ; 100  |// generic bitfield structure
                              230 ; 101  |struct Bitfield {
                              231 ; 102  |    unsigned int B0  :1;
                              232 ; 103  |    unsigned int B1  :1;
                              233 ; 104  |    unsigned int B2  :1;
                              234 ; 105  |    unsigned int B3  :1;
                              235 ; 106  |    unsigned int B4  :1;
                              236 ; 107  |    unsigned int B5  :1;
                              237 ; 108  |    unsigned int B6  :1;
                              238 ; 109  |    unsigned int B7  :1;
                              239 ; 110  |    unsigned int B8  :1;
                              240 ; 111  |    unsigned int B9  :1;
                              241 ; 112  |    unsigned int B10 :1;
                              242 ; 113  |    unsigned int B11 :1;
                              243 ; 114  |    unsigned int B12 :1;
                              244 ; 115  |    unsigned int B13 :1;
                              245 ; 116  |    unsigned int B14 :1;
                              246 ; 117  |    unsigned int B15 :1;
                              247 ; 118  |    unsigned int B16 :1;
                              248 ; 119  |    unsigned int B17 :1;
                              249 ; 120  |    unsigned int B18 :1;
                              250 ; 121  |    unsigned int B19 :1;
                              251 ; 122  |    unsigned int B20 :1;
                              252 ; 123  |    unsigned int B21 :1;
                              253 ; 124  |    unsigned int B22 :1;
                              254 ; 125  |    unsigned int B23 :1;
                              255 ; 126  |};
                              256 ; 127  |
                              257 ; 128  |union BitInt {
                              258 ; 129  |        struct Bitfield B;
                              259 ; 130  |        int        I;
                              260 ; 131  |};
                              261 ; 132  |
TASKING DSP2410 assembler v1.5r1 Build 138 SN 00100122
                                                                                                                                                                                                                                                       Page   2

M:ADDR CODE           CYCLES LINE SOURCELINE
                              262 ; 133  |#define MAX_MSG_LENGTH 10
                              263 ; 134  |struct CMessage
                              264 ; 135  |{
                              265 ; 136  |        unsigned int m_uLength;
                              266 ; 137  |        unsigned int m_uMsg[MAX_MSG_LENGTH];
                              267 ; 138  |};
                              268 ; 139  |
                              269 ; 140  |typedef struct {
                              270 ; 141  |    WORD m_wLength;
                              271 ; 142  |    WORD m_wMessage;
                              272 ; 143  |    WORD m_wParams[MAX_MSG_LENGTH];
                              273 ; 144  |} Message;
                              274 ; 145  |
                              275 ; 146  |struct MessageQueueDescriptor
                              276 ; 147  |{
                              277 ; 148  |        int *m_pBase;
                              278 ; 149  |        int m_iModulo;
                              279 ; 150  |        int m_iSize;
                              280 ; 151  |        int *m_pHead;
                              281 ; 152  |        int *m_pTail;
                              282 ; 153  |};
                              283 ; 154  |
                              284 ; 155  |struct ModuleEntry
                              285 ; 156  |{
                              286 ; 157  |    int m_iSignaledEventMask;
                              287 ; 158  |    int m_iWaitEventMask;
                              288 ; 159  |    int m_iResourceOfCode;
                              289 ; 160  |    struct MessageQueueDescriptor *m_pMessageQueue;
                              290 ; 161  |    int _asmfunc (*m_pProcessEntryPoint)(union WaitMask Signals,struct MessageQueueDescriptor *);
                              291 ; 162  |    int _asmfunc (*m_pInitFunction)(struct MessageQueueDescriptor *);
                              292 ; 163  |    int m_uTimeOutHigh;
                              293 ; 164  |    int m_uTimeOutLow;
                              294 ; 165  |    int _asmfunc (*m_pBackgroundFunction)(struct MessageQueueDescriptor *);
                              295 ; 166  |};
                              296 ; 167  |
                              297 ; 168  |union WaitMask{
                              298 ; 169  |    struct B{
                              299 ; 170  |        unsigned int m_bNone     :1;
                              300 ; 171  |        unsigned int m_bMessage  :1;
                              301 ; 172  |        unsigned int m_bTimer    :1;
                              302 ; 173  |        unsigned int m_bButton   :1;
                              303 ; 174  |    } B;
                              304 ; 175  |    int I;
                              305 ; 176  |} ;
                              306 ; 177  |
                              307 ; 178  |
                              308 ; 179  |struct Button {
                              309 ; 180  |        WORD wButtonEvent;
                              310 ; 181  |        WORD wUnused[MAX_MSG_LENGTH];   
                              311 ; 182  |};
                              312 ; 183  |
                              313 ; 184  |struct Message {
                              314 ; 185  |        WORD wMsgLength;
                              315 ; 186  |        WORD wMsgCommand;
                              316 ; 187  |        WORD wMsgParms[MAX_MSG_LENGTH-1];
                              317 ; 188  |};
                              318 ; 189  |
                              319 ; 190  |union EventTypes {
                              320 ; 191  |        struct CMessage msg;
                              321 ; 192  |        struct Button Button ;
                              322 ; 193  |        struct Message Message;
                              323 ; 194  |};
                              324 ; 195  |
                              325 ; 196  |// next 2 used to get updater build to return correct protocol ver in scsi response.
                              326 ; 197  |#define BUILD_TYPE_UPDATER  0x100
                              327 ; 198  |#define BUILD_TYPE_HOSTLINK 0x101
                              328 ; 199  |#define BUILD_TYPE_PLAYER   0x102
                              329 ; 200  |
                              330 ; 201  |// Resets part if RETAIL build. DEBUG build executes debug instruction to halt.
                              331 ; 202  |#define SystemHalt() __asm(" include 'sysmacro.asm' \n error") 
                              332 ; 203  |#define assert(x)    if(!(x)) __asm(" include 'sysmacro.asm' \n error")
                              333 ; 204  |
                              334 ; 205  |#if DEBUG
                              335 ; 206  |// For DEBUG builds, DebugBuildAssert(condition) halts if condition evaluates to FALSE. 
                              336 ; 207  |#define DebugBuildAssert(x)    if(!(x)) __asm(" debug ")
                              337 ; 208  |#else 
                              338 ; 209  |// For RETAIL builds, DebugBuildAssert(condition) does nothing & execution continues rather than halt or reset. 
                              339 ; 210  |#define DebugBuildAssert(x)    
                              340 ; 211  |#endif
                              341 ; 212  |
                              342 ; 213  |// Do this in your C files to make a reminder that's displayed during the build.
                              343 ; 214  |//  #pragma asm
                              344 ; 215  |//  WARN 'Note to builder: reminder to do this after verifying that'
                              345 ; 216  |//  #pragma endasm
                              346 ; 217  |
                              347 ; 218  |
                              348 ; 219  |#ifdef COLOR_262K
                              349 ; 220  |#define RGB(r,g,b)    ((0x0000FC & (r)) << 10) | ((0x0000FC & (g)) << 4) | ((0x0000FC & (b)) >> 2)    //262k
                              350 ; 221  |#elif defined(COLOR_65K)
                              351 ; 222  |#define RGB(r,g,b)    ((0x0000F8 & (r)) << 8) | ((0x0000FC & (g)) << 3) | ((0x0000F8 & (b)) >> 3)  //65k
                              352 ; 223  |#else
                              353 ; 224  |#define RGB(r,g,b)       ((0x0000F0 & (r)) << 4) | (0x0000F0 & (g)) | ((0x0000F0 & (b)) >> 4)
                              354 ; 225  |#endif
                              355 ; 226  |    
                              356 ; 227  |#endif // #ifndef _TYPES_H
                              357 
                              359 
                              360 ; 14   |
                              361 ; 15   |// Error codes
                              362 ; 16   |#define ERR_STEPDOWN_NOT_NEEDED         1
                              363 ; 17   |#define ERR_STEPUP_NOT_NEEDED           2
                              364 ; 18   |
                              365 ; 19   |#define ERR_INVALID_VOLTAGE_CODE        3
                              366 ; 20   |#define ERR_INVALID_VOLTAGE_CODE_LOW    4
                              367 ; 21   |#define ERR_INVALID_POLARITY_PARAM      5
                              368 ; 22   |#define ERR_INVALID_VOLTAGE_TYPE        6
                              369 ; 23   |#define ERR_INVALID_STEP_DIRECTION      7
                              370 ; 24   |
                              371 ; 25   |
                              372 ; 26   |// Public Input parameter macros
                              373 ; 27   |#define VOLTAGE_TYPE_VDDD       1
                              374 ; 28   |#define VOLTAGE_TYPE_VDDIO      2
                              375 ; 29   |
                              376 ; 30   |//------------------------------------------------------------------------------
                              377 ; 31   |// Public Function Name: SteppingVoltageSet
                              378 ; 32   |// Description: Performs intermediate V step(s) if needed. Steps iStepSize. 
                              379 ; 33   |//              For VDDD, polls VDD_OK register bit after each intermediate step if used. 
                              380 ; 34   |//              This possible polling adds inline delay that may be on the order 
                              381 ; 35   |//              of 1 ms per intermediate step. 
                              382 ; 36   |// Inputs:  WORD wCurrentVoltageCode, WORD wDesiredVoltageCode, WORD wStepSize, /* 3 parms are V bit codes */
                              383 ; 37   |//          int iVoltageType      /* VOLTAGE_TYPE_VDDD or VOLTAGE_TYPE_VDDIO (vddio untested)   */
                              384 ; 38   |//
                              385 ; 39   |// Returns: RETCODE: passes back the status codes from VoltageStepUp or VoltageStepDown. 
                              386 ; 40   |// Notes:   When called from asm, the registers with these params are: a,b,x0,y0
                              387 ; 41   |//------------------------------------------------------------------------------
                              388 ; 42   |RETCODE SteppingVoltageSet(WORD wCurrentVoltageCode, WORD wDesiredVoltageCode, WORD wStepSize, 
                              389 ; 43   |                               int iVoltageType);
                              390 ; 44   |
                              391 ; 45   |   
                              392 ; 46   |
                              393 ; 47   |
                              394 ; 48   |
                              395 ; 49   |// PRIVATE functions. Call the function above, not these. 
                              396 ; 50   |RETCODE VoltageStepUp(WORD wCurrentVoltageCode, WORD wDesiredVoltageCode, WORD wStepSize,
                              397 ; 51   |                         int iVoltageType);
                              398 ; 52   |RETCODE VoltageStepDown(WORD wCurrentVoltageCode, WORD wDesiredVoltageCode, WORD wStepSize,
                              399 ; 53   |                             int iVoltageType);
                              400 ; 54   |
                              401 ; 55   |void ClearHwDcdcTbrBatteryADJ(void);
                              402 ; 56   |
                              403 ; 57   |void SetDCDCTestBitRegister(void);
                              404 ; 58   |
                              405 ; 59   | 
                              406 ; 60   |
                              407 ; 61   |
                              408 
                              410 
                              411 ; 13   |#include "regsrevision.h"
                              412 
                              414 
                              415 ; 1    |#if !(defined(__HW_REVR))
                              416 ; 2    |#define __HW_REVR 1
                              417 ; 3    |
                              418 ; 4    |
                              419 ; 5    |#define HW_GLUE_BASEADDR 0xFA00
                              420 ; 6    |
                              421 ; 7    |#define HW_REVR_RMN_BITPOS (0)
                              422 ; 8    |#define HW_REVR_DCDCMODE_BITPOS (5)
                              423 ; 9    |#define HW_REVR_RMJ_BITPOS (8)
                              424 ; 10   |
                              425 ; 11   |#define HW_REVR_RMN_WIDTH (5)
                              426 ; 12   |#define HW_REVR_DCDCMODE_WIDTH (3)
                              427 ; 13   |
                              428 ; 14   |#define HW_REVR_DCDCMODE_SETMASK (((1<<HW_REVR_DCDCMODE_WIDTH)-1)<<HW_REVR_DCDCMODE_BITPOS)
                              429 ; 15   |
                              430 ; 16   |#define HW_REVR_DCDCMODE_CLRMASK (~(WORD)HW_REVR_DCDCMODE_SETMASK)
                              431 ; 17   |
                              432 ; 18   |
                              433 ; 19   |/////////////////////////////////////////////////////////////////////////////////
                              434 ; 20   |//  Revision Register (HW_REVR) bitfields and values. (read only)
                              435 ; 21   |//  June15 2004: C struct updated to be correct: 
                              436 ; 22   |//   Added DCDCMODE bitfield. Removed RMP bitfield. Reduced size of RMN bitfield to 5 bits.
                              437 ; 23   |typedef union               
                              438 ; 24   |{
                              439 ; 25   |    struct {
                              440 ; 26   |        unsigned RMN    :5;     //Minor Revision
                              441 ; 27   |        unsigned DCDCMODE : 3;  //DCDC mode field function depends on DCDC mode pin strapping
                              442 ; 28   |           #define DCDCMODE_7_CONVERTER1_2CH_BOOST_CONVERTER2_OFF      7
                              443 ; 29   |           #define DCDCMODE_6_RESERVED                                 6
                              444 ; 30   |           #define DCDCMODE_5_CONVERTER1_3CH_BOOST_CONVERTER2_OFF      5
                              445 ; 31   |           #define DCDCMODE_4_RESERVED                                 4
                              446 ; 32   |           #define DCDCMODE_3_CONVERTER1_1CH_BUCK_CONVERTER2_OFF       3
                              447 ; 33   |           #define DCDCMODE_2_CONVERTER1_OFF_CONVERTER2_OFF            2
                              448 ; 34   |           #define DCDCMODE_1_CONVERTER1_1CH_BUCK_CONVERTER2_1CH_BOOST 1
                              449 ; 35   |           #define DCDCMODE_0_CONVERTER1_1CH_BUCK_CONVERTER2_1CH_BUCK  0
                              450 ; 36   |           #define DCDCMODE_X_BUCK_MASKED_SETMASK 0x4
                              451 ; 37   |        unsigned RMJ    :16;    //Major Revision
                              452 ; 38   |    } B;
                              453 ; 39   |
                              454 ; 40   |    int I;
                              455 ; 41   |
                              456 ; 42   |} revr_type;
                              457 ; 43   |#define HW_REVR (*(volatile revr_type _X*) (HW_GLUE_BASEADDR+2))
                              458 ; 44   |
                              459 ; 45   |#define HW_REVR_DCDCMODE_B0_BITPOS 5
                              460 ; 46   |#define HW_REVR_DCDCMODE_B1_BITPOS 6
                              461 ; 47   |#define HW_REVR_DCDCMODE_B2_BITPOS 7
                              462 ; 48   |
                              463 ; 49   |#define HW_REVR_DCDCMODE_BUCK_MASK_POS HW_REVR_DCDCMODE_B2_BITPOS
                              464 ; 50   |// 3 bit bitfield: (HW_REVR_DCDCMODE_B2_BITPOS|HW_REVR_DCDCMODE_B1_BITPOS|HW_REVR_DCDCMODE_B0_BITPOS)
                              465 ; 51   |#define HW_REVR_DCDC_MODE_SETMASK 0x0000E0
                              466 ; 52   |#define HW_REVR_RMN_SETMASK 0xFF<<HW_REVR_RMN_BITPOS
                              467 ; 53   |#define HW_REVR_RMJ_SETMASK 0xFFFF<<HW_REVR_RMJ_BITPOS
                              468 ; 54   |
                              469 ; 55   |#define HW_REVR_RMN_CLRMASK ~(WORD)HW_REVR_RMN_SETMASK
                              470 ; 56   |#define HW_REVR_RMJ_CLRMASK ~(WORD)HW_REVR_RMJ_SETMASK
                              471 ; 57   |
                              472 ; 58   |#endif //!@def(__HW_REVR)
                              473 ; 59   |
                              474 
                              476 
                              477 ; 14   |#include "regsdcdc.h"
                              478 
                              480 
                              481 ; 1    |#if !(defined(regsdcdcinc))
                              482 ; 2    |
                              483 ; 3    |#define regssysteminc 1
                              484 ; 4    |
                              485 ; 5    |
                              486 ; 6    |
                              487 ; 7    |#include "types.h"
                              488 
                              490 
                              491 ; 1    |////////////////////////////////////////////////////////////////////////////////
                              492 ; 2    |// Copyright(C) SigmaTel, Inc. 2000-2004
                              493 ; 3    |//
                              494 ; 4    |// Filename: types.h
                              495 ; 5    |// Description: Standard data types
                              496 ; 6    |////////////////////////////////////////////////////////////////////////////////
                              497 ; 7    |
                              498 ; 8    |#ifndef _TYPES_H
                              499 ; 9    |#define _TYPES_H
                              500 ; 10   |
                              501 ; 11   |// TODO:  move this outta here!
                              502 ; 12   |#if !defined(NOERROR)
                              503 ; 13   |#define NOERROR 0
                              504 ; 14   |#define SUCCESS 0
                              505 ; 15   |#endif 
                              506 ; 16   |#if !defined(SUCCESS)
                              507 ; 17   |#define SUCCESS  0
                              508 ; 18   |#endif
                              509 ; 19   |#if !defined(ERROR)
                              510 ; 20   |#define ERROR   -1
                              511 ; 21   |#endif
                              512 ; 22   |#if !defined(FALSE)
                              513 ; 23   |#define FALSE 0
                              514 ; 24   |#endif
                              515 ; 25   |#if !defined(TRUE)
                              516 ; 26   |#define TRUE  1
                              517 ; 27   |#endif
                              518 ; 28   |
TASKING DSP2410 assembler v1.5r1 Build 138 SN 00100122
                                                                                                                                                                                                                                                       Page   3

M:ADDR CODE           CYCLES LINE SOURCELINE
                              519 ; 29   |#if !defined(NULL)
                              520 ; 30   |#define NULL 0
                              521 ; 31   |#endif
                              522 ; 32   |
                              523 ; 33   |#define MAX_INT     0x7FFFFF
                              524 ; 34   |#define MAX_LONG    0x7FFFFFffffff
                              525 ; 35   |        // max positive unsigned long value: -1 == 0xFFFFFFffffff
                              526 ; 36   |#define MAX_ULONG   (-1) 
                              527 ; 37   |
                              528 ; 38   |#define WORD_SIZE   24              // word size in bits
                              529 ; 39   |#define BYTES_PER_WORD 3            // 8 bit bytes
                              530 ; 40   |
                              531 ; 41   |
                              532 ; 42   |#define BYTE    unsigned char       // btVarName
                              533 ; 43   |#define CHAR    signed char         // cVarName
                              534 ; 44   |#define USHORT  unsigned short      // usVarName
                              535 ; 45   |#define SHORT   unsigned short      // sVarName
                              536 ; 46   |#define WORD    unsigned int        // wVarName
                              537 ; 47   |#define INT     signed int          // iVarName
                              538 ; 48   |#define DWORD   unsigned long       // dwVarName
                              539 ; 49   |#define LONG    signed long         // lVarName
                              540 ; 50   |#define BOOL    unsigned int        // bVarName
                              541 ; 51   |#define FRACT   _fract              // frVarName
                              542 ; 52   |#define LFRACT  long _fract         // lfrVarName
                              543 ; 53   |#define CIRC    _circ               // cp<type prefix>VarName (see below)
                              544 ; 54   |#define FLOAT   float               // fVarName
                              545 ; 55   |#define DBL     double              // dVarName
                              546 ; 56   |#define ENUM    enum                // eVarName
                              547 ; 57   |#define CMX     _complex            // cmxVarName
                              548 ; 58   |typedef WORD UCS3;                   // 
                              549 ; 59   |
                              550 ; 60   |#define UINT16  unsigned short
                              551 ; 61   |#define UINT8   unsigned char   
                              552 ; 62   |#define UINT32  unsigned long
                              553 ; 63   |#define UINT64  unsigned long   // need to figure out how to do 64 bit values.  Or port exisiting code to only use 48 bit
                              554 ; 64   |#define INT64   unsigned long   // need to figure out how to do 64 bit values.  Or port exisiting code to only use 48 bit
                              555 ; 65   |#define WCHAR   UINT16
                              556 ; 66   |
                              557 ; 67   |//UINT128 is 16 bytes or 6 words
                              558 ; 68   |typedef struct UINT128_3500 {   
                              559 ; 69   |    int val[6];     
                              560 ; 70   |} UINT128_3500;
                              561 ; 71   |
                              562 ; 72   |#define UINT128   UINT128_3500
                              563 ; 73   |
                              564 ; 74   |// Little endian word packed byte strings:   
                              565 ; 75   |//      _packed BYTE bTextVarName[]="a string";  bText is a packed byte string prefix
                              566 ; 76   |// Convert to big endian words by reordering bytes from high to low using swizzle.
                              567 ; 77   |// Little endian word packed byte strings:   
                              568 ; 78   |//      _packed BYTE bTextVarName[]="a string";  bText is a packed byte string prefix
                              569 ; 79   |// Convert to big endian words by reordering bytes from high to low using swizzle.
                              570 ; 80   |
                              571 ; 81   |// Declare Memory Spaces To Use When Coding
                              572 ; 82   |// A. Sector Buffers
                              573 ; 83   |#define SECTOR_BUFFER_MEM_X _X
                              574 ; 84   |#define SECTOR_BUFFER_MEM_Y _Y
                              575 ; 85   |#define SECTOR_BUFFER_MEM SECTOR_BUFFER_MEM_X
                              576 ; 86   |typedef WORD SECTOR_BUFFER_MEM SECTOR_BUFFER;
                              577 ; 87   |typedef SECTOR_BUFFER * P_SECTOR_BUFFER;
                              578 ; 88   |// B. Media DDI Memory
                              579 ; 89   |#define MEDIA_DDI_MEM _Y
                              580 ; 90   |
                              581 ; 91   |
                              582 ; 92   |
                              583 ; 93   |// Pointers to linear structures are labeled as: p<type prefix>VarName
                              584 ; 94   |// Examples of circular pointers:
                              585 ; 95   |//    INT CIRC cpiVarName
                              586 ; 96   |//    DWORD CIRC cpdwVarName
                              587 ; 97   |
                              588 ; 98   |#define RETCODE INT                 // rcVarName
                              589 ; 99   |
                              590 ; 100  |// generic bitfield structure
                              591 ; 101  |struct Bitfield {
                              592 ; 102  |    unsigned int B0  :1;
                              593 ; 103  |    unsigned int B1  :1;
                              594 ; 104  |    unsigned int B2  :1;
                              595 ; 105  |    unsigned int B3  :1;
                              596 ; 106  |    unsigned int B4  :1;
                              597 ; 107  |    unsigned int B5  :1;
                              598 ; 108  |    unsigned int B6  :1;
                              599 ; 109  |    unsigned int B7  :1;
                              600 ; 110  |    unsigned int B8  :1;
                              601 ; 111  |    unsigned int B9  :1;
                              602 ; 112  |    unsigned int B10 :1;
                              603 ; 113  |    unsigned int B11 :1;
                              604 ; 114  |    unsigned int B12 :1;
                              605 ; 115  |    unsigned int B13 :1;
                              606 ; 116  |    unsigned int B14 :1;
                              607 ; 117  |    unsigned int B15 :1;
                              608 ; 118  |    unsigned int B16 :1;
                              609 ; 119  |    unsigned int B17 :1;
                              610 ; 120  |    unsigned int B18 :1;
                              611 ; 121  |    unsigned int B19 :1;
                              612 ; 122  |    unsigned int B20 :1;
                              613 ; 123  |    unsigned int B21 :1;
                              614 ; 124  |    unsigned int B22 :1;
                              615 ; 125  |    unsigned int B23 :1;
                              616 ; 126  |};
                              617 ; 127  |
                              618 ; 128  |union BitInt {
                              619 ; 129  |        struct Bitfield B;
                              620 ; 130  |        int        I;
                              621 ; 131  |};
                              622 ; 132  |
                              623 ; 133  |#define MAX_MSG_LENGTH 10
                              624 ; 134  |struct CMessage
                              625 ; 135  |{
                              626 ; 136  |        unsigned int m_uLength;
                              627 ; 137  |        unsigned int m_uMsg[MAX_MSG_LENGTH];
                              628 ; 138  |};
                              629 ; 139  |
                              630 ; 140  |typedef struct {
                              631 ; 141  |    WORD m_wLength;
                              632 ; 142  |    WORD m_wMessage;
                              633 ; 143  |    WORD m_wParams[MAX_MSG_LENGTH];
                              634 ; 144  |} Message;
                              635 ; 145  |
                              636 ; 146  |struct MessageQueueDescriptor
                              637 ; 147  |{
                              638 ; 148  |        int *m_pBase;
                              639 ; 149  |        int m_iModulo;
                              640 ; 150  |        int m_iSize;
                              641 ; 151  |        int *m_pHead;
                              642 ; 152  |        int *m_pTail;
                              643 ; 153  |};
                              644 ; 154  |
                              645 ; 155  |struct ModuleEntry
                              646 ; 156  |{
                              647 ; 157  |    int m_iSignaledEventMask;
                              648 ; 158  |    int m_iWaitEventMask;
                              649 ; 159  |    int m_iResourceOfCode;
                              650 ; 160  |    struct MessageQueueDescriptor *m_pMessageQueue;
                              651 ; 161  |    int _asmfunc (*m_pProcessEntryPoint)(union WaitMask Signals,struct MessageQueueDescriptor *);
                              652 ; 162  |    int _asmfunc (*m_pInitFunction)(struct MessageQueueDescriptor *);
                              653 ; 163  |    int m_uTimeOutHigh;
                              654 ; 164  |    int m_uTimeOutLow;
                              655 ; 165  |    int _asmfunc (*m_pBackgroundFunction)(struct MessageQueueDescriptor *);
                              656 ; 166  |};
                              657 ; 167  |
                              658 ; 168  |union WaitMask{
                              659 ; 169  |    struct B{
                              660 ; 170  |        unsigned int m_bNone     :1;
                              661 ; 171  |        unsigned int m_bMessage  :1;
                              662 ; 172  |        unsigned int m_bTimer    :1;
                              663 ; 173  |        unsigned int m_bButton   :1;
                              664 ; 174  |    } B;
                              665 ; 175  |    int I;
                              666 ; 176  |} ;
                              667 ; 177  |
                              668 ; 178  |
                              669 ; 179  |struct Button {
                              670 ; 180  |        WORD wButtonEvent;
                              671 ; 181  |        WORD wUnused[MAX_MSG_LENGTH];   
                              672 ; 182  |};
                              673 ; 183  |
                              674 ; 184  |struct Message {
                              675 ; 185  |        WORD wMsgLength;
                              676 ; 186  |        WORD wMsgCommand;
                              677 ; 187  |        WORD wMsgParms[MAX_MSG_LENGTH-1];
                              678 ; 188  |};
                              679 ; 189  |
                              680 ; 190  |union EventTypes {
                              681 ; 191  |        struct CMessage msg;
                              682 ; 192  |        struct Button Button ;
                              683 ; 193  |        struct Message Message;
                              684 ; 194  |};
                              685 ; 195  |
                              686 ; 196  |// next 2 used to get updater build to return correct protocol ver in scsi response.
                              687 ; 197  |#define BUILD_TYPE_UPDATER  0x100
                              688 ; 198  |#define BUILD_TYPE_HOSTLINK 0x101
                              689 ; 199  |#define BUILD_TYPE_PLAYER   0x102
                              690 ; 200  |
                              691 ; 201  |// Resets part if RETAIL build. DEBUG build executes debug instruction to halt.
                              692 ; 202  |#define SystemHalt() __asm(" include 'sysmacro.asm' \n error") 
                              693 ; 203  |#define assert(x)    if(!(x)) __asm(" include 'sysmacro.asm' \n error")
                              694 ; 204  |
                              695 ; 205  |#if DEBUG
                              696 ; 206  |// For DEBUG builds, DebugBuildAssert(condition) halts if condition evaluates to FALSE. 
                              697 ; 207  |#define DebugBuildAssert(x)    if(!(x)) __asm(" debug ")
                              698 ; 208  |#else 
                              699 ; 209  |// For RETAIL builds, DebugBuildAssert(condition) does nothing & execution continues rather than halt or reset. 
                              700 ; 210  |#define DebugBuildAssert(x)    
                              701 ; 211  |#endif
                              702 ; 212  |
                              703 ; 213  |// Do this in your C files to make a reminder that's displayed during the build.
                              704 ; 214  |//  #pragma asm
                              705 ; 215  |//  WARN 'Note to builder: reminder to do this after verifying that'
                              706 ; 216  |//  #pragma endasm
                              707 ; 217  |
                              708 ; 218  |
                              709 ; 219  |#ifdef COLOR_262K
                              710 ; 220  |#define RGB(r,g,b)    ((0x0000FC & (r)) << 10) | ((0x0000FC & (g)) << 4) | ((0x0000FC & (b)) >> 2)    //262k
                              711 ; 221  |#elif defined(COLOR_65K)
                              712 ; 222  |#define RGB(r,g,b)    ((0x0000F8 & (r)) << 8) | ((0x0000FC & (g)) << 3) | ((0x0000F8 & (b)) >> 3)  //65k
                              713 ; 223  |#else
                              714 ; 224  |#define RGB(r,g,b)       ((0x0000F0 & (r)) << 4) | (0x0000F0 & (g)) | ((0x0000F0 & (b)) >> 4)
                              715 ; 225  |#endif
                              716 ; 226  |    
                              717 ; 227  |#endif // #ifndef _TYPES_H
                              718 
                              720 
                              721 ; 8    |
                              722 ; 9    |
                              723 ; 10   |
                              724 ; 11   |//;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                              725 ; 12   |
                              726 ; 13   |//   SYSTEM STMP Registers 
                              727 ; 14   |//      Last Edited 2.19.2003 M. May
                              728 ; 15   |//;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                              729 ; 16   |
                              730 ; 17   |#define HW_DCDC_BASEADDR (0xFA0C)
                              731 ; 18   |
                              732 ; 19   |
                              733 ; 20   |
                              734 ; 21   |
                              735 ; 22   |
                              736 ; 23   |
                              737 ; 24   |/////////////////////////////////////////////////////////////////////////////////
                              738 ; 25   |
                              739 ; 26   |//  DcDc#1 Control Register (HW_DCDC1_CTRL0) Bit Definitions
                              740 ; 27   |
                              741 ; 28   |#define HW_DCDC1_CTRL0_PLEVBU_WIDTH (5)
                              742 ; 29   |#define HW_DCDC1_CTRL0_RSVD0_WIDTH (3)
                              743 ; 30   |#define HW_DCDC1_CTRL0_PLEVBO_WIDTH (5)
                              744 ; 31   |#define HW_DCDC1_CTRL0_RSVD1_WIDTH (3)
                              745 ; 32   |#define HW_DCDC1_CTRL0_NLEV_WIDTH (5)
                              746 ; 33   |
                              747 ; 34   |#define HW_DCDC1_CTRL0_RSVD2_WIDTH (3)
                              748 ; 35   |
                              749 ; 36   |
                              750 ; 37   |
                              751 ; 38   |#define HW_DCDC1_CTRL0_PLEVBU_BITPOS (0)
                              752 ; 39   |#define HW_DCDC1_CTRL0_PLEVBO_BITPOS (8)
                              753 ; 40   |#define HW_DCDC1_CTRL0_NLEV_BITPOS (16)
                              754 ; 41   |
                              755 ; 42   |
                              756 ; 43   |
                              757 ; 44   |#define HW_DCDC1_CTRL0_PLEVBU_SETMASK (((1<<HW_DCDC1_CTRL0_PLEVBU_WIDTH)-1)<<HW_DCDC1_CTRL0_PLEVBU_BITPOS)        
                              758 ; 45   |#define HW_DCDC1_CTRL0_PLEVBO_SETMASK (((1<<HW_DCDC1_CTRL0_PLEVBO_WIDTH)-1)<<HW_DCDC1_CTRL0_PLEVBO_BITPOS) 
                              759 ; 46   |#define HW_DCDC1_CTRL0_NLEV_SETMASK (((1<<HW_DCDC1_CTRL0_NLEV_WIDTH)-1)<<HW_DCDC1_CTRL0_NLEV_BITPOS)  
                              760 ; 47   |
                              761 ; 48   |
                              762 ; 49   |
                              763 ; 50   |#define HW_DCDC1_CTRL0_PLEVBU_CLRMASK (~(WORD)HW_DCDC1_CTRL0_PLEVBU_SETMASK)     
                              764 ; 51   |#define HW_DCDC1_CTRL0_PLEVBO_CLRMASK (~(WORD)HW_DCDC1_CTRL0_PLEVBO_SETMASK) 
                              765 ; 52   |#define HW_DCDC1_CTRL0_NLEV_CLRMASK (~(WORD)HW_DCDC1_CTRL0_NLEV_SETMASK)  
                              766 ; 53   |
                              767 ; 54   |
                              768 ; 55   |
                              769 ; 56   |
                              770 ; 57   |
TASKING DSP2410 assembler v1.5r1 Build 138 SN 00100122
                                                                                                                                                                                                                                                       Page   4

M:ADDR CODE           CYCLES LINE SOURCELINE
                              771 ; 58   |typedef union               
                              772 ; 59   |{
                              773 ; 60   |    struct {
                              774 ; 61   |        unsigned int PLEVBU           : HW_DCDC1_CTRL0_PLEVBU_WIDTH;
                              775 ; 62   |        unsigned int RSVD0            : HW_DCDC1_CTRL0_RSVD0_WIDTH;
                              776 ; 63   |        unsigned int PLEVBO           : HW_DCDC1_CTRL0_PLEVBO_WIDTH;
                              777 ; 64   |        unsigned int RSVD1            : HW_DCDC1_CTRL0_RSVD1_WIDTH;
                              778 ; 65   |        unsigned int NLEV             : HW_DCDC1_CTRL0_NLEV_WIDTH;
                              779 ; 66   |        unsigned int RSVD2            : HW_DCDC1_CTRL0_RSVD2_WIDTH;
                              780 ; 67   |    } B;
                              781 ; 68   |    unsigned int I;
                              782 ; 69   |} dcdc1_ctrl0_type;
                              783 ; 70   |#define HW_DCDC1_CTRL0      (*(volatile dcdc1_ctrl0_type _X*) (HW_DCDC_BASEADDR))    /* DcDc#1 Limit Level Register */
                              784 ; 71   |
                              785 ; 72   |
                              786 ; 73   |
                              787 ; 74   |
                              788 ; 75   |/////////////////////////////////////////////////////////////////////////////////
                              789 ; 76   |
                              790 ; 77   |//  DCDc#1 Control Register1 (HW_DCDC1_CTRL1) Bit Definitions
                              791 ; 78   |
                              792 ; 79   |#define HW_DCDC1_CTRL1_C_WIDTH (4)
                              793 ; 80   |#define HW_DCDC1_CTRL1_R_WIDTH (4)
                              794 ; 81   |#define HW_DCDC1_CTRL1_FFOR_WIDTH (3)
                              795 ; 82   |#define HW_DCDC1_CTRL1_RSVD0_WIDTH (1)
                              796 ; 83   |#define HW_DCDC1_CTRL1_PFMCTRL_WIDTH (12)
                              797 ; 84   |
                              798 ; 85   |
                              799 ; 86   |
                              800 ; 87   |#define HW_DCDC1_CTRL1_C_BITPOS (0)
                              801 ; 88   |#define HW_DCDC1_CTRL1_R_BITPOS (4)
                              802 ; 89   |#define HW_DCDC1_CTRL1_FFOR_BITPOS (8)
                              803 ; 90   |#define HW_DCDC1_CTRL1_PFMCTRL_BITPOS (12) 
                              804 ; 91   |
                              805 ; 92   |#define HW_DCDC1_CTRL1_C_SETMASK (((1<<HW_DCDC1_CTRL1_C_WIDTH)-1)<<HW_DCDC1_CTRL1_C_BITPOS)        
                              806 ; 93   |#define HW_DCDC1_CTRL1_R_SETMASK (((1<<HW_DCDC1_CTRL1_R_WIDTH)-1)<<HW_DCDC1_CTRL1_R_BITPOS) 
                              807 ; 94   |#define HW_DCDC1_CTRL1_FFOR_SETMASK (((1<<HW_DCDC1_CTRL1_FFOR_WIDTH)-1)<<HW_DCDC1_CTRL1_FFOR_BITPOS)  
                              808 ; 95   |#define HW_DCDC1_CTRL1_PFMCTRL_SETMASK (((1<<HW_DCDC1_CTRL1_PFMCTRL_WIDTH)-1)<<HW_DCDC1_CTRL1_PFMCTRL_BITPOS)   
                              809 ; 96   |
                              810 ; 97   |#define HW_DCDC1_CTRL1_C_CLRMASK (~(WORD)HW_DCDC1_CTRL1_C_SETMASK)     
                              811 ; 98   |#define HW_DCDC1_CTRL1_R_CLRMASK (~(WORD)HW_DCDC1_CTRL1_R_SETMASK) 
                              812 ; 99   |#define HW_DCDC1_CTRL1_FFOR_CLRMASK (~(WORD)HW_DCDC1_CTRL1_FFOR_SETMASK)  
                              813 ; 100  |#define HW_DCDC1_CTRL1_PFMCTRL_CLRMASK (~(WORD)HW_DCDC1_CTRL1_PFMCTRL_SETMASK)  
                              814 ; 101  |
                              815 ; 102  |
                              816 ; 103  |typedef union               
                              817 ; 104  |{
                              818 ; 105  |    struct {
                              819 ; 106  |        unsigned int C       : HW_DCDC1_CTRL1_C_WIDTH;
                              820 ; 107  |        unsigned int R                : HW_DCDC1_CTRL1_R_WIDTH;
                              821 ; 108  |        unsigned int FFOR             : HW_DCDC1_CTRL1_FFOR_WIDTH;
                              822 ; 109  |        unsigned int RSVD0            : HW_DCDC1_CTRL1_RSVD0_WIDTH;
                              823 ; 110  |        unsigned int PFMCTRL          : HW_DCDC1_CTRL1_FFOR_WIDTH;
                              824 ; 111  |    } B;
                              825 ; 112  |    unsigned int I;
                              826 ; 113  |} dcdc1_ctrl1_type;
                              827 ; 114  |#define HW_DCDC1_CTRL1      (*(volatile dcdc1_ctrl1_type _X*) (HW_DCDC_BASEADDR+1))    /* DcDc#1 Ctrl #1 Register */
                              828 ; 115  |
                              829 ; 116  |
                              830 ; 117  |
                              831 ; 118  |
                              832 ; 119  |/////////////////////////////////////////////////////////////////////////////////
                              833 ; 120  |
                              834 ; 121  |//  DcDc VDDIO Register (HW_DCDC_VDDIO) Bit Definitions
                              835 ; 122  |
                              836 ; 123  |#define HW_DCDC_VDDIO_VOLTAGE_LEVEL_WIDTH (5)
                              837 ; 124  |#define HW_DCDC_VDDIO_RSVD0_WIDTH (3)
                              838 ; 125  |#define HW_DCDC_VDDIO_BROWNOUT_LEVEL_WIDTH (5)
                              839 ; 126  |#define HW_DCDC_VDDIO_RSVD1_WIDTH (3)
                              840 ; 127  |#define HW_DCDC_VDDIO_BROWNOUT_ENABLE_WIDTH (1)
                              841 ; 128  |#define HW_DCDC_VDDIO_RSVD2_WIDTH (3)
                              842 ; 129  |#define HW_DCDC_VDDIO_BROWNOUT_STATUS_WIDTH (1)
                              843 ; 130  |#define HW_DCDC_VDDIO_OK_WIDTH (1)
                              844 ; 131  |#define HW_DCDC_VDDIO_RSVD3_WIDTH (2)
                              845 ; 132  |
                              846 ; 133  |
                              847 ; 134  |
                              848 ; 135  |#define HW_DCDC_VDDIO_VOLTAGE_LEVEL_BITPOS (0)
                              849 ; 136  |#define HW_DCDC_VDDIO_BROWNOUT_LEVEL_BITPOS (8)
                              850 ; 137  |#define HW_DCDC_VDDIO_BROWNOUT_ENABLE_BITPOS (16)
                              851 ; 138  |#define HW_DCDC_VDDIO_BROWNOUT_STATUS_BITPOS (20)
                              852 ; 139  |#define HW_DCDC_VDDIO_OK_BITPOS (21)
                              853 ; 140  |
                              854 ; 141  |
                              855 ; 142  |#define HW_DCDC_VDDIO_VOLTAGE_LEVEL_SETMASK (((1<<HW_DCDC_VDDIO_VOLTAGE_LEVEL_WIDTH)-1)<<HW_DCDC_VDDIO_VOLTAGE_LEVEL_BITPOS)        
                              856 ; 143  |#define HW_DCDC_VDDIO_BROWNOUT_LEVEL_SETMASK (((1<<HW_DCDC_VDDIO_BROWNOUT_LEVEL_WIDTH)-1)<<HW_DCDC_VDDIO_BROWNOUT_LEVEL_BITPOS) 
                              857 ; 144  |#define HW_DCDC_VDDIO_BROWNOUT_ENABLE_SETMASK (((1<<HW_DCDC_VDDIO_BROWNOUT_ENABLE_WIDTH)-1)<<HW_DCDC_VDDIO_BROWNOUT_ENABLE_BITPOS)  
                              858 ; 145  |#define HW_DCDC_VDDIO_BROWNOUT_STATUS_SETMASK (((1<<HW_DCDC_VDDIO_BROWNOUT_STATUS_WIDTH)-1)<<HW_DCDC_VDDIO_BROWNOUT_STATUS_BITPOS)  
                              859 ; 146  |
                              860 ; 147  |
                              861 ; 148  |
                              862 ; 149  |#define HW_DCDC_VDDIO_VOLTAGE_LEVEL_CLRMASK (~(WORD)HW_DCDC_VDDIO_VOLTAGE_LEVEL_SETMASK)     
                              863 ; 150  |#define HW_DCDC_VDDIO_BROWNOUT_LEVEL_CLRMASK (~(WORD)HW_DCDC_VDDIO_BROWNOUT_LEVEL_SETMASK) 
                              864 ; 151  |#define HW_DCDC_VDDIO_BROWNOUT_ENABLE_CLRMASK (~(WORD)HW_DCDC_VDDIO_BROWNOUT_ENABLE_SETMASK)  
                              865 ; 152  |#define HW_DCDC_VDDIO_BROWNOUT_STATUS_CLRMASK (~(WORD)HW_DCDC_VDDIO_BROWNOUT_STATUS_SETMASK)  
                              866 ; 153  |
                              867 ; 154  |
                              868 ; 155  |typedef union               
                              869 ; 156  |{
                              870 ; 157  |    struct {
                              871 ; 158  |        unsigned int VOLTAGE_LEVEL    : HW_DCDC_VDDIO_VOLTAGE_LEVEL_WIDTH;
                              872 ; 159  |        unsigned int RSVD0            : HW_DCDC_VDDIO_RSVD0_WIDTH;
                              873 ; 160  |        unsigned int BROWNOUT_LEVEL   : HW_DCDC_VDDIO_BROWNOUT_LEVEL_WIDTH;
                              874 ; 161  |        unsigned int RSVD1            : HW_DCDC_VDDIO_RSVD1_WIDTH;
                              875 ; 162  |        unsigned int BROWNOUT_ENABLE  : HW_DCDC_VDDIO_BROWNOUT_ENABLE_WIDTH;
                              876 ; 163  |        unsigned int RSVD2            : HW_DCDC_VDDIO_RSVD2_WIDTH;
                              877 ; 164  |        unsigned int BROWNOUT_STATUS  : HW_DCDC_VDDIO_BROWNOUT_STATUS_WIDTH;
                              878 ; 165  |                 unsigned int VDDIO_OK        : HW_DCDC_VDDIO_OK_WIDTH;
                              879 ; 166  |        unsigned int RSVD3            : HW_DCDC_VDDIO_RSVD3_WIDTH;
                              880 ; 167  |    } B;
                              881 ; 168  |    unsigned int I;
                              882 ; 169  |} dcdc_vddio_type;
                              883 ; 170  |#define HW_DCDC_VDDIO      (*(volatile dcdc_vddio_type _X*) (HW_DCDC_BASEADDR+2))    /* DcDc VDDIO Register */
                              884 ; 171  |
                              885 ; 172  |
                              886 ; 173  |
                              887 ; 174  |/////////////////////////////////////////////////////////////////////////////////
                              888 ; 175  |//  DcDc VDDD Register (HW_DCDC_VDDD) Bit Definitions
                              889 ; 176  |
                              890 ; 177  |#define HW_DCDC_VDDD_VOLTAGE_LEVEL_WIDTH (5)
                              891 ; 178  |#define HW_DCDC_VDDD_RSVD0_WIDTH (3)
                              892 ; 179  |#define HW_DCDC_VDDD_BROWNOUT_LEVEL_WIDTH (5)
                              893 ; 180  |#define HW_DCDC_VDDD_RSVD1_WIDTH (3)
                              894 ; 181  |#define HW_DCDC_VDDD_BROWNOUT_ENABLE_WIDTH (1)
                              895 ; 182  |#define HW_DCDC_VDDD_RSVD2_WIDTH (3)
                              896 ; 183  |#define HW_DCDC_VDDD_BROWNOUT_STATUS_WIDTH (1)
                              897 ; 184  |#define HW_DCDC_VDDD_OK_WIDTH (1)
                              898 ; 185  |#define HW_DCDC_VDDD_RSVD3_WIDTH (2)
                              899 ; 186  |
                              900 ; 187  |#define HW_DCDC_VDDD_VOLTAGE_LEVEL_BITPOS (0)
                              901 ; 188  |#define HW_DCDC_VDDD_BROWNOUT_LEVEL_BITPOS (8)
                              902 ; 189  |#define HW_DCDC_VDDD_BROWNOUT_ENABLE_BITPOS (16)
                              903 ; 190  |#define HW_DCDC_VDDD_BROWNOUT_STATUS_BITPOS (20)
                              904 ; 191  |#define HW_DCDC_VDDD_OK_BITPOS (21)
                              905 ; 192  |#define HW_DCDC_VDDD_VOLTAGE_LEVEL_SETMASK (((1<<HW_DCDC_VDDD_VOLTAGE_LEVEL_WIDTH)-1)<<HW_DCDC_VDDD_VOLTAGE_LEVEL_BITPOS)        
                              906 ; 193  |#define HW_DCDC_VDDD_BROWNOUT_LEVEL_SETMASK (((1<<HW_DCDC_VDDD_BROWNOUT_LEVEL_WIDTH)-1)<<HW_DCDC_VDDD_BROWNOUT_LEVEL_BITPOS) 
                              907 ; 194  |#define HW_DCDC_VDDD_BROWNOUT_ENABLE_SETMASK (((1<<HW_DCDC_VDDD_BROWNOUT_ENABLE_WIDTH)-1)<<HW_DCDC_VDDD_BROWNOUT_ENABLE_BITPOS)  
                              908 ; 195  |#define HW_DCDC_VDDD_BROWNOUT_STATUS_SETMASK (((1<<HW_DCDC_VDDD_BROWNOUT_STATUS_WIDTH)-1)<<HW_DCDC_VDDD_BROWNOUT_STATUS_BITPOS)  
                              909 ; 196  |
                              910 ; 197  |#define HW_DCDC_VDDD_VOLTAGE_LEVEL_CLRMASK (~(WORD)HW_DCDC_VDDD_VOLTAGE_LEVEL_SETMASK)     
                              911 ; 198  |#define HW_DCDC_VDDD_BROWNOUT_LEVEL_CLRMASK (~(WORD)HW_DCDC_VDDD_BROWNOUT_LEVEL_SETMASK) 
                              912 ; 199  |#define HW_DCDC_VDDD_BROWNOUT_ENABLE_CLRMASK (~(WORD)HW_DCDC_VDDD_BROWNOUT_ENABLE_SETMASK)  
                              913 ; 200  |#define HW_DCDC_VDDD_BROWNOUT_STATUS_CLRMASK (~(WORD)HW_DCDC_VDDD_BROWNOUT_STATUS_SETMASK)  
                              914 ; 201  |
                              915 ; 202  |typedef union               
                              916 ; 203  |{
                              917 ; 204  |    struct {
                              918 ; 205  |        unsigned int VOLTAGE_LEVEL    : HW_DCDC_VDDD_VOLTAGE_LEVEL_WIDTH;
                              919 ; 206  |        unsigned int RSVD0            : HW_DCDC_VDDD_RSVD0_WIDTH;
                              920 ; 207  |        unsigned int BROWNOUT_LEVEL   : HW_DCDC_VDDD_BROWNOUT_LEVEL_WIDTH;
                              921 ; 208  |        unsigned int RSVD1            : HW_DCDC_VDDD_RSVD1_WIDTH;
                              922 ; 209  |        unsigned int BROWNOUT_ENABLE  : HW_DCDC_VDDD_BROWNOUT_ENABLE_WIDTH;
                              923 ; 210  |        unsigned int RSVD2            : HW_DCDC_VDDD_RSVD2_WIDTH;
                              924 ; 211  |        unsigned int BROWNOUT_STATUS  : HW_DCDC_VDDD_BROWNOUT_STATUS_WIDTH;
                              925 ; 212  |                 unsigned int VDD_OK           : HW_DCDC_VDDD_OK_WIDTH;
                              926 ; 213  |        unsigned int RSVD3            : HW_DCDC_VDDD_RSVD3_WIDTH;
                              927 ; 214  |    } B;
                              928 ; 215  |   unsigned int I;
                              929 ; 216  |        unsigned U;
                              930 ; 217  |} dcdc_vddd_type;
                              931 ; 218  |#define HW_DCDC_VDDD      (*(volatile dcdc_vddd_type _X*) (HW_DCDC_BASEADDR+3))    /* DcDc VDDD Register */
                              932 ; 219  |
                              933 ; 220  |
                              934 ; 221  |
                              935 ; 222  |
                              936 ; 223  |/////////////////////////////////////////////////////////////////////////////////
                              937 ; 224  |
                              938 ; 225  |//  DcDc Vdda Register (HW_DCDC_VDDA) Bit Definitions
                              939 ; 226  |
                              940 ; 227  |#define HW_DCDC_VDDA_VOLTAGE_LEVEL_WIDTH (5)
                              941 ; 228  |#define HW_DCDC_VDDA_RSVD0_WIDTH (3)
                              942 ; 229  |#define HW_DCDC_VDDA_BROWNOUT_LEVEL_WIDTH (5)
                              943 ; 230  |#define HW_DCDC_VDDA_RSVD1_WIDTH (3)
                              944 ; 231  |#define HW_DCDC_VDDA_BROWNOUT_ENABLE_WIDTH (1)
                              945 ; 232  |#define HW_DCDC_VDDA_RSVD2_WIDTH (3)
                              946 ; 233  |#define HW_DCDC_VDDA_BROWNOUT_STATUS_WIDTH (1)
                              947 ; 234  |#define HW_DCDC_VDDA_OK_WIDTH (1)
                              948 ; 235  |#define HW_DCDC_VDDA_RSVD3_WIDTH (2)
                              949 ; 236  |
                              950 ; 237  |
                              951 ; 238  |
                              952 ; 239  |#define HW_DCDC_VDDA_VOLTAGE_LEVEL_BITPOS (0)
                              953 ; 240  |#define HW_DCDC_VDDA_BROWNOUT_LEVEL_BITPOS (8)
                              954 ; 241  |#define HW_DCDC_VDDA_BROWNOUT_ENABLE_BITPOS (16)
                              955 ; 242  |#define HW_DCDC_VDDA_BROWNOUT_STATUS_BITPOS (20)
                              956 ; 243  |#define HW_DCDC_VDDA_OK_BITPOS (21)
                              957 ; 244  |
                              958 ; 245  |
                              959 ; 246  |#define HW_DCDC_VDDA_VOLTAGE_LEVEL_SETMASK (((1<<HW_DCDC_VDDA_VOLTAGE_LEVEL_WIDTH)-1)<<HW_DCDC_VDDA_VOLTAGE_LEVEL_BITPOS)        
                              960 ; 247  |#define HW_DCDC_VDDA_BROWNOUT_LEVEL_SETMASK (((1<<HW_DCDC_VDDA_BROWNOUT_LEVEL_WIDTH)-1)<<HW_DCDC_VDDA_BROWNOUT_LEVEL_BITPOS) 
                              961 ; 248  |#define HW_DCDC_VDDA_BROWNOUT_ENABLE_SETMASK (((1<<HW_DCDC_VDDA_BROWNOUT_ENABLE_WIDTH)-1)<<HW_DCDC_VDDA_BROWNOUT_ENABLE_BITPOS)  
                              962 ; 249  |#define HW_DCDC_VDDA_BROWNOUT_STATUS_SETMASK (((1<<HW_DCDC_VDDA_BROWNOUT_STATUS_WIDTH)-1)<<HW_DCDC_VDDA_BROWNOUT_STATUS_BITPOS)  
                              963 ; 250  |
                              964 ; 251  |
                              965 ; 252  |
                              966 ; 253  |#define HW_DCDC_VDDA_VOLTAGE_LEVEL_CLRMASK (~(WORD)HW_DCDC_VDDA_VOLTAGE_LEVEL_SETMASK)     
                              967 ; 254  |#define HW_DCDC_VDDA_BROWNOUT_LEVEL_CLRMASK (~(WORD)HW_DCDC_VDDA_BROWNOUT_LEVEL_SETMASK) 
                              968 ; 255  |#define HW_DCDC_VDDA_BROWNOUT_ENABLE_CLRMASK (~(WORD)HW_DCDC_VDDA_BROWNOUT_ENABLE_SETMASK)  
                              969 ; 256  |#define HW_DCDC_VDDA_BROWNOUT_STATUS_CLRMASK (~(WORD)HW_DCDC_VDDA_BROWNOUT_STATUS_SETMASK)  
                              970 ; 257  |
                              971 ; 258  |
                              972 ; 259  |typedef union               
                              973 ; 260  |{
                              974 ; 261  |    struct {
                              975 ; 262  |        unsigned int VOLTAGE_LEVEL    : HW_DCDC_VDDA_VOLTAGE_LEVEL_WIDTH;
                              976 ; 263  |        unsigned int RSVD0            : HW_DCDC_VDDA_RSVD0_WIDTH;
                              977 ; 264  |        unsigned int BROWNOUT_LEVEL   : HW_DCDC_VDDA_BROWNOUT_LEVEL_WIDTH;
                              978 ; 265  |        unsigned int RSVD1            : HW_DCDC_VDDA_RSVD1_WIDTH;
                              979 ; 266  |        unsigned int BROWNOUT_ENABLE  : HW_DCDC_VDDA_BROWNOUT_ENABLE_WIDTH;
                              980 ; 267  |        unsigned int RSVD2            : HW_DCDC_VDDA_RSVD2_WIDTH;
                              981 ; 268  |        unsigned int BROWNOUT_STATUS  : HW_DCDC_VDDA_BROWNOUT_STATUS_WIDTH;
                              982 ; 269  |             unsigned int VDDA_OK          : HW_DCDC_VDDA_OK_WIDTH;
                              983 ; 270  |        unsigned int RSVD3            : HW_DCDC_VDDA_RSVD3_WIDTH;
                              984 ; 271  |    } B;
                              985 ; 272  |    unsigned int I;
                              986 ; 273  |} dcdc_vdda_type;
                              987 ; 274  |#define HW_DCDC_VDDA      (*(volatile dcdc_vdda_type _X*) (HW_DCDC_BASEADDR+4))    /* DcDc VDDA Register */
                              988 ; 275  |
                              989 ; 276  |
                              990 ; 277  |
                              991 ; 278  |
                              992 ; 279  |/////////////////////////////////////////////////////////////////////////////////
                              993 ; 280  |
                              994 ; 281  |//  DcDc#2 Control Register 0 (HW_DCDC2_CTRL0) Bit Definitions
                              995 ; 282  |
                              996 ; 283  |#define HW_DCDC2_CTRL0_PLEVBU_WIDTH (5)
                              997 ; 284  |#define HW_DCDC2_CTRL0_RSVD0_WIDTH (3)
                              998 ; 285  |#define HW_DCDC2_CTRL0_PLEVBO_WIDTH (5)
                              999 ; 286  |#define HW_DCDC2_CTRL0_RSVD1_WIDTH (3)
                             1000 ; 287  |#define HW_DCDC2_CTRL0_NLEV_WIDTH (5)
                             1001 ; 288  |#define HW_DCDC2_CTRL0_RSVD2_WIDTH (3)
                             1002 ; 289  |
                             1003 ; 290  |
                             1004 ; 291  |
                             1005 ; 292  |#define HW_DCDC2_CTRL0_PLEVBU_BITPOS (0)
                             1006 ; 293  |#define HW_DCDC2_CTRL0_PLEVBO_BITPOS (8)
                             1007 ; 294  |#define HW_DCDC2_CTRL0_NLEV_BITPOS (16)
                             1008 ; 295  |
                             1009 ; 296  |#define HW_DCDC2_CTRL0_PLEVBU_SETMASK (((1<<HW_DCDC2_CTRL0_PLEVBU_WIDTH)-1)<<HW_DCDC2_CTRL0_PLEVBU_BITPOS)        
                             1010 ; 297  |#define HW_DCDC2_CTRL0_PLEVBO_SETMASK (((1<<HW_DCDC2_CTRL0_PLEVBO_WIDTH)-1)<<HW_DCDC2_CTRL0_PLEVBO_BITPOS) 
                             1011 ; 298  |#define HW_DCDC2_CTRL0_NLEV_SETMASK (((1<<HW_DCDC2_CTRL0_NLEV_WIDTH)-1)<<HW_DCDC2_CTRL0_NLEV_BITPOS)  
                             1012 ; 299  |
                             1013 ; 300  |#define HW_DCDC2_CTRL0_PLEVBU_CLRMASK (~(WORD)HW_DCDC2_CTRL0_PLEVBU_SETMASK)     
                             1014 ; 301  |#define HW_DCDC2_CTRL0_PLEVBO_CLRMASK (~(WORD)HW_DCDC2_CTRL0_PLEVBO_SETMASK) 
                             1015 ; 302  |#define HW_DCDC2_CTRL0_NLEV_CLRMASK (~(WORD)HW_DCDC2_CTRL0_NLEV_SETMASK)  
                             1016 ; 303  |
                             1017 ; 304  |
                             1018 ; 305  |typedef union               
                             1019 ; 306  |{
                             1020 ; 307  |    struct {
                             1021 ; 308  |        unsigned int PLEVBU           : HW_DCDC2_CTRL0_PLEVBU_WIDTH;
TASKING DSP2410 assembler v1.5r1 Build 138 SN 00100122
                                                                                                                                                                                                                                                       Page   5

M:ADDR CODE           CYCLES LINE SOURCELINE
                             1022 ; 309  |        unsigned int RSVD0            : HW_DCDC2_CTRL0_RSVD0_WIDTH;
                             1023 ; 310  |        unsigned int PLEVBO           : HW_DCDC2_CTRL0_PLEVBO_WIDTH;
                             1024 ; 311  |        unsigned int RSVD1            : HW_DCDC2_CTRL0_RSVD1_WIDTH;
                             1025 ; 312  |        unsigned int NLEV             : HW_DCDC2_CTRL0_NLEV_WIDTH;
                             1026 ; 313  |        unsigned int RSVD2            : HW_DCDC2_CTRL0_RSVD2_WIDTH;
                             1027 ; 314  |    } B;
                             1028 ; 315  |    unsigned int I;
                             1029 ; 316  |} dcdc2_ctrl0_type; 
                             1030 ; 317  |#define HW_DCDC2_CTRL0      (*(volatile dcdc2_ctrl0_type _X*) (HW_DCDC_BASEADDR+5))    /* DcDc#2 Limit Level Register */
                             1031 ; 318  |
                             1032 ; 319  |
                             1033 ; 320  |
                             1034 ; 321  |
                             1035 ; 322  |/////////////////////////////////////////////////////////////////////////////////
                             1036 ; 323  |
                             1037 ; 324  |//  DcDc#2 Control Register #1 (HW_DCDC2_CTRL1) Bit Definitions
                             1038 ; 325  |
                             1039 ; 326  |#define HW_DCDC2_CTRL1_C_WIDTH (4)
                             1040 ; 327  |#define HW_DCDC2_CTRL1_R_WIDTH (4)
                             1041 ; 328  |#define HW_DCDC2_CTRL1_FFOR_WIDTH (3)
                             1042 ; 329  |#define HW_DCDC2_CTRL1_RSVD0_WIDTH (1)
                             1043 ; 330  |#define HW_DCDC2_CTRL1_PFMCTRL_WIDTH (12)
                             1044 ; 331  |
                             1045 ; 332  |
                             1046 ; 333  |#define HW_DCDC2_CTRL1_C_BITPOS (0)
                             1047 ; 334  |#define HW_DCDC2_CTRL1_R_BITPOS (4)
                             1048 ; 335  |#define HW_DCDC2_CTRL1_FFOR_BITPOS (8)
                             1049 ; 336  |#define HW_DCDC2_CTRL1_PFMCTRL_BITPOS (12)
                             1050 ; 337  |
                             1051 ; 338  |
                             1052 ; 339  |
                             1053 ; 340  |#define HW_DCDC2_CTRL1_C_SETMASK (((1<<HW_DCDC2_CTRL1_C_WIDTH)-1)<<HW_DCDC2_CTRL1_C_BITPOS)        
                             1054 ; 341  |#define HW_DCDC2_CTRL1_R_SETMASK (((1<<HW_DCDC2_CTRL1_R_WIDTH)-1)<<HW_DCDC2_CTRL1_R_BITPOS) 
                             1055 ; 342  |#define HW_DCDC2_CTRL1_FFOR_SETMASK (((1<<HW_DCDC2_CTRL1_FFOR_WIDTH)-1)<<HW_DCDC2_CTRL1_FFOR_BITPOS)  
                             1056 ; 343  |#define HW_DCDC2_CTRL1_PFMCTRL_SETMASK (((1<<HW_DCDC2_CTRL1_PFMCTRL_WIDTH)-1)<<HW_DCDC2_CTRL1_PFMCTRL_BITPOS)  
                             1057 ; 344  |
                             1058 ; 345  |
                             1059 ; 346  |
                             1060 ; 347  |#define HW_DCDC2_CTRL1_C_CLRMASK (~(WORD)HW_DCDC2_CTRL1_C_SETMASK)     
                             1061 ; 348  |#define HW_DCDC2_CTRL1_R_CLRMASK (~(WORD)HW_DCDC2_CTRL1_R_SETMASK) 
                             1062 ; 349  |#define HW_DCDC2_CTRL1_FFOR_CLRMASK (~(WORD)HW_DCDC2_CTRL1_FFOR_SETMASK)  
                             1063 ; 350  |#define HW_DCDC2_CTRL1_PFMCTRL_CLRMASK (~(WORD)HW_DCDC2_CTRL1_PFMCTRL_SETMASK)  
                             1064 ; 351  |
                             1065 ; 352  |
                             1066 ; 353  |typedef union               
                             1067 ; 354  |{
                             1068 ; 355  |    struct {
                             1069 ; 356  |        unsigned int C                : HW_DCDC2_CTRL1_C_WIDTH;
                             1070 ; 357  |        unsigned int R                : HW_DCDC2_CTRL1_R_WIDTH;
                             1071 ; 358  |        unsigned int FFOR             : HW_DCDC2_CTRL1_FFOR_WIDTH;
                             1072 ; 359  |        unsigned int RSVD0            : HW_DCDC2_CTRL1_RSVD0_WIDTH;
                             1073 ; 360  |        unsigned int PFMCTRL          : HW_DCDC2_CTRL1_FFOR_WIDTH;
                             1074 ; 361  |    } B;
                             1075 ; 362  |    unsigned int I;
                             1076 ; 363  |} dcdc2_ctrl1_type;
                             1077 ; 364  |#define HW_DCDC2_CTRL1      (*(volatile dcdc2_ctrl1_type _X*) (HW_DCDC_BASEADDR+6))    /* DcDc#2 Ctrl Register #1 */
                             1078 ; 365  |
                             1079 ; 366  |
                             1080 ; 367  |
                             1081 ; 368  |
                             1082 ; 369  |/////////////////////////////////////////////////////////////////////////////////
                             1083 ; 370  |
                             1084 ; 371  |//  Speed Monitoring Register (HW_SPEED) Bit Definitions
                             1085 ; 372  |
                             1086 ; 373  |#define HW_SPEED_OSC1_PWRUP_WIDTH (1)
                             1087 ; 374  |#define HW_SPEED_OSC1_START_COUNT_WIDTH (1)
                             1088 ; 375  |#define HW_SPEED_RSVD0_WIDTH (2)
                             1089 ; 376  |#define HW_SPEED_RINGOSC1_WIDTH (7)
                             1090 ; 377  |#define HW_SPEED_RSVD1_WIDTH (1)
                             1091 ; 378  |#define HW_SPEED_OSC2_PWRUP_WIDTH (1)
                             1092 ; 379  |#define HW_SPEED_OSC2_START_COUNT_WIDTH (1)
                             1093 ; 380  |#define HW_SPEED_RSVD2_WIDTH (2)
                             1094 ; 381  |#define HW_SPEED_RINGOSC2_WIDTH (7)
                             1095 ; 382  |#define HW_SPEED_RSVD3_WIDTH (1)
                             1096 ; 383  |
                             1097 ; 384  |
                             1098 ; 385  |
                             1099 ; 386  |#define HW_SPEED_OSC1_PWRUP_BITPOS (0)
                             1100 ; 387  |#define HW_SPEED_OSC1_START_COUNT_BITPOS (1)
                             1101 ; 388  |#define HW_SPEED_RINGOSC1_BITPOS (4)
                             1102 ; 389  |#define HW_SPEED_OSC2_PWRUP_BITPOS (12)
                             1103 ; 390  |#define HW_SPEED_OSC2_START_COUNT_BITPOS (13)
                             1104 ; 391  |#define HW_SPEED_RINGOSC2_BITPOS (16)
                             1105 ; 392  |
                             1106 ; 393  |
                             1107 ; 394  |#define HW_SPEED_OSC1_PWRUP_SETMASK (((1<<HW_SPEED_OSC1_PWRUP_WIDTH)-1)<<HW_SPEED_OSC1_PWRUP_BITPOS)        
                             1108 ; 395  |#define HW_SPEED_OSC1_START_COUNT_SETMASK (((1<<HW_SPEED_OSC1_START_COUNT_WIDTH)-1)<<HW_SPEED_OSC1_START_COUNT_BITPOS)        
                             1109 ; 396  |#define HW_SPEED_RINGOSC1_SETMASK (((1<<HW_SPEED_RINGOSC1_WIDTH)-1)<<HW_SPEED_RINGOSC1_BITPOS) 
                             1110 ; 397  |#define HW_SPEED_OSC2_PWRUP_SETMASK (((1<<HW_SPEED_OSC2_PWRUP_WIDTH)-1)<<HW_SPEED_OSC2_PWRUP_BITPOS)        
                             1111 ; 398  |
                             1112 ; 399  |#define HW_SPEED_OSC2_START_COUNT_SETMASK (((1<<HW_SPEED_OSC2_START_COUNT_WIDTH)-1)<<HW_SPEED_OSC2_START_COUNT_BITPOS)        
                             1113 ; 400  |#define HW_SPEED_RINGOSC2_SETMASK (((1<<HW_SPEED_RINGOSC2_WIDTH)-1)<<HW_SPEED_RINGOSC2_BITPOS) 
                             1114 ; 401  |
                             1115 ; 402  |
                             1116 ; 403  |
                             1117 ; 404  |#define HW_SPEED_OSC1_PWRUP_CLRMASK (~(WORD)HW_SPEED_OSC1_PWRUP_SETMASK)     
                             1118 ; 405  |#define HW_SPEED_OSC1_START_COUNT_CLRMASK (~(WORD)HW_SPEED_OSC1_START_COUNT_SETMASK)     
                             1119 ; 406  |#define HW_SPEED_RINGOSC1_CLRMASK (~(WORD)HW_SPEED_RINGOSC1_SETMASK) 
                             1120 ; 407  |#define HW_SPEED_OSC2_PWRUP_CLRMASK (~(WORD)HW_SPEED_OSC2_PWRUP_SETMASK)   
                             1121 ; 408  |#define HW_SPEED_OSC2_START_COUNT_CLRMASK (~(WORD)HW_SPEED_OSC2_START_COUNT_SETMASK)     
                             1122 ; 409  |#define HW_SPEED_RINGOSC2_CLRMASK (~(WORD)HW_SPEED_RINGOSC2_SETMASK) 
                             1123 ; 410  |
                             1124 ; 411  |
                             1125 ; 412  |typedef union               
                             1126 ; 413  |{
                             1127 ; 414  |    struct {
                             1128 ; 415  |        unsigned int OSC1_PWRUP          : HW_SPEED_OSC1_PWRUP_WIDTH;
                             1129 ; 416  |        unsigned int OSC1_START_COUNT    : HW_SPEED_OSC1_START_COUNT_WIDTH;
                             1130 ; 417  |        unsigned int RSVD0               : HW_SPEED_RSVD0_WIDTH;
                             1131 ; 418  |        unsigned int RINGOSC1            : HW_SPEED_RINGOSC1_WIDTH;
                             1132 ; 419  |        unsigned int RSVD1               : HW_SPEED_RSVD1_WIDTH;
                             1133 ; 420  |        unsigned int OSC2_PWRUP          : HW_SPEED_OSC2_PWRUP_WIDTH;
                             1134 ; 421  |        unsigned int OSC2_START_COUNT    : HW_SPEED_OSC2_START_COUNT_WIDTH;
                             1135 ; 422  |        unsigned int RSVD2               : HW_SPEED_RSVD2_WIDTH;
                             1136 ; 423  |        unsigned int RINGOSC2            : HW_SPEED_RINGOSC2_WIDTH;
                             1137 ; 424  |        unsigned int RSVD3               : HW_SPEED_RSVD3_WIDTH;
                             1138 ; 425  |    } B;
                             1139 ; 426  |    unsigned int I;
                             1140 ; 427  |} speed_type;
                             1141 ; 428  |#define HW_SPEED      (*(volatile speed_type _X*) (HW_DCDC_BASEADDR+7))    /* Speed Measurement Register */
                             1142 ; 429  |
                             1143 ; 430  |
                             1144 ; 431  |
                             1145 ; 432  |
                             1146 ; 433  |
                             1147 ; 434  |
                             1148 ; 435  |
                             1149 ; 436  |// DC DC Test Bit Register (HW_DCDCTBR) Definitions
                             1150 ; 437  |#define HW_DCDC_TBR_DCDC1_ADJ_TN_WIDTH 4
                             1151 ; 438  |#define HW_DCDC_TBR_DCDC1_DIS_5BIT_WIDTH 1
                             1152 ; 439  |#define HW_DCDC_TBR_DCDC1_BAT_ADJ_WIDTH 1
                             1153 ; 440  |#define HW_DCDC_TBR_DCDC1_CLK4X_WIDTH 1
                             1154 ; 441  |#define HW_DCDC_TBR_DCDC1_CLK2X_WIDTH 1
                             1155 ; 442  |#define HW_DCDC_TBR_DCDC1_NOZERO_WIDTH 1
                             1156 ; 443  |#define HW_DCDC_TBR_DCDC1_VDD5V_ACTIVE_WIDTH 1
                             1157 ; 444  |#define HW_DCDC_TBR_DCDC1_PFM_WIDTH 1
                             1158 ; 445  |#define HW_DCDC_TBR_DCDC1_STOPCLK_WIDTH 1
                             1159 ; 446  |#define HW_DCDC_TBR_PWRUP_VDDIO_BRNOUT_WIDTH 1
                             1160 ; 447  |#define HW_DCDC_TBR_DCDC_ANA_LESSI_WIDTH 1
                             1161 ; 448  |#define HW_DCDC_TBR_DCDC_MORE_CAP_WIDTH 1
                             1162 ; 449  |#define HW_DCDC_TBR_DCDC_ANA_BGR_BIAS_WIDTH 1
                             1163 ; 450  |#define HW_DCDC_TBR_DCDC1_NEW_SCHEME_WIDTH 1
                             1164 ; 451  |#define HW_DCDC_TBR_DCDC1_HALF_FETS_WIDTH 1
                             1165 ; 452  |#define HW_DCDC_TBR_DCDC2_DIS_5BIT_WIDTH 1
                             1166 ; 453  |#define HW_DCDC_TBR_DCDC2_CLK4X_WIDTH 1
                             1167 ; 454  |#define HW_DCDC_TBR_DCDC2_CLK2X_WIDTH 1
                             1168 ; 455  |#define HW_DCDC_TBR_DCDC2_VDD5V_ACTIVE_WIDTH 1
                             1169 ; 456  |#define HW_DCDC_TBR_DCDC2_PFM_WIDTH 1
                             1170 ; 457  |#define HW_DCDC_TBR_DCDC2_STOPCLK_WIDTH 1
                             1171 ; 458  |
                             1172 ; 459  |#define HW_DCDC_TBR_DCDC1_ADJ_TN_BITPOS (0)
                             1173 ; 460  |#define HW_DCDC_TBR_DCDC1_DIS_5BIT_BITPOS (4)
                             1174 ; 461  |#define HW_DCDC_TBR_DCDC1_BAT_ADJ_BITPOS (5)
                             1175 ; 462  |#define HW_DCDC_TBR_DCDC1_CLK4X_BITPOS (6)
                             1176 ; 463  |#define HW_DCDC_TBR_DCDC1_CLK2X_BITPOS (7)
                             1177 ; 464  |#define HW_DCDC_TBR_DCDC1_NOZERO_BITPOS (8)
                             1178 ; 465  |#define HW_DCDC_TBR_DCDC1_VDD5V_ACTIVE_BITPOS (9)
                             1179 ; 466  |#define HW_DCDC_TBR_DCDC1_PFM_BITPOS (10)
                             1180 ; 467  |#define HW_DCDC_TBR_DCDC1_STOPCLK_BITPOS (11)
                             1181 ; 468  |#define HW_DCDC_TBR_PWRUP_VDDIO_BRNOUT_BITPOS (12)
                             1182 ; 469  |#define HW_DCDC_TBR_DCDC_ANA_LESSI_BITPOS (13)
                             1183 ; 470  |#define HW_DCDC_TBR_DCDC_MORE_CAP_BITPOS (14)
                             1184 ; 471  |#define HW_DCDC_TBR_DCDC_DCDC_ANA_BGR_BIAS_BITPOS (15)
                             1185 ; 472  |#define HW_DCDC_TBR_DCDC1_NEW_SCHEME_BITPOS (16)
                             1186 ; 473  |#define HW_DCDC_TBR_DCDC1_HALF_FETS_BITPOS (17)
                             1187 ; 474  |#define HW_DCDC_TBR_DCDC2_DIS_5BIT_BITPOS (18)
                             1188 ; 475  |#define HW_DCDC_TBR_DCDC2_CLK4X_BITPOS (19)
                             1189 ; 476  |#define HW_DCDC_TBR_DCDC2_CLK2X_BITPOS (20)
                             1190 ; 477  |#define HW_DCDC_TBR_DCDC2_VDD5V_ACTIVE_BITPOS (21)
                             1191 ; 478  |#define HW_DCDC_TBR_DCDC2_PFM_BITPOS (22)
                             1192 ; 479  |#define HW_DCDC_TBR_DCDC2_STOPCLK_BITPOS (23)
                             1193 ; 480  |
                             1194 ; 481  |#define HW_DCDC_TBR_DCDC1_ADJ_TN_SETMASK (((1<<HW_DCDC_TBR_DCDC1_ADJ_TN_WIDTH)-1)<<HW_DCDC_TBR_DCDC1_ADJ_TN_BITPOS)
                             1195 ; 482  |#define HW_DCDC_TBR_DCDC1_BAT_ADJ_SETMASK (((1<<HW_DCDC_TBR_DCDC1_BAT_ADJ_WIDTH)-1)<<HW_DCDC_TBR_DCDC1_BAT_ADJ_BITPOS)
                             1196 ; 483  |#define HW_DCDC_TBR_DCDC_ANA_BGR_BIAS_SETMASK (((1<<HW_DCDC_TBR_DCDC_ANA_BGR_BIAS_WIDTH)-1)<<HW_DCDC_TBR_DCDC_DCDC_ANA_BGR_BIAS_BITPOS)
                             1197 ; 484  |
                             1198 ; 485  |#define HW_DCDC_TBR_DCDC1_ADJ_TN_CLRMASK (~(WORD)HW_DCDC_TBR_DCDC1_ADJ_TN_SETMASK)
                             1199 ; 486  |#define HW_DCDC_TBR_DCDC1_BAT_ADJ_CLRMASK (~(WORD)HW_DCDC_TBR_DCDC1_BAT_ADJ_SETMASK)
                             1200 ; 487  |#define HW_DCDC_TBR_DCDC_ANA_BGR_BIAS_CLRMASK (~(WORD)HW_DCDC_TBR_DCDC_ANA_BGR_BIAS_SETMASK)
                             1201 ; 488  |
                             1202 ; 489  |// Defines for What needs to change to be able to use a higher Core voltage and when the change should happen
                             1203 ; 490  |#define HW_DCDC_VDDD_CHANGE_TBR_CUTOFF_VALUE ((18<<HW_DCDC_VDDD_VOLTAGE_LEVEL_BITPOS)&HW_DCDC_VDDD_VOLTAGE_LEVEL_SETMASK)
                             1204 ; 491  |#define HW_DCDC_TBR_VDDD_HI_VALUE ((1<<HW_DCDC_TBR_DCDC_DCDC_ANA_BGR_BIAS_BITPOS)&HW_DCDC_TBR_DCDC_ANA_BGR_BIAS_SETMASK)
                             1205 ; 492  |#define HW_DCDC_TBR_VDDD_LO_VALUE (((1<<HW_DCDC_TBR_DCDC_DCDC_ANA_BGR_BIAS_BITPOS)&HW_DCDC_TBR_DCDC_ANA_BGR_BIAS_SETMASK)+((2<<HW_DCDC_TBR_DCDC1_ADJ_TN_BITPOS)&HW_DCDC_TBR_DCDC1_ADJ_TN_SETMASK)+((1<<HW_DCDC_TBR_DC
                                  DC1_BAT_ADJ_BITPOS)&HW_DCDC_TBR_DCDC1_BAT_ADJ_SETMASK))
                             1206 ; 493  |
                             1207 ; 494  |typedef union               
                             1208 ; 495  |{
                             1209 ; 496  |    struct {
                             1210 ; 497  |        unsigned int DCDC1_ADJ_TN               : HW_DCDC_TBR_DCDC1_ADJ_TN_WIDTH;
                             1211 ; 498  |        unsigned int DCDC1_DIS_5BIT             : HW_DCDC_TBR_DCDC1_DIS_5BIT_WIDTH;
                             1212 ; 499  |        unsigned int DCDC1_BAT_ADJ              : HW_DCDC_TBR_DCDC1_BAT_ADJ_WIDTH;
                             1213 ; 500  |        unsigned int DCDC1_CLK4X                : HW_DCDC_TBR_DCDC1_CLK4X_WIDTH;
                             1214 ; 501  |        unsigned int DCDC1_CLK2X                : HW_DCDC_TBR_DCDC1_CLK2X_WIDTH;
                             1215 ; 502  |        unsigned int DCDC1_NOZERO               : HW_DCDC_TBR_DCDC1_NOZERO_WIDTH;
                             1216 ; 503  |        unsigned int DCDC1_VDD5V_ACTIVE         : HW_DCDC_TBR_DCDC1_VDD5V_ACTIVE_WIDTH;
                             1217 ; 504  |        unsigned int DCDC1_PFM                  : HW_DCDC_TBR_DCDC1_PFM_WIDTH;
                             1218 ; 505  |        unsigned int DCDC1_STOPCLK              : HW_DCDC_TBR_DCDC1_STOPCLK_WIDTH;
                             1219 ; 506  |        unsigned int PWRUP_VDDIO_BRNOUT         : HW_DCDC_TBR_PWRUP_VDDIO_BRNOUT_WIDTH;
                             1220 ; 507  |        unsigned int DCDC_ANA_LESSI             : HW_DCDC_TBR_DCDC_ANA_LESSI_WIDTH;
                             1221 ; 508  |        unsigned int DCDC_MORE_CAP              : HW_DCDC_TBR_DCDC_MORE_CAP_WIDTH;
                             1222 ; 509  |        unsigned int DCDC_ANA_BGR_BIAS          : HW_DCDC_TBR_DCDC_ANA_BGR_BIAS_WIDTH;
                             1223 ; 510  |        unsigned int DCDC1_NEW_SCHEME           : HW_DCDC_TBR_DCDC1_NEW_SCHEME_WIDTH;
                             1224 ; 511  |        unsigned int DCDC1_HALF_FETS            : HW_DCDC_TBR_DCDC1_HALF_FETS_WIDTH;
                             1225 ; 512  |        unsigned int DCDC2_DIS_5BIT             : HW_DCDC_TBR_DCDC2_DIS_5BIT_WIDTH;
                             1226 ; 513  |        unsigned int DCDC2_CLK4X                : HW_DCDC_TBR_DCDC2_CLK4X_WIDTH;
                             1227 ; 514  |        unsigned int DCDC2_CLK2X                : HW_DCDC_TBR_DCDC2_CLK2X_WIDTH;
                             1228 ; 515  |        unsigned int DCDC2_VDD5V_ACTIVE         : HW_DCDC_TBR_DCDC2_VDD5V_ACTIVE_WIDTH;
                             1229 ; 516  |        unsigned int DCDC2_PFM                  : HW_DCDC_TBR_DCDC2_PFM_WIDTH;
                             1230 ; 517  |        unsigned int DCDC2_STOPCLK              : HW_DCDC_TBR_DCDC2_STOPCLK_WIDTH;
                             1231 ; 518  |    } B;
                             1232 ; 519  |    unsigned int I;
                             1233 ; 520  |} usb_dcdctbr_type;
                             1234 ; 521  |#define HW_DCDC_TBR                     (*(volatile usb_dcdctbr_type _X*) (HW_DCDC_BASEADDR+8))    /* Analog test bit register*/
                             1235 ; 522  |
                             1236 ; 523  |
                             1237 ; 524  |/////////////////////////////////////////////////////////////////////////////////
                             1238 ; 525  |
                             1239 ; 526  |//  Analog Persistent Config (HW_VDD5V_PWR_CHARGE) Bit Definitions
                             1240 ; 527  |
                             1241 ; 528  |#define HW_VDD5V_PWR_CHARGE_BATT_CURRENT_WIDTH (6)
                             1242 ; 529  |#define HW_VDD5V_PWR_CHARGE_RSVD0_WIDTH (2)
                             1243 ; 530  |#define HW_VDD5V_PWR_CHARGE_PWD_WIDTH (1)
                             1244 ; 531  |#define HW_VDD5V_PWR_CHARGE_RES_WIDTH (1)
                             1245 ; 532  |#define HW_VDD5V_PWR_CHARGE_NIMH_WIDTH (1)
                             1246 ; 533  |#define HW_VDD5V_PWR_CHARGE_LI_TYPE_WIDTH (1)
                             1247 ; 534  |#define HW_VDD5V_PWR_CHARGE_DISABLE_ILIMIT_WIDTH (1)
                             1248 ; 535  |#define HW_VDD5V_PWR_CHARGE_PWDN_ON_IOBRNOUT_WIDTH (1)
                             1249 ; 536  |#define HW_VDD5V_PWR_CHARGE_DCANA_LP_WIDTH (1)
                             1250 ; 537  |#define HW_VDD5V_PWR_CHARGE_TEST_USBREGS_WIDTH (1)
                             1251 ; 538  |#define HW_VDD5V_PWR_CHARGE_DRV_BATT_WIDTH (1)
                             1252 ; 539  |#define HW_VDD5V_PWR_CHARGE_SWCHRG_BAT_WIDTH (1)
                             1253 ; 540  |#define HW_VDD5V_PWR_CHARGE_RSVD1_WIDTH (2)
                             1254 ; 541  |#define HW_VDD5V_PWR_CHARGE_VDD5V_PRESENT_WIDTH (1)
                             1255 ; 542  |#define HW_VDD5V_PWR_CHARGE_BATT_INFO_WIDTH (2)
                             1256 ; 543  |#define HW_VDD5V_PWR_CHARGE_RSVD2_WIDTH (3)
                             1257 ; 544  |
                             1258 ; 545  |#define HW_VDD5V_PWR_CHARGE_BATT_CURRENT_BITPOS (0)
                             1259 ; 546  |#define HW_VDD5V_PWR_CHARGE_PWD_BITPOS (8)
                             1260 ; 547  |#define HW_VDD5V_PWR_CHARGE_RES_BITPOS (9)
                             1261 ; 548  |#define HW_VDD5V_PWR_CHARGE_NIMH_BITPOS (10)
                             1262 ; 549  |
                             1263 ; 550  |#define HW_VDD5V_PWR_CHARGE_LI_TYPE_BITPOS (11)
                             1264 ; 551  |#define HW_VDD5V_PWR_CHARGE_DISABLE_ILIMIT_BITPOS (12)
                             1265 ; 552  |#define HW_VDD5V_PWR_CHARGE_PWDN_ON_IOBRNOUT_BITPOS (13)
                             1266 ; 553  |#define HW_VDD5V_PWR_CHARGE_DCANA_LP_BITPOS (14)
                             1267 ; 554  |#define HW_VDD5V_PWR_CHARGE_TEST_USBREGS_BITPOS (15)
                             1268 ; 555  |#define HW_VDD5V_PWR_CHARGE_DRV_BATT_BITPOS (16)
                             1269 ; 556  |#define HW_VDD5V_PWR_CHARGE_SWCHRG_BAT_BITPOS (17)
                             1270 ; 557  |#define HW_VDD5V_PWR_CHARGE_VDD5V_PRESENT_BITPOS (20)
                             1271 ; 558  |#define HW_VDD5V_PWR_CHARGE_BATT_INFO_BITPOS (21)
TASKING DSP2410 assembler v1.5r1 Build 138 SN 00100122
                                                                                                                                                                                                                                                       Page   6

M:ADDR CODE           CYCLES LINE SOURCELINE
                             1272 ; 559  |
                             1273 ; 560  |#define HW_VDD5V_PWR_CHARGE_BATT_CURRENT_SETMASK (((1<<HW_VDD5V_PWR_CHARGE_BATT_CURRENT_WIDTH)-1)<<HW_VDD5V_PWR_CHARGE_BATT_CURRENT_BITPOS)        
                             1274 ; 561  |#define HW_VDD5V_PWR_CHARGE_PWD_SETMASK (((1<<HW_VDD5V_PWR_CHARGE_PWD_WIDTH)-1)<<HW_VDD5V_PWR_CHARGE_PWD_BITPOS)        
                             1275 ; 562  |#define HW_VDD5V_PWR_CHARGE_RES_SETMASK (((1<<HW_VDD5V_PWR_CHARGE_RES_WIDTH)-1)<<HW_VDD5V_PWR_CHARGE_RES_BITPOS) 
                             1276 ; 563  |#define HW_VDD5V_PWR_CHARGE_NIMH_SETMASK (((1<<HW_VDD5V_PWR_CHARGE_NIMH_WIDTH)-1)<<HW_VDD5V_PWR_CHARGE_NIMH_BITPOS) 
                             1277 ; 564  |#define HW_VDD5V_PWR_CHARGE_LI_TYPE_SETMASK (((1<<HW_VDD5V_PWR_CHARGE_LI_TYPE_WIDTH)-1)<<HW_VDD5V_PWR_CHARGE_LI_TYPE_BITPOS) 
                             1278 ; 565  |#define HW_VDD5V_PWR_CHARGE_DISABLE_ILIMIT_SETMASK (((1<<HW_VDD5V_PWR_CHARGE_DISABLE_ILIMIT_WIDTH)-1)<<HW_VDD5V_PWR_CHARGE_DISABLE_ILIMIT_BITPOS)        
                             1279 ; 566  |#define HW_VDD5V_PWR_CHARGE_PWDN_ON_IOBRNOUT_SETMASK (((1<<HW_VDD5V_PWR_CHARGE_PWDN_ON_IOBRNOUT_WIDTH)-1)<<HW_VDD5V_PWR_CHARGE_PWDN_ON_IOBRNOUT_BITPOS)        
                             1280 ; 567  |#define HW_VDD5V_PWR_CHARGE_DCANA_LP_SETMASK (((1<<HW_VDD5V_PWR_CHARGE_DCANA_LP_WIDTH)-1)<<HW_VDD5V_PWR_CHARGE_DCANA_LP_BITPOS) 
                             1281 ; 568  |#define HW_VDD5V_PWR_CHARGE_TEST_USBREGS_SETMASK (((1<<HW_VDD5V_PWR_CHARGE_TEST_USBREGS_WIDTH)-1)<<HW_VDD5V_PWR_CHARGE_TEST_USBREGS_BITPOS) 
                             1282 ; 569  |#define HW_VDD5V_PWR_CHARGE_DRV_BATT_SETMASK (((1<<HW_VDD5V_PWR_CHARGE_DRV_BATT_WIDTH)-1)<<HW_VDD5V_PWR_CHARGE_DRV_BATT_BITPOS) 
                             1283 ; 570  |#define HW_VDD5V_PWR_CHARGE_SWCHRG_BAT_SETMASK (((1<<HW_VDD5V_PWR_CHARGE_SWCHRG_BAT_WIDTH)-1)<<HW_VDD5V_PWR_CHARGE_SWCHRG_BAT_BITPOS) 
                             1284 ; 571  |#define HW_VDD5V_PWR_CHARGE_VDD5V_PRESENT_SETMASK (((1<<HW_VDD5V_PWR_CHARGE_VDD5V_PRESENT_WIDTH)-1)<<HW_VDD5V_PWR_CHARGE_VDD5V_PRESENT_BITPOS) 
                             1285 ; 572  |#define HW_VDD5V_PWR_CHARGE_BATT_INFO_SETMASK (((1<<HW_VDD5V_PWR_CHARGE_BATT_INFO_WIDTH)-1)<<HW_VDD5V_PWR_CHARGE_BATT_INFO_BITPOS) 
                             1286 ; 573  |
                             1287 ; 574  |
                             1288 ; 575  |#define HW_VDD5V_PWR_CHARGE_BATT_CURRENT_CLRMASK (~(WORD)HW_VDD5V_PWR_CHARGE_BATT_CURRENT_SETMASK)     
                             1289 ; 576  |#define HW_VDD5V_PWR_CHARGE_PWD_CLRMASK (~(WORD)HW_VDD5V_PWR_CHARGE_PWD_SETMASK)     
                             1290 ; 577  |#define HW_VDD5V_PWR_CHARGE_RES_CLRMASK (~(WORD)HW_VDD5V_PWR_CHARGE_RES_SETMASK) 
                             1291 ; 578  |#define HW_VDD5V_PWR_CHARGE_NIMH_CLRMASK (~(WORD)HW_VDD5V_PWR_CHARGE_NIMH_SETMASK) 
                             1292 ; 579  |#define HW_VDD5V_PWR_CHARGE_LI_TYPE_CLRMASK (~(WORD)HW_VDD5V_PWR_CHARGE_LI_TYPE_SETMASK) 
                             1293 ; 580  |#define HW_VDD5V_PWR_CHARGE_DISABLE_ILIMIT_CLRMASK (~(WORD)HW_VDD5V_PWR_CHARGE_DISABLE_ILIMIT_SETMASK)     
                             1294 ; 581  |#define HW_VDD5V_PWR_CHARGE_PWDN_ON_IOBRNOUT_CLRMASK (~(WORD)HW_VDD5V_PWR_CHARGE_PWDN_ON_IOBRNOUT_SETMASK)     
                             1295 ; 582  |#define HW_VDD5V_PWR_CHARGE_DCANA_LP_CLRMASK (~(WORD)HW_VDD5V_PWR_CHARGE_DCANA_LP_SETMASK) 
                             1296 ; 583  |#define HW_VDD5V_PWR_CHARGE_TEST_USBREGS_CLRMASK (~(WORD)HW_VDD5V_PWR_CHARGE_TEST_USBREGS_SETMASK) 
                             1297 ; 584  |#define HW_VDD5V_PWR_CHARGE_DRV_BATT_CLRMASK (~(WORD)HW_VDD5V_PWR_CHARGE_DRV_BATT_SETMASK) 
                             1298 ; 585  |#define HW_VDD5V_PWR_CHARGE_SWCHRG_BAT_CLRMASK (~(WORD)HW_VDD5V_PWR_CHARGE_SWCHRG_BAT_SETMASK) 
                             1299 ; 586  |#define HW_VDD5V_PWR_CHARGE_VDD5V_PRESENT_CLRMASK (~(WORD)HW_VDD5V_PWR_CHARGE_VDD5V_PRESENT_SETMASK) 
                             1300 ; 587  |#define HW_VDD5V_PWR_CHARGE_BATT_INFO_CLRMASK (~(WORD)HW_VDD5V_PWR_CHARGE_BATT_INFO_SETMASK) 
                             1301 ; 588  |
                             1302 ; 589  |typedef union               
                             1303 ; 590  |{
                             1304 ; 591  |    struct {
                             1305 ; 592  |        unsigned int BATT_CURRENT               : HW_VDD5V_PWR_CHARGE_BATT_CURRENT_WIDTH;
                             1306 ; 593  |        unsigned int RSVD0                      : HW_VDD5V_PWR_CHARGE_RSVD0_WIDTH;
                             1307 ; 594  |        unsigned int PWD                        : HW_VDD5V_PWR_CHARGE_PWD_WIDTH;
                             1308 ; 595  |        unsigned int RES                        : HW_VDD5V_PWR_CHARGE_RES_WIDTH;
                             1309 ; 596  |        unsigned int NIMH                       : HW_VDD5V_PWR_CHARGE_NIMH_WIDTH;
                             1310 ; 597  |        unsigned int LI_TYPE                    : HW_VDD5V_PWR_CHARGE_LI_TYPE_WIDTH;
                             1311 ; 598  |        unsigned int DISABLE_ILIMIT             : HW_VDD5V_PWR_CHARGE_DISABLE_ILIMIT_WIDTH;
                             1312 ; 599  |        unsigned int PWDN_ON_IOBRNOUT           : HW_VDD5V_PWR_CHARGE_PWDN_ON_IOBRNOUT_WIDTH;
                             1313 ; 600  |        unsigned int DCANA_LP                   : HW_VDD5V_PWR_CHARGE_DCANA_LP_WIDTH;
                             1314 ; 601  |        unsigned int TEST_USBREGS               : HW_VDD5V_PWR_CHARGE_TEST_USBREGS_WIDTH;
                             1315 ; 602  |        unsigned int DRV_BATT                   : HW_VDD5V_PWR_CHARGE_DRV_BATT_WIDTH;
                             1316 ; 603  |        unsigned int SWCHRG_BAT                 : HW_VDD5V_PWR_CHARGE_SWCHRG_BAT_WIDTH;
                             1317 ; 604  |        unsigned int RSVD1                      : HW_VDD5V_PWR_CHARGE_RSVD1_WIDTH;
                             1318 ; 605  |        unsigned int VDD5V_PRESENT              : HW_VDD5V_PWR_CHARGE_VDD5V_PRESENT_WIDTH;
                             1319 ; 606  |        unsigned int RSVD2                      : HW_VDD5V_PWR_CHARGE_RSVD2_WIDTH;
                             1320 ; 607  |    } B;
                             1321 ; 608  |    unsigned int I;
                             1322 ; 609  |} usb_pwr_charge_type;
                             1323 ; 610  |#define HW_VDD5V_PWR_CHARGE      (*(volatile usb_pwr_charge_type _X*) (HW_DCDC_BASEADDR+17))    /* Analog Persistent Config Register */
                             1324 ; 611  |
                             1325 ; 612  |#define HW_DCDC_PERSIST_AUTO_RESTART_STAT_WIDTH 1
                             1326 ; 613  |#define HW_DCDC_PERSIST_DELAY_5V_AUTO_RESTART_STAT_WIDTH 1
                             1327 ; 614  |#define HW_DCDC_PERSIST_UPDATE_WIDTH 1
                             1328 ; 615  |#define HW_DCDC_PERSIST_AUTO_RESTART_WIDTH 1
                             1329 ; 616  |#define HW_DCDC_PERSIST_DELAY_5V_AUTO_RESTART_WIDTH 1
                             1330 ; 617  |#define HW_DCDC_PERSIST_LOW_BATT_TYPE_WIDTH 1
                             1331 ; 618  |#define HW_DCDC_PERSIST_LOW_BATTERY_ENABLE_WIDTH 1
                             1332 ; 619  |#define HW_DCDC_PERSIST_SLEEP_XTAL_ENABLE_WIDTH 1
                             1333 ; 620  |#define HW_DCDC_PERSIST_XTAL_TRIM1_WIDTH 1
                             1334 ; 621  |#define HW_DCDC_PERSIST_XTAL_TRIM0_WIDTH 1
                             1335 ; 622  |#define HW_DCDC_PERSIST_XTAL_BIAS_DOWN1_WIDTH 1
                             1336 ; 623  |#define HW_DCDC_PERSIST_XTAL_BIAS_DOWN0_WIDTH 1
                             1337 ; 624  |#define HW_DCDC_PERSIST_XTAL_TRM_ENABLE_WIDTH 1
                             1338 ; 625  |#define HW_DCDC_PERSIST_RSRVD_WIDTH 2
                             1339 ; 626  |
                             1340 ; 627  |#define HW_DCDC_PERSIST_AUTO_RESTART_STAT_BITPOS 12
                             1341 ; 628  |#define HW_DCDC_PERSIST_DELAY_5V_AUTO_RESTART_STAT_BITPOS 11
                             1342 ; 629  |#define HW_DCDC_PERSIST_UPDATE_BITPOS 10
                             1343 ; 630  |#define HW_DCDC_PERSIST_AUTO_RESTART_BITPOS 9
                             1344 ; 631  |#define HW_DCDC_PERSIST_DELAY_5V_AUTO_RESTART_BITPOS 8 
                             1345 ; 632  |#define HW_DCDC_PERSIST_LOW_BATT_TYPE_BITPOS 7
                             1346 ; 633  |#define HW_DCDC_PERSIST_LOW_BATTERY_ENABLE_BITPOS 6
                             1347 ; 634  |#define HW_DCDC_PERSIST_SLEEP_XTAL_ENABLE_BITPOS 5
                             1348 ; 635  |#define HW_DCDC_PERSIST_XTAL_TRIM1_BITPOS 4
                             1349 ; 636  |#define HW_DCDC_PERSIST_XTAL_TRIM0_BITPOS 3
                             1350 ; 637  |#define HW_DCDC_PERSIST_XTAL_BIAS_DOWN1_BITPOS 2
                             1351 ; 638  |#define HW_DCDC_PERSIST_XTAL_BIAS_DOWN0_BITPOS 1
                             1352 ; 639  |#define HW_DCDC_PERSIST_XTAL_TRM_ENABLE_BITPOS 0
                             1353 ; 640  |
                             1354 ; 641  |typedef union               
                             1355 ; 642  |{
                             1356 ; 643  |    struct {       
                             1357 ; 644  |       int XTAL_TRM_ENABLE             : HW_DCDC_PERSIST_XTAL_TRM_ENABLE_WIDTH;
                             1358 ; 645  |       int XTAL_BIAS_DOWN0             : HW_DCDC_PERSIST_XTAL_BIAS_DOWN0_WIDTH;
                             1359 ; 646  |       int XTAL_BIAS_DOWN1             : HW_DCDC_PERSIST_XTAL_BIAS_DOWN1_WIDTH;
                             1360 ; 647  |       int XTAL_TRIM0                  : HW_DCDC_PERSIST_XTAL_TRIM0_WIDTH;
                             1361 ; 648  |       int XTAL_TRIM1                  : HW_DCDC_PERSIST_XTAL_TRIM1_WIDTH;
                             1362 ; 649  |       int SLEEP_XTAL_ENABLE           : HW_DCDC_PERSIST_SLEEP_XTAL_ENABLE_WIDTH;
                             1363 ; 650  |       int LOW_BATTERY_ENABLE          : HW_DCDC_PERSIST_LOW_BATTERY_ENABLE_WIDTH;
                             1364 ; 651  |       int LOW_BATT_TYPE               : HW_DCDC_PERSIST_LOW_BATT_TYPE_WIDTH;
                             1365 ; 652  |       int DELAY_5V_AUTO_RESTART       : HW_DCDC_PERSIST_DELAY_5V_AUTO_RESTART_WIDTH;
                             1366 ; 653  |       int AUTO_RESTART                : HW_DCDC_PERSIST_AUTO_RESTART_WIDTH;
                             1367 ; 654  |       int UPDATE                      : HW_DCDC_PERSIST_UPDATE_WIDTH;
                             1368 ; 655  |       int DELAY_5V_AUTO_RESTART_STAT  : HW_DCDC_PERSIST_DELAY_5V_AUTO_RESTART_STAT_WIDTH;
                             1369 ; 656  |       int AUTO_RESTART_STAT           : HW_DCDC_PERSIST_AUTO_RESTART_STAT_WIDTH;
                             1370 ; 657  |       int RSRVD                       : HW_DCDC_PERSIST_RSRVD_WIDTH;
                             1371 ; 658  |    } B;
                             1372 ; 659  |    int I;
                             1373 ; 660  |} usb_dcdcpersist_type;
                             1374 ; 661  |#define HW_DCDC_PERSIST                (*(volatile usb_dcdcpersist_type _X*) (HW_DCDC_BASEADDR+15))    /* Analog test bit register*/
                             1375 ; 662  |
                             1376 ; 663  |
                             1377 ; 664  |
                             1378 ; 665  |#endif
                             1379 ; 666  |
                             1380 ; 667  |
                             1381 ; 668  |
                             1382 
                             1384 
                             1385 ; 15   |#include "misc.h"
                             1386 
                             1388 
                             1389 ; 1    |////////////////////////////////////////////////////////////////////////////////
                             1390 ; 2    |// Copyright(C) SigmaTel, Inc. 2002
                             1391 ; 3    |//
                             1392 ; 4    |// Filename: misc.h
                             1393 ; 5    |// Description: 
                             1394 ; 6    |////////////////////////////////////////////////////////////////////////////////
                             1395 ; 7    |
                             1396 ; 8    |#ifndef _MISC_H
                             1397 ; 9    |#define _MISC_H
                             1398 ; 10   |
                             1399 ; 11   |////////////////////////////////////////////////////////////////////////////////
                             1400 ; 12   |// Defs
                             1401 ; 13   |////////////////////////////////////////////////////////////////////////////////
                             1402 ; 14   |
                             1403 ; 15   |////////////////////////////////////////////////////////////////////////////////
                             1404 ; 16   |// Error codes
                             1405 ; 17   |////////////////////////////////////////////////////////////////////////////////
                             1406 ; 18   |
                             1407 ; 19   |////////////////////////////////////////////////////////////////////////////////
                             1408 ; 20   |// Typedefs
                             1409 ; 21   |////////////////////////////////////////////////////////////////////////////////
                             1410 ; 22   |
                             1411 ; 23   |////////////////////////////////////////////////////////////////////////////////
                             1412 ; 24   |// Prototypes
                             1413 ; 25   |////////////////////////////////////////////////////////////////////////////////
                             1414 ; 26   |
                             1415 ; 27   |RETCODE PowerInit(void);
                             1416 ; 28   |RETCODE PllInit(void);
                             1417 ; 29   |RETCODE _reentrant SystemShutdown(void);
                             1418 ; 30   |RETCODE _reentrant SysGpioDisableAll(void);
                             1419 ; 31   |RETCODE _reentrant SysPadPowerDownAll(void);
                             1420 ; 32   |RETCODE _reentrant SysPllShutdown(void);
                             1421 ; 33   |RETCODE GoToSleep(void);
                             1422 ; 34   |void _reentrant SysDelayMs(WORD wDelay);
                             1423 ; 35   |DWORD GetDclkCount(void);
                             1424 ; 36   |#ifdef USE_PLAYLIST2
                             1425 ; 37   |DWORD GetDclkCount_PL2(void);
                             1426 ; 38   |#endif
                             1427 ; 39   |void SetDclkCount(DWORD dwCount);
                             1428 ; 40   |RETCODE SmartMediaSetPortTiming(WORD wTiming);
                             1429 ; 41   |RETCODE ProgramPll(INT iSpeed);
                             1430 ; 42   |void _reentrant SystemReset(void);
                             1431 ; 43   |void _reentrant SystemPowerOff(void);
                             1432 ; 44   |void _reentrant ReconfigureAsDcc(void);
                             1433 ; 45   |void _reentrant PowerDownFMTuners(void);
                             1434 ; 46   |#ifdef TUNER_5767
                             1435 ; 47   |void _reentrant  Philips5767_3WireWriteByte(INT data);
                             1436 ; 48   |void _reentrant Philips5767_3WireClockDelay(void);
                             1437 ; 49   |#endif
                             1438 ; 50   |extern BOOL g_bPowerOff;
                             1439 ; 51   |
                             1440 ; 52   |#ifndef DISABLE_USB_CURRENT_REQUIREMENT_FOR_MMC_DRIVER
                             1441 ; 53   |extern int g_iHighPwrPeriphInitMode; // def in usbmscmisc.c
                             1442 ; 54   | #define STRUCTURE_INIT_ONLY                            2
                             1443 ; 55   | #define USB_HIGH_CURRENT_GRANTED                       3
                             1444 ; 56   |#endif
                             1445 ; 57   |
                             1446 ; 58   |#endif // #ifndef _MISC_H
                             1447 
                             1449 
                             1450 ; 16   |#include "exec.h"
                             1451 
                             1453 
                             1454 ; 1    |#ifndef EXEC_H
                             1455 ; 2    |#define EXEC_H
                             1456 ; 3    |
                             1457 ; 4    |
                             1458 ; 5    |void _reentrant SysPostMessage(int iLength,...);
                             1459 ; 6    |int _asmfunc GetMessage(struct MessageQueueDescriptor*,struct CMessage * );
                             1460 ; 7    |long _asmfunc SysGetCurrentTime(void);
                             1461 ; 8    |
                             1462 ; 9    |
                             1463 ; 10   |#endif
                             1464 
                             1466 
                             1467 ; 17   |#include "regsgpio.h"
                             1468 
                             1470 
                             1471 ; 1    |#if !(defined(__REGS_GPIO_INC))
                             1472 ; 2    |#define __REGS_GPIO_INC 1
                             1473 ; 3    |
                             1474 ; 4    |#include "types.h"
                             1475 
                             1477 
                             1478 ; 1    |////////////////////////////////////////////////////////////////////////////////
                             1479 ; 2    |// Copyright(C) SigmaTel, Inc. 2000-2004
                             1480 ; 3    |//
                             1481 ; 4    |// Filename: types.h
                             1482 ; 5    |// Description: Standard data types
                             1483 ; 6    |////////////////////////////////////////////////////////////////////////////////
                             1484 ; 7    |
                             1485 ; 8    |#ifndef _TYPES_H
                             1486 ; 9    |#define _TYPES_H
                             1487 ; 10   |
                             1488 ; 11   |// TODO:  move this outta here!
                             1489 ; 12   |#if !defined(NOERROR)
                             1490 ; 13   |#define NOERROR 0
                             1491 ; 14   |#define SUCCESS 0
                             1492 ; 15   |#endif 
                             1493 ; 16   |#if !defined(SUCCESS)
                             1494 ; 17   |#define SUCCESS  0
                             1495 ; 18   |#endif
                             1496 ; 19   |#if !defined(ERROR)
                             1497 ; 20   |#define ERROR   -1
                             1498 ; 21   |#endif
                             1499 ; 22   |#if !defined(FALSE)
                             1500 ; 23   |#define FALSE 0
                             1501 ; 24   |#endif
                             1502 ; 25   |#if !defined(TRUE)
                             1503 ; 26   |#define TRUE  1
                             1504 ; 27   |#endif
                             1505 ; 28   |
                             1506 ; 29   |#if !defined(NULL)
                             1507 ; 30   |#define NULL 0
                             1508 ; 31   |#endif
                             1509 ; 32   |
                             1510 ; 33   |#define MAX_INT     0x7FFFFF
                             1511 ; 34   |#define MAX_LONG    0x7FFFFFffffff
                             1512 ; 35   |        // max positive unsigned long value: -1 == 0xFFFFFFffffff
                             1513 ; 36   |#define MAX_ULONG   (-1) 
                             1514 ; 37   |
                             1515 ; 38   |#define WORD_SIZE   24              // word size in bits
                             1516 ; 39   |#define BYTES_PER_WORD 3            // 8 bit bytes
                             1517 ; 40   |
                             1518 ; 41   |
                             1519 ; 42   |#define BYTE    unsigned char       // btVarName
                             1520 ; 43   |#define CHAR    signed char         // cVarName
                             1521 ; 44   |#define USHORT  unsigned short      // usVarName
                             1522 ; 45   |#define SHORT   unsigned short      // sVarName
                             1523 ; 46   |#define WORD    unsigned int        // wVarName
                             1524 ; 47   |#define INT     signed int          // iVarName
                             1525 ; 48   |#define DWORD   unsigned long       // dwVarName
                             1526 ; 49   |#define LONG    signed long         // lVarName
                             1527 ; 50   |#define BOOL    unsigned int        // bVarName
                             1528 ; 51   |#define FRACT   _fract              // frVarName
                             1529 ; 52   |#define LFRACT  long _fract         // lfrVarName
TASKING DSP2410 assembler v1.5r1 Build 138 SN 00100122
                                                                                                                                                                                                                                                       Page   7

M:ADDR CODE           CYCLES LINE SOURCELINE
                             1530 ; 53   |#define CIRC    _circ               // cp<type prefix>VarName (see below)
                             1531 ; 54   |#define FLOAT   float               // fVarName
                             1532 ; 55   |#define DBL     double              // dVarName
                             1533 ; 56   |#define ENUM    enum                // eVarName
                             1534 ; 57   |#define CMX     _complex            // cmxVarName
                             1535 ; 58   |typedef WORD UCS3;                   // 
                             1536 ; 59   |
                             1537 ; 60   |#define UINT16  unsigned short
                             1538 ; 61   |#define UINT8   unsigned char   
                             1539 ; 62   |#define UINT32  unsigned long
                             1540 ; 63   |#define UINT64  unsigned long   // need to figure out how to do 64 bit values.  Or port exisiting code to only use 48 bit
                             1541 ; 64   |#define INT64   unsigned long   // need to figure out how to do 64 bit values.  Or port exisiting code to only use 48 bit
                             1542 ; 65   |#define WCHAR   UINT16
                             1543 ; 66   |
                             1544 ; 67   |//UINT128 is 16 bytes or 6 words
                             1545 ; 68   |typedef struct UINT128_3500 {   
                             1546 ; 69   |    int val[6];     
                             1547 ; 70   |} UINT128_3500;
                             1548 ; 71   |
                             1549 ; 72   |#define UINT128   UINT128_3500
                             1550 ; 73   |
                             1551 ; 74   |// Little endian word packed byte strings:   
                             1552 ; 75   |//      _packed BYTE bTextVarName[]="a string";  bText is a packed byte string prefix
                             1553 ; 76   |// Convert to big endian words by reordering bytes from high to low using swizzle.
                             1554 ; 77   |// Little endian word packed byte strings:   
                             1555 ; 78   |//      _packed BYTE bTextVarName[]="a string";  bText is a packed byte string prefix
                             1556 ; 79   |// Convert to big endian words by reordering bytes from high to low using swizzle.
                             1557 ; 80   |
                             1558 ; 81   |// Declare Memory Spaces To Use When Coding
                             1559 ; 82   |// A. Sector Buffers
                             1560 ; 83   |#define SECTOR_BUFFER_MEM_X _X
                             1561 ; 84   |#define SECTOR_BUFFER_MEM_Y _Y
                             1562 ; 85   |#define SECTOR_BUFFER_MEM SECTOR_BUFFER_MEM_X
                             1563 ; 86   |typedef WORD SECTOR_BUFFER_MEM SECTOR_BUFFER;
                             1564 ; 87   |typedef SECTOR_BUFFER * P_SECTOR_BUFFER;
                             1565 ; 88   |// B. Media DDI Memory
                             1566 ; 89   |#define MEDIA_DDI_MEM _Y
                             1567 ; 90   |
                             1568 ; 91   |
                             1569 ; 92   |
                             1570 ; 93   |// Pointers to linear structures are labeled as: p<type prefix>VarName
                             1571 ; 94   |// Examples of circular pointers:
                             1572 ; 95   |//    INT CIRC cpiVarName
                             1573 ; 96   |//    DWORD CIRC cpdwVarName
                             1574 ; 97   |
                             1575 ; 98   |#define RETCODE INT                 // rcVarName
                             1576 ; 99   |
                             1577 ; 100  |// generic bitfield structure
                             1578 ; 101  |struct Bitfield {
                             1579 ; 102  |    unsigned int B0  :1;
                             1580 ; 103  |    unsigned int B1  :1;
                             1581 ; 104  |    unsigned int B2  :1;
                             1582 ; 105  |    unsigned int B3  :1;
                             1583 ; 106  |    unsigned int B4  :1;
                             1584 ; 107  |    unsigned int B5  :1;
                             1585 ; 108  |    unsigned int B6  :1;
                             1586 ; 109  |    unsigned int B7  :1;
                             1587 ; 110  |    unsigned int B8  :1;
                             1588 ; 111  |    unsigned int B9  :1;
                             1589 ; 112  |    unsigned int B10 :1;
                             1590 ; 113  |    unsigned int B11 :1;
                             1591 ; 114  |    unsigned int B12 :1;
                             1592 ; 115  |    unsigned int B13 :1;
                             1593 ; 116  |    unsigned int B14 :1;
                             1594 ; 117  |    unsigned int B15 :1;
                             1595 ; 118  |    unsigned int B16 :1;
                             1596 ; 119  |    unsigned int B17 :1;
                             1597 ; 120  |    unsigned int B18 :1;
                             1598 ; 121  |    unsigned int B19 :1;
                             1599 ; 122  |    unsigned int B20 :1;
                             1600 ; 123  |    unsigned int B21 :1;
                             1601 ; 124  |    unsigned int B22 :1;
                             1602 ; 125  |    unsigned int B23 :1;
                             1603 ; 126  |};
                             1604 ; 127  |
                             1605 ; 128  |union BitInt {
                             1606 ; 129  |        struct Bitfield B;
                             1607 ; 130  |        int        I;
                             1608 ; 131  |};
                             1609 ; 132  |
                             1610 ; 133  |#define MAX_MSG_LENGTH 10
                             1611 ; 134  |struct CMessage
                             1612 ; 135  |{
                             1613 ; 136  |        unsigned int m_uLength;
                             1614 ; 137  |        unsigned int m_uMsg[MAX_MSG_LENGTH];
                             1615 ; 138  |};
                             1616 ; 139  |
                             1617 ; 140  |typedef struct {
                             1618 ; 141  |    WORD m_wLength;
                             1619 ; 142  |    WORD m_wMessage;
                             1620 ; 143  |    WORD m_wParams[MAX_MSG_LENGTH];
                             1621 ; 144  |} Message;
                             1622 ; 145  |
                             1623 ; 146  |struct MessageQueueDescriptor
                             1624 ; 147  |{
                             1625 ; 148  |        int *m_pBase;
                             1626 ; 149  |        int m_iModulo;
                             1627 ; 150  |        int m_iSize;
                             1628 ; 151  |        int *m_pHead;
                             1629 ; 152  |        int *m_pTail;
                             1630 ; 153  |};
                             1631 ; 154  |
                             1632 ; 155  |struct ModuleEntry
                             1633 ; 156  |{
                             1634 ; 157  |    int m_iSignaledEventMask;
                             1635 ; 158  |    int m_iWaitEventMask;
                             1636 ; 159  |    int m_iResourceOfCode;
                             1637 ; 160  |    struct MessageQueueDescriptor *m_pMessageQueue;
                             1638 ; 161  |    int _asmfunc (*m_pProcessEntryPoint)(union WaitMask Signals,struct MessageQueueDescriptor *);
                             1639 ; 162  |    int _asmfunc (*m_pInitFunction)(struct MessageQueueDescriptor *);
                             1640 ; 163  |    int m_uTimeOutHigh;
                             1641 ; 164  |    int m_uTimeOutLow;
                             1642 ; 165  |    int _asmfunc (*m_pBackgroundFunction)(struct MessageQueueDescriptor *);
                             1643 ; 166  |};
                             1644 ; 167  |
                             1645 ; 168  |union WaitMask{
                             1646 ; 169  |    struct B{
                             1647 ; 170  |        unsigned int m_bNone     :1;
                             1648 ; 171  |        unsigned int m_bMessage  :1;
                             1649 ; 172  |        unsigned int m_bTimer    :1;
                             1650 ; 173  |        unsigned int m_bButton   :1;
                             1651 ; 174  |    } B;
                             1652 ; 175  |    int I;
                             1653 ; 176  |} ;
                             1654 ; 177  |
                             1655 ; 178  |
                             1656 ; 179  |struct Button {
                             1657 ; 180  |        WORD wButtonEvent;
                             1658 ; 181  |        WORD wUnused[MAX_MSG_LENGTH];   
                             1659 ; 182  |};
                             1660 ; 183  |
                             1661 ; 184  |struct Message {
                             1662 ; 185  |        WORD wMsgLength;
                             1663 ; 186  |        WORD wMsgCommand;
                             1664 ; 187  |        WORD wMsgParms[MAX_MSG_LENGTH-1];
                             1665 ; 188  |};
                             1666 ; 189  |
                             1667 ; 190  |union EventTypes {
                             1668 ; 191  |        struct CMessage msg;
                             1669 ; 192  |        struct Button Button ;
                             1670 ; 193  |        struct Message Message;
                             1671 ; 194  |};
                             1672 ; 195  |
                             1673 ; 196  |// next 2 used to get updater build to return correct protocol ver in scsi response.
                             1674 ; 197  |#define BUILD_TYPE_UPDATER  0x100
                             1675 ; 198  |#define BUILD_TYPE_HOSTLINK 0x101
                             1676 ; 199  |#define BUILD_TYPE_PLAYER   0x102
                             1677 ; 200  |
                             1678 ; 201  |// Resets part if RETAIL build. DEBUG build executes debug instruction to halt.
                             1679 ; 202  |#define SystemHalt() __asm(" include 'sysmacro.asm' \n error") 
                             1680 ; 203  |#define assert(x)    if(!(x)) __asm(" include 'sysmacro.asm' \n error")
                             1681 ; 204  |
                             1682 ; 205  |#if DEBUG
                             1683 ; 206  |// For DEBUG builds, DebugBuildAssert(condition) halts if condition evaluates to FALSE. 
                             1684 ; 207  |#define DebugBuildAssert(x)    if(!(x)) __asm(" debug ")
                             1685 ; 208  |#else 
                             1686 ; 209  |// For RETAIL builds, DebugBuildAssert(condition) does nothing & execution continues rather than halt or reset. 
                             1687 ; 210  |#define DebugBuildAssert(x)    
                             1688 ; 211  |#endif
                             1689 ; 212  |
                             1690 ; 213  |// Do this in your C files to make a reminder that's displayed during the build.
                             1691 ; 214  |//  #pragma asm
                             1692 ; 215  |//  WARN 'Note to builder: reminder to do this after verifying that'
                             1693 ; 216  |//  #pragma endasm
                             1694 ; 217  |
                             1695 ; 218  |
                             1696 ; 219  |#ifdef COLOR_262K
                             1697 ; 220  |#define RGB(r,g,b)    ((0x0000FC & (r)) << 10) | ((0x0000FC & (g)) << 4) | ((0x0000FC & (b)) >> 2)    //262k
                             1698 ; 221  |#elif defined(COLOR_65K)
                             1699 ; 222  |#define RGB(r,g,b)    ((0x0000F8 & (r)) << 8) | ((0x0000FC & (g)) << 3) | ((0x0000F8 & (b)) >> 3)  //65k
                             1700 ; 223  |#else
                             1701 ; 224  |#define RGB(r,g,b)       ((0x0000F0 & (r)) << 4) | (0x0000F0 & (g)) | ((0x0000F0 & (b)) >> 4)
                             1702 ; 225  |#endif
                             1703 ; 226  |    
                             1704 ; 227  |#endif // #ifndef _TYPES_H
                             1705 
                             1707 
                             1708 ; 5    |
                             1709 ; 6    |/////////////////////////////////////////////////////////////////////////////////
                             1710 ; 7    |//  Interrupt Collector Registers
                             1711 ; 8    |/////////////////////////////////////////////////////////////////////////////////
                             1712 ; 9    |
                             1713 ; 10   |#define HW_GPIO_BASEADDR 0xF400
                             1714 ; 11   |
                             1715 ; 12   |#define HW_GPB0_BASEADDR HW_GPIO_BASEADDR
                             1716 ; 13   |#define HW_GPB1_BASEADDR HW_GPIO_BASEADDR+0x10
                             1717 ; 14   |#define HW_GPB2_BASEADDR HW_GPIO_BASEADDR+0x20
                             1718 ; 15   |#define HW_GPB3_BASEADDR HW_GPIO_BASEADDR+0x30
                             1719 ; 16   |
                             1720 ; 17   |#define HW_GPB0_BLOCKNUM 0
                             1721 ; 18   |#define HW_GPB1_BLOCKNUM 1
                             1722 ; 19   |#define HW_GPB2_BLOCKNUM 2
                             1723 ; 20   |#define HW_GPB3_BLOCKNUM 3
                             1724 ; 21   |
                             1725 ; 22   |#define HW_GPB_GPENR 0
                             1726 ; 23   |#define HW_GPB_GPDOR 1
                             1727 ; 24   |#define HW_GPB_GPDIR 2
                             1728 ; 25   |#define HW_GPB_GPDOER 3
                             1729 ; 26   |#define HW_GPB_GPIPENR 4
                             1730 ; 27   |#define HW_GPB_GPIENR 5
                             1731 ; 28   |#define HW_GPB_GPILVLR 6
                             1732 ; 29   |#define HW_GPB_GPIPOLR 7
                             1733 ; 30   |#define HW_GPB_GPISTATR 8
                             1734 ; 31   |#define HW_GPB_GPPWR 9
                             1735 ; 32   |#define HW_GPB_GP8MA 10
                             1736 ; 33   |
                             1737 ; 34   |
                             1738 ; 35   |
                             1739 ; 36   |/////////////////////////////////////////////////////////////////////////////////
                             1740 ; 37   |//  GPIO Register Bit Positions
                             1741 ; 38   |typedef union               /* GPIO Pin Register Bank 0 */
                             1742 ; 39   |{
                             1743 ; 40   |    struct Bitfield B;      // Bitfield is generic structure B0 - B23 in types.h
                             1744 ; 41   |    unsigned int I;
                             1745 ; 42   |    unsigned int U;
                             1746 ; 43   |} gpr_type;
                             1747 ; 44   |
                             1748 ; 45   |#define HW_GP_B0_BITPOS 0
                             1749 ; 46   |#define HW_GP_B1_BITPOS 1
                             1750 ; 47   |#define HW_GP_B2_BITPOS 2
                             1751 ; 48   |#define HW_GP_B3_BITPOS 3
                             1752 ; 49   |#define HW_GP_B4_BITPOS 4
                             1753 ; 50   |#define HW_GP_B5_BITPOS 5
                             1754 ; 51   |#define HW_GP_B6_BITPOS 6
                             1755 ; 52   |#define HW_GP_B7_BITPOS 7
                             1756 ; 53   |#define HW_GP_B8_BITPOS 8
                             1757 ; 54   |#define HW_GP_B9_BITPOS 9
                             1758 ; 55   |#define HW_GP_B10_BITPOS 10
                             1759 ; 56   |#define HW_GP_B11_BITPOS 11
                             1760 ; 57   |#define HW_GP_B12_BITPOS 12
                             1761 ; 58   |#define HW_GP_B13_BITPOS 13
                             1762 ; 59   |#define HW_GP_B14_BITPOS 14
                             1763 ; 60   |#define HW_GP_B15_BITPOS 15
                             1764 ; 61   |#define HW_GP_B16_BITPOS 16
                             1765 ; 62   |#define HW_GP_B17_BITPOS 17
                             1766 ; 63   |#define HW_GP_B18_BITPOS 18
                             1767 ; 64   |#define HW_GP_B19_BITPOS 19
                             1768 ; 65   |#define HW_GP_B20_BITPOS 20
                             1769 ; 66   |#define HW_GP_B21_BITPOS 21
                             1770 ; 67   |#define HW_GP_B22_BITPOS 22
                             1771 ; 68   |#define HW_GP_B23_BITPOS 23
                             1772 ; 69   |
                             1773 ; 70   |#define HW_GP_B0_SETMASK (1<<HW_GP_B0_BITPOS)
                             1774 ; 71   |#define HW_GP_B1_SETMASK (1<<HW_GP_B1_BITPOS)
                             1775 ; 72   |#define HW_GP_B2_SETMASK (1<<HW_GP_B2_BITPOS)
                             1776 ; 73   |#define HW_GP_B3_SETMASK (1<<HW_GP_B3_BITPOS)
                             1777 ; 74   |#define HW_GP_B4_SETMASK (1<<HW_GP_B4_BITPOS)
                             1778 ; 75   |#define HW_GP_B5_SETMASK (1<<HW_GP_B5_BITPOS)
                             1779 ; 76   |#define HW_GP_B6_SETMASK (1<<HW_GP_B6_BITPOS)
                             1780 ; 77   |#define HW_GP_B7_SETMASK (1<<HW_GP_B7_BITPOS)
                             1781 ; 78   |#define HW_GP_B8_SETMASK (1<<HW_GP_B8_BITPOS)
TASKING DSP2410 assembler v1.5r1 Build 138 SN 00100122
                                                                                                                                                                                                                                                       Page   8

M:ADDR CODE           CYCLES LINE SOURCELINE
                             1782 ; 79   |#define HW_GP_B9_SETMASK (1<<HW_GP_B9_BITPOS)
                             1783 ; 80   |#define HW_GP_B10_SETMASK (1<<HW_GP_B10_BITPOS)
                             1784 ; 81   |#define HW_GP_B11_SETMASK (1<<HW_GP_B11_BITPOS)
                             1785 ; 82   |#define HW_GP_B12_SETMASK (1<<HW_GP_B12_BITPOS)
                             1786 ; 83   |#define HW_GP_B13_SETMASK (1<<HW_GP_B13_BITPOS)
                             1787 ; 84   |#define HW_GP_B14_SETMASK (1<<HW_GP_B14_BITPOS)
                             1788 ; 85   |#define HW_GP_B15_SETMASK (1<<HW_GP_B15_BITPOS)
                             1789 ; 86   |#define HW_GP_B16_SETMASK (1<<HW_GP_B16_BITPOS)
                             1790 ; 87   |#define HW_GP_B17_SETMASK (1<<HW_GP_B17_BITPOS)
                             1791 ; 88   |#define HW_GP_B18_SETMASK (1<<HW_GP_B18_BITPOS)
                             1792 ; 89   |#define HW_GP_B19_SETMASK (1<<HW_GP_B19_BITPOS)
                             1793 ; 90   |#define HW_GP_B20_SETMASK (1<<HW_GP_B20_BITPOS)
                             1794 ; 91   |#define HW_GP_B21_SETMASK (1<<HW_GP_B21_BITPOS)
                             1795 ; 92   |#define HW_GP_B22_SETMASK (1<<HW_GP_B22_BITPOS)
                             1796 ; 93   |#define HW_GP_B23_SETMASK (1<<HW_GP_B23_BITPOS)
                             1797 ; 94   |
                             1798 ; 95   |#define HW_GP_B0_CLRMASK (~(WORD)HW_GP_B0_SETMASK)
                             1799 ; 96   |#define HW_GP_B1_CLRMASK (~(WORD)HW_GP_B1_SETMASK)
                             1800 ; 97   |#define HW_GP_B2_CLRMASK (~(WORD)HW_GP_B2_SETMASK)
                             1801 ; 98   |#define HW_GP_B3_CLRMASK (~(WORD)HW_GP_B3_SETMASK)
                             1802 ; 99   |#define HW_GP_B4_CLRMASK (~(WORD)HW_GP_B4_SETMASK)
                             1803 ; 100  |#define HW_GP_B5_CLRMASK (~(WORD)HW_GP_B5_SETMASK)
                             1804 ; 101  |#define HW_GP_B6_CLRMASK (~(WORD)HW_GP_B6_SETMASK)
                             1805 ; 102  |#define HW_GP_B7_CLRMASK (~(WORD)HW_GP_B7_SETMASK)
                             1806 ; 103  |#define HW_GP_B8_CLRMASK (~(WORD)HW_GP_B8_SETMASK)
                             1807 ; 104  |#define HW_GP_B9_CLRMASK (~(WORD)HW_GP_B9_SETMASK)
                             1808 ; 105  |#define HW_GP_B10_CLRMASK (~(WORD)HW_GP_B10_SETMASK)
                             1809 ; 106  |#define HW_GP_B11_CLRMASK (~(WORD)HW_GP_B11_SETMASK)
                             1810 ; 107  |#define HW_GP_B12_CLRMASK (~(WORD)HW_GP_B12_SETMASK)
                             1811 ; 108  |#define HW_GP_B13_CLRMASK (~(WORD)HW_GP_B13_SETMASK)
                             1812 ; 109  |#define HW_GP_B14_CLRMASK (~(WORD)HW_GP_B14_SETMASK)
                             1813 ; 110  |#define HW_GP_B15_CLRMASK (~(WORD)HW_GP_B15_SETMASK)
                             1814 ; 111  |#define HW_GP_B16_CLRMASK (~(WORD)HW_GP_B16_SETMASK)
                             1815 ; 112  |#define HW_GP_B17_CLRMASK (~(WORD)HW_GP_B17_SETMASK)
                             1816 ; 113  |#define HW_GP_B18_CLRMASK (~(WORD)HW_GP_B18_SETMASK)
                             1817 ; 114  |#define HW_GP_B19_CLRMASK (~(WORD)HW_GP_B19_SETMASK)
                             1818 ; 115  |#define HW_GP_B20_CLRMASK (~(WORD)HW_GP_B20_SETMASK)
                             1819 ; 116  |#define HW_GP_B21_CLRMASK (~(WORD)HW_GP_B21_SETMASK)
                             1820 ; 117  |#define HW_GP_B22_CLRMASK (~(WORD)HW_GP_B22_SETMASK)
                             1821 ; 118  |#define HW_GP_B23_CLRMASK (~(WORD)HW_GP_B23_SETMASK)
                             1822 ; 119  |
                             1823 ; 120  |/////////////////////////////////////////////////////////////////////////////////
                             1824 ; 121  |//  GPIO 8mA Register Bit Positions
                             1825 ; 122  |#define HW_GP8MA_B7_B0_BITPOS 0
                             1826 ; 123  |#define HW_GP8MA_B15_B8_BITPOS 1
                             1827 ; 124  |#define HW_GP8MA_B23_B16_BITPOS 2
                             1828 ; 125  |#define HW_GP8MA_CLK_GATE_BITPOS 23
                             1829 ; 126  |
                             1830 ; 127  |
                             1831 ; 128  |/////////////////////////////////////////////////////////////////////////////////
                             1832 ; 129  |//  Logical GPIO numbers
                             1833 ; 130  |#define HW_GPIO_000 0
                             1834 ; 131  |#define HW_GPIO_001 1
                             1835 ; 132  |#define HW_GPIO_002 2
                             1836 ; 133  |#define HW_GPIO_003 3
                             1837 ; 134  |#define HW_GPIO_004 4
                             1838 ; 135  |#define HW_GPIO_005 5
                             1839 ; 136  |#define HW_GPIO_006 6
                             1840 ; 137  |#define HW_GPIO_007 7
                             1841 ; 138  |#define HW_GPIO_008 8
                             1842 ; 139  |#define HW_GPIO_009 9
                             1843 ; 140  |#define HW_GPIO_010 10
                             1844 ; 141  |#define HW_GPIO_011 11
                             1845 ; 142  |#define HW_GPIO_012 12
                             1846 ; 143  |#define HW_GPIO_013 13
                             1847 ; 144  |#define HW_GPIO_014 14
                             1848 ; 145  |#define HW_GPIO_015 15
                             1849 ; 146  |#define HW_GPIO_016 16
                             1850 ; 147  |#define HW_GPIO_017 17
                             1851 ; 148  |#define HW_GPIO_018 18
                             1852 ; 149  |#define HW_GPIO_019 19
                             1853 ; 150  |#define HW_GPIO_020 20
                             1854 ; 151  |#define HW_GPIO_021 21
                             1855 ; 152  |#define HW_GPIO_022 22
                             1856 ; 153  |#define HW_GPIO_023 23
                             1857 ; 154  |#define HW_GPIO_024 24
                             1858 ; 155  |#define HW_GPIO_025 25
                             1859 ; 156  |#define HW_GPIO_026 26
                             1860 ; 157  |#define HW_GPIO_027 27
                             1861 ; 158  |#define HW_GPIO_028 28
                             1862 ; 159  |#define HW_GPIO_029 29
                             1863 ; 160  |#define HW_GPIO_030 30
                             1864 ; 161  |#define HW_GPIO_031 31
                             1865 ; 162  |#define HW_GPIO_032 32
                             1866 ; 163  |#define HW_GPIO_033 33
                             1867 ; 164  |#define HW_GPIO_034 34
                             1868 ; 165  |#define HW_GPIO_035 35
                             1869 ; 166  |#define HW_GPIO_036 36
                             1870 ; 167  |#define HW_GPIO_037 37
                             1871 ; 168  |#define HW_GPIO_038 38
                             1872 ; 169  |#define HW_GPIO_039 39
                             1873 ; 170  |#define HW_GPIO_040 40
                             1874 ; 171  |#define HW_GPIO_041 41
                             1875 ; 172  |#define HW_GPIO_042 42
                             1876 ; 173  |#define HW_GPIO_043 43
                             1877 ; 174  |#define HW_GPIO_044 44
                             1878 ; 175  |#define HW_GPIO_045 45
                             1879 ; 176  |#define HW_GPIO_046 46
                             1880 ; 177  |#define HW_GPIO_047 47
                             1881 ; 178  |#define HW_GPIO_048 48
                             1882 ; 179  |#define HW_GPIO_049 49
                             1883 ; 180  |#define HW_GPIO_050 50
                             1884 ; 181  |#define HW_GPIO_051 51
                             1885 ; 182  |#define HW_GPIO_052 52
                             1886 ; 183  |#define HW_GPIO_053 53
                             1887 ; 184  |#define HW_GPIO_054 54
                             1888 ; 185  |#define HW_GPIO_055 55
                             1889 ; 186  |#define HW_GPIO_056 56
                             1890 ; 187  |#define HW_GPIO_057 57
                             1891 ; 188  |#define HW_GPIO_058 58
                             1892 ; 189  |#define HW_GPIO_059 59
                             1893 ; 190  |#define HW_GPIO_060 60
                             1894 ; 191  |#define HW_GPIO_061 61
                             1895 ; 192  |#define HW_GPIO_062 62
                             1896 ; 193  |#define HW_GPIO_063 63
                             1897 ; 194  |#define HW_GPIO_064 64
                             1898 ; 195  |#define HW_GPIO_065 65
                             1899 ; 196  |#define HW_GPIO_066 66
                             1900 ; 197  |#define HW_GPIO_067 67
                             1901 ; 198  |#define HW_GPIO_068 68
                             1902 ; 199  |#define HW_GPIO_069 69
                             1903 ; 200  |#define HW_GPIO_070 70
                             1904 ; 201  |#define HW_GPIO_071 71
                             1905 ; 202  |#define HW_GPIO_072 72
                             1906 ; 203  |#define HW_GPIO_073 73
                             1907 ; 204  |#define HW_GPIO_074 74
                             1908 ; 205  |#define HW_GPIO_075 75
                             1909 ; 206  |#define HW_GPIO_076 76
                             1910 ; 207  |#define HW_GPIO_077 77
                             1911 ; 208  |#define HW_GPIO_078 78
                             1912 ; 209  |#define HW_GPIO_079 79
                             1913 ; 210  |#define HW_GPIO_080 80
                             1914 ; 211  |#define HW_GPIO_081 81
                             1915 ; 212  |#define HW_GPIO_082 82
                             1916 ; 213  |#define HW_GPIO_083 83
                             1917 ; 214  |#define HW_GPIO_084 84
                             1918 ; 215  |#define HW_GPIO_085 85
                             1919 ; 216  |#define HW_GPIO_086 86
                             1920 ; 217  |#define HW_GPIO_087 87
                             1921 ; 218  |#define HW_GPIO_088 88
                             1922 ; 219  |#define HW_GPIO_089 89
                             1923 ; 220  |#define HW_GPIO_090 90
                             1924 ; 221  |#define HW_GPIO_091 91
                             1925 ; 222  |#define HW_GPIO_092 92
                             1926 ; 223  |#define HW_GPIO_093 93
                             1927 ; 224  |#define HW_GPIO_094 94
                             1928 ; 225  |#define HW_GPIO_095 95
                             1929 ; 226  |#define HW_GPIO_LAST HW_GPIO_095
                             1930 ; 227  |
                             1931 ; 228  |#define HW_GP0ENR      (*(volatile gpr_type _X*) (HW_GPB0_BASEADDR+HW_GPB_GPENR))  /* GPIO 0 Enable Register   */
                             1932 ; 229  |#define HW_GP0DOR      (*(volatile gpr_type _X*) (HW_GPB0_BASEADDR+HW_GPB_GPDOR)) /* GPIO 0 Data Out Register */
                             1933 ; 230  |#define HW_GP0DIR      (*(volatile gpr_type _X*) (HW_GPB0_BASEADDR+HW_GPB_GPDIR)) /* GPIO 0 Dait In Register  */
                             1934 ; 231  |#define HW_GP0DOER     (*(volatile gpr_type _X*) (HW_GPB0_BASEADDR+HW_GPB_GPDOER)) /* GPIO 0 Dait Out Enable Register  */
                             1935 ; 232  |#define HW_GP0IPENR    (*(volatile gpr_type _X*) (HW_GPB0_BASEADDR+HW_GPB_GPIPENR)) /* GPIO 0 Interrupt Pin Enable Register */
                             1936 ; 233  |#define HW_GP0IENR     (*(volatile gpr_type _X*) (HW_GPB0_BASEADDR+HW_GPB_GPIENR)) /* GPIO 0 Interrupt Enable Register */
                             1937 ; 234  |#define HW_GP0ILVLR    (*(volatile gpr_type _X*) (HW_GPB0_BASEADDR+HW_GPB_GPILVLR)) /* GPIO 0 Interrupt Level Register  */
                             1938 ; 235  |#define HW_GP0IPOLR    (*(volatile gpr_type _X*) (HW_GPB0_BASEADDR+HW_GPB_GPIPOLR)) /* GPIO 0 Interrupt Polarity Register   */
                             1939 ; 236  |#define HW_GP0ISTATR   (*(volatile gpr_type _X*) (HW_GPB0_BASEADDR+HW_GPB_GPISTATR)) /* GPIO 0 Interrupt Status Register */
                             1940 ; 237  |#define HW_GP0PWR      (*(volatile gpr_type _X*) (HW_GPB0_BASEADDR+HW_GPB_GPPWR)) /* GPIO 0 Power Register */
                             1941 ; 238  |#define HW_GP08MA      (*(volatile gpr_type _X*) (HW_GPB0_BASEADDR+HW_GPB_GP8MA)) 
                             1942 ; 239  |#define HW_GP1ENR      (*(volatile gpr_type _X*) (HW_GPB1_BASEADDR+HW_GPB_GPENR))     /* GPIO 1 Enable Register   */
                             1943 ; 240  |#define HW_GP1DOR      (*(volatile gpr_type _X*) (HW_GPB1_BASEADDR+HW_GPB_GPDOR)) /* GPIO 1 Data Out Register */
                             1944 ; 241  |#define HW_GP1DIR      (*(volatile gpr_type _X*) (HW_GPB1_BASEADDR+HW_GPB_GPDIR)) /* GPIO 1 Dait In Register  */
                             1945 ; 242  |#define HW_GP1DOER     (*(volatile gpr_type _X*) (HW_GPB1_BASEADDR+HW_GPB_GPDOER)) /* GPIO 1 Dait Out Enable Register  */
                             1946 ; 243  |#define HW_GP1IPENR    (*(volatile gpr_type _X*) (HW_GPB1_BASEADDR+HW_GPB_GPIPENR)) /* GPIO 1 Interrupt Pin Enable Register */
                             1947 ; 244  |#define HW_GP1IENR     (*(volatile gpr_type _X*) (HW_GPB1_BASEADDR+HW_GPB_GPIENR)) /* GPIO 1 Interrupt Enable Register */
                             1948 ; 245  |#define HW_GP1ILVLR    (*(volatile gpr_type _X*) (HW_GPB1_BASEADDR+HW_GPB_GPILVLR)) /* GPIO 1 Interrupt Level Register  */
                             1949 ; 246  |#define HW_GP1IPOLR    (*(volatile gpr_type _X*) (HW_GPB1_BASEADDR+HW_GPB_GPIPOLR)) /* GPIO 1 Interrupt Polarity Register   */
                             1950 ; 247  |#define HW_GP1ISTATR   (*(volatile gpr_type _X*) (HW_GPB1_BASEADDR+HW_GPB_GPISTATR)) /* GPIO 1 Interrupt Status Register */
                             1951 ; 248  |#define HW_GP1PWR      (*(volatile gpr_type _X*) (HW_GPB1_BASEADDR+HW_GPB_GPPWR)) /* GPIO 0 Power Register */
                             1952 ; 249  |#define HW_GP18MA      (*(volatile gpr_type _X*) (HW_GPB1_BASEADDR+HW_GPB_GP8MA)) 
                             1953 ; 250  |#define HW_GP2ENR      (*(volatile gpr_type _X*) (HW_GPB2_BASEADDR+HW_GPB_GPENR))     /* GPIO 2 Enable Register   */
                             1954 ; 251  |#define HW_GP2DOR      (*(volatile gpr_type _X*) (HW_GPB2_BASEADDR+HW_GPB_GPDOR)) /* GPIO 2 Data Out Register */
                             1955 ; 252  |#define HW_GP2DIR      (*(volatile gpr_type _X*) (HW_GPB2_BASEADDR+HW_GPB_GPDIR)) /* GPIO 2 Dait In Register  */
                             1956 ; 253  |#define HW_GP2DOER     (*(volatile gpr_type _X*) (HW_GPB2_BASEADDR+HW_GPB_GPDOER)) /* GPIO 2 Dait Out Enable Register  */
                             1957 ; 254  |#define HW_GP2IPENR    (*(volatile gpr_type _X*) (HW_GPB2_BASEADDR+HW_GPB_GPIPENR)) /* GPIO 2 Interrupt Pin Enable Register */
                             1958 ; 255  |#define HW_GP2IENR     (*(volatile gpr_type _X*) (HW_GPB2_BASEADDR+HW_GPB_GPIENR)) /* GPIO 2 Interrupt Enable Register */
                             1959 ; 256  |#define HW_GP2ILVLR    (*(volatile gpr_type _X*) (HW_GPB2_BASEADDR+HW_GPB_GPILVLR)) /* GPIO 2 Interrupt Level Register  */
                             1960 ; 257  |#define HW_GP2IPOLR    (*(volatile gpr_type _X*) (HW_GPB2_BASEADDR+HW_GPB_GPIPOLR)) /* GPIO 2 Interrupt Polarity Register   */
                             1961 ; 258  |#define HW_GP2ISTATR   (*(volatile gpr_type _X*) (HW_GPB2_BASEADDR+HW_GPB_GPISTATR)) /* GPIO 2 Interrupt Status Register */
                             1962 ; 259  |#define HW_GP2PWR      (*(volatile gpr_type _X*) (HW_GPB2_BASEADDR+HW_GPB_GPPWR)) /* GPIO 0 Power Register */
                             1963 ; 260  |#define HW_GP28MA      (*(volatile gpr_type _X*) (HW_GPB2_BASEADDR+HW_GPB_GP8MA)) 
                             1964 ; 261  |#define HW_GP3ENR      (*(volatile gpr_type _X*) (HW_GPB3_BASEADDR+HW_GPB_GPENR))     /* GPIO 2 Enable Register   */
                             1965 ; 262  |#define HW_GP3DOR      (*(volatile gpr_type _X*) (HW_GPB3_BASEADDR+HW_GPB_GPDOR)) /* GPIO 2 Data Out Register */
                             1966 ; 263  |#define HW_GP3DIR      (*(volatile gpr_type _X*) (HW_GPB3_BASEADDR+HW_GPB_GPDIR)) /* GPIO 2 Dait In Register  */
                             1967 ; 264  |#define HW_GP3DOER     (*(volatile gpr_type _X*) (HW_GPB3_BASEADDR+HW_GPB_GPDOER)) /* GPIO 2 Dait Out Enable Register  */
                             1968 ; 265  |#define HW_GP3IPENR    (*(volatile gpr_type _X*) (HW_GPB3_BASEADDR+HW_GPB_GPIPENR)) /* GPIO 2 Interrupt Pin Enable Register */
                             1969 ; 266  |#define HW_GP3IENR     (*(volatile gpr_type _X*) (HW_GPB3_BASEADDR+HW_GPB_GPIENR)) /* GPIO 2 Interrupt Enable Register */
                             1970 ; 267  |#define HW_GP3ILVLR    (*(volatile gpr_type _X*) (HW_GPB3_BASEADDR+HW_GPB_GPILVLR)) /* GPIO 2 Interrupt Level Register  */
                             1971 ; 268  |#define HW_GP3IPOLR    (*(volatile gpr_type _X*) (HW_GPB3_BASEADDR+HW_GPB_GPIPOLR)) /* GPIO 2 Interrupt Polarity Register   */
                             1972 ; 269  |#define HW_GP3ISTATR   (*(volatile gpr_type _X*) (HW_GPB3_BASEADDR+HW_GPB_GPISTATR)) /* GPIO 2 Interrupt Status Register */
                             1973 ; 270  |#define HW_GP3PWR      (*(volatile gpr_type _X*) (HW_GPB3_BASEADDR+HW_GPB_GPPWR)) /* GPIO 0 Power Register */
                             1974 ; 271  |#define HW_GP38MA      (*(volatile gpr_type _X*) (HW_GPB3_BASEADDR+HW_GPB_GP8MA)) 
                             1975 ; 272  |
                             1976 ; 273  |#endif
                             1977 ; 274  |
                             1978 
                             1980 
                             1981 ; 18   |#include "lowresolutionadc.h"
                             1982 
                             1984 
                             1985 ; 1    |//;///////////////////////////////////////////////////////////////////////////////
                             1986 ; 2    |//; Copyright(C) SigmaTel, Inc. 2000-2003
                             1987 ; 3    |//;
                             1988 ; 4    |//; Filename:    lowresolutionadc.h
                             1989 ; 5    |//; Description: General purpose interface to LRADCs
                             1990 ; 6    |//;              Generic symbols are mapped to more specific symbols in inc\34xx\regslradc.inc files
                             1991 ; 7    |//;///////////////////////////////////////////////////////////////////////////////
                             1992 ; 8    |
                             1993 ; 9    |#ifndef _LOWRESOLUTIONADC_H
                             1994 ; 10   |#define _LOWRESOLUTIONADC_H
                             1995 ; 11   |
                             1996 ; 12   |#include "regslradc.h"
                             1997 
                             1999 
                             2000 ; 1    |#if !(defined(regslradcinc))
                             2001 ; 2    |
                             2002 ; 3    |#define regslradcinc 1
                             2003 ; 4    |
                             2004 ; 5    |#include "types.h"
                             2005 
                             2007 
                             2008 ; 1    |////////////////////////////////////////////////////////////////////////////////
                             2009 ; 2    |// Copyright(C) SigmaTel, Inc. 2000-2004
                             2010 ; 3    |//
                             2011 ; 4    |// Filename: types.h
                             2012 ; 5    |// Description: Standard data types
                             2013 ; 6    |////////////////////////////////////////////////////////////////////////////////
                             2014 ; 7    |
                             2015 ; 8    |#ifndef _TYPES_H
                             2016 ; 9    |#define _TYPES_H
                             2017 ; 10   |
                             2018 ; 11   |// TODO:  move this outta here!
                             2019 ; 12   |#if !defined(NOERROR)
                             2020 ; 13   |#define NOERROR 0
                             2021 ; 14   |#define SUCCESS 0
                             2022 ; 15   |#endif 
                             2023 ; 16   |#if !defined(SUCCESS)
                             2024 ; 17   |#define SUCCESS  0
                             2025 ; 18   |#endif
                             2026 ; 19   |#if !defined(ERROR)
                             2027 ; 20   |#define ERROR   -1
                             2028 ; 21   |#endif
                             2029 ; 22   |#if !defined(FALSE)
                             2030 ; 23   |#define FALSE 0
                             2031 ; 24   |#endif
                             2032 ; 25   |#if !defined(TRUE)
                             2033 ; 26   |#define TRUE  1
                             2034 ; 27   |#endif
                             2035 ; 28   |
                             2036 ; 29   |#if !defined(NULL)
TASKING DSP2410 assembler v1.5r1 Build 138 SN 00100122
                                                                                                                                                                                                                                                       Page   9

M:ADDR CODE           CYCLES LINE SOURCELINE
                             2037 ; 30   |#define NULL 0
                             2038 ; 31   |#endif
                             2039 ; 32   |
                             2040 ; 33   |#define MAX_INT     0x7FFFFF
                             2041 ; 34   |#define MAX_LONG    0x7FFFFFffffff
                             2042 ; 35   |        // max positive unsigned long value: -1 == 0xFFFFFFffffff
                             2043 ; 36   |#define MAX_ULONG   (-1) 
                             2044 ; 37   |
                             2045 ; 38   |#define WORD_SIZE   24              // word size in bits
                             2046 ; 39   |#define BYTES_PER_WORD 3            // 8 bit bytes
                             2047 ; 40   |
                             2048 ; 41   |
                             2049 ; 42   |#define BYTE    unsigned char       // btVarName
                             2050 ; 43   |#define CHAR    signed char         // cVarName
                             2051 ; 44   |#define USHORT  unsigned short      // usVarName
                             2052 ; 45   |#define SHORT   unsigned short      // sVarName
                             2053 ; 46   |#define WORD    unsigned int        // wVarName
                             2054 ; 47   |#define INT     signed int          // iVarName
                             2055 ; 48   |#define DWORD   unsigned long       // dwVarName
                             2056 ; 49   |#define LONG    signed long         // lVarName
                             2057 ; 50   |#define BOOL    unsigned int        // bVarName
                             2058 ; 51   |#define FRACT   _fract              // frVarName
                             2059 ; 52   |#define LFRACT  long _fract         // lfrVarName
                             2060 ; 53   |#define CIRC    _circ               // cp<type prefix>VarName (see below)
                             2061 ; 54   |#define FLOAT   float               // fVarName
                             2062 ; 55   |#define DBL     double              // dVarName
                             2063 ; 56   |#define ENUM    enum                // eVarName
                             2064 ; 57   |#define CMX     _complex            // cmxVarName
                             2065 ; 58   |typedef WORD UCS3;                   // 
                             2066 ; 59   |
                             2067 ; 60   |#define UINT16  unsigned short
                             2068 ; 61   |#define UINT8   unsigned char   
                             2069 ; 62   |#define UINT32  unsigned long
                             2070 ; 63   |#define UINT64  unsigned long   // need to figure out how to do 64 bit values.  Or port exisiting code to only use 48 bit
                             2071 ; 64   |#define INT64   unsigned long   // need to figure out how to do 64 bit values.  Or port exisiting code to only use 48 bit
                             2072 ; 65   |#define WCHAR   UINT16
                             2073 ; 66   |
                             2074 ; 67   |//UINT128 is 16 bytes or 6 words
                             2075 ; 68   |typedef struct UINT128_3500 {   
                             2076 ; 69   |    int val[6];     
                             2077 ; 70   |} UINT128_3500;
                             2078 ; 71   |
                             2079 ; 72   |#define UINT128   UINT128_3500
                             2080 ; 73   |
                             2081 ; 74   |// Little endian word packed byte strings:   
                             2082 ; 75   |//      _packed BYTE bTextVarName[]="a string";  bText is a packed byte string prefix
                             2083 ; 76   |// Convert to big endian words by reordering bytes from high to low using swizzle.
                             2084 ; 77   |// Little endian word packed byte strings:   
                             2085 ; 78   |//      _packed BYTE bTextVarName[]="a string";  bText is a packed byte string prefix
                             2086 ; 79   |// Convert to big endian words by reordering bytes from high to low using swizzle.
                             2087 ; 80   |
                             2088 ; 81   |// Declare Memory Spaces To Use When Coding
                             2089 ; 82   |// A. Sector Buffers
                             2090 ; 83   |#define SECTOR_BUFFER_MEM_X _X
                             2091 ; 84   |#define SECTOR_BUFFER_MEM_Y _Y
                             2092 ; 85   |#define SECTOR_BUFFER_MEM SECTOR_BUFFER_MEM_X
                             2093 ; 86   |typedef WORD SECTOR_BUFFER_MEM SECTOR_BUFFER;
                             2094 ; 87   |typedef SECTOR_BUFFER * P_SECTOR_BUFFER;
                             2095 ; 88   |// B. Media DDI Memory
                             2096 ; 89   |#define MEDIA_DDI_MEM _Y
                             2097 ; 90   |
                             2098 ; 91   |
                             2099 ; 92   |
                             2100 ; 93   |// Pointers to linear structures are labeled as: p<type prefix>VarName
                             2101 ; 94   |// Examples of circular pointers:
                             2102 ; 95   |//    INT CIRC cpiVarName
                             2103 ; 96   |//    DWORD CIRC cpdwVarName
                             2104 ; 97   |
                             2105 ; 98   |#define RETCODE INT                 // rcVarName
                             2106 ; 99   |
                             2107 ; 100  |// generic bitfield structure
                             2108 ; 101  |struct Bitfield {
                             2109 ; 102  |    unsigned int B0  :1;
                             2110 ; 103  |    unsigned int B1  :1;
                             2111 ; 104  |    unsigned int B2  :1;
                             2112 ; 105  |    unsigned int B3  :1;
                             2113 ; 106  |    unsigned int B4  :1;
                             2114 ; 107  |    unsigned int B5  :1;
                             2115 ; 108  |    unsigned int B6  :1;
                             2116 ; 109  |    unsigned int B7  :1;
                             2117 ; 110  |    unsigned int B8  :1;
                             2118 ; 111  |    unsigned int B9  :1;
                             2119 ; 112  |    unsigned int B10 :1;
                             2120 ; 113  |    unsigned int B11 :1;
                             2121 ; 114  |    unsigned int B12 :1;
                             2122 ; 115  |    unsigned int B13 :1;
                             2123 ; 116  |    unsigned int B14 :1;
                             2124 ; 117  |    unsigned int B15 :1;
                             2125 ; 118  |    unsigned int B16 :1;
                             2126 ; 119  |    unsigned int B17 :1;
                             2127 ; 120  |    unsigned int B18 :1;
                             2128 ; 121  |    unsigned int B19 :1;
                             2129 ; 122  |    unsigned int B20 :1;
                             2130 ; 123  |    unsigned int B21 :1;
                             2131 ; 124  |    unsigned int B22 :1;
                             2132 ; 125  |    unsigned int B23 :1;
                             2133 ; 126  |};
                             2134 ; 127  |
                             2135 ; 128  |union BitInt {
                             2136 ; 129  |        struct Bitfield B;
                             2137 ; 130  |        int        I;
                             2138 ; 131  |};
                             2139 ; 132  |
                             2140 ; 133  |#define MAX_MSG_LENGTH 10
                             2141 ; 134  |struct CMessage
                             2142 ; 135  |{
                             2143 ; 136  |        unsigned int m_uLength;
                             2144 ; 137  |        unsigned int m_uMsg[MAX_MSG_LENGTH];
                             2145 ; 138  |};
                             2146 ; 139  |
                             2147 ; 140  |typedef struct {
                             2148 ; 141  |    WORD m_wLength;
                             2149 ; 142  |    WORD m_wMessage;
                             2150 ; 143  |    WORD m_wParams[MAX_MSG_LENGTH];
                             2151 ; 144  |} Message;
                             2152 ; 145  |
                             2153 ; 146  |struct MessageQueueDescriptor
                             2154 ; 147  |{
                             2155 ; 148  |        int *m_pBase;
                             2156 ; 149  |        int m_iModulo;
                             2157 ; 150  |        int m_iSize;
                             2158 ; 151  |        int *m_pHead;
                             2159 ; 152  |        int *m_pTail;
                             2160 ; 153  |};
                             2161 ; 154  |
                             2162 ; 155  |struct ModuleEntry
                             2163 ; 156  |{
                             2164 ; 157  |    int m_iSignaledEventMask;
                             2165 ; 158  |    int m_iWaitEventMask;
                             2166 ; 159  |    int m_iResourceOfCode;
                             2167 ; 160  |    struct MessageQueueDescriptor *m_pMessageQueue;
                             2168 ; 161  |    int _asmfunc (*m_pProcessEntryPoint)(union WaitMask Signals,struct MessageQueueDescriptor *);
                             2169 ; 162  |    int _asmfunc (*m_pInitFunction)(struct MessageQueueDescriptor *);
                             2170 ; 163  |    int m_uTimeOutHigh;
                             2171 ; 164  |    int m_uTimeOutLow;
                             2172 ; 165  |    int _asmfunc (*m_pBackgroundFunction)(struct MessageQueueDescriptor *);
                             2173 ; 166  |};
                             2174 ; 167  |
                             2175 ; 168  |union WaitMask{
                             2176 ; 169  |    struct B{
                             2177 ; 170  |        unsigned int m_bNone     :1;
                             2178 ; 171  |        unsigned int m_bMessage  :1;
                             2179 ; 172  |        unsigned int m_bTimer    :1;
                             2180 ; 173  |        unsigned int m_bButton   :1;
                             2181 ; 174  |    } B;
                             2182 ; 175  |    int I;
                             2183 ; 176  |} ;
                             2184 ; 177  |
                             2185 ; 178  |
                             2186 ; 179  |struct Button {
                             2187 ; 180  |        WORD wButtonEvent;
                             2188 ; 181  |        WORD wUnused[MAX_MSG_LENGTH];   
                             2189 ; 182  |};
                             2190 ; 183  |
                             2191 ; 184  |struct Message {
                             2192 ; 185  |        WORD wMsgLength;
                             2193 ; 186  |        WORD wMsgCommand;
                             2194 ; 187  |        WORD wMsgParms[MAX_MSG_LENGTH-1];
                             2195 ; 188  |};
                             2196 ; 189  |
                             2197 ; 190  |union EventTypes {
                             2198 ; 191  |        struct CMessage msg;
                             2199 ; 192  |        struct Button Button ;
                             2200 ; 193  |        struct Message Message;
                             2201 ; 194  |};
                             2202 ; 195  |
                             2203 ; 196  |// next 2 used to get updater build to return correct protocol ver in scsi response.
                             2204 ; 197  |#define BUILD_TYPE_UPDATER  0x100
                             2205 ; 198  |#define BUILD_TYPE_HOSTLINK 0x101
                             2206 ; 199  |#define BUILD_TYPE_PLAYER   0x102
                             2207 ; 200  |
                             2208 ; 201  |// Resets part if RETAIL build. DEBUG build executes debug instruction to halt.
                             2209 ; 202  |#define SystemHalt() __asm(" include 'sysmacro.asm' \n error") 
                             2210 ; 203  |#define assert(x)    if(!(x)) __asm(" include 'sysmacro.asm' \n error")
                             2211 ; 204  |
                             2212 ; 205  |#if DEBUG
                             2213 ; 206  |// For DEBUG builds, DebugBuildAssert(condition) halts if condition evaluates to FALSE. 
                             2214 ; 207  |#define DebugBuildAssert(x)    if(!(x)) __asm(" debug ")
                             2215 ; 208  |#else 
                             2216 ; 209  |// For RETAIL builds, DebugBuildAssert(condition) does nothing & execution continues rather than halt or reset. 
                             2217 ; 210  |#define DebugBuildAssert(x)    
                             2218 ; 211  |#endif
                             2219 ; 212  |
                             2220 ; 213  |// Do this in your C files to make a reminder that's displayed during the build.
                             2221 ; 214  |//  #pragma asm
                             2222 ; 215  |//  WARN 'Note to builder: reminder to do this after verifying that'
                             2223 ; 216  |//  #pragma endasm
                             2224 ; 217  |
                             2225 ; 218  |
                             2226 ; 219  |#ifdef COLOR_262K
                             2227 ; 220  |#define RGB(r,g,b)    ((0x0000FC & (r)) << 10) | ((0x0000FC & (g)) << 4) | ((0x0000FC & (b)) >> 2)    //262k
                             2228 ; 221  |#elif defined(COLOR_65K)
                             2229 ; 222  |#define RGB(r,g,b)    ((0x0000F8 & (r)) << 8) | ((0x0000FC & (g)) << 3) | ((0x0000F8 & (b)) >> 3)  //65k
                             2230 ; 223  |#else
                             2231 ; 224  |#define RGB(r,g,b)       ((0x0000F0 & (r)) << 4) | (0x0000F0 & (g)) | ((0x0000F0 & (b)) >> 4)
                             2232 ; 225  |#endif
                             2233 ; 226  |    
                             2234 ; 227  |#endif // #ifndef _TYPES_H
                             2235 
                             2237 
                             2238 ; 6    |//;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                             2239 ; 7    |
                             2240 ; 8    |//   SYSTEM STMP Registers 
                             2241 ; 9    |//  Last Edited 6.26.2003 M. Henson
                             2242 ; 10   |//;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                             2243 ; 11   |
                             2244 ; 12   |#define HW_LRADC_BASEADDR (0xFA20)
                             2245 ; 13   |
                             2246 ; 14   |
                             2247 ; 15   |
                             2248 ; 16   |/////////////////////////////////////////////////////////////////////////////////
                             2249 ; 17   |//  Battery LRADC Control Register (HW_BATT_CTRL) Bit Definitions
                             2250 ; 18   |#define HW_BATT_CTRL_INPUT_OFFSET_WIDTH (7)
                             2251 ; 19   |#define HW_BATT_CTRL_RSVD0_WIDTH (1)
                             2252 ; 20   |#define HW_BATT_CTRL_HALF_CMP_PWR_WIDTH (1)
                             2253 ; 21   |#define HW_BATT_CTRL_INPUT_DIV2_WIDTH (1)
                             2254 ; 22   |#define HW_BATT_CTRL_CLEAR_WIDTH (1)
                             2255 ; 23   |#define HW_BATT_CTRL_PWD_WIDTH (1)
                             2256 ; 24   |#define HW_BATT_CTRL_CLK_DIV_WIDTH (2)
                             2257 ; 25   |#define HW_BATT_CTRL_RSVD1_WIDTH (2)
                             2258 ; 26   |#define HW_BATT_CTRL_REF_VAL_WIDTH (2)
                             2259 ; 27   |#define HW_BATT_CTRL_RSVD2_WIDTH (2)
                             2260 ; 28   |#define HW_BATT_CTRL_IRQ_EN_EVENT0_WIDTH (1)
                             2261 ; 29   |#define HW_BATT_CTRL_IRQ_EN_EVENT1_WIDTH (1)
                             2262 ; 30   |#define HW_BATT_CTRL_POLARITY_EVENT0_WIDTH (1)
                             2263 ; 31   |#define HW_BATT_CTRL_POLARITY_EVENT1_WIDTH (1)
                             2264 ; 32   |
                             2265 ; 33   |#define HW_BATT_CTRL_INPUT_OFFSET_BITPOS (0)
                             2266 ; 34   |#define HW_BATT_CTRL_HALF_CMP_PWR_BITPOS (8)
                             2267 ; 35   |#define HW_BATT_CTRL_INPUT_DIV2_BITPOS (9)
                             2268 ; 36   |#define HW_BATT_CTRL_CLEAR_BITPOS (10)
                             2269 ; 37   |#define HW_BATT_CTRL_PWD_BITPOS (11)
                             2270 ; 38   |#define HW_BATT_CTRL_CLK_DIV_BITPOS (12)
                             2271 ; 39   |#define HW_BATT_CTRL_REF_VAL_BITPOS (16)
                             2272 ; 40   |
                             2273 ; 41   |#define HW_BATT_CTRL_INPUT_OFFSET_SETMASK (((1<<HW_BATT_CTRL_INPUT_OFFSET_WIDTH)-1)<<HW_BATT_CTRL_INPUT_OFFSET_BITPOS)        
                             2274 ; 42   |#define HW_BATT_CTRL_HALF_CMP_PWR_SETMASK (((1<<HW_BATT_CTRL_HALF_CMP_PWR_WIDTH)-1)<<HW_BATT_CTRL_HALF_CMP_PWR_BITPOS)        
                             2275 ; 43   |#define HW_BATT_CTRL_INPUT_DIV2_SETMASK (((1<<HW_BATT_CTRL_INPUT_DIV2_WIDTH)-1)<<HW_BATT_CTRL_INPUT_DIV2_BITPOS) 
                             2276 ; 44   |#define HW_BATT_CTRL_CLEAR_SETMASK (((1<<HW_BATT_CTRL_CLEAR_WIDTH)-1)<<HW_BATT_CTRL_CLEAR_BITPOS) 
                             2277 ; 45   |#define HW_BATT_CTRL_PWD_SETMASK (((1<<HW_BATT_CTRL_PWD_WIDTH)-1)<<HW_BATT_CTRL_PWD_BITPOS) 
                             2278 ; 46   |#define HW_BATT_CTRL_CLK_DIV_SETMASK (((1<<HW_BATT_CTRL_CLK_DIV_WIDTH)-1)<<HW_BATT_CTRL_CLK_DIV_BITPOS)        
                             2279 ; 47   |#define HW_BATT_CTRL_REF_VAL_SETMASK (((1<<HW_BATT_CTRL_REF_VAL_WIDTH)-1)<<HW_BATT_CTRL_REF_VAL_BITPOS)        
                             2280 ; 48   |
                             2281 ; 49   |#define HW_BATT_CTRL_INPUT_OFFSET_CLRMASK (~(WORD)HW_BATT_CTRL_INPUT_OFFSET_SETMASK)     
                             2282 ; 50   |#define HW_BATT_CTRL_HALF_CMP_PWR_CLRMASK (~(WORD)HW_BATT_CTRL_HALF_CMP_PWR_SETMASK)     
                             2283 ; 51   |#define HW_BATT_CTRL_INPUT_DIV2_CLRMASK (~(WORD)HW_BATT_CTRL_INPUT_DIV2_SETMASK) 
                             2284 ; 52   |#define HW_BATT_CTRL_CLEAR_CLRMASK (~(WORD)HW_BATT_CTRL_CLEAR_SETMASK) 
                             2285 ; 53   |#define HW_BATT_CTRL_PWD_CLRMASK (~(WORD)HW_BATT_CTRL_PWD_SETMASK) 
                             2286 ; 54   |#define HW_BATT_CTRL_CLK_DIV_CLRMASK (~(WORD)HW_BATT_CTRL_CLK_DIV_SETMASK)     
                             2287 ; 55   |#define HW_BATT_CTRL_REF_VAL_CLRMASK (~(WORD)HW_BATT_CTRL_REF_VAL_SETMASK)
                             2288 ; 56   |
TASKING DSP2410 assembler v1.5r1 Build 138 SN 00100122
                                                                                                                                                                                                                                                       Page  10

M:ADDR CODE           CYCLES LINE SOURCELINE
                             2289 ; 57   |typedef union               
                             2290 ; 58   |{
                             2291 ; 59   |    struct {
                             2292 ; 60   |        unsigned int INPUT_OFFSET                 : HW_BATT_CTRL_INPUT_OFFSET_WIDTH;
                             2293 ; 61   |        unsigned int RSVD0                        : HW_BATT_CTRL_RSVD0_WIDTH;
                             2294 ; 62   |        unsigned int HALF_CMP_PWR                 : HW_BATT_CTRL_HALF_CMP_PWR_WIDTH;
                             2295 ; 63   |        unsigned int INPUT_DIV2                   : HW_BATT_CTRL_INPUT_DIV2_WIDTH;
                             2296 ; 64   |        unsigned int CLEAR                        : HW_BATT_CTRL_CLEAR_WIDTH;
                             2297 ; 65   |        unsigned int PWD                          : HW_BATT_CTRL_PWD_WIDTH;
                             2298 ; 66   |        unsigned int CLK_DIV                      : HW_BATT_CTRL_CLK_DIV_WIDTH;
                             2299 ; 67   |        unsigned int RSVD1                        : HW_BATT_CTRL_RSVD1_WIDTH;
                             2300 ; 68   |        unsigned int REF_VAL                      : HW_BATT_CTRL_REF_VAL_WIDTH;
                             2301 ; 69   |        unsigned int RSVD2                        : HW_BATT_CTRL_RSVD2_WIDTH;
                             2302 ; 70   |                 unsigned int IRQ_EN_EVENT0                               : HW_BATT_CTRL_IRQ_EN_EVENT0_WIDTH;
                             2303 ; 71   |                 unsigned int IRQ_EN_EVENT1                               : HW_BATT_CTRL_IRQ_EN_EVENT1_WIDTH;
                             2304 ; 72   |             unsigned int POLARITY_EVENT0              : HW_BATT_CTRL_POLARITY_EVENT0_WIDTH;
                             2305 ; 73   |                 unsigned int POLARITY_EVENT1              : HW_BATT_CTRL_POLARITY_EVENT1_WIDTH;
                             2306 ; 74   |    } B;
                             2307 ; 75   |   unsigned int I;
                             2308 ; 76   |        unsigned int U;
                             2309 ; 77   |} lradc_ctrl_type;
                             2310 ; 78   |#define HW_BATT_CTRL      (*(volatile lradc_ctrl_type _X*) (HW_LRADC_BASEADDR))    /* Battery LRADC Control Register */
                             2311 ; 79   |
                             2312 ; 80   |
                             2313 ; 81   |/////////////////////////////////////////////////////////////////////////////////
                             2314 ; 82   |//  Battery LRADC Threshold Register (HW_BATT_THRSH) Bit Definitions
                             2315 ; 83   |#define HW_BATT_THRSH_THRESHOLD_EVENT0_WIDTH (9)
                             2316 ; 84   |#define HW_BATT_THRSH_RSVD0_WIDTH (3)
                             2317 ; 85   |#define HW_BATT_THRSH_THRESHOLD_EVENT1_WIDTH (9)
                             2318 ; 86   |#define HW_BATT_THRSH_RSVD1_WIDTH (3)
                             2319 ; 87   |
                             2320 ; 88   |#define HW_BATT_THRSH_THRESHOLD_EVENT0_BITPOS (0)
                             2321 ; 89   |#define HW_BATT_THRSH_THRESHOLD_EVENT1_BITPOS (12)
                             2322 ; 90   |
                             2323 ; 91   |#define HW_BATT_THRSH_THRESHOLD_EVENT0_SETMASK (((1<<HW_BATT_THRSH_THRESHOLD_EVENT0_WIDTH)-1)<<HW_BATT_THRSH_THRESHOLD_EVENT0_BITPOS)        
                             2324 ; 92   |#define HW_BATT_THRSH_THRESHOLD_EVENT1_SETMASK (((1<<HW_BATT_THRSH_THRESHOLD_EVENT1_WIDTH)-1)<<HW_BATT_THRSH_THRESHOLD_EVENT1_BITPOS)        
                             2325 ; 93   |
                             2326 ; 94   |#define HW_BATT_THRSH_THRESHOLD_EVENT0_CLRMASK (~(WORD)HW_BATT_THRSH_THRESHOLD_EVENT0_SETMASK)     
                             2327 ; 95   |#define HW_BATT_THRSH_THRESHOLD_EVENT1_CLRMASK (~(WORD)HW_BATT_THRSH_THRESHOLD_EVENT1_SETMASK)     
                             2328 ; 96   |
                             2329 ; 97   |
                             2330 ; 98   |typedef union               
                             2331 ; 99   |{
                             2332 ; 100  |    struct {
                             2333 ; 101  |        unsigned int THRESHOLD_EVENT0   : HW_BATT_THRSH_THRESHOLD_EVENT0_WIDTH;
                             2334 ; 102  |        unsigned int RSVD0                  : HW_BATT_THRSH_RSVD0_WIDTH;
                             2335 ; 103  |        unsigned int THRESHOLD_EVENT1   : HW_BATT_THRSH_THRESHOLD_EVENT1_WIDTH;
                             2336 ; 104  |        unsigned int RSVD1              : HW_BATT_THRSH_RSVD1_WIDTH;
                             2337 ; 105  |    } B;
                             2338 ; 106  |    unsigned int I;
                             2339 ; 107  |} lradc_thrsh_type;
                             2340 ; 108  |#define HW_BATT_THRSH      (*(volatile lradc_thrsh_type _X*) (HW_LRADC_BASEADDR+1))    /* Battery LRADC Threshold Register */
                             2341 ; 109  |
                             2342 ; 110  |
                             2343 ; 111  |/////////////////////////////////////////////////////////////////////////////////
                             2344 ; 112  |//  Battery LRADC Result Register (HW_BATT_RESULT) Bit Definitions
                             2345 ; 113  |#define HW_BATT_RESULT_EQ_EVENT1_WIDTH (1)
                             2346 ; 114  |#define HW_BATT_RESULT_EQ_EVENT0_WIDTH (1)
                             2347 ; 115  |#define HW_BATT_RESULT_GT_EVENT1_WIDTH (1)
                             2348 ; 116  |#define HW_BATT_RESULT_GT_EVENT0_WIDTH (1)
                             2349 ; 117  |#define HW_BATT_RESULT_LT_EVENT1_WIDTH (1)
                             2350 ; 118  |#define HW_BATT_RESULT_LT_EVENT0_WIDTH (1)
                             2351 ; 119  |#define HW_BATT_RESULT_RSVD0_WIDTH (2)
                             2352 ; 120  |#define HW_BATT_RESULT_DATA_OUT_WIDTH (9)
                             2353 ; 121  |#define HW_BATT_RESULT_RSVD1_WIDTH (3)
                             2354 ; 122  |#define HW_BATT_RESULT_IRQ_EVENT0_WIDTH (1)
                             2355 ; 123  |#define HW_BATT_RESULT_IRQ_EVENT1_WIDTH (1)
                             2356 ; 124  |#define HW_BATT_RESULT_RSVD2_WIDTH (2)
                             2357 ; 125  |
                             2358 ; 126  |#define HW_BATT_RESULT_EQ_EVENT1_BITPOS (0)
                             2359 ; 127  |#define HW_BATT_RESULT_EQ_EVENT0_BITPOS (1)
                             2360 ; 128  |#define HW_BATT_RESULT_GT_EVENT1_BITPOS (2)
                             2361 ; 129  |#define HW_BATT_RESULT_GT_EVENT0_BITPOS (3)
                             2362 ; 130  |#define HW_BATT_RESULT_LT_EVENT1_BITPOS (4)
                             2363 ; 131  |#define HW_BATT_RESULT_LT_EVENT0_BITPOS (5)
                             2364 ; 132  |#define HW_BATT_RESULT_RSVD0_BITPOS (6)
                             2365 ; 133  |#define HW_BATT_RESULT_DATA_OUT_BITPOS (8)
                             2366 ; 134  |#define HW_BATT_RESULT_RSVD1_BITPOS (17)
                             2367 ; 135  |#define HW_BATT_RESULT_IRQ_EVENT0_BITPOS (20)
                             2368 ; 136  |#define HW_BATT_RESULT_IRQ_EVENT1_BITPOS (21)
                             2369 ; 137  |#define HW_BATT_RESULT_RSVD2_BITPOS (22)
                             2370 ; 138  |
                             2371 ; 139  |
                             2372 ; 140  |
                             2373 ; 141  |#define HW_BATT_RESULT_EQ_EVENT1_SETMASK (((1<<HW_BATT_RESULT_EQ_EVENT1_WIDTH)-1)<<HW_BATT_RESULT_EQ_EVENT1_BITPOS)
                             2374 ; 142  |#define HW_BATT_RESULT_EQ_EVENT0_SETMASK (((1<<HW_BATT_RESULT_EQ_EVENT0_WIDTH)-1)<<HW_BATT_RESULT_EQ_EVENT0_BITPOS)
                             2375 ; 143  |#define HW_BATT_RESULT_GT_EVENT1_SETMASK (((1<<HW_BATT_RESULT_GT_EVENT1_WIDTH)-1)<<HW_BATT_RESULT_GT_EVENT1_BITPOS)
                             2376 ; 144  |#define HW_BATT_RESULT_GT_EVENT0_SETMASK (((1<<HW_BATT_RESULT_GT_EVENT0_WIDTH)-1)<<HW_BATT_RESULT_GT_EVENT0_BITPOS)
                             2377 ; 145  |#define HW_BATT_RESULT_LT_EVENT1_SETMASK (((1<<HW_BATT_RESULT_LT_EVENT1_WIDTH)-1)<<HW_BATT_RESULT_LT_EVENT1_BITPOS)
                             2378 ; 146  |#define HW_BATT_RESULT_LT_EVENT0_SETMASK (((1<<HW_BATT_RESULT_LT_EVENT0_WIDTH)-1)<<HW_BATT_RESULT_LT_EVENT0_BITPOS)
                             2379 ; 147  |#define HW_BATT_RESULT_RSVD0_SETMASK (((1<<HW_BATT_RESULT_RSVD0_WIDTH)-1)<<HW_BATT_RESULT_RSVD0_BITPOS)
                             2380 ; 148  |#define HW_BATT_RESULT_DATA_OUT_SETMASK (((1<<HW_BATT_RESULT_DATA_OUT_WIDTH)-1)<<HW_BATT_RESULT_DATA_OUT_BITPOS)
                             2381 ; 149  |#define HW_BATT_RESULT_RSVD1_SETMASK (((1<<HW_BATT_RESULT_RSVD1_WIDTH)-1)<<HW_BATT_RESULT_RSVD1_BITPOS)
                             2382 ; 150  |#define HW_BATT_RESULT_IRQ_EVENT0_SETMASK (((1<<HW_BATT_RESULT_IRQ_EVENT0_WIDTH)-1)<<HW_BATT_RESULT_IRQ_EVENT0_BITPOS)
                             2383 ; 151  |#define HW_BATT_RESULT_IRQ_EVENT1_SETMASK (((1<<HW_BATT_RESULT_IRQ_EVENT1_WIDTH)-1)<<HW_BATT_RESULT_IRQ_EVENT1_BITPOS)
                             2384 ; 152  |#define HW_BATT_RESULT_RSVD2_SETMASK (((1<<HW_BATT_RESULT_RSVD2_WIDTH)-1)<<HW_BATT_RESULT_RSVD2_BITPOS)
                             2385 ; 153  |
                             2386 ; 154  |
                             2387 ; 155  |#define HW_BATT_RESULT_EQ_EVENT1_CLRMASK (~(WORD)HW_BATT_RESULT_EQ_EVENT1_SETMASK)
                             2388 ; 156  |#define HW_BATT_RESULT_EQ_EVENT0_CLRMASK (~(WORD)HW_BATT_RESULT_EQ_EVENT0_SETMASK)
                             2389 ; 157  |#define HW_BATT_RESULT_GT_EVENT1_CLRMASK (~(WORD)HW_BATT_RESULT_GT_EVENT1_SETMASK)
                             2390 ; 158  |#define HW_BATT_RESULT_GT_EVENT0_CLRMASK (~(WORD)HW_BATT_RESULT_GT_EVENT0_SETMASK)
                             2391 ; 159  |#define HW_BATT_RESULT_LT_EVENT1_CLRMASK (~(WORD)HW_BATT_RESULT_LT_EVENT1_SETMASK)
                             2392 ; 160  |#define HW_BATT_RESULT_LT_EVENT0_CLRMASK (~(WORD)HW_BATT_RESULT_LT_EVENT0_SETMASK)
                             2393 ; 161  |#define HW_BATT_RESULT_RSVD0_CLRMASK (~(WORD)HW_BATT_RESULT_RSVD0_SETMASK)
                             2394 ; 162  |#define HW_BATT_RESULT_DATA_OUT_CLRMASK (~(WORD)HW_BATT_RESULT_DATA_OUT_SETMASK)
                             2395 ; 163  |#define HW_BATT_RESULT_RSVD1_CLRMASK (~(WORD)HW_BATT_RESULT_RSVD1_SETMASK)
                             2396 ; 164  |#define HW_BATT_RESULT_IRQ_EVENT0_CLRMASK (~(WORD)HW_BATT_RESULT_IRQ_EVENT0_SETMASK)
                             2397 ; 165  |#define HW_BATT_RESULT_IRQ_EVENT1_CLRMASK (~(WORD)HW_BATT_RESULT_IRQ_EVENT1_SETMASK)
                             2398 ; 166  |#define HW_BATT_RESULT_RSVD2_CLRMASK (~(WORD)HW_BATT_RESULT_RSVD2_SETMASK)
                             2399 ; 167  |
                             2400 ; 168  |typedef union               
                             2401 ; 169  |{
                             2402 ; 170  |    struct {
                             2403 ; 171  |        unsigned int EQ_EVENT1                  : HW_BATT_RESULT_EQ_EVENT1_WIDTH;
                             2404 ; 172  |        unsigned int EQ_EVENT0                  : HW_BATT_RESULT_EQ_EVENT0_WIDTH;
                             2405 ; 173  |        unsigned int GT_EVENT1                  : HW_BATT_RESULT_GT_EVENT1_WIDTH;
                             2406 ; 174  |        unsigned int GT_EVENT0                  : HW_BATT_RESULT_GT_EVENT0_WIDTH;
                             2407 ; 175  |        unsigned int LT_EVENT1                  : HW_BATT_RESULT_LT_EVENT1_WIDTH;
                             2408 ; 176  |        unsigned int LT_EVENT0                  : HW_BATT_RESULT_LT_EVENT0_WIDTH;
                             2409 ; 177  |        unsigned int RSVD0                     : HW_BATT_RESULT_RSVD0_WIDTH;
                             2410 ; 178  |        unsigned int DATA_OUT                  : HW_BATT_RESULT_DATA_OUT_WIDTH;
                             2411 ; 179  |        unsigned int RSVD1                     : HW_BATT_RESULT_RSVD1_WIDTH;
                             2412 ; 180  |                 unsigned int IRQ_EVENT0                                : HW_BATT_RESULT_IRQ_EVENT0_WIDTH;
                             2413 ; 181  |                 unsigned int IRQ_EVENT1                                : HW_BATT_RESULT_IRQ_EVENT1_WIDTH;                      
                             2414 ; 182  |                 unsigned int RSVD2                                         : HW_BATT_RESULT_RSVD2_WIDTH;
                             2415 ; 183  |    } B;
                             2416 ; 184  |    unsigned int I;
                             2417 ; 185  |} lradc_result_type;
                             2418 ; 186  |#define HW_BATT_RESULT      (*(volatile lradc_result_type _X*) (HW_LRADC_BASEADDR+2))    /* Battery LRADC Result Register */
                             2419 ; 187  |
                             2420 ; 188  |
                             2421 ; 189  |
                             2422 ; 190  |/////////////////////////////////////////////////////////////////////////////////
                             2423 ; 191  |//  LRADC1 Control Register (HW_LRADC1_CTRL) Bit Definitions
                             2424 ; 192  |#define HW_LRADC1_CTRL_INPUT_OFFSET_WIDTH (7)
                             2425 ; 193  |#define HW_LRADC1_CTRL_RSVD0_WIDTH (1)
                             2426 ; 194  |#define HW_LRADC1_CTRL_HALF_CMP_PWR_WIDTH (1)
                             2427 ; 195  |#define HW_LRADC1_CTRL_INPUT_DIV2_WIDTH (1)
                             2428 ; 196  |#define HW_LRADC1_CTRL_CLEAR_WIDTH (1)
                             2429 ; 197  |#define HW_LRADC1_CTRL_PWD_WIDTH (1)
                             2430 ; 198  |#define HW_LRADC1_CTRL_CLK_DIV_WIDTH (2)
                             2431 ; 199  |#define HW_LRADC1_CTRL_RSVD1_WIDTH (2)
                             2432 ; 200  |#define HW_LRADC1_CTRL_REF_VAL_WIDTH (2)
                             2433 ; 201  |#define HW_LRADC1_CTRL_RSVD2_WIDTH (6)
                             2434 ; 202  |
                             2435 ; 203  |#define HW_LRADC1_CTRL_INPUT_OFFSET_BITPOS (0)
                             2436 ; 204  |#define HW_LRADC1_CTRL_HALF_CMP_PWR_BITPOS (8)
                             2437 ; 205  |#define HW_LRADC1_CTRL_INPUT_DIV2_BITPOS (9)
                             2438 ; 206  |#define HW_LRADC1_CTRL_CLEAR_BITPOS (10)
                             2439 ; 207  |#define HW_LRADC1_CTRL_PWD_BITPOS (11)
                             2440 ; 208  |#define HW_LRADC1_CTRL_CLK_DIV_BITPOS (12)
                             2441 ; 209  |#define HW_LRADC1_CTRL_REF_VAL_BITPOS (16)
                             2442 ; 210  |
                             2443 ; 211  |#define HW_LRADC1_CTRL_INPUT_OFFSET_SETMASK (((1<<HW_LRADC1_CTRL_INPUT_OFFSET_WIDTH)-1)<<HW_LRADC1_CTRL_INPUT_OFFSET_BITPOS)        
                             2444 ; 212  |#define HW_LRADC1_CTRL_HALF_CMP_PWR_SETMASK (((1<<HW_LRADC1_CTRL_HALF_CMP_PWR_WIDTH)-1)<<HW_LRADC1_CTRL_HALF_CMP_PWR_BITPOS)        
                             2445 ; 213  |#define HW_LRADC1_CTRL_INPUT_DIV2_SETMASK (((1<<HW_LRADC1_CTRL_INPUT_DIV2_WIDTH)-1)<<HW_LRADC1_CTRL_INPUT_DIV2_BITPOS) 
                             2446 ; 214  |#define HW_LRADC1_CTRL_CLEAR_SETMASK (((1<<HW_LRADC1_CTRL_CLEAR_WIDTH)-1)<<HW_LRADC1_CTRL_CLEAR_BITPOS) 
                             2447 ; 215  |#define HW_LRADC1_CTRL_PWD_SETMASK (((1<<HW_LRADC1_CTRL_PWD_WIDTH)-1)<<HW_LRADC1_CTRL_PWD_BITPOS) 
                             2448 ; 216  |#define HW_LRADC1_CTRL_CLK_DIV_SETMASK (((1<<HW_LRADC1_CTRL_CLK_DIV_WIDTH)-1)<<HW_LRADC1_CTRL_CLK_DIV_BITPOS)        
                             2449 ; 217  |#define HW_LRADC1_CTRL_REF_VAL_SETMASK (((1<<HW_LRADC1_CTRL_REF_VAL_WIDTH)-1)<<HW_LRADC1_CTRL_REF_VAL_BITPOS)        
                             2450 ; 218  |
                             2451 ; 219  |#define HW_LRADC1_CTRL_INPUT_OFFSET_CLRMASK (~(WORD)HW_LRADC1_CTRL_INPUT_OFFSET_SETMASK)     
                             2452 ; 220  |#define HW_LRADC1_CTRL_HALF_CMP_PWR_CLRMASK (~(WORD)HW_LRADC1_CTRL_HALF_CMP_PWR_SETMASK)     
                             2453 ; 221  |#define HW_LRADC1_CTRL_INPUT_DIV2_CLRMASK (~(WORD)HW_LRADC1_CTRL_INPUT_DIV2_SETMASK) 
                             2454 ; 222  |#define HW_LRADC1_CTRL_CLEAR_CLRMASK (~(WORD)HW_LRADC1_CTRL_CLEAR_SETMASK) 
                             2455 ; 223  |#define HW_LRADC1_CTRL_PWD_CLRMASK (~(WORD)HW_LRADC1_CTRL_PWD_SETMASK) 
                             2456 ; 224  |#define HW_LRADC1_CTRL_CLK_DIV_CLRMASK (~(WORD)HW_LRADC1_CTRL_CLK_DIV_SETMASK)     
                             2457 ; 225  |#define HW_LRADC1_CTRL_REF_VAL_CLRMASK (~(WORD)HW_LRADC1_CTRL_REF_VAL_SETMASK)     
                             2458 ; 226  |
                             2459 ; 227  |#define HW_LRADC1_CTRL      (*(volatile lradc_ctrl_type _X*) (HW_LRADC_BASEADDR+3))    /* LRADC1 Control Register */
                             2460 ; 228  |
                             2461 ; 229  |
                             2462 ; 230  |
                             2463 ; 231  |/////////////////////////////////////////////////////////////////////////////////
                             2464 ; 232  |//  LRADC1 Threshold Register (HW_LRADC1_THRSH) Bit Definitions
                             2465 ; 233  |#define HW_LRADC1_THRSH_MIN_THRESHOLD_WIDTH (9)
                             2466 ; 234  |#define HW_LRADC1_THRSH_RSVD0_WIDTH (3)
                             2467 ; 235  |#define HW_LRADC1_THRSH_MAX_THRESHOLD_WIDTH (9)
                             2468 ; 236  |#define HW_LRADC1_THRSH_RSVD1_WIDTH (3)
                             2469 ; 237  |
                             2470 ; 238  |#define HW_LRADC1_THRSH_MIN_THRESHOLD_BITPOS (0)
                             2471 ; 239  |#define HW_LRADC1_THRSH_MAX_THRESHOLD_BITPOS (12)
                             2472 ; 240  |
                             2473 ; 241  |#define HW_LRADC1_THRSH_MIN_THRESHOLD_SETMASK (((1<<HW_LRADC1_THRSH_MIN_THRESHOLD_WIDTH)-1)<<HW_LRADC1_THRSH_MIN_THRESHOLD_BITPOS)        
                             2474 ; 242  |#define HW_LRADC1_THRSH_MAX_THRESHOLD_SETMASK (((1<<HW_LRADC1_THRSH_MAX_THRESHOLD_WIDTH)-1)<<HW_LRADC1_THRSH_MAX_THRESHOLD_BITPOS)        
                             2475 ; 243  |
                             2476 ; 244  |#define HW_LRADC1_THRSH_MIN_THRESHOLD_CLRMASK (~(WORD)HW_LRADC1_THRSH_MIN_THRESHOLD_SETMASK)     
                             2477 ; 245  |#define HW_LRADC1_THRSH_MAX_THRESHOLD_CLRMASK (~(WORD)HW_LRADC1_THRSH_MAX_THRESHOLD_SETMASK)     
                             2478 ; 246  |
                             2479 ; 247  |#define HW_LRADC1_THRSH      (*(volatile lradc_thrsh_type _X*) (HW_LRADC_BASEADDR+4))    /* LRADC1 Threshold Register */
                             2480 ; 248  |
                             2481 ; 249  |/////////////////////////////////////////////////////////////////////////////////
                             2482 ; 250  |//  LRADC1 Result Register (HW_LRADC1_RESULT) Bit Definitions
                             2483 ; 251  |#define HW_LRADC1_RESULT_EQ_EVENT1_WIDTH (1)
                             2484 ; 252  |#define HW_LRADC1_RESULT_EQ_EVENT0_WIDTH (1)
                             2485 ; 253  |#define HW_LRADC1_RESULT_GT_EVENT1_WIDTH (1)
                             2486 ; 254  |#define HW_LRADC1_RESULT_GT_EVENT0_WIDTH (1)
                             2487 ; 255  |#define HW_LRADC1_RESULT_LT_EVENT1_WIDTH (1)
                             2488 ; 256  |#define HW_LRADC1_RESULT_LT_EVENT0_WIDTH (1)
                             2489 ; 257  |#define HW_LRADC1_RESULT_RSVD0_WIDTH (2)
                             2490 ; 258  |#define HW_LRADC1_RESULT_DATA_OUT_WIDTH (9)
                             2491 ; 259  |#define HW_LRADC1_RESULT_RSVD1_WIDTH (3)
                             2492 ; 260  |#define HW_LRADC1_RESULT_IRQ_EVENT0_WIDTH (1)
                             2493 ; 261  |#define HW_LRADC1_RESULT_IRQ_EVENT1_WIDTH (1)
                             2494 ; 262  |#define HW_LRADC1_RESULT_RSVD2_WIDTH (2)
                             2495 ; 263  |
                             2496 ; 264  |#define HW_LRADC1_RESULT_EQ_EVENT1_BITPOS (0)
                             2497 ; 265  |#define HW_LRADC1_RESULT_EQ_EVENT0_BITPOS (1)
                             2498 ; 266  |#define HW_LRADC1_RESULT_GT_EVENT1_BITPOS (2)
                             2499 ; 267  |#define HW_LRADC1_RESULT_GT_EVENT0_BITPOS (3)
                             2500 ; 268  |#define HW_LRADC1_RESULT_LT_EVENT1_BITPOS (4)
                             2501 ; 269  |#define HW_LRADC1_RESULT_LT_EVENT0_BITPOS (5)
                             2502 ; 270  |#define HW_LRADC1_RESULT_RSVD0_BITPOS (6)
                             2503 ; 271  |#define HW_LRADC1_RESULT_DATA_OUT_BITPOS (8)
                             2504 ; 272  |#define HW_LRADC1_RESULT_RSVD1_BITPOS (17)
                             2505 ; 273  |#define HW_LRADC1_RESULT_IRQ_EVENT0_BITPOS (20)
                             2506 ; 274  |#define HW_LRADC1_RESULT_IRQ_EVENT1_BITPOS (21)
                             2507 ; 275  |#define HW_LRADC1_RESULT_RSVD2_BITPOS (22)
                             2508 ; 276  |
                             2509 ; 277  |#define HW_LRADC1_RESULT_EQ_EVENT1_SETMASK (((1<<HW_LRADC1_RESULT_EQ_EVENT1_WIDTH)-1)<<HW_LRADC1_RESULT_EQ_EVENT1_BITPOS)
                             2510 ; 278  |#define HW_LRADC1_RESULT_EQ_EVENT0_SETMASK (((1<<HW_LRADC1_RESULT_EQ_EVENT0_WIDTH)-1)<<HW_LRADC1_RESULT_EQ_EVENT0_BITPOS)
                             2511 ; 279  |#define HW_LRADC1_RESULT_GT_EVENT1_SETMASK (((1<<HW_LRADC1_RESULT_GT_EVENT1_WIDTH)-1)<<HW_LRADC1_RESULT_GT_EVENT1_BITPOS)
                             2512 ; 280  |#define HW_LRADC1_RESULT_GT_EVENT0_SETMASK (((1<<HW_LRADC1_RESULT_GT_EVENT0_WIDTH)-1)<<HW_LRADC1_RESULT_GT_EVENT0_BITPOS)
                             2513 ; 281  |#define HW_LRADC1_RESULT_LT_EVENT1_SETMASK (((1<<HW_LRADC1_RESULT_LT_EVENT1_WIDTH)-1)<<HW_LRADC1_RESULT_LT_EVENT1_BITPOS)
                             2514 ; 282  |#define HW_LRADC1_RESULT_LT_EVENT0_SETMASK (((1<<HW_LRADC1_RESULT_LT_EVENT0_WIDTH)-1)<<HW_LRADC1_RESULT_LT_EVENT0_BITPOS)
                             2515 ; 283  |#define HW_LRADC1_RESULT_RSVD0_SETMASK (((1<<HW_LRADC1_RESULT_RSVD0_WIDTH)-1)<<HW_LRADC1_RESULT_RSVD0_BITPOS)
                             2516 ; 284  |#define HW_LRADC1_RESULT_DATA_OUT_SETMASK (((1<<HW_LRADC1_RESULT_DATA_OUT_WIDTH)-1)<<HW_LRADC1_RESULT_DATA_OUT_BITPOS)
                             2517 ; 285  |#define HW_LRADC1_RESULT_RSVD1_SETMASK (((1<<HW_LRADC1_RESULT_RSVD1_WIDTH)-1)<<HW_LRADC1_RESULT_RSVD1_BITPOS)
                             2518 ; 286  |#define HW_LRADC1_RESULT_IRQ_EVENT0_SETMASK (((1<<HW_LRADC1_RESULT_IRQ_EVENT0_WIDTH)-1)<<HW_LRADC1_RESULT_IRQ_EVENT0_BITPOS)
                             2519 ; 287  |#define HW_LRADC1_RESULT_IRQ_EVENT1_SETMASK (((1<<HW_LRADC1_RESULT_IRQ_EVENT1_WIDTH)-1)<<HW_LRADC1_RESULT_IRQ_EVENT1_BITPOS)
                             2520 ; 288  |#define HW_LRADC1_RESULT_RSVD2_SETMASK (((1<<HW_LRADC1_RESULT_RSVD2_WIDTH)-1)<<HW_LRADC1_RESULT_RSVD2_BITPOS)
                             2521 ; 289  |
                             2522 ; 290  |
                             2523 ; 291  |#define HW_LRADC1_RESULT_EQ_EVENT1_CLRMASK (~(WORD)HW_LRADC1_RESULT_EQ_EVENT1_SETMASK)
                             2524 ; 292  |#define HW_LRADC1_RESULT_EQ_EVENT0_CLRMASK (~(WORD)HW_LRADC1_RESULT_EQ_EVENT0_SETMASK)
                             2525 ; 293  |#define HW_LRADC1_RESULT_GT_EVENT1_CLRMASK (~(WORD)HW_LRADC1_RESULT_GT_EVENT1_SETMASK)
                             2526 ; 294  |#define HW_LRADC1_RESULT_GT_EVENT0_CLRMASK (~(WORD)HW_LRADC1_RESULT_GT_EVENT0_SETMASK)
                             2527 ; 295  |#define HW_LRADC1_RESULT_LT_EVENT1_CLRMASK (~(WORD)HW_LRADC1_RESULT_LT_EVENT1_SETMASK)
                             2528 ; 296  |#define HW_LRADC1_RESULT_LT_EVENT0_CLRMASK (~(WORD)HW_LRADC1_RESULT_LT_EVENT0_SETMASK)
                             2529 ; 297  |#define HW_LRADC1_RESULT_RSVD0_CLRMASK (~(WORD)HW_LRADC1_RESULT_RSVD0_SETMASK)
                             2530 ; 298  |#define HW_LRADC1_RESULT_DATA_OUT_CLRMASK (~(WORD)HW_LRADC1_RESULT_DATA_OUT_SETMASK)
                             2531 ; 299  |#define HW_LRADC1_RESULT_RSVD1_CLRMASK (~(WORD)HW_LRADC1_RESULT_RSVD1_SETMASK)
                             2532 ; 300  |#define HW_LRADC1_RESULT_IRQ_EVENT0_CLRMASK (~(WORD)HW_LRADC1_RESULT_IRQ_EVENT0_SETMASK)
                             2533 ; 301  |#define HW_LRADC1_RESULT_IRQ_EVENT1_CLRMASK (~(WORD)HW_LRADC1_RESULT_IRQ_EVENT1_SETMASK)
                             2534 ; 302  |#define HW_LRADC1_RESULT_RSVD2_CLRMASK (~(WORD)HW_LRADC1_RESULT_RSVD2_SETMASK)
                             2535 ; 303  |
                             2536 ; 304  |#define HW_LRADC1_RESULT      (*(volatile lradc_result_type _X*) (HW_LRADC_BASEADDR+5))    /* LRADC1 Result Register */
                             2537 ; 305  |
                             2538 ; 306  |/////////////////////////////////////////////////////////////////////////////////
                             2539 ; 307  |//  LRADC2_CTRL Control Register (HW_LRADC2_CTRL_CTRL) Bit Definitions
TASKING DSP2410 assembler v1.5r1 Build 138 SN 00100122
                                                                                                                                                                                                                                                       Page  11

M:ADDR CODE           CYCLES LINE SOURCELINE
                             2540 ; 308  |#define HW_LRADC2_CTRL_CTRL_INPUT_OFFSET_WIDTH (7)
                             2541 ; 309  |#define HW_LRADC2_CTRL_CTRL_RSVD0_WIDTH (1)
                             2542 ; 310  |#define HW_LRADC2_CTRL_CTRL_HALF_CMP_PWR_WIDTH (1)
                             2543 ; 311  |#define HW_LRADC2_CTRL_CTRL_INPUT_DIV2_WIDTH (1)
                             2544 ; 312  |#define HW_LRADC2_CTRL_CTRL_CLEAR_WIDTH (1)
                             2545 ; 313  |#define HW_LRADC2_CTRL_CTRL_PWD_WIDTH (1)
                             2546 ; 314  |#define HW_LRADC2_CTRL_CTRL_CLK_DIV_WIDTH (2)
                             2547 ; 315  |#define HW_LRADC2_CTRL_CTRL_RSVD1_WIDTH (2)
                             2548 ; 316  |#define HW_LRADC2_CTRL_CTRL_REF_VAL_WIDTH (2)
                             2549 ; 317  |#define HW_LRADC2_CTRL_CTRL_RSVD2_WIDTH (6)
                             2550 ; 318  |
                             2551 ; 319  |#define HW_LRADC2_CTRL_CTRL_INPUT_OFFSET_BITPOS (0)
                             2552 ; 320  |#define HW_LRADC2_CTRL_CTRL_HALF_CMP_PWR_BITPOS (8)
                             2553 ; 321  |#define HW_LRADC2_CTRL_CTRL_INPUT_DIV2_BITPOS (9)
                             2554 ; 322  |#define HW_LRADC2_CTRL_CTRL_CLEAR_BITPOS (10)
                             2555 ; 323  |#define HW_LRADC2_CTRL_CTRL_PWD_BITPOS (11)
                             2556 ; 324  |#define HW_LRADC2_CTRL_CTRL_CLK_DIV_BITPOS (12)
                             2557 ; 325  |#define HW_LRADC2_CTRL_CTRL_REF_VAL_BITPOS (16)
                             2558 ; 326  |
                             2559 ; 327  |#define HW_LRADC2_CTRL_CTRL_INPUT_OFFSET_SETMASK (((1<<HW_LRADC2_CTRL_CTRL_INPUT_OFFSET_WIDTH)-1)<<HW_LRADC2_CTRL_CTRL_INPUT_OFFSET_BITPOS)        
                             2560 ; 328  |#define HW_LRADC2_CTRL_CTRL_HALF_CMP_PWR_SETMASK (((1<<HW_LRADC2_CTRL_CTRL_HALF_CMP_PWR_WIDTH)-1)<<HW_LRADC2_CTRL_CTRL_HALF_CMP_PWR_BITPOS)        
                             2561 ; 329  |#define HW_LRADC2_CTRL_CTRL_INPUT_DIV2_SETMASK (((1<<HW_LRADC2_CTRL_CTRL_INPUT_DIV2_WIDTH)-1)<<HW_LRADC2_CTRL_CTRL_INPUT_DIV2_BITPOS) 
                             2562 ; 330  |#define HW_LRADC2_CTRL_CTRL_CLEAR_SETMASK (((1<<HW_LRADC2_CTRL_CTRL_CLEAR_WIDTH)-1)<<HW_LRADC2_CTRL_CTRL_CLEAR_BITPOS) 
                             2563 ; 331  |#define HW_LRADC2_CTRL_CTRL_PWD_SETMASK (((1<<HW_LRADC2_CTRL_CTRL_PWD_WIDTH)-1)<<HW_LRADC2_CTRL_CTRL_PWD_BITPOS) 
                             2564 ; 332  |#define HW_LRADC2_CTRL_CTRL_CLK_DIV_SETMASK (((1<<HW_LRADC2_CTRL_CTRL_CLK_DIV_WIDTH)-1)<<HW_LRADC2_CTRL_CTRL_CLK_DIV_BITPOS)        
                             2565 ; 333  |#define HW_LRADC2_CTRL_CTRL_REF_VAL_SETMASK (((1<<HW_LRADC2_CTRL_CTRL_REF_VAL_WIDTH)-1)<<HW_LRADC2_CTRL_CTRL_REF_VAL_BITPOS)        
                             2566 ; 334  |
                             2567 ; 335  |#define HW_LRADC2_CTRL_CTRL_INPUT_OFFSET_CLRMASK (~(WORD)HW_LRADC2_CTRL_CTRL_INPUT_OFFSET_SETMASK)     
                             2568 ; 336  |#define HW_LRADC2_CTRL_CTRL_HALF_CMP_PWR_CLRMASK (~(WORD)HW_LRADC2_CTRL_CTRL_HALF_CMP_PWR_SETMASK)     
                             2569 ; 337  |#define HW_LRADC2_CTRL_CTRL_INPUT_DIV2_CLRMASK (~(WORD)HW_LRADC2_CTRL_CTRL_INPUT_DIV2_SETMASK) 
                             2570 ; 338  |#define HW_LRADC2_CTRL_CTRL_CLEAR_CLRMASK (~(WORD)HW_LRADC2_CTRL_CTRL_CLEAR_SETMASK) 
                             2571 ; 339  |#define HW_LRADC2_CTRL_CTRL_PWD_CLRMASK (~(WORD)HW_LRADC2_CTRL_CTRL_PWD_SETMASK) 
                             2572 ; 340  |#define HW_LRADC2_CTRL_CTRL_CLK_DIV_CLRMASK (~(WORD)HW_LRADC2_CTRL_CTRL_CLK_DIV_SETMASK)     
                             2573 ; 341  |#define HW_LRADC2_CTRL_CTRL_REF_VAL_CLRMASK (~(WORD)HW_LRADC2_CTRL_CTRL_REF_VAL_SETMASK)     
                             2574 ; 342  |
                             2575 ; 343  |
                             2576 ; 344  |#define HW_LRADC2_CTRL      (*(volatile lradc_ctrl_type _X*) (HW_LRADC_BASEADDR+6))    /* LRADC2_CTRL Control Register */
                             2577 ; 345  |
                             2578 ; 346  |
                             2579 ; 347  |
                             2580 ; 348  |/////////////////////////////////////////////////////////////////////////////////
                             2581 ; 349  |//  LRADC2 Threshold Register (HW_LRADC2_THRSH) Bit Definitions
                             2582 ; 350  |#define HW_LRADC2_THRSH_MIN_THRESHOLD_WIDTH (9)
                             2583 ; 351  |#define HW_LRADC2_THRSH_RSVD0_WIDTH (3)
                             2584 ; 352  |#define HW_LRADC2_THRSH_MAX_THRESHOLD_WIDTH (9)
                             2585 ; 353  |#define HW_LRADC2_THRSH_RSVD1_WIDTH (3)
                             2586 ; 354  |
                             2587 ; 355  |#define HW_LRADC2_THRSH_MIN_THRESHOLD_BITPOS (0)
                             2588 ; 356  |#define HW_LRADC2_THRSH_MAX_THRESHOLD_BITPOS (12)
                             2589 ; 357  |
                             2590 ; 358  |#define HW_LRADC2_THRSH_MIN_THRESHOLD_SETMASK (((1<<HW_LRADC2_THRSH_MIN_THRESHOLD_WIDTH)-1)<<HW_LRADC2_THRSH_MIN_THRESHOLD_BITPOS)        
                             2591 ; 359  |#define HW_LRADC2_THRSH_MAX_THRESHOLD_SETMASK (((1<<HW_LRADC2_THRSH_MAX_THRESHOLD_WIDTH)-1)<<HW_LRADC2_THRSH_MAX_THRESHOLD_BITPOS)        
                             2592 ; 360  |
                             2593 ; 361  |#define HW_LRADC2_THRSH_MIN_THRESHOLD_CLRMASK (~(WORD)HW_LRADC2_THRSH_MIN_THRESHOLD_SETMASK)     
                             2594 ; 362  |#define HW_LRADC2_THRSH_MAX_THRESHOLD_CLRMASK (~(WORD)HW_LRADC2_THRSH_MAX_THRESHOLD_SETMASK)     
                             2595 ; 363  |
                             2596 ; 364  |#define HW_LRADC2_THRSH      (*(volatile lradc_thrsh_type _X*) (HW_LRADC_BASEADDR+7))    /* LRADC2 Threshold Register */
                             2597 ; 365  |
                             2598 ; 366  |
                             2599 ; 367  |
                             2600 ; 368  |/////////////////////////////////////////////////////////////////////////////////
                             2601 ; 369  |//  LRADC2 Result Register (HW_LRADC2_RESULT) Bit Definitions
                             2602 ; 370  |#define HW_LRADC2_RESULT_EQ_EVENT1_WIDTH (1)
                             2603 ; 371  |#define HW_LRADC2_RESULT_EQ_EVENT0_WIDTH (1)
                             2604 ; 372  |#define HW_LRADC2_RESULT_GT_EVENT1_WIDTH (1)
                             2605 ; 373  |#define HW_LRADC2_RESULT_GT_EVENT0_WIDTH (1)
                             2606 ; 374  |#define HW_LRADC2_RESULT_LT_EVENT1_WIDTH (1)
                             2607 ; 375  |#define HW_LRADC2_RESULT_LT_EVENT0_WIDTH (1)
                             2608 ; 376  |#define HW_LRADC2_RESULT_RSVD0_WIDTH (2)
                             2609 ; 377  |#define HW_LRADC2_RESULT_DATA_OUT_WIDTH (9)
                             2610 ; 378  |#define HW_LRADC2_RESULT_RSVD1_WIDTH (3)
                             2611 ; 379  |#define HW_LRADC2_RESULT_IRQ_EVENT0_WIDTH (1)
                             2612 ; 380  |#define HW_LRADC2_RESULT_IRQ_EVENT1_WIDTH (1)
                             2613 ; 381  |#define HW_LRADC2_RESULT_RSVD2_WIDTH (2)
                             2614 ; 382  |
                             2615 ; 383  |#define HW_LRADC2_RESULT_EQ_EVENT1_BITPOS (0)
                             2616 ; 384  |#define HW_LRADC2_RESULT_EQ_EVENT0_BITPOS (1)
                             2617 ; 385  |#define HW_LRADC2_RESULT_GT_EVENT1_BITPOS (2)
                             2618 ; 386  |#define HW_LRADC2_RESULT_GT_EVENT0_BITPOS (3)
                             2619 ; 387  |#define HW_LRADC2_RESULT_LT_EVENT1_BITPOS (4)
                             2620 ; 388  |#define HW_LRADC2_RESULT_LT_EVENT0_BITPOS (5)
                             2621 ; 389  |#define HW_LRADC2_RESULT_RSVD0_BITPOS (6)
                             2622 ; 390  |#define HW_LRADC2_RESULT_DATA_OUT_BITPOS (8)
                             2623 ; 391  |#define HW_LRADC2_RESULT_RSVD1_BITPOS (17)
                             2624 ; 392  |#define HW_LRADC2_RESULT_IRQ_EVENT0_BITPOS (20)
                             2625 ; 393  |#define HW_LRADC2_RESULT_IRQ_EVENT1_BITPOS (21)
                             2626 ; 394  |#define HW_LRADC2_RESULT_RSVD2_BITPOS (22)
                             2627 ; 395  |
                             2628 ; 396  |#define HW_LRADC2_RESULT_EQ_EVENT1_SETMASK (((1<<HW_LRADC2_RESULT_EQ_EVENT1_WIDTH)-1)<<HW_LRADC2_RESULT_EQ_EVENT1_BITPOS)
                             2629 ; 397  |#define HW_LRADC2_RESULT_EQ_EVENT0_SETMASK (((1<<HW_LRADC2_RESULT_EQ_EVENT0_WIDTH)-1)<<HW_LRADC2_RESULT_EQ_EVENT0_BITPOS)
                             2630 ; 398  |#define HW_LRADC2_RESULT_GT_EVENT1_SETMASK (((1<<HW_LRADC2_RESULT_GT_EVENT1_WIDTH)-1)<<HW_LRADC2_RESULT_GT_EVENT1_BITPOS)
                             2631 ; 399  |#define HW_LRADC2_RESULT_GT_EVENT0_SETMASK (((1<<HW_LRADC2_RESULT_GT_EVENT0_WIDTH)-1)<<HW_LRADC2_RESULT_GT_EVENT0_BITPOS)
                             2632 ; 400  |#define HW_LRADC2_RESULT_LT_EVENT1_SETMASK (((1<<HW_LRADC2_RESULT_LT_EVENT1_WIDTH)-1)<<HW_LRADC2_RESULT_LT_EVENT1_BITPOS)
                             2633 ; 401  |#define HW_LRADC2_RESULT_LT_EVENT0_SETMASK (((1<<HW_LRADC2_RESULT_LT_EVENT0_WIDTH)-1)<<HW_LRADC2_RESULT_LT_EVENT0_BITPOS)
                             2634 ; 402  |#define HW_LRADC2_RESULT_RSVD0_SETMASK (((1<<HW_LRADC2_RESULT_RSVD0_WIDTH)-1)<<HW_LRADC2_RESULT_RSVD0_BITPOS)
                             2635 ; 403  |#define HW_LRADC2_RESULT_DATA_OUT_SETMASK (((1<<HW_LRADC2_RESULT_DATA_OUT_WIDTH)-1)<<HW_LRADC2_RESULT_DATA_OUT_BITPOS)
                             2636 ; 404  |#define HW_LRADC2_RESULT_RSVD1_SETMASK (((1<<HW_LRADC2_RESULT_RSVD1_WIDTH)-1)<<HW_LRADC2_RESULT_RSVD1_BITPOS)
                             2637 ; 405  |#define HW_LRADC2_RESULT_IRQ_EVENT0_SETMASK (((1<<HW_LRADC2_RESULT_IRQ_EVENT0_WIDTH)-1)<<HW_LRADC2_RESULT_IRQ_EVENT0_BITPOS)
                             2638 ; 406  |#define HW_LRADC2_RESULT_IRQ_EVENT1_SETMASK (((1<<HW_LRADC2_RESULT_IRQ_EVENT1_WIDTH)-1)<<HW_LRADC2_RESULT_IRQ_EVENT1_BITPOS)
                             2639 ; 407  |#define HW_LRADC2_RESULT_RSVD2_SETMASK (((1<<HW_LRADC2_RESULT_RSVD2_WIDTH)-1)<<HW_LRADC2_RESULT_RSVD2_BITPOS)
                             2640 ; 408  |
                             2641 ; 409  |#define HW_LRADC2_RESULT_EQ_EVENT1_CLRMASK (~(WORD)HW_LRADC2_RESULT_EQ_EVENT1_SETMASK)
                             2642 ; 410  |#define HW_LRADC2_RESULT_EQ_EVENT0_CLRMASK (~(WORD)HW_LRADC2_RESULT_EQ_EVENT0_SETMASK)
                             2643 ; 411  |#define HW_LRADC2_RESULT_GT_EVENT1_CLRMASK (~(WORD)HW_LRADC2_RESULT_GT_EVENT1_SETMASK)
                             2644 ; 412  |#define HW_LRADC2_RESULT_GT_EVENT0_CLRMASK (~(WORD)HW_LRADC2_RESULT_GT_EVENT0_SETMASK)
                             2645 ; 413  |#define HW_LRADC2_RESULT_LT_EVENT1_CLRMASK (~(WORD)HW_LRADC2_RESULT_LT_EVENT1_SETMASK)
                             2646 ; 414  |#define HW_LRADC2_RESULT_LT_EVENT0_CLRMASK (~(WORD)HW_LRADC2_RESULT_LT_EVENT0_SETMASK)
                             2647 ; 415  |#define HW_LRADC2_RESULT_RSVD0_CLRMASK (~(WORD)HW_LRADC2_RESULT_RSVD0_SETMASK)
                             2648 ; 416  |#define HW_LRADC2_RESULT_DATA_OUT_CLRMASK (~(WORD)HW_LRADC2_RESULT_DATA_OUT_SETMASK)
                             2649 ; 417  |#define HW_LRADC2_RESULT_RSVD1_CLRMASK (~(WORD)HW_LRADC2_RESULT_RSVD1_SETMASK)
                             2650 ; 418  |#define HW_LRADC2_RESULT_IRQ_EVENT0_CLRMASK (~(WORD)HW_LRADC2_RESULT_IRQ_EVENT0_SETMASK)
                             2651 ; 419  |#define HW_LRADC2_RESULT_IRQ_EVENT1_CLRMASK (~(WORD)HW_LRADC2_RESULT_IRQ_EVENT1_SETMASK)
                             2652 ; 420  |#define HW_LRADC2_RESULT_RSVD2_CLRMASK (~(WORD)HW_LRADC2_RESULT_RSVD2_SETMASK)
                             2653 ; 421  |
                             2654 ; 422  |#define HW_LRADC2_RESULT      (*(volatile lradc_result_type _X*) (HW_LRADC_BASEADDR+8))    /* LRADC2 Result Register */
                             2655 ; 423  |#define HW_LRADC_REF_0_SETMASK                  0x0<<HW_BATT_CTRL_REF_VAL_BITPOS
                             2656 ; 424  |#define HW_LRADC_REF_1_SETMASK                  0x1<<HW_BATT_CTRL_REF_VAL_BITPOS
                             2657 ; 425  |#define HW_LRADC_REF_2_SETMASK                  0x2<<HW_BATT_CTRL_REF_VAL_BITPOS
                             2658 ; 426  |#define HW_LRADC_REF_3_SETMASK                  0x3<<HW_BATT_CTRL_REF_VAL_BITPOS
                             2659 ; 427  |#define HW_LRADC_REF_4_SETMASK                  HW_LRADC_REF_0_SETMASK|HW_BATT_CTRL_INPUT_DIV2_SETMASK
                             2660 ; 428  |#define HW_LRADC_REF_5_SETMASK                  HW_LRADC_REF_1_SETMASK|HW_BATT_CTRL_INPUT_DIV2_SETMASK
                             2661 ; 429  |#define HW_LRADC_REF_6_SETMASK                  HW_LRADC_REF_2_SETMASK|HW_BATT_CTRL_INPUT_DIV2_SETMASK
                             2662 ; 430  |#define HW_LRADC_REF_7_SETMASK                  HW_LRADC_REF_3_SETMASK|HW_BATT_CTRL_INPUT_DIV2_SETMASK
                             2663 ; 431  |#define HW_LRADC_RES_REF_0                              80
                             2664 ; 432  |#define HW_LRADC_RES_REF_1                              77
                             2665 ; 433  |#define HW_LRADC_RES_REF_2                              100
                             2666 ; 434  |#define HW_LRADC_RES_REF_3                              129
                             2667 ; 435  |#define HW_LRADC_RES_REF_4                              160
                             2668 ; 436  |#define HW_LRADC_RES_REF_5                              154
                             2669 ; 437  |#define HW_LRADC_RES_REF_6                              200
                             2670 ; 438  |#define HW_LRADC_RES_REF_7                              258
                             2671 ; 439  |#define LRADC_HALF_POWER_SETMASK                HW_BATT_CTRL_HALF_CMP_PWR_SETMASK          
                             2672 ; 440  |// Translate the generic API enumerations into more meaningful labels for the implementation
                             2673 ; 441  |#define REF_2700MV                      HW_LRADC_REF_0_SETMASK
                             2674 ; 442  |#define REF_2600MV              HW_LRADC_REF_1_SETMASK
                             2675 ; 443  |#define REF_2560MV              HW_LRADC_REF_2_SETMASK
                             2676 ; 444  |#define REF_VDDIO               HW_LRADC_REF_3_SETMASK
                             2677 ; 445  |#define REF_5400MV              HW_LRADC_REF_4_SETMASK
                             2678 ; 446  |#define REF_5200MV              HW_LRADC_REF_5_SETMASK
                             2679 ; 447  |#define REF_5120MV              HW_LRADC_REF_6_SETMASK
                             2680 ; 448  |#define REF_VDDIOx2             HW_LRADC_REF_7_SETMASK
                             2681 ; 449  |#define RES_REF_2700MV  HW_LRADC_RES_REF_0
                             2682 ; 450  |#define RES_REF_2600MV  HW_LRADC_RES_REF_1
                             2683 ; 451  |#define RES_REF_2560MV  HW_LRADC_RES_REF_2
                             2684 ; 452  |#define RES_REF_VDDIO   HW_LRADC_RES_REF_3
                             2685 ; 453  |#define RES_REF_5400MV  HW_LRADC_RES_REF_4
                             2686 ; 454  |#define RES_REF_5200MV  HW_LRADC_RES_REF_5
                             2687 ; 455  |#define RES_REF_5120MV  HW_LRADC_RES_REF_6
                             2688 ; 456  |#define RES_REF_VDDIOx2         HW_LRADC_RES_REF_7
                             2689 ; 457  |
                             2690 ; 458  |//Needed by button.asm
                             2691 ; 459  |#define LOW_RES_ADC_BATT_READ_MASK 0x01FF00
                             2692 ; 460  |#define LOW_RES_ADC_AUX_READ_MASK 0x01FF00
                             2693 ; 461  |#define LOW_RES_ADC_AUX2_READ_MASK 0x01FF00
                             2694 ; 462  |
                             2695 ; 463  |#define HW_LRADC_CTRL_AUXADC_SETMASK 3<<HW_BATT_CTRL_REF_VAL_BITPOS
                             2696 ; 464  |
                             2697 ; 465  |#endif
                             2698 ; 466  |
                             2699 ; 467  |
                             2700 
                             2702 
                             2703 ; 13   |
                             2704 ; 14   |// Variables
                             2705 ; 15   |extern WORD LowResAdcStatus;
                             2706 ; 16   |extern WORD LowResAdcBattResult, LowResAdcBattAvg;                                      // Results and Averages come from buttons.asm
                             2707 ; 17   |extern WORD LowResAdcAuxResult,  LowResAdcAuxAvg;
                             2708 ; 18   |extern WORD LowResAdcAux2Result, LowResAdcAux2Avg;                                      // Aux2 result and average valid for 3500
                             2709 ; 19   |
                             2710 ; 20   |
                             2711 ; 21   |// Types
                             2712 ; 22   |enum LowResADCChannel {BATT, AUX, AUX2};                                                    // AUX2 valid for 3500
                             2713 ; 23   |enum LowResADCHalfPwr {OFF = 0, ON = LRADC_HALF_POWER_SETMASK};
                             2714 ; 24   |enum LowResADCRef     {REF_0 = HW_LRADC_REF_0_SETMASK,
                             2715 ; 25   |                       REF_1 = HW_LRADC_REF_1_SETMASK,
                             2716 ; 26   |                                           REF_2 = HW_LRADC_REF_2_SETMASK,
                             2717 ; 27   |                                           REF_3 = HW_LRADC_REF_3_SETMASK,
                             2718 ; 28   |                                           REF_4 = HW_LRADC_REF_4_SETMASK,
                             2719 ; 29   |                                           REF_5 = HW_LRADC_REF_5_SETMASK,
                             2720 ; 30   |                                           REF_6 = HW_LRADC_REF_6_SETMASK,
                             2721 ; 31   |                                           REF_7 = HW_LRADC_REF_7_SETMASK
                             2722 ; 32   |                      };
                             2723 ; 33   |
                             2724 ; 34   |
                             2725 ; 35   |// ADC Reference resolutions in mV*10
                             2726 ; 36   |// 1 ADC count = Vref(mV)/([2^N] - 1) where N = # bits in result, and Vref based on selected LRADC reference.
                             2727 ; 37   |#define RES_REF_0      HW_LRADC_RES_REF_0
                             2728 ; 38   |#define RES_REF_1      HW_LRADC_RES_REF_1
                             2729 ; 39   |#define RES_REF_2      HW_LRADC_RES_REF_2
                             2730 ; 40   |#define RES_REF_3      HW_LRADC_RES_REF_3
                             2731 ; 41   |#define RES_REF_4      HW_LRADC_RES_REF_4
                             2732 ; 42   |#define RES_REF_5      HW_LRADC_RES_REF_5
                             2733 ; 43   |#define RES_REF_6      HW_LRADC_RES_REF_6
                             2734 ; 44   |#define RES_REF_7      HW_LRADC_RES_REF_7
                             2735 ; 45   |
                             2736 ; 46   |
                             2737 ; 47   |// These bits are used against LowResAdcStatus, to signal which channels to read in buttons routine
                             2738 ; 48   |#define LOW_RES_ADC_BATT_EN_MASK    1 
                             2739 ; 49   |#define LOW_RES_ADC_AUX_EN_MASK         2 
                             2740 ; 50   |#define LOW_RES_ADC_AUX2_EN_MASK        4
                             2741 ; 51   |
                             2742 ; 52   |/////////////////////////////////////////////////////////////////////////////////////////
                             2743 ; 53   |//
                             2744 ; 54   |//>  Name:          SysLowResolutionAdcReadBin
                             2745 ; 55   |//
                             2746 ; 56   |//   Type:          Function 
                             2747 ; 57   |//
                             2748 ; 58   |//   Description:   Returns the instantaneous Result of the Low Resolution ADC Channel specified
                             2749 ; 59   |//
                             2750 ; 60   |//   Inputs:        Constant specifying the Low Resolution ADC Channel
                             2751 ; 61   |//                  BATT for Battery channel
                             2752 ; 62   |//                  AUX for Auxiliary channel 1
                             2753 ; 63   |//                  AUX2 for Auxiliary channel 2
                             2754 ; 64   |//
                             2755 ; 65   |//   Outputs:       Average in binary format (0->127 for 3410, 0->255 for 3500)
                             2756 ; 66   |//
                             2757 ; 67   |//   Notes:         none
                             2758 ; 68   |//<
                             2759 ; 69   |//////////////////////////////////////////////////////////////////////////////////////////
                             2760 ; 70   |#ifdef DEVICE_3500
                             2761 ; 71   |#define SysLowResolutionAdcReadBin(n)    (n==BATT ? HW_BATT_RESULT.B.DATA_OUT : (n == AUX ? HW_LRADC1_RESULT.B.DATA_OUT: HW_LRADC2_RESULT.B.DATA_OUT))
                             2762 ; 72   |#else
                             2763 ; 73   |//3410 does not support AUX2
                             2764 ; 74   |#define SysLowResolutionAdcReadBin(n)    (n==BATT ? HW_LRADC_RES.B.BATLRR : (n == AUX ? HW_LRADC_RES.B.AUXLRR: 0))
                             2765 ; 75   |#endif
                             2766 ; 76   |
                             2767 ; 77   |/////////////////////////////////////////////////////////////////////////////////////////
                             2768 ; 78   |//
                             2769 ; 79   |//>  Name:          SysLowResolutionAdcReadAvg
                             2770 ; 80   |//
                             2771 ; 81   |//   Type:          Function 
                             2772 ; 82   |//
                             2773 ; 83   |//   Description:   Reads the Averaged Result of the Low Resolution ADC Channel specified
                             2774 ; 84   |//
                             2775 ; 85   |//   Inputs:        Constant specifying the Low Resolution ADC Channel
                             2776 ; 86   |//                  BATT for Battery channel
                             2777 ; 87   |//                  AUX for Auxiliary channel 1
                             2778 ; 88   |//                  AUX2 for Auxiliary channel 2
                             2779 ; 89   |//
                             2780 ; 90   |//   Outputs:       Average in binary format (0->127 for 3410, 0->255 for 3500)
                             2781 ; 91   |//
                             2782 ; 92   |//   Notes:         The average is done using 256 samples
                             2783 ; 93   |//<
                             2784 ; 94   |//////////////////////////////////////////////////////////////////////////////////////////
                             2785 ; 95   |#define SysLowResolutionAdcReadAvg(n)    (n==BATT ? LowResAdcBattAvg : (n == AUX ? LowResAdcAuxAvg : LowResAdcAux2Avg))
                             2786 ; 96   |
                             2787 ; 97   |// Functions  
                             2788 ; 98   |void _reentrant SysLowResolutionADCInit(enum LowResADCChannel Adc, enum LowResADCHalfPwr Power, enum LowResADCRef Ref);
                             2789 ; 99   |INT SysLowResolutionAdcReadVolt(BYTE bAdcChannel,BOOL bAverage);
                             2790 ; 100  |
                             2791 ; 101  |// Equates
TASKING DSP2410 assembler v1.5r1 Build 138 SN 00100122
                                                                                                                                                                                                                                                       Page  12

M:ADDR CODE           CYCLES LINE SOURCELINE
                             2792 ; 102  |#define AVERAGE_RESULT  TRUE
                             2793 ; 103  |#define INSTANT_RESULT  FALSE
                             2794 ; 104  |
                             2795 ; 105  |#endif // _LOWRESOLUTIONADC_H
                             2796 
                             2798 
                             2799 ; 19   |// Use absolute path so i2ctest.bat will work
                             2800 ; 20   |#include "..\..\Projects\SDK\lcdexample\battery_config.h"
                             2801 
                             2803 
                             2804 ; 1    |///////////////////////////////////////////////////////////////////////////////
                             2805 ; 2    |// Sigmatel, Inc  copyright (C) 2003-2004
                             2806 ; 3    |// Filename: battery_config.h
                             2807 ; 4    |// Battery Low Resolution ADC values & recharge values 
                             2808 ; 5    |///////////////////////////////////////////////////////////////////////////////
                             2809 ; 6    |
                             2810 ; 7    |#ifdef BATTERY_TYPE_LI_ION
                             2811 ; 8    |    //these are 3500 only
                             2812 ; 9    |    #define VBATT_REF           REF_5120MV
                             2813 ; 10   |    #define VBATT_MIN_MV        3000
                             2814 ; 11   |    #define VBATT_MAX_MV        4200
                             2815 ; 12   |
                             2816 ; 13   |    #define VBATT_BO_MV         3000
                             2817 ; 14   |
                             2818 ; 15   |    #define BATT_BROWNOUT       VBATT_BO_MV
                             2819 ; 16   |
                             2820 ; 17   |    #ifndef LIION_BATTERY_VOLTAGE
                             2821 ; 18   |    //this is in mV
                             2822 ; 19   |    //The reference design uses a 4.2V LiIon battery
                             2823 ; 20   |    #define LIION_BATTERY_VOLTAGE LIION_BATTERY_VOLTAGE_4_2
                             2824 ; 21   |    #endif 
                             2825 ; 22   |
                             2826 ; 23   |    #ifndef LIION_CONDITIONING_VOLTAGE_THRESHHOLD
                             2827 ; 24   |    //This is in millivolts
                             2828 ; 25   |    #define LIION_CONDITIONING_VOLTAGE_THRESHHOLD 3000
                             2829 ; 26   |    #endif
                             2830 ; 27   |
                             2831 ; 28   |    #ifndef LIION_CONDITIONING_CURRENT_LIMIT
                             2832 ; 29   |    //This is in mA.   
                             2833 ; 30   |    //Refer to the battery data sheet for the proper value
                             2834 ; 31   |    //the reference design uses a 400mAh battery that suggests 40mA is a good conditioning current
                             2835 ; 32   |    #define LIION_CONDITIONING_CURRENT_LIMIT 40
                             2836 ; 33   |    #endif 
                             2837 ; 34   |
                             2838 ; 35   |    #ifndef LIION_CHARGING_TIMEOUT
                             2839 ; 36   |    //the default is 4 hours
                             2840 ; 37   |    #define LIION_CHARGING_TIMEOUT  ((DWORD)(DWORD)4*(DWORD)60*(DWORD)60*(DWORD)1000)
                             2841 ; 38   |    #endif 
                             2842 ; 39   |
                             2843 ; 40   |    #ifndef LIION_CHARGING_DIFFERENTIAL_THRESHHOLD
                             2844 ; 41   |    //We want to enter the 'top-off' mode when the voltage differential between
                             2845 ; 42   |    //charging on and off is 20 mV
                             2846 ; 43   |    #define LIION_CHARGING_DIFFERENTIAL_THRESHHOLD  20
                             2847 ; 44   |    #endif 
                             2848 ; 45   |
                             2849 ; 46   |    #ifndef LIION_CHARGING_DIFFERENTIAL_THRESHHOLD_COUNT
                             2850 ; 47   |    //we want 10 samples of the non-charging current to be within the 
                             2851 ; 48   |    //differential threshhold.  
                             2852 ; 49   |
                             2853 ; 50   |#ifdef STMP_BUILD_PLAYER
                             2854 ; 51   |    #define LIION_CHARGING_DIFFERENTIAL_THRESHHOLD_COUNT 5
                             2855 ; 52   |#else
                             2856 ; 53   |    #define LIION_CHARGING_DIFFERENTIAL_THRESHHOLD_COUNT 10
                             2857 ; 54   |#endif
                             2858 ; 55   |    #endif 
                             2859 ; 56   |
                             2860 ; 57   |    #ifndef LIION_CHARGING_CURRENT_LIMIT
                             2861 ; 58   |    //This is in mA.   
                             2862 ; 59   |    //Refer to the battery data sheet for the proper value
                             2863 ; 60   |    //the reference design uses a 400mAh battery that suggests 400mA is a good charging current
                             2864 ; 61   |    #define LIION_CHARGING_CURRENT_LIMIT 400
                             2865 ; 62   |    #endif 
                             2866 ; 63   |
                             2867 ; 64   |    #ifndef LIION_TOPOFF_TIMEOUT
                             2868 ; 65   |    //After we reach that limit, we want to run for a set amount of time to 'top off' the charging
                             2869 ; 66   |    //in this case, 2 minutes (was 30)
                             2870 ; 67   |#ifdef STMP_BUILD_PLAYER
                             2871 ; 68   |    #define LIION_TOPOFF_TIMEOUT ((DWORD)(DWORD)15*(DWORD)60*(DWORD)1000)
                             2872 ; 69   |#else
                             2873 ; 70   |    #define LIION_TOPOFF_TIMEOUT ((DWORD)(DWORD)2*(DWORD)60*(DWORD)1000)
                             2874 ; 71   |#endif
                             2875 ; 72   |    #endif
                             2876 ; 73   |
                             2877 ; 74   |        #ifndef POWER_OFF_FREQUENCY
                             2878 ; 75   |        //Set the Power Off Frequency.  Determines how frequently charging is turned-off.  
                             2879 ; 76   |#ifdef STMP_BUILD_PLAYER
                             2880 ; 77   |        #define POWER_OFF_FREQUENCY 40
                             2881 ; 78   |#else
                             2882 ; 79   |        #define POWER_OFF_FREQUENCY 500
                             2883 ; 80   |#endif
                             2884 ; 81   |        #endif
                             2885 ; 82   |#endif
                             2886 ; 83   |
                             2887 ; 84   |////////////////////////////////////////////////////////////////////////////////
                             2888 ; 85   |#ifdef BATTERY_TYPE_NIMH
                             2889 ; 86   |    #define ONE  1
                             2890 ; 87   |    #define ZERO 0
                             2891 ; 88   |
                             2892 ; 89   |    //NOTE:  Battery is currently Hardcoded to REF_5120MV in USBMSC
                             2893 ; 90   |#ifdef STMP_BUILD_PLAYER
                             2894 ; 91   |    #define VBATT_REF          REF_2700MV
                             2895 ; 92   |    #define VBATT_MIN_MV       900
                             2896 ; 93   |    #define VBATT_MAX_MV       1500
                             2897 ; 94   |    #define VBATT_BO_MV        840
                             2898 ; 95   |#else
                             2899 ; 96   |    #define VBATT_REF          REF_5120MV
                             2900 ; 97   |    #define VBATT_MIN_MV       900
                             2901 ; 98   |    #define VBATT_MAX_MV       1200
                             2902 ; 99   |    #define VBATT_BO_MV        850
                             2903 ; 100  |#endif
                             2904 ; 101  |
                             2905 ; 102  |    #ifdef DEVICE_3500
                             2906 ; 103  |        #define BATT_BROWNOUT                           VBATT_BO_MV
                             2907 ; 104  |    #else
                             2908 ; 105  |        #define BATT_BROWNOUT               HW_LRADC_BO_TRIP_830MV_SETMASK
                             2909 ; 106  |    #endif
                             2910 ; 107  |    // nimh settings above this line are similar to alkaline values below except v max.
                             2911 ; 108  |    
                             2912 ; 109  |    #ifndef NIMH_BATTERY_VOLTAGE
                             2913 ; 110  |    //Units: mV. This is the rated battery voltage.
                             2914 ; 111  |    //The reference design uses a 1.5V NIMH battery
                             2915 ; 112  |    #define NIMH_BATTERY_VOLTAGE NIMH_BATTERY_VOLTAGE_1_2
                             2916 ; 113  |    #endif 
                             2917 ; 114  |
                             2918 ; 115  |    #ifndef NIMH_VOLTAGE_THRESHHOLD_MV
                             2919 ; 116  |    //Units: mV      Stop charging if this ADC battery voltage is measured. This can occur if an alkaline is inserted.
                             2920 ; 117  |    #define NIMH_VOLTAGE_THRESHHOLD_MV 1800
                             2921 ; 118  |    #endif
                             2922 ; 119  |    // 1 enables alkaline detection via brief charge current & voltage threshold check.
                             2923 ; 120  |    #define ALKALINE_DETECTION_IMPULSE_CHARGE_ENABLE 0 /* LEAVE DISABLED. Unimplemented. */
                             2924 ; 121  |
                             2925 ; 122  |    //------- NIMH Detection via exposed batt case check w/ gpio. You must configure a gpio reg & pin num also below.
                             2926 ; 123  |    #define BATTERY_CASE_POLARITY_DETECT_ENABLE 0 // Verified. GPIO pin setup in nimh.c init, External pullup R (47kOhm)
                             2927 ; 124  |    // Explanation: General Purpose Input pin can connect to cylindrical batt end corner. 
                             2928 ; 125  |    // NiMH AAA batteries have ground case exposed at corner, else casing insulation 
                             2929 ; 126  |    //   causes signal to float & external pullup R gives a logic 1 indicating non-nimh. 
                             2930 ; 127  |    // NiMH AA  batteries instead have additional positive terminal exposure (opposite polarity). 
                             2931 ; 128  |    //   Ext transistor can Vlevel shift for gpio logic-1 voltage. 
                             2932 ; 129  |    //   non-NIMH casing will allow gpio pin to stay grounded & gives logic 0.
                             2933 ; 130  |
                             2934 ; 131  |    // SET this to ZERO if your NiMH is AAA or has ground case contact (detects NiMH via case (-) contact)
                             2935 ; 132  |    // SET this to ONE if your NiMH battery is AA (detects NiMH via (+) terminal contact). Requires ext transistor V level shift.
                             2936 ; 133  |    #define NIMH_BATTERY_CASE_LOGIC_LEVEL ZERO
                             2937 ; 134  |    // *** IF YOU HAVE ENABLED, battery case polarity detection (used with nimh), 
                             2938 ; 135  |    //  NOTE: The GP number and bit number in the four macros below must be set to match your input PIN number. 
                             2939 ; 136  |    //    LAYOUT SPECIFIC, but all 3550/3560 qfp and bga can use a single GPIO register & bit num as below. 
                             2940 ; 137  |    //    SigmaTel HW apps recommends pin GP37= pin 17 (100qfp)= pin j7 (bga)= cpu card pin24= GP1 Bit13 per 35xx datasheet.
                             2941 ; 138  |    #define CONFIGURED_GPIO_INPUT_BIT_FOR_BATTERY_CASE_POLARITY ( HW_GP1DIR.B.B13 )
                             2942 ; 139  |    // GPIO Enable register number as GPIO function.
                             2943 ; 140  |    #define CONFIGURED_BATT_CASE_GP_NUM_ENR (HW_GP1ENR)
                             2944 ; 141  |    // Data output enable reg num to use (will be set as input pin in this case)
                             2945 ; 142  |    #define CONFIGURED_BATT_CASE_GP_NUM_DOER  (HW_GP1DOER)
                             2946 ; 143  |    // bit num to use with desired input pin above
                             2947 ; 144  |    #define CONFIGURED_BATT_CASE_GP_BIT  (HW_GP_B13_SETMASK)
                             2948 ; 145  |    
                             2949 ; 146  |    // Error code returned during charging init when case detect feature enabled but cell case not detected.
                             2950 ; 147  |    #define NIMH_POLARITY_NOT_DETECTED (-2)
                             2951 ; 148  |    //------- end batt case polarity detection
                             2952 ; 149  |
                             2953 ; 150  |    //------------------------------------
                             2954 ; 151  |    #ifndef NIMH_EQUILIBRIUM_CHARGING_TIMEOUT_MS
                             2955 ; 152  |    // 0.1C = 10 hr charge, but use 12 hours to more fully charge larger cells. (units: msec)
                             2956 ; 153  |    #define NIMH_EQUILIBRIUM_CHARGING_TIMEOUT_MS ((DWORD)((DWORD)12*(DWORD)60*(DWORD)60*(DWORD)1000))
                             2957 ; 154  |    //#define NIMH_EQUILIBRIUM_CHARGING_TIMEOUT_MS ((DWORD)((DWORD)10*(DWORD)1000)) //10 sec test mode to easily observe transition
                             2958 ; 155  |    #endif 
                             2959 ; 156  |    
                             2960 ; 157  |    #ifndef NIMH_EQUILIBRIUM_CHARGING_CURRENT_LIMIT
                             2961 ; 158  |    // Units: mA. Refer to the battery data sheet for the proper value. 
                             2962 ; 159  |    // Usually 1 C AAA means a charge of 700 mAh, 750 mAh for a few AAA cells (energizer).
                             2963 ; 160  |    // Assume 700mAh battery so EQUILIBRIUM charge at 0.1C rate (1/10th charge/hr) = 70mA. 
                             2964 ; 161  |    // Register options are 60 or 75mA. Suggest 75mA for AAA. AA's have wide mAh range. Use 1/10th of mAh here:
                             2965 ; 162  |    #define NIMH_EQUILIBRIUM_CHARGING_CURRENT_LIMIT 75
                             2966 ; 163  |    #endif   
                             2967 ; 164  |    #ifndef
                             2968 ; 165  |    #define NIMH_TRICKLE_CHARGE_ENABLE 1
                             2969 ; 166  |    #endif
                             2970 ; 167  |    #ifndef NIMH_TRICKLE_CHARGE_CURRENT
                             2971 ; 168  |    #define NIMH_TRICKLE_CHARGE_CURRENT 10  
                             2972 ; 169  |    #endif //25mA is 0.035C rate for a 700mAh cell. 10mA recommended by 35xx charger designer.
                             2973 ; 170  |    //-------------------------------------
                             2974 ; 171  |    #ifndef NIMH_QUICK_CHARGING_TIMEOUT_MS   // NOTE: C/3 quick charging (3.6hrs) is not implemented.
                             2975 ; 172  |    // ~4 hr charge rate of C/3 terminated by one of 3 events: (per Duracell whitepaper) 
                             2976 ; 173  |    //   -dV/minute of 10mV, or 3.6hr timeout (216 minutes), or real temperature>=(60celcius|140F).
                             2977 ; 174  |    // Thermal warning: at this C/3 charge rate, all 3 of the above termination events must be checked.
                             2978 ; 175  |    #define NIMH_QUICK_CHARGING_TIMEOUT_MS ((DWORD)(DWORD)216*(DWORD)60*(DWORD)1000) 
                             2979 ; 176  |    #endif
                             2980 ; 177  |    #ifndef NIMH_QUICK_CHARGING_MV_PER_MINUTE_THRESHOLD
                             2981 ; 178  |    #define NIMH_QUICK_CHARGING_MV_PER_MINUTE_THRESHOLD 10
                             2982 ; 179  |    #endif
                             2983 ; 180  |    #ifndef NIMH_QUICK_CHARGING_TEMPERATURE_LIMIT_C
                             2984 ; 181  |    // For temp check to function:    10celcius|50F < Ambient Temperature < 45celcius|113F
                             2985 ; 182  |    #define NIMH_QUICK_CHARGING_TEMPERATURE_LIMIT_C 60
                             2986 ; 183  |    #endif
                             2987 ; 184  |    #ifndef NIMH_QUICK_CHARGING_TEMPERATURE_LIMIT_F
                             2988 ; 185  |    #define NIMH_QUICK_CHARGING_TEMPERATURE_LIMIT_F 140
                             2989 ; 186  |    #endif
                             2990 ; 187  |    // C/3 = 700mA/3 = 233 mA, HW supports 235mA. For C=750mAh: 750mA/3= 250mA. 
                             2991 ; 188  |    #ifndef NIMH_QUICK_CHARGING_CURRENT_LIMIT
                             2992 ; 189  |    #define NIMH_QUICK_CHARGING_CURRENT_LIMIT 235        
                             2993 ; 190  |    #endif    
                             2994 ; 191  |    //-------------------------------------
                             2995 ; 192  |    #ifndef NIMH_FAST_CHARGING_CURRENT_LIMIT  // NOTE: C/2 Fast charging (2hrs) is not implemented. 
                             2996 ; 193  |    // in units of mA.   Temperature measurement required with this mode. 
                             2997 ; 194  |    #define NIMH_FAST_CHARGING_CURRENT_LIMIT 400
                             2998 ; 195  |    #endif      
                             2999 ; 196  |    #ifndef NIMH_FAST_CHARGING_TOPOFF_TIMEOUT
                             3000 ; 197  |    //After we reach that limit, we may want to run for a set amount of time to 'top off'
                             3001 ; 198  |    //the charging in this case,                       n minutes
                             3002 ; 199  |    #define NIMH_FAST_CHARGING_TOPOFF_TIMEOUT ((DWORD)(DWORD)30*(DWORD)60*(DWORD)1000)
                             3003 ; 200  |    #endif
                             3004 ; 201  |
                             3005 ; 202  |        #ifndef POWER_OFF_FREQUENCY
                             3006 ; 203  |        //Set the Power Off Frequency Count.  Determines how frequently charging is turned-off. 
                             3007 ; 204  |#ifdef STMP_BUILD_PLAYER
                             3008 ; 205  |        #define POWER_OFF_FREQUENCY 40
                             3009 ; 206  |#else
                             3010 ; 207  |        #define POWER_OFF_FREQUENCY 500
                             3011 ; 208  |#endif
                             3012 ; 209  |        #endif
                             3013 ; 210  |    
                             3014 ; 211  |#endif // BATTERY_TYPE_NIMH
                             3015 ; 212  |////////////////////////////////////////////////////////////////////////////////
                             3016 ; 213  |
                             3017 ; 214  |#ifdef BATTERY_TYPE_ALKALINE
                             3018 ; 215  |#ifdef STMP_BUILD_PLAYER
                             3019 ; 216  |    #define VBATT_REF          REF_2700MV
                             3020 ; 217  |    #define VBATT_MIN_MV       900
                             3021 ; 218  |    #define VBATT_MAX_MV       1500
                             3022 ; 219  |    #define VBATT_BO_MV        840
                             3023 ; 220  |#else
                             3024 ; 221  |    #define VBATT_REF          REF_5120MV
                             3025 ; 222  |    #define VBATT_MIN_MV       900
                             3026 ; 223  |    #define VBATT_MAX_MV       1500
                             3027 ; 224  |    #define VBATT_BO_MV        850
                             3028 ; 225  |#endif
                             3029 ; 226  |
                             3030 ; 227  |    #define BATT_BROWNOUT                               VBATT_BO_MV
                             3031 ; 228  |    
                             3032 ; 229  |    #define OXYRIDE_THRESHOLD_MV  1550     // Battery considered Oxyride if avg voltage exceeds 1.55v
                             3033 ; 230  |    #define OXYRIDE_SETBACK_MV     200     // Battery Voltage - VDDD < 200mv for VDDIO stability
                             3034 ; 231  |#endif 
                             3035 
                             3037 
                             3038 ; 21   |
                             3039 ; 22   |#define POST_OK_SETTLING_DELAY_STEPDOWN_VALUE 3200
                             3040 ; 23   |#define POST_OK_SETTLING_DELAY_STEPUP_VALUE 1000
                             3041 ; 24   |#define VDD_OK_SETUP_CYCLES_AT_70MHZ 160
                             3042 ; 25   |#define DCDCTBR_SETTLING_DELAY_VALUE 3200
                             3043 ; 26   |
                             3044 ; 27   |//void SysDelay(int iMs);
                             3045 ; 28   |
TASKING DSP2410 assembler v1.5r1 Build 138 SN 00100122
                                                                                                                                                                                                                                                       Page  13

M:ADDR CODE           CYCLES LINE SOURCELINE
                             3046 ; 29   |//int VStepHalt=0; //  only uncomment during debug
                             3047 ; 30   |
                             3048 ; 31   |    // Single public entry point function:
                             3049 ; 32   |//------------------------------------------------------------------------------
                             3050 ; 33   |// Public Function Name: SteppingVoltageSet
                             3051 ; 34   |// Description: Performs intermediate V step(s) if needed. Steps iStepSize. 
                             3052 ; 35   |//              For VDDD, polls VDD_OK register bit after each intermediate step if used. 
                             3053 ; 36   |//              This possible polling adds inline delay that may be on the order 
                             3054 ; 37   |//              of 1 ms per intermediate step. 
                             3055 ; 38   |// Inputs:  WORD wCurrentVoltageCode, WORD wDesiredVoltageCode, WORD sStepSize, /* 3 parms are V bit codes */
                             3056 ; 39   |//          int iVoltageType      /* VOLTAGE_TYPE_VDDD or VOLTAGE_TYPE_VDDIO (VDDIO untested)   */
                             3057 ; 40   |// 
                             3058 ; 41   |// Returns: RETCODE: SUCCESS if no change needed, ERR_INVALID_VOLTAGE_CODE, 
                             3059 ; 42   |//          or passes back the RETCODE from VoltageStepUp or VoltageStepDown. 
                             3060 ; 43   |// Notes:   When called from asm, the registers with these params are: a,b,x0,y0
                             3061 ; 44   |//------------------------------------------------------------------------------
                             3062 ; 45   |//int g_iErr=0;
                             3063 ; 46   |#ifdef FUNCLET
                             3064 ; 47   |RETCODE SteppingVoltageSetFunclet(WORD wCurrentVoltageCode, WORD wDesiredVoltageCode, WORD wStepSize, 
                             3065 ; 48   |                                       int iVoltageType) 
                             3066 ; 49   |#else
                             3067 ; 50   |RETCODE SteppingVoltageSet(WORD wCurrentVoltageCode, WORD wDesiredVoltageCode, WORD wStepSize, 
                             3068 ; 51   |                                       int iVoltageType) 
                             3069 ; 52   |#endif
                             3070 ; 53   |{
                             3071 
P:0000                       3072         org     p,".ptextsteppingvoltageset":
                             3077 FSteppingVoltageSetFunclet:
P:0000 05707C rrrrrr  4    4 3078         movec   ssh,y:ss_SteppingVoltageSetFunclet
                             3092 
                             3093 ; 54   |    INT iAvgBatteryVoltageMV;
                             3094 ; 55   |    WORD wNewDesiredVoltageCode;
                             3095 ; 56   |  
                             3096 ; 57   |    if( wDesiredVoltageCode == wCurrentVoltageCode ) 
                             3097 
P:0002 2A0000         2    6 3099         move    #0,a2
P:0003 2B0000         2    8 3100         move    #0,b2
P:0004 20000D         2   10 3101         cmp     a,b
P:0005 0AF0A2 rrrrrr  6   16 3102         jne     L3
                             3103 
                             3104 ; 58   |        return SUCCESS; 
                             3105 
P:0007 200013         2   18 3107         clr     a   
P:0008 0AF080 rrrrrr  6   24 3109         jmp     L14
                             3110 
                             3111 ; 59   |
                             3112 ; 60   |    #ifdef DEVICE_3500 // DEVICE_3600 has a 5 bit field also. 
                             3113 ; 61   |    if( (wDesiredVoltageCode > 31) || (wCurrentVoltageCode > 31) ) // STMP35xx has 5 lsb V codes. 
                             3114 
                             3116 L3:
P:000A 47F400 00001F  3   27 3118         move    #>$1F,y1
P:000C 20007D         2   29 3119         cmp     y1,b
P:000D 0AF0A7 rrrrrr  6   35 3120         jgt     L4
P:000F 200075         2   37 3121         cmp     y1,a
P:0010 0AF0AF rrrrrr  6   43 3122         jle     L5
                             3123 
                             3124 ; 62   |        return ERR_INVALID_VOLTAGE_CODE; // Max v code is 31 == 0x1F
                             3125 
P:0012 56F400 000003  3   46 3127 L4:     move    #>3,a
P:0014 0AF080 rrrrrr  6   52 3129         jmp     L14
                             3130 
                             3131 ; 63   |
                             3132 ; 64   |    //8 is min register settable voltage code of 1.28V, below which we disallow here.
                             3133 ; 65   |    if( (wDesiredVoltageCode < 8) ) 
                             3134 
                             3136 L5:
P:0016 5D7000 rrrrrr  3   55 3138         move    b1,y:ss_SteppingVoltageSetFunclet+1
P:0018 45F400 000008  3   58 3139         move    #>8,x1
P:001A 20006D         2   60 3140         cmp     x1,b
P:001B 0AF0A1 rrrrrr  6   66 3143         jge     L6
                             3144 
                             3145 ; 66   |    {   //g_iErr = iDesiredVoltageCode;
                             3146 ; 67   |        return ERR_INVALID_VOLTAGE_CODE_LOW;
                             3147 
P:001D 56F400 000004  3   69 3149         move    #>4,a
P:001F 0AF080 rrrrrr  6   75 3151         jmp     L14
                             3152 
                             3153 ; 68   |    }    
                             3154 ; 69   |    #endif
                             3155 ; 70   |
                             3156 ; 71   |    if( (iVoltageType != VOLTAGE_TYPE_VDDD) && (iVoltageType != VOLTAGE_TYPE_VDDIO) )//can comment out for codespace
                             3157 
                             3159 L6:
P:0021 200059         2   77 3161         tfr     y0,b
P:0022 47F400 000001  3   80 3162         move    #>1,y1
P:0024 20007D         2   82 3163         cmp     y1,b
P:0025 0AF0AA rrrrrr  6   88 3164         jeq     L8
P:0027 47F400 000002  3   91 3165         move    #>2,y1
P:0029 20007D         2   93 3166         cmp     y1,b
P:002A 0AF0AA rrrrrr  6   99 3167         jeq     L8
                             3168 
                             3169 ; 72   |        return ERR_INVALID_VOLTAGE_TYPE;
                             3170 
P:002C 56F400 000006  3  102 3172         move    #>6,a
P:002E 0AF080 rrrrrr  6  108 3174         jmp     L14
                             3175 
                             3176 ; 73   |
                             3177 ; 74   |#ifdef BATTERY_TYPE_ALKALINE
                             3178 ; 75   |// Special processing for Oxyride battery
                             3179 ; 76   |    iAvgBatteryVoltageMV = SysLowResolutionAdcReadVolt(BATT, 0); // Read battery voltage (Don't use avg!!!)
                             3180 ; 77   |
                             3181 ; 78   |    if (OXYRIDE_THRESHOLD_MV < iAvgBatteryVoltageMV)   // Oxyride if battery voltage above threshold (max alkaline + delta)  
                             3182 ; 79   |    { 
                             3183 ; 80   |         // Convert between Millivolts (MV) and Voltage Code (VC) : MV = (190/6) * VC + 1028 ;  VC = ...
                             3184 ; 81   |        wNewDesiredVoltageCode = (((iAvgBatteryVoltageMV - OXYRIDE_SETBACK_MV - 1028) * 6) / 190);
                             3185 ; 82   |        if (wDesiredVoltageCode < wNewDesiredVoltageCode)  // Use higher of Desired and Oxyride for Vddd
                             3186 ; 83   |        {
                             3187 ; 84   |            wDesiredVoltageCode = wNewDesiredVoltageCode;
                             3188 ; 85   |        }
                             3189 ; 86   |     }
                             3190 ; 87   |#endif
                             3191 ; 88   |
                             3192 ; 89   |    if( wDesiredVoltageCode > wCurrentVoltageCode )
                             3193 
                             3195 L8:
P:0030 5FF000 rrrrrr  3  111 3197         move    y:ss_SteppingVoltageSetFunclet+1,b
P:0032 2A0000         2  113 3198         move    #0,a2
P:0033 2B0000         2  115 3199         move    #0,b2
P:0034 20000D         2  117 3200         cmp     a,b
P:0035 0AF0AF rrrrrr  6  123 3201         jle     L9
                             3202 
                             3203 ; 90   |    {      
                             3204 ; 91   |        return( VoltageStepUp(wCurrentVoltageCode, wDesiredVoltageCode, wStepSize, 
                             3205 ; 92   |                              iVoltageType) );
                             3206 
P:0037 0BF080 rrrrrr  6  129 3208         jsr     FVoltageStepUp
P:0039 0AF080 rrrrrr  6  135 3215         jmp     L14
                             3216 
                             3217 ; 93   |    }
                             3218 ; 94   |    else           // desired < current V
                             3219 ; 95   |    {
                             3220 ; 96   |        //SystemHalt();   
                             3221 ; 97   |        return( VoltageStepDown(wCurrentVoltageCode, wDesiredVoltageCode, wStepSize, 
                             3222 ; 98   |                                iVoltageType) );
                             3223 
                             3225 L9:
P:003B 0BF080 rrrrrr  6  141 3230         jsr     FVoltageStepDown
                             3237 
                             3238 ; 99   |    }
                             3239 ; 100  |}
                             3240 
P:003D 05F07C rrrrrr  4  145 3242 L14:    movec   y:ss_SteppingVoltageSetFunclet,ssh
P:003F 000000         2  147 3244         nop
P:0040 00000C         4  151 3245         rts
                             3246 
Y:0000                       3247         org     y,".yovlsteppingvoltageset@SteppingVoltageSetFunclet",overlay:
                             3248 ss_SteppingVoltageSetFunclet:
Y:0000                       3249         ds      2
   |   RESERVED                   
Y:0001
                             3250 
P:0041                       3251         org     p,".ptextsteppingvoltageset":
                             3253 
                             3254 ; 101  |
                             3255 ; 102  |// FUNCTIONS BELOW THIS LINE ARE PRIVATE AND BEHIND THE INTERFACE ABOVE.
                             3256 ; 103  |
                             3257 ; 104  |//Amount of time recommended by HW
                             3258 ; 105  |//engineer for waiting for HW to
                             3259 ; 106  |//settle is 1ms per step per tick.
                             3260 ; 107  |//The exact value is 3ms, and
                             3261 ; 108  |//due to granularity of System Timer,
                             3262 ; 109  |//we need to wait one more millisecond
                             3263 ; 110  |//than 3ms to make sure that in worst
                             3264 ; 111  |//case we wait at least 3ms.
                             3265 ; 112  |#define SETTLING_WAIT_TIME_MS 4
                             3266 ; 113  |
                             3267 ; 114  |void WaitForVDD_OKOrTimeOut(void)
                             3268 ; 115  |{
                             3269 
                             3298 FWaitForVDD_OKOrTimeOut:
P:0041 05707C rrrrrr  4  155 3299         movec   ssh,y:ss_WaitForVDD_OKOrTimeOut
                             3303 
                             3304 ; 116  |    LONG iFinishTime;
                             3305 ; 117  |
                             3306 ; 118  |    iFinishTime = (LONG)SETTLING_WAIT_TIME_MS + SysGetCurrentTime();
                             3307 
P:0043 0BF080 rrrrrr  6  161 3309         jsr     SysGetCurrentTime
P:0045 20001B         2  163 3310         clr     b   
P:0046 290400         2  165 3311         move    #4,b0
P:0047 200010         2  167 3312         add     b,a
P:0048 5C7000 rrrrrr  3  170 3313         move    a1,y:ss_WaitForVDD_OKOrTimeOut+2
P:004A 587000 rrrrrr  3  173 3314         move    a0,y:ss_WaitForVDD_OKOrTimeOut+1
                             3316 
                             3317 ; 119  |
                             3318 ; 120  |    while( HW_DCDC_VDDD.B.VDD_OK != 1 )    
                             3319 
P:004C 0AF080 rrrrrr  6  179 3321         jmp     L16
                             3322 
                             3323 ; 121  |    { // nop();
                             3324 ; 122  |        if ( SysGetCurrentTime() >= iFinishTime )
                             3325 
P:004E 0BF080 rrrrrr  6  185 3327 L15:    jsr     SysGetCurrentTime
P:0050 5FF000 rrrrrr  3  188 3328         move    y:ss_WaitForVDD_OKOrTimeOut+2,b
P:0052 59F000 rrrrrr  3  191 3329         move    y:ss_WaitForVDD_OKOrTimeOut+1,b0
P:0054 200005         2  193 3330         cmp     b,a
P:0055 0AF0A1 rrrrrr  6  199 3331         jge     L17
P:0057 57F000 00FA0F  3  202 3333 L16:    move    x:$FA0F,b
P:0059 0BCD75         4  206 3334         btst    #21,b1
P:005A 20001B         2  208 3335         clr     b   
P:005B 20003F         2  210 3336         rol     b
P:005C 44F400 000001  3  213 3337         move    #>1,x0
P:005E 20004D         2  215 3338         cmp     x0,b
P:005F 0AF0A2 rrrrrr  6  221 3339         jne     L15
                             3340 
                             3341 ; 123  |        {    break;
                             3342 ; 124  |        }
                             3343 ; 125  |    }
                             3344 
                             3346 L17:
                             3347 
                             3348 ; 126  |} /* WaitForVDD_OKOrTimeOut */
                             3349 
P:0061 05F07C rrrrrr  4  225 3351         movec   y:ss_WaitForVDD_OKOrTimeOut,ssh
P:0063 000000         2  227 3353         nop
P:0064 00000C         4  231 3354         rts
                             3356 
Y:0000                       3357         org     y,".yovlsteppingvoltageset@WaitForVDD_OKOrTimeOut",overlay:
                             3358 ss_WaitForVDD_OKOrTimeOut:
Y:0000                       3359         ds      3
   |   RESERVED                   
Y:0002
                             3360 
P:0065                       3361         org     p,".ptextsteppingvoltageset":
                             3363 
                             3364 ; 127  |
                             3365 ; 128  |//------------------------------------------------------------------------------
                             3366 ; 129  |// Private Function Name: VoltageStepDown
                             3367 ; 130  |// Description: Performs Voltage intermediate step(s) down if needed. Steps iStepSize. 
                             3368 ; 131  |//              Polls VDD_OK register bit after each intermediate step if used. 
                             3369 ; 132  |//              This possible polling adds inline delay that may be on the order 
                             3370 ; 133  |//              of 1 ms per intermediate step but varies with system HW state. 
                             3371 ; 134  |// Inputs:  WORD wCurrentVoltageCode, WORD wDesiredVoltageCode, WORD wStepSize, /* these are V bit codes */
                             3372 ; 135  |//          int iVoltageType     /* VOLTAGE_TYPE_VDDD or VOLTAGE_TYPE_VDDIO (VDDIO untested) */
                             3373 ; 136  |//
                             3374 ; 137  |// Returns: RETCODE: SUCCESS 
                             3375 ; 138  |//                    
                             3376 ; 139  |// Notes:   
                             3377 ; 140  |//------------------------------------------------------------------------------
                             3378 ; 141  |//int VStepHalt=0; //debug int only
                             3379 ; 142  |
                             3380 ; 143  |RETCODE VoltageStepDown(WORD wCurrentVoltageCode, WORD wDesiredVoltageCode, WORD wStepSize, 
                             3381 ; 144  |                             int iVoltageType)
                             3382 ; 145  |{
                             3383 
                             3461 FVoltageStepDown:
P:0065 05707C rrrrrr  4  235 3462         movec   ssh,y:ss_VoltageStepDown
                             3478 
                             3479 ; 146  |    WORD wRemainder; 
                             3480 ; 147  |    //int retCode=SUCCESS;
                             3481 ; 148  |    int iDelayCounter;
                             3482 ; 149  |    WORD wSavedDcDcControlReg = HW_DCDC1_CTRL1.I;
TASKING DSP2410 assembler v1.5r1 Build 138 SN 00100122
                                                                                                                                                                                                                                                       Page  14

M:ADDR CODE           CYCLES LINE SOURCELINE
                             3483 
P:0067 4E7000 rrrrrr  3  238 3485         move    y0,y:ss_VoltageStepDown+3
P:0069 4C7000 rrrrrr  3  241 3488         move    x0,y:ss_VoltageStepDown+2
P:006B 5D7000 rrrrrr  3  244 3491         move    b1,y:ss_VoltageStepDown+1
P:006D 47F000 00FA0D  3  247 3494         move    x:$FA0D,y1
P:006F 4F7000 rrrrrr  3  250 3495         move    y1,y:ss_VoltageStepDown+4
                             3499 
                             3500 ; 150  |    LONG iFinishTime;
                             3501 ; 151  |
                             3502 ; 152  |    // All params except iStepSize are already qualified in calling function. 
                             3503 ; 153  |    
                             3504 ; 154  |    // if(VStepHalt)  { _asm( " debug"); _asm( " nop"); _asm( " nop"); _asm( " nop");}
                             3505 ; 155  |
                             3506 ; 156  |    #if 0 // input verification removed for codespace    
                             3507 ; 157  |    if( wDesiredVoltageCode > wCurrentVoltageCode )
                             3508 ; 158  |    {   return ERR_STEPDOWN_NOT_NEEDED; //Notifies caller: this function is only for stepping down, not up. 
                             3509 ; 159  |    }
                             3510 ; 160  |    #endif
                             3511 ; 161  |
                             3512 ; 162  |    //Changing the RC value of the DCDC1_CTRL1 register will stabalize the transients on VDDIO and VDDD when
                             3513 ; 163  |        //the voltage is changed.  However, it will also close the DCDC control loop for the 5V to DCDC Transfer.
                             3514 ; 164  |        //This may crash the player when disconnecting from 5V.  Only change the RC values when 5V is not connected.
                             3515 ; 165  |    if(!(HW_VDD5V_PWR_CHARGE.B.VDD5V_PRESENT))
                             3516 
P:0071 54F000 00FA1D  3  253 3518         move    x:$FA1D,a1
P:0073 0ACC34 rrrrrr  6  259 3520         jset    #20,a1,L19
                             3521 
                             3522 ; 166  |        {
                             3523 ; 167  |        HW_DCDC1_CTRL1.I = 0x000098;  // with 0x94 had best results yet. Resistance is nibble1. Capacitor is nibble0.
                             3524 
P:0075 46F400 000098  3  262 3526         move    #>152,y0
P:0077 467000 00FA0D  3  265 3527         move    y0,x:$FA0D
                             3528 
                             3529 ; 168  |        }
                             3530 ; 169  |
                             3531 ; 170  |    while( 1 ) // break near end exits the V stepping loop.
                             3532 
                             3534 L19:
                             3535 L20:
                             3536 L21:
                             3537 
                             3538 ; 171  |    {
                             3539 ; 172  |        if(iVoltageType == VOLTAGE_TYPE_VDDD)
                             3540 
P:0079 5FF000 rrrrrr  3  268 3542 L22:    move    y:ss_VoltageStepDown+3,b
P:007B 46F400 000001  3  271 3543         move    #>1,y0
P:007D 20005D         2  273 3544         cmp     y0,b
P:007E 0AF0A2 rrrrrr  6  279 3545         jne     L23
                             3546 
                             3547 ; 173  |            wCurrentVoltageCode = (WORD)HW_DCDC_VDDD.B.VOLTAGE_LEVEL; // a 5 bit bitfield of the register
                             3548 
P:0080 45F000 00FA0F  3  282 3550         move    x:$FA0F,x1
P:0082 200069         2  284 3551         tfr     x1,b
P:0083 45F400 00001F  3  287 3552         move    #>$1F,x1
P:0085 20006E         2  289 3553         and     x1,b
P:0086 0AF080 rrrrrr  6  295 3554         jmp     L24
                             3555 
                             3556 ; 174  |        else // (iVoltageType == VOLTAGE_TYPE_VDDIO)
                             3557 ; 175  |            wCurrentVoltageCode = (WORD)HW_DCDC_VDDIO.B.VOLTAGE_LEVEL; // a 5 bit bitfield of the register
                             3558 
P:0088 44F000 00FA0E  3  298 3560 L23:    move    x:$FA0E,x0
P:008A 200049         2  300 3561         tfr     x0,b
P:008B 44F400 00001F  3  303 3562         move    #>$1F,x0
P:008D 20004E         2  305 3563         and     x0,b
P:008E 21AF00         2  307 3565 L24:    move    b1,b
                             3567 
                             3568 ; 176  |
                             3569 ; 177  |        wRemainder = wCurrentVoltageCode - wDesiredVoltageCode; // V code bits remaining of total decrease
                             3570 
P:008F 4FF000 rrrrrr  3  310 3572         move    y:ss_VoltageStepDown+1,y1
P:0091 20007C         2  312 3573         sub     y1,b
                             3576 
                             3577 ; 178  |
                             3578 ; 179  |        if( wRemainder > wStepSize )
                             3579 
P:0092 5EF000 rrrrrr  3  315 3581         move    y:ss_VoltageStepDown+2,a
P:0094 2A0000         2  317 3582         move    #0,a2
P:0095 2B0000         2  319 3583         move    #0,b2
P:0096 20000D         2  321 3584         cmp     a,b
P:0097 0AF0AF rrrrrr  6  327 3585         jle     L35
                             3586 
                             3587 ; 180  |        {   
                             3588 ; 181  |            // step down V by stepSize. Write the voltage control register.
                             3589 ; 182  |            if(iVoltageType == VOLTAGE_TYPE_VDDD)
                             3590 
P:0099 5FF000 rrrrrr  3  330 3592         move    y:ss_VoltageStepDown+3,b
P:009B 20005D         2  332 3593         cmp     y0,b
P:009C 0AF0A2 rrrrrr  6  338 3594         jne     L25
                             3595 
                             3596 ; 183  |            {   
                             3597 ; 184  |                HW_DCDC_VDDD.B.VOLTAGE_LEVEL -= wStepSize;  // set the new voltage
                             3598 
P:009E 46F000 00FA0F  3  341 3600         move    x:$FA0F,y0
P:00A0 200059         2  343 3601         tfr     y0,b
P:00A1 46F400 00001F  3  346 3602         move    #>$1F,y0
P:00A3 20005E         2  348 3603         and     y0,b
P:00A4 4DF000 rrrrrr  3  351 3605         move    y:ss_VoltageStepDown+2,x1
P:00A6 21AF00         2  353 3606         move    b1,b
P:00A7 20006C         2  355 3607         sub     x1,b
P:00A8 56F000 00FA0F  3  358 3608         move    x:$FA0F,a
P:00AA 44F400 FFFFE0  3  361 3609         move    #$FFFFE0,x0
P:00AC 200046         2  363 3610         and     x0,a
P:00AD 20C400         2  365 3611         move    y0,x0
P:00AE 20004E         2  367 3612         and     x0,b
P:00AF 21A400         2  369 3613         move    b1,x0
P:00B0 200042         2  371 3614         or      x0,a
P:00B1 547000 00FA0F  3  374 3615         move    a1,x:$FA0F
                             3616 
                             3617 ; 185  |                SetDCDCTestBitRegister();
                             3618 
P:00B3 0BF080 rrrrrr  6  380 3620         jsr     FSetDCDCTestBitRegister
                             3621 
                             3622 ; 186  |                // _asm( " bset #HW_GP_B17_BITPOS,x:HW_GP0DOR ");    //make pin 5 high for scope profiling VDD_OK.
                             3623 ; 187  |            }
                             3624 
P:00B5 0AF080 rrrrrr  6  386 3626         jmp     L27
                             3627 
                             3628 ; 188  |            else if (iVoltageType == VOLTAGE_TYPE_VDDIO)
                             3629 
P:00B7 5EF000 rrrrrr  3  389 3631 L25:    move    y:ss_VoltageStepDown+3,a
P:00B9 44F400 000002  3  392 3632         move    #>2,x0
P:00BB 200045         2  394 3633         cmp     x0,a
P:00BC 0AF0A2 rrrrrr  6  400 3634         jne     L27
                             3635 
                             3636 ; 189  |            {   
                             3637 ; 190  |                HW_DCDC_VDDIO.B.VOLTAGE_LEVEL -= wStepSize;
                             3638 
P:00BE 46F000 00FA0E  3  403 3640         move    x:$FA0E,y0
P:00C0 200059         2  405 3641         tfr     y0,b
P:00C1 46F400 00001F  3  408 3642         move    #>$1F,y0
P:00C3 20005E         2  410 3643         and     y0,b
P:00C4 4EF000 rrrrrr  3  413 3644         move    y:ss_VoltageStepDown+2,y0
P:00C6 21AF00         2  415 3645         move    b1,b
P:00C7 20005C         2  417 3646         sub     y0,b
P:00C8 56F000 00FA0E  3  420 3647         move    x:$FA0E,a
P:00CA 46F400 FFFFE0  3  423 3648         move    #$FFFFE0,y0
P:00CC 200056         2  425 3649         and     y0,a
P:00CD 46F400 00001F  3  428 3650         move    #>$1F,y0
P:00CF 20005E         2  430 3651         and     y0,b
P:00D0 21A600         2  432 3652         move    b1,y0
P:00D1 200052         2  434 3653         or      y0,a
P:00D2 547000 00FA0E  3  437 3654         move    a1,x:$FA0E
                             3655 
                             3656 ; 191  |            }
                             3657 ; 192  |            // above are all cases since calling func qualified the inputs
                             3658 ; 193  |
                             3659 ; 194  |            // poll for voltage convergence
                             3660 ; 195  |            if(iVoltageType == VOLTAGE_TYPE_VDDD)
                             3661 
P:00D4 5FF000 rrrrrr  3  440 3663 L27:    move    y:ss_VoltageStepDown+3,b
P:00D6 44F400 000001  3  443 3664         move    #>1,x0
P:00D8 20004D         2  445 3665         cmp     x0,b
P:00D9 0AF0A2 rrrrrr  6  451 3666         jne     L32
                             3667 
                             3668 ; 196  |            {                
                             3669 ; 197  |                //while( HW_DCDC_VDDD.B.VDD_OK != 0 ) _nop(); // must be 0 or fall to 0. Designer required. 
                             3670 ; 198  |                //When TBR func was separate funclet, DSP slower than OK bit setup time so delay count for worst case. 
                             3671 ; 199  |                //          Designer specifies 3T at 1.5Mhz so 72cycles@36MHz; 144cycles@72MHz. For safety use 160.
                             3672 ; 200  |                //          as seen on scope.  
                             3673 ; 201  |                iDelayCounter = VDD_OK_SETUP_CYCLES_AT_70MHZ;
                             3674 
P:00DB 57F400 0000A0  3  454 3676         move    #>160,b
                             3678 
                             3679 ; 202  |                while( iDelayCounter-- > 0 ) _nop();
                             3680 
P:00DD 0AF080 rrrrrr  6  460 3682         jmp     L29
P:00DF 000000         2  462 3683 L28:    nop
P:00E0 21AE00         2  464 3684 L29:    move    b1,a
P:00E1 47F400 000001  3  467 3687         move    #>1,y1
P:00E3 20007C         2  469 3688         sub     y1,b
P:00E4 200003         2  471 3691         tst     a
P:00E5 0AF0A7 rrrrrr  6  477 3692         jgt     L28
                             3693 
                             3694 ; 203  |                
                             3695 ; 204  |                WaitForVDD_OKOrTimeOut();
                             3696 
P:00E7 0BF080 rrrrrr  6  483 3698         jsr     FWaitForVDD_OKOrTimeOut
                             3700 
                             3701 ; 205  |
                             3702 ; 206  |                // _asm( " bclr #HW_GP_B17_BITPOS,x:HW_GP0DOR "); //make pin 5 low for scope profiling VDD_OK.
                             3703 ; 207  |
                             3704 ; 208  |                // SysDelay(1); // spin for 1 ms to let the VDDD and VDDIO voltages settle. Not a reliable ms. 
                             3705 ; 209  |                iDelayCounter = POST_OK_SETTLING_DELAY_STEPDOWN_VALUE; 
                             3706 
P:00E9 57F400 000C80  3  486 3708         move    #3200,b
                             3710 
                             3711 ; 210  |                // 3200 best yet. 1800 didn't prevent vddd brownout w/ stepsize 3. 
                             3712 ; 211  |                // 1100 w/ stepsize 1 resulted in: undershoot issues so avoid. 
                             3713 ; 212  |                while(iDelayCounter-- > 0) _nop();
                             3714 
P:00EB 0AF080 rrrrrr  6  492 3716         jmp     L31
P:00ED 000000         2  494 3717 L30:    nop
P:00EE 21AE00         2  496 3718 L31:    move    b1,a
P:00EF 46F400 000001  3  499 3721         move    #>1,y0
P:00F1 20005C         2  501 3722         sub     y0,b
P:00F2 200003         2  503 3725         tst     a
P:00F3 0AF0A7 rrrrrr  6  509 3726         jgt     L30
                             3727 
                             3728 ; 213  |            }
                             3729 
P:00F5 0AF080 rrrrrr  6  515 3731         jmp     L22
                             3732 
                             3733 ; 214  |            else if(iVoltageType == VOLTAGE_TYPE_VDDIO)
                             3734 
P:00F7 5FF000 rrrrrr  3  518 3736 L32:    move    y:ss_VoltageStepDown+3,b
P:00F9 46F400 000002  3  521 3737         move    #>2,y0
P:00FB 20005D         2  523 3738         cmp     y0,b
P:00FC 0AF0A2 rrrrrr  6  529 3739         jne     L21
                             3740 
                             3741 ; 215  |            {   
                             3742 ; 216  |                //while( HW_DCDC_VDDIO.B.VDDIO_OK != 0 ) _nop(); // must be 0 or fall to 0. Designer requires. 
                             3743 ; 217  |                //When TBR func was separate funclet, DSP slower than OK bit setup time so delay count for worst case. 
                             3744 ; 218  |                iDelayCounter = VDD_OK_SETUP_CYCLES_AT_70MHZ;
                             3745 
P:00FE 57F400 0000A0  3  532 3747         move    #>160,b
                             3748 
                             3749 ; 219  |                while( iDelayCounter-- > 0 ) _nop();
                             3750 
P:0100 0AF080 rrrrrr  6  538 3752         jmp     L34
P:0102 000000         2  540 3753 L33:    nop
P:0103 21AE00         2  542 3754 L34:    move    b1,a
P:0104 45F400 000001  3  545 3757         move    #>1,x1
P:0106 20006C         2  547 3758         sub     x1,b
P:0107 200003         2  549 3761         tst     a
P:0108 0AF0A7 rrrrrr  6  555 3762         jgt     L33
                             3763 
                             3764 ; 220  |
                             3765 ; 221  |                iFinishTime = (LONG)SETTLING_WAIT_TIME_MS + SysGetCurrentTime();
                             3766 
P:010A 0BF080 rrrrrr  6  561 3768         jsr     SysGetCurrentTime
P:010C 20001B         2  563 3770         clr     b   
P:010D 290400         2  565 3771         move    #4,b0
P:010E 200010         2  567 3772         add     b,a
P:010F 5C7000 rrrrrr  3  570 3773         move    a1,y:ss_VoltageStepDown+6
P:0111 587000 rrrrrr  3  573 3774         move    a0,y:ss_VoltageStepDown+5
                             3776 
                             3777 ; 222  |
                             3778 ; 223  |                while( HW_DCDC_VDDIO.B.VDDIO_OK != 1 )    
                             3779 
P:0113 0AF080 rrrrrr  6  579 3781         jmp     L45
                             3782 
                             3783 ; 224  |                {   _nop(); // poll for V converged state. 
                             3784 ; 225  |                    if ( SysGetCurrentTime() >= iFinishTime )
                             3785 ; 226  |                    {    break;
                             3786 ; 227  |                    }
                             3787 ; 228  |                }
                             3788 ; 229  |                
                             3789 ; 230  |            }    
                             3790 ; 231  |        }
                             3791 ; 232  |        else // No full steps left. Just set the target voltage & wait for it to converge. 
                             3792 ; 233  |        {   if(wRemainder>0)
TASKING DSP2410 assembler v1.5r1 Build 138 SN 00100122
                                                                                                                                                                                                                                                       Page  15

M:ADDR CODE           CYCLES LINE SOURCELINE
                             3793 
P:0115 2B0000         2  581 3795 L35:    move    #0,b2
P:0116 20000B         2  583 3796         tst     b
P:0117 0AF0AF rrrrrr  6  589 3797         jle     L51
                             3798 
                             3799 ; 234  |            {
                             3800 ; 235  |                if(iVoltageType == VOLTAGE_TYPE_VDDD) 
                             3801 
P:0119 5EF000 rrrrrr  3  592 3803         move    y:ss_VoltageStepDown+3,a
P:011B 200055         2  594 3804         cmp     y0,a
P:011C 0AF0A2 rrrrrr  6  600 3805         jne     L36
                             3806 
                             3807 ; 236  |                {   HW_DCDC_VDDD.B.VOLTAGE_LEVEL = wDesiredVoltageCode;  // set target voltage 
                             3808 
P:011E 5FF000 rrrrrr  3  603 3810         move    y:ss_VoltageStepDown+1,b
P:0120 56F000 00FA0F  3  606 3811         move    x:$FA0F,a
P:0122 44F400 FFFFE0  3  609 3812         move    #$FFFFE0,x0
P:0124 200046         2  611 3813         and     x0,a
P:0125 44F400 00001F  3  614 3814         move    #>$1F,x0
P:0127 20004E         2  616 3815         and     x0,b
P:0128 21A400         2  618 3816         move    b1,x0
P:0129 200042         2  620 3817         or      x0,a
P:012A 547000 00FA0F  3  623 3818         move    a1,x:$FA0F
                             3821 
                             3822 ; 237  |                    SetDCDCTestBitRegister();
                             3823 
P:012C 0BF080 rrrrrr  6  629 3825         jsr     FSetDCDCTestBitRegister
                             3827 
                             3828 ; 238  |                }
                             3829 
P:012E 0AF080 rrrrrr  6  635 3831         jmp     L38
                             3832 
                             3833 ; 239  |                else if(iVoltageType == VOLTAGE_TYPE_VDDIO)    
                             3834 
                             3836 L36:
P:0130 5FF000 rrrrrr  3  638 3838         move    y:ss_VoltageStepDown+3,b
P:0132 56F400 000002  3  641 3839         move    #>2,a
P:0134 20000D         2  643 3840         cmp     a,b
P:0135 0AF0A2 rrrrrr  6  649 3841         jne     L38
                             3842 
                             3843 ; 240  |                {   
                             3844 ; 241  |                    HW_DCDC_VDDIO.B.VOLTAGE_LEVEL = wDesiredVoltageCode;  // set target voltage
                             3845 
P:0137 5FF000 rrrrrr  3  652 3847         move    y:ss_VoltageStepDown+1,b
P:0139 56F000 00FA0E  3  655 3848         move    x:$FA0E,a
P:013B 46F400 FFFFE0  3  658 3849         move    #$FFFFE0,y0
P:013D 200056         2  660 3850         and     y0,a
P:013E 46F400 00001F  3  663 3851         move    #>$1F,y0
P:0140 20005E         2  665 3852         and     y0,b
P:0141 21A600         2  667 3853         move    b1,y0
P:0142 200052         2  669 3854         or      y0,a
P:0143 547000 00FA0E  3  672 3855         move    a1,x:$FA0E
                             3858 
                             3859 ; 242  |                }
                             3860 ; 243  |
                             3861 ; 244  |                #if 1 // delay may not be needed here since we're not changing VDDD again til next call. 
                             3862 ; 245  |                // Poll for voltage convergence. Since this is last change, 
                             3863 ; 246  |                //  we probably don't need to wait here. fDCLK is set previously. 
                             3864 ; 247  |                if(iVoltageType == VOLTAGE_TYPE_VDDD)
                             3865 
P:0145 5FF000 rrrrrr  3  675 3867 L38:    move    y:ss_VoltageStepDown+3,b
P:0147 45F400 000001  3  678 3868         move    #>1,x1
P:0149 20006D         2  680 3869         cmp     x1,b
P:014A 0AF0A2 rrrrrr  6  686 3872         jne     L39
                             3873 
                             3874 ; 248  |                {
                             3875 ; 249  |                    //while( HW_DCDC_VDDD.B.VDD_OK != 0 ) _nop(); // must be 0 or fall to 0. Designer required. 
                             3876 ; 250  |                    //When TBR func was separate funclet, DSP slower than OK bit setup time so delay count for worst case. 
                             3877 ; 251  |                    iDelayCounter = VDD_OK_SETUP_CYCLES_AT_70MHZ;
                             3878 
P:014C 57F400 0000A0  3  689 3880         move    #>160,b
                             3884 
                             3885 ; 252  |                    while( iDelayCounter-- > 0 ) _nop();
                             3886 
P:014E 0AF080 rrrrrr  6  695 3888         jmp     L47
                             3889 
                             3890 ; 253  |
                             3891 ; 254  |                    WaitForVDD_OKOrTimeOut();
                             3892 ; 255  |
                             3893 ; 256  |                }               
                             3894 ; 257  |                else if(iVoltageType == VOLTAGE_TYPE_VDDIO)
                             3895 
                             3897 L39:
P:0150 47F400 000002  3  698 3899         move    #>2,y1
P:0152 20007D         2  700 3900         cmp     y1,b
P:0153 0AF0A2 rrrrrr  6  706 3901         jne     L51
                             3902 
                             3903 ; 258  |                {   
                             3904 ; 259  |                    //while( HW_DCDC_VDDIO.B.VDDIO_OK != 0 ) _nop(); // must be 0 or fall to 0. Designer required. 
                             3905 ; 260  |                    //When TBR func was separate funclet, DSP slower than OK bit setup time so delay count for worst case. 
                             3906 ; 261  |                    iDelayCounter = VDD_OK_SETUP_CYCLES_AT_70MHZ;
                             3907 
P:0155 57F400 0000A0  3  709 3909         move    #>160,b
                             3911 
                             3912 ; 262  |                    while( iDelayCounter-- > 0 ) _nop();
                             3913 
P:0157 0AF080 rrrrrr  6  715 3915         jmp     L41
P:0159 000000         2  717 3916 L40:    nop
P:015A 21AE00         2  719 3917 L41:    move    b1,a
P:015B 20006C         2  721 3920         sub     x1,b
P:015C 200003         2  723 3923         tst     a
P:015D 0AF0A7 rrrrrr  6  729 3924         jgt     L40
                             3925 
                             3926 ; 263  |
                             3927 ; 264  |                    iFinishTime = (LONG)SETTLING_WAIT_TIME_MS + SysGetCurrentTime();
                             3928 
P:015F 0BF080 rrrrrr  6  735 3930         jsr     SysGetCurrentTime
P:0161 20001B         2  737 3932         clr     b   
P:0162 290400         2  739 3933         move    #4,b0
P:0163 200010         2  741 3934         add     b,a
P:0164 5C7000 rrrrrr  3  744 3935         move    a1,y:ss_VoltageStepDown+8
P:0166 587000 rrrrrr  3  747 3936         move    a0,y:ss_VoltageStepDown+7
                             3937 
                             3938 ; 265  |
                             3939 ; 266  |                    while( HW_DCDC_VDDIO.B.VDDIO_OK != 1 )    
                             3940 
P:0168 0AF080 rrrrrr  6  753 3942         jmp     L43
                             3943 
                             3944 ; 267  |                    {   _nop(); // poll for V converged state. 
                             3945 
P:016A 000000         2  755 3947 L42:    nop
                             3948 
                             3949 ; 268  |                        if ( SysGetCurrentTime() >= iFinishTime )
                             3950 
P:016B 0BF080 rrrrrr  6  761 3952         jsr     SysGetCurrentTime
P:016D 5FF000 rrrrrr  3  764 3953         move    y:ss_VoltageStepDown+8,b
P:016F 59F000 rrrrrr  3  767 3954         move    y:ss_VoltageStepDown+7,b0
P:0171 200005         2  769 3955         cmp     b,a
P:0172 0AF0A1 rrrrrr  6  775 3956         jge     L51
P:0174 56F000 00FA0E  3  778 3958 L43:    move    x:$FA0E,a
P:0176 0BCC75         4  782 3959         btst    #21,a1
P:0177 200013         2  784 3960         clr     a   
P:0178 200037         2  786 3961         rol     a
P:0179 46F400 000001  3  789 3962         move    #>1,y0
P:017B 200055         2  791 3963         cmp     y0,a
P:017C 0AF0A2 rrrrrr  6  797 3964         jne     L42
                             3965 
                             3966 ; 269  |                        {    break;
                             3967 ; 270  |                        }
                             3968 ; 271  |                    }
                             3969 ; 272  |
                             3970 ; 273  |                }    
                             3971 ; 274  |                #endif                
                             3972 ; 275  |            }            
                             3973 ; 276  |            break; // done. The desired voltage is set and converged upon. LOOP's ONLY EXIT POINT
                             3974 
P:017E 0AF080 rrrrrr  6  803 3976         jmp     L51
                             3978 L44:
P:0180 000000         2  805 3981         nop
P:0181 0BF080 rrrrrr  6  811 3983         jsr     SysGetCurrentTime
P:0183 5FF000 rrrrrr  3  814 3984         move    y:ss_VoltageStepDown+6,b
P:0185 59F000 rrrrrr  3  817 3985         move    y:ss_VoltageStepDown+5,b0
P:0187 200005         2  819 3986         cmp     b,a
P:0188 0AF0A1 rrrrrr  6  825 3987         jge     L19
P:018A 57F000 00FA0E  3  828 3989 L45:    move    x:$FA0E,b
P:018C 0BCD75         4  832 3990         btst    #21,b1
P:018D 20001B         2  834 3991         clr     b   
P:018E 20003F         2  836 3992         rol     b
P:018F 44F400 000001  3  839 3993         move    #>1,x0
P:0191 20004D         2  841 3994         cmp     x0,b
P:0192 0AF0A2 rrrrrr  6  847 3995         jne     L44
P:0194 0AF080 rrrrrr  6  853 3997         jmp     L20
                             3999 L46:
P:0196 000000         2  855 4001         nop
P:0197 21AE00         2  857 4002 L47:    move    b1,a
P:0198 46F400 000001  3  860 4005         move    #>1,y0
P:019A 20005C         2  862 4006         sub     y0,b
P:019B 200003         2  864 4009         tst     a
P:019C 0AF0A7 rrrrrr  6  870 4010         jgt     L46
P:019E 0BF080 rrrrrr  6  876 4012         jsr     FWaitForVDD_OKOrTimeOut
                             4014 
                             4015 ; 277  |        }// endif full step remaining?
                             4016 ; 278  |   
                             4017 ; 279  |    }// loop
                             4018 ; 280  |
                             4019 ; 281  |    HW_DCDC1_CTRL1.I = wSavedDcDcControlReg;
                             4020 
P:01A0 4DF000 rrrrrr  3  879 4022 L51:    move    y:ss_VoltageStepDown+4,x1
P:01A2 457000 00FA0D  3  882 4023         move    x1,x:$FA0D
                             4024 
                             4025 ; 282  |
                             4026 ; 283  |    // continue normal system operation.
                             4027 ; 284  |    return SUCCESS;
                             4028 
P:01A4 200013         2  884 4030         clr     a   
                             4031 
                             4032 ; 285  |}
                             4033 
P:01A5 05F07C rrrrrr  4  888 4035         movec   y:ss_VoltageStepDown,ssh
P:01A7 000000         2  890 4037         nop
P:01A8 00000C         4  894 4038         rts
                             4044 
Y:0000                       4045         org     y,".yovlsteppingvoltageset@VoltageStepDown",overlay:
                             4046 ss_VoltageStepDown:
Y:0000                       4047         ds      10
   |   RESERVED                   
Y:0009
                             4048 
P:01A9                       4049         org     p,".ptextsteppingvoltageset":
                             4051 
                             4052 ; 286  |
                             4053 ; 287  |//------------------------------------------------------------------------------
                             4054 ; 288  |// Private Function Name:    VoltageStepUp  
                             4055 ; 289  |// Description: Raising the voltage in steps is requested also but is less critical.   
                             4056 ; 290  |//              Initial version just sets voltage per type as in sysspeed without stepping. 
                             4057 ; 291  |// Inputs:  WORD wCurrentVoltageCode, WORD wDesiredVoltageCode, WORD wStepSize, /* 3 parms are V bit codes */
                             4058 ; 292  |//          int iVoltageType      /* VOLTAGE_TYPE_VDDD or VOLTAGE_TYPE_VDDIO (VDDIO untested) */
                             4059 ; 293  |// Returns: SUCCESS
                             4060 ; 294  |// Notes:   
                             4061 ; 295  |//------------------------------------------------------------------------------
                             4062 ; 296  |RETCODE VoltageStepUp(WORD wCurrentVoltageCode, WORD wDesiredVoltageCode, WORD wStepSize,
                             4063 ; 297  |                      int iVoltageType)  
                             4064 ; 298  |{
                             4065 
                             4070 FVoltageStepUp:
P:01A9 05707C rrrrrr  4  898 4071         movec   ssh,y:ss_VoltageStepUp
                             4085 
                             4086 ; 299  |    WORD wRemainder;
                             4087 ; 300  |        WORD iDelayCounter;
                             4088 
P:01AB 4C7000 rrrrrr  3  901 4090         move    x0,y:ss_VoltageStepUp+2
P:01AD 5D7000 rrrrrr  3  904 4093         move    b1,y:ss_VoltageStepUp+1
                             4096 
                             4097 ; 301  |
                             4098 ; 302  |    #if 0 // input verification removed for codespace    
                             4099 ; 303  |    if( wDesiredVoltageCode < wCurrentVoltageCode )
                             4100 ; 304  |    {   return ERR_STEPUP_NOT_NEEDED; //Notifies caller: this function is only for stepping up, not down. 
                             4101 ; 305  |    }
                             4102 ; 306  |    #endif
                             4103 ; 307  |
                             4104 ; 308  |    // All params except iStepSize are already qualified by caller.
                             4105 ; 309  |        // Step-up core voltage
                             4106 ; 310  |    if(iVoltageType == VOLTAGE_TYPE_VDDD)
                             4107 
P:01AF 200059         2  906 4109         tfr     y0,b
P:01B0 47F400 000001  3  909 4110         move    #>1,y1
P:01B2 20007D         2  911 4111         cmp     y1,b
P:01B3 0AF0A2 rrrrrr  6  917 4112         jne     L72
                             4113 
                             4114 ; 311  |    {
                             4115 ; 312  |       while(1)
                             4116 ; 313  |       {
                             4117 ; 314  |           wCurrentVoltageCode = (WORD)HW_DCDC_VDDD.B.VOLTAGE_LEVEL; // a 5 bit bitfield of the register
                             4118 
P:01B5 45F000 00FA0F  3  920 4120 L64:    move    x:$FA0F,x1
P:01B7 200061         2  922 4121         tfr     x1,a
P:01B8 45F400 00001F  3  925 4122         move    #>$1F,x1
P:01BA 200066         2  927 4123         and     x1,a
                             4126 
                             4127 ; 315  |
                             4128 ; 316  |           wRemainder = wDesiredVoltageCode - wCurrentVoltageCode; // V code bits remaining of total increase
TASKING DSP2410 assembler v1.5r1 Build 138 SN 00100122
                                                                                                                                                                                                                                                       Page  16

M:ADDR CODE           CYCLES LINE SOURCELINE
                             4129 
P:01BB 5FF000 rrrrrr  3  930 4131         move    y:ss_VoltageStepUp+1,b
P:01BD 218600         2  932 4132         move    a1,y0
P:01BE 20005C         2  934 4133         sub     y0,b
                             4138 
                             4139 ; 317  |
                             4140 ; 318  |           if( wRemainder > wStepSize )
                             4141 
P:01BF 5EF000 rrrrrr  3  937 4143         move    y:ss_VoltageStepUp+2,a
P:01C1 2A0000         2  939 4144         move    #0,a2
P:01C2 2B0000         2  941 4145         move    #0,b2
P:01C3 20000D         2  943 4146         cmp     a,b
P:01C4 0AF0AF rrrrrr  6  949 4149         jle     L67
                             4150 
                             4151 ; 319  |           {    HW_DCDC_VDDD.B.VOLTAGE_LEVEL += wStepSize;  // set the new voltage
                             4152 
P:01C6 44F000 00FA0F  3  952 4154         move    x:$FA0F,x0
P:01C8 200049         2  954 4155         tfr     x0,b
P:01C9 20A400         2  956 4156         move    x1,x0
P:01CA 20004E         2  958 4157         and     x0,b
P:01CB 21AF00         2  960 4159         move    b1,b
P:01CC 200018         2  962 4160         add     a,b
P:01CD 56F000 00FA0F  3  965 4163         move    x:$FA0F,a
P:01CF 46F400 FFFFE0  3  968 4164         move    #$FFFFE0,y0
P:01D1 200056         2  970 4165         and     y0,a
P:01D2 20A600         2  972 4166         move    x1,y0
P:01D3 20005E         2  974 4167         and     y0,b
P:01D4 21A600         2  976 4168         move    b1,y0
P:01D5 200052         2  978 4169         or      y0,a
P:01D6 547000 00FA0F  3  981 4170         move    a1,x:$FA0F
                             4171 
                             4172 ; 320  |                
                             4173 ; 321  |                //while( HW_DCDC_VDDD.B.VDD_OK != 0 ) _nop(); // must be 0 or fall to 0. Designer required. 
                             4174 ; 322  |                //When TBR func was separate funclet, DSP slower than OK bit setup time so delay count for worst case. 
                             4175 ; 323  |                //          Designer specifies 3T at 1.5Mhz so 72cycles@36MHz; 144cycles@72MHz. For safety use 160.
                             4176 ; 324  |                //          as seen on scope.  
                             4177 ; 325  |                iDelayCounter = VDD_OK_SETUP_CYCLES_AT_70MHZ;
                             4178 
P:01D8 57F400 0000A0  3  984 4180         move    #>160,b
                             4182 
                             4183 ; 326  |                while( iDelayCounter-- > 0 ) _nop();
                             4184 
P:01DA 0AF080 rrrrrr  6  990 4186         jmp     L66
P:01DC 000000         2  992 4187 L65:    nop
P:01DD 21AE00         2  994 4188 L66:    move    b1,a
P:01DE 47F400 000001  3  997 4191         move    #>1,y1
P:01E0 20007C         2  999 4192         sub     y1,b
P:01E1 2A0000         2 1001 4195         move    #0,a2
P:01E2 200003         2 1003 4196         tst     a
P:01E3 0AF0A7 rrrrrr  6 1009 4197         jgt     L65
                             4198 
                             4199 ; 327  |                WaitForVDD_OKOrTimeOut();
                             4200 
P:01E5 0BF080 rrrrrr  6 1015 4202         jsr     FWaitForVDD_OKOrTimeOut
                             4205 
                             4206 ; 328  |
                             4207 ; 329  |                // SysDelay(1); // spin for 1 ms to let the VDDD and VDDIO voltages settle. Not a reliable ms. 
                             4208 ; 330  |                iDelayCounter = POST_OK_SETTLING_DELAY_STEPUP_VALUE;  
                             4209 
P:01E7 57F400 0003E8  3 1018 4211         move    #1000,b
                             4213 
                             4214 ; 331  |                while(iDelayCounter-- > 0) _nop();
                             4215 
P:01E9 0AF080 rrrrrr  6 1024 4217         jmp     L70
                             4218 
                             4219 ; 332  |                 
                             4220 ; 333  |                            SetDCDCTestBitRegister();   
                             4221 ; 334  |                   }
                             4222 ; 335  |                   else
                             4223 ; 336  |                   {
                             4224 ; 337  |                        if(wRemainder > 0) 
                             4225 
                             4227 L67:
P:01EB 20000B         2 1026 4229         tst     b
P:01EC 0AF0AF rrrrrr  6 1032 4230         jle     L75
                             4231 
                             4232 ; 338  |                        {       HW_DCDC_VDDD.B.VOLTAGE_LEVEL = wDesiredVoltageCode;  // set final voltage  
                             4233 ; 339  |                                SetDCDCTestBitRegister();
                             4234 ; 340  |                                }
                             4235 ; 341  |                                //Voltage Step-Up has completed.  Time to leave.
                             4236 ; 342  |                                break;
                             4237 
P:01EE 0AF080 rrrrrr  6 1038 4239         jmp     L71
P:01F0 000000         2 1040 4241 L69:    nop
P:01F1 21AE00         2 1042 4242 L70:    move    b1,a
P:01F2 44F400 000001  3 1045 4245         move    #>1,x0
P:01F4 20004C         2 1047 4246         sub     x0,b
P:01F5 2A0000         2 1049 4249         move    #0,a2
P:01F6 200003         2 1051 4250         tst     a
P:01F7 0AF0A7 rrrrrr  6 1057 4251         jgt     L69
P:01F9 0BF080 rrrrrr  6 1063 4253         jsr     FSetDCDCTestBitRegister
P:01FB 0AF080 rrrrrr  6 1069 4256         jmp     L64
P:01FD 5EF000 rrrrrr  3 1072 4258 L71:    move    y:ss_VoltageStepUp+1,a
P:01FF 57F000 00FA0F  3 1075 4259         move    x:$FA0F,b
P:0201 44F400 FFFFE0  3 1078 4260         move    #$FFFFE0,x0
P:0203 20004E         2 1080 4261         and     x0,b
P:0204 44F400 00001F  3 1083 4262         move    #>$1F,x0
P:0206 200046         2 1085 4263         and     x0,a
P:0207 218400         2 1087 4264         move    a1,x0
P:0208 20004A         2 1089 4265         or      x0,b
P:0209 557000 00FA0F  3 1092 4266         move    b1,x:$FA0F
P:020B 0BF080 rrrrrr  6 1098 4270         jsr     FSetDCDCTestBitRegister
                             4272 
                             4273 ; 343  |                   }
                             4274 ; 344  |                }
                             4275 ; 345  |    }
                             4276 
P:020D 0AF080 rrrrrr  6 1104 4278         jmp     L75
                             4279 
                             4280 ; 346  |    else if(iVoltageType == VOLTAGE_TYPE_VDDIO)
                             4281 
                             4283 L72:
P:020F 56F400 000002  3 1107 4286         move    #>2,a
P:0211 20000D         2 1109 4287         cmp     a,b
P:0212 0AF0A2 rrrrrr  6 1115 4290         jne     L75
                             4291 
                             4292 ; 347  |    {   
                             4293 ; 348  |        HW_DCDC_VDDIO.B.VOLTAGE_LEVEL = wDesiredVoltageCode;  // set final voltage  
                             4294 
P:0214 5EF000 rrrrrr  3 1118 4296         move    y:ss_VoltageStepUp+1,a
P:0216 57F000 00FA0E  3 1121 4297         move    x:$FA0E,b
P:0218 46F400 FFFFE0  3 1124 4298         move    #$FFFFE0,y0
P:021A 20005E         2 1126 4299         and     y0,b
P:021B 46F400 00001F  3 1129 4300         move    #>$1F,y0
P:021D 200056         2 1131 4301         and     y0,a
P:021E 218600         2 1133 4302         move    a1,y0
P:021F 20005A         2 1135 4303         or      y0,b
P:0220 557000 00FA0E  3 1138 4304         move    b1,x:$FA0E
                             4307 
                             4308 ; 349  |    }
                             4309 ; 350  |    //iVoltageType is always one of above cases since input is prequalified    
                             4310 ; 351  |
                             4311 ; 352  |    return SUCCESS;
                             4312 
P:0222 200013         2 1140 4314 L75:    clr     a   
                             4316 
                             4317 ; 353  |}
                             4318 
P:0223 05F07C rrrrrr  4 1144 4320         movec   y:ss_VoltageStepUp,ssh
P:0225 000000         2 1146 4322         nop
P:0226 00000C         4 1150 4323         rts
                             4326 
Y:0000                       4327         org     y,".yovlsteppingvoltageset@VoltageStepUp",overlay:
                             4328 ss_VoltageStepUp:
Y:0000                       4329         ds      3
   |   RESERVED                   
Y:0002
                             4330 
P:0227                       4331         org     p,".ptextsteppingvoltageset":
                             4333 
                             4334 ; 354  |
                             4335 ; 355  |
                             4336 ; 356  |//------------------------------------------------------------------------------
                             4337 ; 357  |// Private Function: SetDCDCTestBitRegister() 
                             4338 ; 358  |// Inputs: No parameters. reads HW_REVR, HW_DCDC_VDDD
                             4339 ; 359  |// Outputs: void return. Writes HW_DCDDC_TBR
                             4340 ; 360  |// Notes:   This version is originally written for STMP35xx registers. 
                             4341 ; 361  |//          Moved here from SysSetSpeed per SOC designer requirement to set DCDCTBR
                             4342 ; 362  |//          at time of VDDD change. Returns immediately if in a buck mode. 
                             4343 ; 363  |//          The first full C version of this function sets the DCDCTBR to one of
                             4344 ; 364  |//          4 values depending on VddD voltage value. 
                             4345 ; 365  |//------------------------------------------------------------------------------
                             4346 ; 366  |void SetDCDCTestBitRegister(void) 
                             4347 ; 367  |{
                             4348 
                             4411 FSetDCDCTestBitRegister:
P:0227 05707C rrrrrr  4 1154 4412         movec   ssh,y:ss_SetDCDCTestBitRegister
                             4416 
                             4417 ; 368  |    WORD wDCDCMode = HW_REVR.B.DCDCMODE; // low 3 bits are the mode. 7 total codes
                             4418 
P:0229 46F000 00FA02  3 1157 4420         move    x:$FA02,y0
P:022B 0105E0         2 1159 4421         mpy     y0,#5,a
P:022C 46F400 000007  3 1162 4422         move    #>7,y0
P:022E 200056         2 1164 4423         and     y0,a
                             4429 
                             4430 ; 369  |    int iDelayCounter;
                             4431 ; 370  |    WORD wVdddVoltageLevelCode = (WORD)(HW_DCDC_VDDD.B.VOLTAGE_LEVEL);
                             4432 
P:022F 46F000 00FA0F  3 1167 4434         move    x:$FA0F,y0
P:0231 200059         2 1169 4435         tfr     y0,b
P:0232 46F400 00001F  3 1172 4436         move    #>$1F,y0
P:0234 20005E         2 1174 4437         and     y0,b
                             4439 
                             4440 ; 371  |    //WORD wVdddVoltageLevelCode = (WORD)HW_DCDC_VDDD.I;  
                             4441 ; 372  |    //wVdddVoltageLevelCode &= 0x00001f; 
                             4442 ; 373  |
                             4443 ; 374  |    // if pins & therefore read-only-reg specify DCDC converter #1 buck mode, exit.
                             4444 ; 375  |
                             4445 ; 376  |    //if( (HW_REVR.B.DCDCMODE != DCDCMODE_7_CONVERTER1_2CH_BOOST_CONVERTER2_OFF) && 
                             4446 ; 377  |    //    (HW_REVR.B.DCDCMODE != DCDCMODE_5_CONVERTER1_3CH_BOOST_CONVERTER2_OFF) && 
                             4447 ; 378  |    //    (HW_REVR.B.DCDCMODE != DCDCMODE_6_RESERVED) &&
                             4448 ; 379  |    //    (HW_REVR.B.DCDCMODE != DCDCMODE_4_RESERVED) ) 
                             4449 ; 380  |    //    {   DebugBuildAssert(0);
                             4450 ; 381  |    //        return;
                             4451 ; 382  |    //    }  
                             4452 ; 383  |    //The clear logic above simplifies to this:  
                             4453 ; 384  |    if( (wDCDCMode & DCDCMODE_X_BUCK_MASKED_SETMASK) != DCDCMODE_X_BUCK_MASKED_SETMASK ) 
                             4454 
P:0235 47F400 000004  3 1177 4456         move    #>4,y1
P:0237 200076         2 1179 4457         and     y1,a
P:0238 218E00         2 1181 4459         move    a1,a
P:0239 2A0000         2 1183 4460         move    #0,a2
P:023A 200003         2 1185 4461         tst     a
P:023B 0AF0AA rrrrrr  6 1191 4462         jeq     L89
                             4463 
                             4464 ; 385  |    {   //DebugBuildAssert(0);
                             4465 ; 386  |        return; // If buck not masked, exit. bit high means buck mode not present for DCDC converter 1
                             4466 ; 387  |    }  
                             4467 ; 388  |
                             4468 ; 389  |    #if 0
                             4469 ; 390  |    // Alternate working (verified) technique to ensure a non buck DCDC converter mode. 
                             4470 ; 391  |    // With just 3 instructions, saves the most memory but less portable since assembly.
                             4471 ; 392  |#pragma asm
                             4472 ; 393  |    include "hwequ.inc"
                             4473 ; 394  |    btst    #>HW_REVR_DCDCMODE_BUCK_MASK_POS,x:HW_REVR
                             4474 ; 395  |                                ; What mode is dcdc1 in? Is buck masked bit set?
                             4475 ; 396  |    jcs     _continueSegment               
                             4476 ; 397  |    rts                         ; Dont need to change the DCDC TBR
                             4477 ; 398  |_continueSegment
                             4478 ; 399  |#pragma endasm
                             4479 ; 400  |    #endif
                             4480 ; 401  |
                             4481 ; 402  |    // comment this line when testpoint unneeded
                             4482 ; 403  |    //if(VStepHalt) {DebugBuildAssert(0); _asm( " nop"); _asm( " nop"); _asm( " nop");} 
                             4483 ; 404  |
                             4484 ; 405  |    HW_DCDC_TBR.B.DCDC_ANA_BGR_BIAS = 1; // for all cases. Required by IC designer.
                             4485 
P:023D 0A702F 00FA14  6 1197 4487         bset    #15,x:$FA14
                             4488 
                             4489 ; 406  |         
                             4490 ; 407  |    // Set the DCDC test bit reg fields for duty cycle & bat adjust 
                             4491 ; 408  |    if(     (wVdddVoltageLevelCode) >= 0x12) // 0x12 is 1.60V. Range [1.60, 2.02]
                             4492 
P:023F 46F400 000012  3 1200 4494         move    #>18,y0
P:0241 21AF00         2 1202 4495         move    b1,b
P:0242 21AE00         2 1204 4496         move    b1,a
P:0243 2B0000         2 1206 4497         move    #0,b2
P:0244 20005D         2 1208 4498         cmp     y0,b
P:0245 0AF0A9 rrrrrr  6 1214 4500         jlt     L83
                             4501 
                             4502 ; 409  |    {  
                             4503 ; 410  |        HW_DCDC_TBR.B.DCDC1_ADJ_TN = 0;
                             4504 
P:0247 57F000 00FA14  3 1217 4506         move    x:$FA14,b
P:0249 44F400 FFFFF0  3 1220 4507         move    #$FFFFF0,x0
P:024B 20004E         2 1222 4508         and     x0,b
P:024C 557000 00FA14  3 1225 4509         move    b1,x:$FA14
                             4510 
                             4511 ; 411  |        ClearHwDcdcTbrBatteryADJ();     
                             4512 
P:024E 0BF080 rrrrrr  6 1231 4514         jsr     FClearHwDcdcTbrBatteryADJ
TASKING DSP2410 assembler v1.5r1 Build 138 SN 00100122
                                                                                                                                                                                                                                                       Page  17

M:ADDR CODE           CYCLES LINE SOURCELINE
                             4515 
                             4516 ; 412  |    }
                             4517 
P:0250 0AF080 rrrrrr  6 1237 4519         jmp     L89
                             4520 
                             4521 ; 413  |    else if((wVdddVoltageLevelCode) >= 0x0F) // 0x0F is 1.50V. Range [1.50, 1.57V]
                             4522 
P:0252 57F400 00000F  3 1240 4524 L83:    move    #>15,b
P:0254 2A0000         2 1242 4525         move    #0,a2
P:0255 200005         2 1244 4526         cmp     b,a
P:0256 0AF0A9 rrrrrr  6 1250 4527         jlt     L84
                             4528 
                             4529 ; 414  |    { //Scope optimized step down sequence achieved with ver that just sets 2 bits and sets R&C values. 
                             4530 ; 415  |        //if(!(WORD)(HW_DCDC_TBR.B.DCDC1_BAT_ADJ))
                             4531 ; 416  |        //{
                             4532 ; 417  |            //#define DCDC_BATT_ADJ_COUNTDOWN_VALUE 3200
                             4533 ; 418  |            //iDelayCounter = DCDC_BATT_ADJ_COUNTDOWN_VALUE; 
                             4534 ; 419  |            // 3200 here showed on scope that this bitset is not cause of vddio drop, 
                             4535 ; 420  |            // since vddio drop occurs before this, near time when vddd is reduced.
                             4536 ; 421  |            //while(iDelayCounter-- > 0) _nop();
                             4537 ; 422  |        HW_DCDC_TBR.B.DCDC1_BAT_ADJ = 1;
                             4538 
P:0258 0A7025 00FA14  6 1256 4540         bset    #5,x:$FA14
                             4541 
                             4542 ; 423  |            //iDelayCounter = POST_DCDC_BATT_ADJ_COUNTDOWN_VALUE; // 3200 initialliy tried.
                             4543 ; 424  |            //while(iDelayCounter-- > 0) _nop();      
                             4544 ; 425  |        //}        
                             4545 ; 426  |        HW_DCDC_TBR.B.DCDC1_ADJ_TN = 0;
                             4546 
P:025A 57F000 00FA14  3 1259 4548         move    x:$FA14,b
P:025C 46F400 FFFFF0  3 1262 4549         move    #$FFFFF0,y0
P:025E 20005E         2 1264 4550         and     y0,b
P:025F 557000 00FA14  3 1267 4551         move    b1,x:$FA14
                             4552 
                             4553 ; 427  |        // SystemHalt();
                             4554 ; 428  |    }
                             4555 
P:0261 0AF080 rrrrrr  6 1273 4557         jmp     L89
                             4558 
                             4559 ; 429  |    else if((wVdddVoltageLevelCode) >= 0x0C) // 0x0C is 1.40V. Range [1.40, 1.47]
                             4560 
P:0263 47F400 00000C  3 1276 4562 L84:    move    #>12,y1
P:0265 200075         2 1278 4563         cmp     y1,a
P:0266 0AF0A9 rrrrrr  6 1284 4564         jlt     L85
                             4565 
                             4566 ; 430  |    {
                             4567 ; 431  |        HW_DCDC_TBR.B.DCDC1_ADJ_TN = 1;  
                             4568 
P:0268 56F000 00FA14  3 1287 4570         move    x:$FA14,a
P:026A 45F400 FFFFF0  3 1290 4571         move    #$FFFFF0,x1
P:026C 200066         2 1292 4572         and     x1,a
P:026D 45F400 000001  3 1295 4573         move    #>1,x1
P:026F 200062         2 1297 4574         or      x1,a
                             4575 
                             4576 ; 432  |        HW_DCDC_TBR.B.DCDC1_BAT_ADJ = 1;     
                             4577 
P:0270 0AF080 rrrrrr  6 1303 4579         jmp     L86
                             4580 
                             4581 ; 433  |    }
                             4582 ; 434  |    else           // VOLTAGE_LEVEL <= 0x0B    V range [1.34, 1.37].         
                             4583 ; 435  |    {
                             4584 ; 436  |        HW_DCDC_TBR.B.DCDC1_ADJ_TN = 2;
                             4585 
P:0272 56F000 00FA14  3 1306 4587 L85:    move    x:$FA14,a
P:0274 46F400 FFFFF0  3 1309 4588         move    #$FFFFF0,y0
P:0276 200056         2 1311 4589         and     y0,a
P:0277 46F400 000002  3 1314 4590         move    #>2,y0
P:0279 200052         2 1316 4591         or      y0,a
                             4592 
                             4593 ; 437  |        HW_DCDC_TBR.B.DCDC1_BAT_ADJ = 1;     
                             4594 
                             4596 L86:
P:027A 547000 00FA14  3 1319 4598         move    a1,x:$FA14
P:027C 0A7025 00FA14  6 1325 4600         bset    #5,x:$FA14
                             4601 
                             4602 ; 438  |    }
                             4603 ; 439  |
                             4604 ; 440  |}// end function
                             4605 
P:027E 05F07C rrrrrr  4 1329 4607 L89:    movec   y:ss_SetDCDCTestBitRegister,ssh
P:0280 000000         2 1331 4609         nop
P:0281 00000C         4 1335 4610         rts
                             4611 
Y:0000                       4612         org     y,".yovlsteppingvoltageset@SetDCDCTestBitRegister",overlay:
                             4613 ss_SetDCDCTestBitRegister:
Y:0000 RESERVED              4614         ds      1
Y:0000
                             4615 
P:0282                       4616         org     p,".ptextsteppingvoltageset":
                             4618 
                             4619 ; 441  |
                             4620 ; 442  |//------------------------------------------------------------------------------
                             4621 ; 443  |// Private Function: ClearHwDcdcTbrBatteryADJ() 
                             4622 ; 444  |// Inputs: No parameters. Clear HW_DCDC_TBR[DCDC1_BAT_ADJ] Register
                             4623 ; 445  |// Outputs: None
                             4624 ; 446  |// Notes:   This version is originally written for STMP35xx registers. 
                             4625 ; 447  |//          Clearing the DCDC1_BAT_ADJ bit may cause false VDDIO Brownouts.
                             4626 ; 448  |//                      This function will disable VDDIO brownout before clearing the bit.
                             4627 ; 449  |//------------------------------------------------------------------------------
                             4628 ; 450  |void ClearHwDcdcTbrBatteryADJ(void)
                             4629 ; 451  |{
                             4630 
                             4635 FClearHwDcdcTbrBatteryADJ:
                             4638 
                             4639 ; 452  |        WORD iDelayCounter;
                             4640 ; 453  |
                             4641 ; 454  |        //check to see if bit is set.  No need to delay if the bit is already cleared. 
                             4642 ; 455  |        if(HW_DCDC_TBR.B.DCDC1_BAT_ADJ)
                             4643 
P:0282 50F000 00FA14  3 1338 4645         move    x:$FA14,a0
P:0284 0AC805 rrrrrr  6 1344 4646         jclr    #5,a0,L92
                             4647 
                             4648 ; 456  |        { 
                             4649 ; 457  |                //Before Changing TBR Register, clear VDDIO Brownout.  Clearing the DCDC1_BAT_ADJ may cause 
                             4650 ; 458  |                //false Brownouts.
                             4651 ; 459  |                HW_DCDC_VDDIO.B.BROWNOUT_ENABLE = 0;
                             4652 
P:0286 0A7010 00FA0E  6 1350 4654         bclr    #16,x:$FA0E
                             4655 
                             4656 ; 460  |
                             4657 ; 461  |                HW_DCDC_TBR.B.DCDC1_BAT_ADJ = 0;
                             4658 
P:0288 0A7005 00FA14  6 1356 4660         bclr    #5,x:$FA14
                             4661 
                             4662 ; 462  |
                             4663 ; 463  |        // SysDelay(1); // spin for 1 ms to let the VDDD and VDDIO voltages settle. Not a reliable ms. 
                             4664 ; 464  |        iDelayCounter = DCDCTBR_SETTLING_DELAY_VALUE;  
                             4665 
P:028A 57F400 000C80  3 1359 4667         move    #3200,b
                             4669 
                             4670 ; 465  |        while(iDelayCounter-- > 0) _nop();
                             4671 
P:028C 46F400 000001  3 1362 4673         move    #>1,y0
P:028E 0AF080 rrrrrr  6 1368 4674         jmp     L91
P:0290 000000         2 1370 4675 L90:    nop
P:0291 21AE00         2 1372 4676 L91:    move    b1,a
P:0292 20005C         2 1374 4679         sub     y0,b
P:0293 2A0000         2 1376 4682         move    #0,a2
P:0294 200003         2 1378 4683         tst     a
P:0295 0AF0A7 rrrrrr  6 1384 4684         jgt     L90
                             4685 
                             4686 ; 466  |
                             4687 ; 467  |                // Now it should be safe to re-enable VDDIO Brownout
                             4688 ; 468  |                HW_DCDC_VDDIO.B.BROWNOUT_ENABLE = 1;
                             4689 
P:0297 0A7030 00FA0E  6 1390 4691         bset    #16,x:$FA0E
                             4692 
                             4693 ; 469  |        }
                             4694 
                             4696 L92:
                             4697 
                             4698 ; 470  |} 
                             4699 
P:0299 00000C         4 1394 4701         rts
                             4704 
                             4705 ; 471  |
                             4706 ; 472  |
                             4707 ; 473  |
                             4708 ; 474  |#ifdef FUNCLET
                             4709 ; 475  |#pragma asm
                             4710   extern    SysCallFunclet
                             4711   global FSteppingVoltageSet
P:0000                       4712   org p,".ptextsteppingvoltagesetprologue":
                             4713 FSteppingVoltageSet
                             4718   CallFunclet2 RSRC_FUNCLET_STEPPINGVOLTAGESET
P:0000 0D0082         4    4 4718     jsr       $82
P:0001 000009                4718     DC       RSRC_FUNCLET_STEPPINGVOLTAGESET  ; 1 word
                             4719 ; 485  |#pragma endasm
                             4720 ; 486  |
                             4721 ; 487  |
                             4722 ; 488  |#pragma asm
P:0000                       4723         org p,".ptextskiponewordforsteppingvoltage":
P:0000 000009                4724         dc RSRC_FUNCLET_STEPPINGVOLTAGESET    
                             4725 ; 491  |#pragma endasm
                             4726 ; 492  |#endif
                             4727 
                             4729 
                             4730         extern  SysGetCurrentTime
                             4731 
                             4732         global  FClearHwDcdcTbrBatteryADJ, FSetDCDCTestBitRegister
                             4733         global  FSteppingVoltageSetFunclet, FVoltageStepDown
                             4734         global  FVoltageStepUp, FWaitForVDD_OKOrTimeOut
                             4735 
                             4736         local   L3, L4, L5, L6, L8, L9, L14, L15, L16, L17, L19, L20, L21
                             4737         local   L22, L23, L24, L25, L27, L28, L29, L30, L31, L32, L33, L34
                             4738         local   L35, L36, L38, L39, L40, L41, L42, L43, L44, L45, L46, L47
                             4739         local   L51, L64, L65, L66, L67, L69, L70, L71, L72, L75, L83, L84
                             4740         local   L85, L86, L89, L90, L91, L92, ss_SetDCDCTestBitRegister
                             4741         local   ss_SteppingVoltageSetFunclet, ss_VoltageStepDown
                             4742         local   ss_VoltageStepUp, ss_WaitForVDD_OKOrTimeOut
                             4743 
                             4744         calls   "SetDCDCTestBitRegister", "ClearHwDcdcTbrBatteryADJ"
                             4745         calls   "SteppingVoltageSetFunclet", "VoltageStepDown"
                             4746         calls   "SteppingVoltageSetFunclet", "VoltageStepUp"
                             4747         calls   "VoltageStepDown", "SetDCDCTestBitRegister"
                             4748         calls   "VoltageStepDown", "SysGetCurrentTime"
                             4749         calls   "VoltageStepDown", "WaitForVDD_OKOrTimeOut"
                             4750         calls   "VoltageStepUp", "SetDCDCTestBitRegister"
                             4751         calls   "VoltageStepUp", "WaitForVDD_OKOrTimeOut"
                             4752         calls   "WaitForVDD_OKOrTimeOut", "SysGetCurrentTime"
                             4753 
