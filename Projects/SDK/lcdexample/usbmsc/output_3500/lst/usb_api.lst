TASKING DSP2410 assembler v1.5r1 Build 138 SN 00100122
                                                                                                                                                                                                                                                       Page   1
C:\STMP3XXX_SDK_FIRMWARE_320_finalfix\Projects\SDK\lcdexample\usbmsc\Make\cc86fcfb.src
M:ADDR CODE           CYCLES LINE SOURCELINE
                                1 ; TASKING DSP2410 C compiler v1.5r1 Build 208 SN 00100122
                                2 ; options: -OG -si -w68 -w66 -I..\output_3500\include
                                3 ;          -I..\..\..\..\..\Projects\sdk\lcdexample\usbmsc -I -I..\..
                                4 ;          -I..\..\..\..\..\inc -I..\..\..\..\..\System\Common
                                5 ;          -I..\..\..\..\..\System\Common\symbols -I
                                6 ;          -I..\..\..\..\..\Algorithms\DRM\janus\src\h
                                7 ;          -I..\..\..\..\..\devicedriver\media\ddildl
                                8 ;          -I..\..\..\..\..\devicedriver\media\ddildl\include
                                9 ;          -I..\..\..\..\..\devicedriver\media\MediaTypeMMC\DDI\include
                               10 ;          -I..\..\..\..\..\devicedriver\media\ddildl\include
                               11 ;          -I..\..\..\..\..\devicedriver\media\MediaTypeMMC\DDI\include
                               12 ;          -I..\..\..\..\..\devicedriver\media\MediaTypeMMC\DDI\Media
                               13 ;          -I..\..\..\..\..\devicedriver\media\MediaTypeMMC\HAL\include
                               14 ;          -I..\..\..\..\..\devicedriver\media\MediaTypeRAM\include
                               15 ;          -I..\..\..\..\..\devicedriver\media\MediaTypeRAM\DDI\DataDrive\include
                               16 ;          -I..\..\..\..\..\devicedriver\media\MediaTypeRAM\DDI\include
                               17 ;          -I..\..\..\..\..\devicedriver\media\MediaTypeRAM\HAL\include
                               18 ;          -I..\..\..\..\..\devicedriver\media\MediaTypeRAM\DDI\DataDrive
                               19 ;          -I..\..\..\..\..\devicedriver\media\MediaTypeRAM\include
                               20 ;          -I..\..\..\..\..\devicedriver\media\MediaTypeRAM\DDI\SystemDrive\include
                               21 ;          -I..\..\..\..\..\devicedriver\media\MediaTypeRAM\DDI\include
                               22 ;          -I..\..\..\..\..\devicedriver\media\MediaTypeRAM\HAL\include
                               23 ;          -I..\..\..\..\..\devicedriver\media\MediaTypeRAM\DDI\SystemDrive
                               24 ;          -I..\..\..\..\..\devicedriver\media\MediaTypeRAM\include
                               25 ;          -I..\..\..\..\..\devicedriver\media\MediaTypeRAM\DDI\Media\include
                               26 ;          -I..\..\..\..\..\devicedriver\media\MediaTypeRAM\DDI\include
                               27 ;          -I..\..\..\..\..\devicedriver\media\MediaTypeRAM\HAL\include
                               28 ;          -I..\..\..\..\..\devicedriver\media\MediaTypeRAM\DDI\Media
                               29 ;          -I..\..\..\..\..\devicedriver\media\MediaTypeRAM\include
                               30 ;          -I..\..\..\..\..\devicedriver\media\MediaTypeRAM\DDI\include
                               31 ;          -I..\..\..\..\..\devicedriver\media\MediaTypeRAM\HAL\include
                               32 ;          -I..\..\..\..\..\devicedriver\media\MediaTypeNAND\include
                               33 ;          -I..\..\..\..\..\devicedriver\media\MediaTypeNAND\DDI\DataDrive\include
                               34 ;          -I..\..\..\..\..\devicedriver\media\MediaTypeNAND\DDI\include
                               35 ;          -I..\..\..\..\..\devicedriver\media\MediaTypeNAND\HAL\include
                               36 ;          -I..\..\..\..\..\devicedriver\media\MediaTypeNAND\DDI\DataDrive
                               37 ;          -I..\..\..\..\..\devicedriver\media\ddildl\include -I
                               38 ;          -I..\..\..\..\..\FileSystem\Fat32\cmp\cmp_stdtype
                               39 ;          -I..\..\..\..\..\FileSystem\Fat32\cmp\cmp_debug
                               40 ;          -I..\..\..\..\..\FileSystem\Fat32\cmp\cmp_file_system
                               41 ;          -I..\..\..\..\..\DeviceDriver\Media\cmp\cmp_media_nand
                               42 ;          -I..\..\..\..\..\devicedriver\media\MediaTypeNAND\include
                               43 ;          -I..\..\..\..\..\devicedriver\media\MediaTypeNAND\DDI\Common\include
                               44 ;          -I..\..\..\..\..\devicedriver\media\MediaTypeNAND\DDI\include
                               45 ;          -I..\..\..\..\..\devicedriver\media\MediaTypeNAND\HAL\include
                               46 ;          -I..\..\..\..\..\devicedriver\media\MediaTypeNAND\DDI\Common
                               47 ;          -I..\..\..\..\..\devicedriver\media\MediaTypeNAND\include
                               48 ;          -I..\..\..\..\..\devicedriver\media\MediaTypeNAND\DDI\SystemDrive\include
                               49 ;          -I..\..\..\..\..\devicedriver\media\MediaTypeNAND\DDI\include
                               50 ;          -I..\..\..\..\..\devicedriver\media\MediaTypeNAND\HAL\include
                               51 ;          -I..\..\..\..\..\devicedriver\media\MediaTypeNAND\DDI\SystemDrive
                               52 ;          -I..\..\..\..\..\devicedriver\media\MediaTypeNAND\include
                               53 ;          -I..\..\..\..\..\devicedriver\media\MediaTypeNAND\DDI\Media\include
                               54 ;          -I..\..\..\..\..\devicedriver\media\MediaTypeNAND\DDI\include
                               55 ;          -I..\..\..\..\..\devicedriver\media\MediaTypeNAND\HAL\include
                               56 ;          -I..\..\..\..\..\devicedriver\media\MediaTypeNAND\DDI\Media
                               57 ;          -I..\..\..\..\..\devicedriver\media\include
                               58 ;          -I..\..\..\..\..\devicedriver\media\ddildl
                               59 ;          -I..\..\..\..\..\devicedriver\media\ddildl\include
                               60 ;          -I..\..\..\..\..\devicedriver\media\MediaTypeNAND\DDI\Common\include
                               61 ;          -I..\..\..\..\..\devicedriver\media\MediaTypeNAND\DDI\include
                               62 ;          -I..\..\..\..\..\DeviceDriver\Media\MediaTypeNAND\HAL
                               63 ;          -I..\..\..\..\..\DeviceDriver\Media\MediaTypeNAND\HAL\include
                               64 ;          -I..\..\..\..\..\DeviceDriver\Media\include
                               65 ;          -I..\..\..\..\..\DeviceDriver\Media\PortHIL\GPFlash\include
                               66 ;          -I..\..\..\..\..\DeviceDriver\Media\PortHIL\GPFlash
                               67 ;          -I..\..\..\..\..\system\common\resourcemanager -I..\..\..\..\..\inc
                               68 ;          -I..\..\..\..\..\DeviceDriver\Media\usb\Ch9
                               69 ;          -I..\..\..\..\..\DeviceDriver\Media\scsi
                               70 ;          -I..\..\..\..\..\DeviceDriver\Media\usbmsc
                               71 ;          -I..\..\..\..\..\DeviceDriver\Media\mtp
                               72 ;          -I..\..\..\..\..\System\Common\updater
                               73 ;          -I..\..\..\..\..\libsource\sysserialnumber -DALL -DD3500 -DMMC
                               74 ;          -DLIION -DTUNER_STFM1000 -DSTFM1000_LCD=TRUE -DDCDC_POWER_TRANSFER
                               75 ;          -DBACKLIGHT -DWMAAPI_NO_DRM -DREVB_ENGR_BD -DSED15XX_LCD -DFAT16
                               76 ;          -DDEVICE_3500 -DENGR_BD -DUSBMSC_BUILD -DBATTERY_TYPE_LI_ION
                               77 ;          -DBATTERY_CHARGE -DUSE_PLAYLIST3_HOST -DASCII_ONLY -DRETAIL
                               78 ;          -DDEVICE_3500 -DMMC -Dk_opt_performance_enhancement
                               79 ;          -I..\..\..\..\..\devicedriver\display
                               80 ;          -I..\..\..\..\..\System\MsgModules\Hardware\Display -g -O2 -R -Cs
                               81 ;          -MmyL
                               82 
                               90 
                               91 ;      usb_api.c:
                               92 ; 1    |////////////////////////////////////////////////////////////////////////////////
                               93 ; 2    |// Copyright(C) SigmaTel, Inc. 2001-2005
                               94 ; 3    |//
                               95 ; 4    |// File : usb20devapi.c
                               96 ; 5    |// Description : USB2.0 device API functions
                               97 ; 6    |////////////////////////////////////////////////////////////////////////////////
                               98 ; 7    |
                               99 ; 8    |////////////////////////////////////////////////////////////////////////////////
                              100 ; 9    |//  Macros
                              101 ; 10   |////////////////////////////////////////////////////////////////////////////////
                              102 ; 11   |
                              103 ; 12   |////////////////////////////////////////////////////////////////////////////////
                              104 ; 13   |//  Includes
                              105 ; 14   |////////////////////////////////////////////////////////////////////////////////
                              106 ; 15   |
                              107 ; 16   |#include "types.h"
                              108 
                              110 
                              111 ; 1    |////////////////////////////////////////////////////////////////////////////////
                              112 ; 2    |// Copyright(C) SigmaTel, Inc. 2000-2004
                              113 ; 3    |//
                              114 ; 4    |// Filename: types.h
                              115 ; 5    |// Description: Standard data types
                              116 ; 6    |////////////////////////////////////////////////////////////////////////////////
                              117 ; 7    |
                              118 ; 8    |#ifndef _TYPES_H
                              119 ; 9    |#define _TYPES_H
                              120 ; 10   |
                              121 ; 11   |// TODO:  move this outta here!
                              122 ; 12   |#if !defined(NOERROR)
                              123 ; 13   |#define NOERROR 0
                              124 ; 14   |#define SUCCESS 0
                              125 ; 15   |#endif 
                              126 ; 16   |#if !defined(SUCCESS)
                              127 ; 17   |#define SUCCESS  0
                              128 ; 18   |#endif
                              129 ; 19   |#if !defined(ERROR)
                              130 ; 20   |#define ERROR   -1
                              131 ; 21   |#endif
                              132 ; 22   |#if !defined(FALSE)
                              133 ; 23   |#define FALSE 0
                              134 ; 24   |#endif
                              135 ; 25   |#if !defined(TRUE)
                              136 ; 26   |#define TRUE  1
                              137 ; 27   |#endif
                              138 ; 28   |
                              139 ; 29   |#if !defined(NULL)
                              140 ; 30   |#define NULL 0
                              141 ; 31   |#endif
                              142 ; 32   |
                              143 ; 33   |#define MAX_INT     0x7FFFFF
                              144 ; 34   |#define MAX_LONG    0x7FFFFFffffff
                              145 ; 35   |        // max positive unsigned long value: -1 == 0xFFFFFFffffff
                              146 ; 36   |#define MAX_ULONG   (-1) 
                              147 ; 37   |
                              148 ; 38   |#define WORD_SIZE   24              // word size in bits
                              149 ; 39   |#define BYTES_PER_WORD 3            // 8 bit bytes
                              150 ; 40   |
                              151 ; 41   |
                              152 ; 42   |#define BYTE    unsigned char       // btVarName
                              153 ; 43   |#define CHAR    signed char         // cVarName
                              154 ; 44   |#define USHORT  unsigned short      // usVarName
                              155 ; 45   |#define SHORT   unsigned short      // sVarName
                              156 ; 46   |#define WORD    unsigned int        // wVarName
                              157 ; 47   |#define INT     signed int          // iVarName
                              158 ; 48   |#define DWORD   unsigned long       // dwVarName
                              159 ; 49   |#define LONG    signed long         // lVarName
                              160 ; 50   |#define BOOL    unsigned int        // bVarName
                              161 ; 51   |#define FRACT   _fract              // frVarName
                              162 ; 52   |#define LFRACT  long _fract         // lfrVarName
                              163 ; 53   |#define CIRC    _circ               // cp<type prefix>VarName (see below)
                              164 ; 54   |#define FLOAT   float               // fVarName
                              165 ; 55   |#define DBL     double              // dVarName
                              166 ; 56   |#define ENUM    enum                // eVarName
                              167 ; 57   |#define CMX     _complex            // cmxVarName
                              168 ; 58   |typedef WORD UCS3;                   // 
                              169 ; 59   |
                              170 ; 60   |#define UINT16  unsigned short
                              171 ; 61   |#define UINT8   unsigned char   
                              172 ; 62   |#define UINT32  unsigned long
                              173 ; 63   |#define UINT64  unsigned long   // need to figure out how to do 64 bit values.  Or port exisiting code to only use 48 bit
                              174 ; 64   |#define INT64   unsigned long   // need to figure out how to do 64 bit values.  Or port exisiting code to only use 48 bit
                              175 ; 65   |#define WCHAR   UINT16
                              176 ; 66   |
                              177 ; 67   |//UINT128 is 16 bytes or 6 words
                              178 ; 68   |typedef struct UINT128_3500 {   
                              179 ; 69   |    int val[6];     
                              180 ; 70   |} UINT128_3500;
                              181 ; 71   |
                              182 ; 72   |#define UINT128   UINT128_3500
                              183 ; 73   |
                              184 ; 74   |// Little endian word packed byte strings:   
                              185 ; 75   |//      _packed BYTE bTextVarName[]="a string";  bText is a packed byte string prefix
                              186 ; 76   |// Convert to big endian words by reordering bytes from high to low using swizzle.
                              187 ; 77   |// Little endian word packed byte strings:   
                              188 ; 78   |//      _packed BYTE bTextVarName[]="a string";  bText is a packed byte string prefix
                              189 ; 79   |// Convert to big endian words by reordering bytes from high to low using swizzle.
                              190 ; 80   |
                              191 ; 81   |// Declare Memory Spaces To Use When Coding
                              192 ; 82   |// A. Sector Buffers
                              193 ; 83   |#define SECTOR_BUFFER_MEM_X _X
                              194 ; 84   |#define SECTOR_BUFFER_MEM_Y _Y
                              195 ; 85   |#define SECTOR_BUFFER_MEM SECTOR_BUFFER_MEM_X
                              196 ; 86   |typedef WORD SECTOR_BUFFER_MEM SECTOR_BUFFER;
                              197 
                              199 
                              200 ; 87   |typedef SECTOR_BUFFER * P_SECTOR_BUFFER;
                              201 ; 88   |// B. Media DDI Memory
                              202 ; 89   |#define MEDIA_DDI_MEM _Y
                              203 ; 90   |
                              204 ; 91   |
                              205 ; 92   |
                              206 ; 93   |// Pointers to linear structures are labeled as: p<type prefix>VarName
                              207 ; 94   |// Examples of circular pointers:
                              208 ; 95   |//    INT CIRC cpiVarName
                              209 ; 96   |//    DWORD CIRC cpdwVarName
                              210 ; 97   |
                              211 ; 98   |#define RETCODE INT                 // rcVarName
                              212 ; 99   |
                              213 ; 100  |// generic bitfield structure
                              214 ; 101  |struct Bitfield {
                              215 ; 102  |    unsigned int B0  :1;
                              216 ; 103  |    unsigned int B1  :1;
                              217 ; 104  |    unsigned int B2  :1;
                              218 ; 105  |    unsigned int B3  :1;
                              219 ; 106  |    unsigned int B4  :1;
                              220 ; 107  |    unsigned int B5  :1;
                              221 ; 108  |    unsigned int B6  :1;
                              222 ; 109  |    unsigned int B7  :1;
                              223 ; 110  |    unsigned int B8  :1;
                              224 ; 111  |    unsigned int B9  :1;
                              225 ; 112  |    unsigned int B10 :1;
                              226 ; 113  |    unsigned int B11 :1;
                              227 ; 114  |    unsigned int B12 :1;
                              228 ; 115  |    unsigned int B13 :1;
                              229 ; 116  |    unsigned int B14 :1;
                              230 ; 117  |    unsigned int B15 :1;
                              231 ; 118  |    unsigned int B16 :1;
                              232 ; 119  |    unsigned int B17 :1;
                              233 ; 120  |    unsigned int B18 :1;
                              234 ; 121  |    unsigned int B19 :1;
                              235 ; 122  |    unsigned int B20 :1;
                              236 ; 123  |    unsigned int B21 :1;
                              237 ; 124  |    unsigned int B22 :1;
                              238 ; 125  |    unsigned int B23 :1;
                              239 ; 126  |};
                              240 ; 127  |
                              241 ; 128  |union BitInt {
                              242 ; 129  |        struct Bitfield B;
                              243 ; 130  |        int        I;
                              244 ; 131  |};
                              245 ; 132  |
                              246 ; 133  |#define MAX_MSG_LENGTH 10
                              247 ; 134  |struct CMessage
                              248 ; 135  |{
                              249 ; 136  |        unsigned int m_uLength;
                              250 ; 137  |        unsigned int m_uMsg[MAX_MSG_LENGTH];
                              251 ; 138  |};
                              252 ; 139  |
                              253 ; 140  |typedef struct {
                              254 ; 141  |    WORD m_wLength;
                              255 ; 142  |    WORD m_wMessage;
                              256 ; 143  |    WORD m_wParams[MAX_MSG_LENGTH];
                              257 ; 144  |} Message;
                              258 ; 145  |
                              259 ; 146  |struct MessageQueueDescriptor
                              260 ; 147  |{
TASKING DSP2410 assembler v1.5r1 Build 138 SN 00100122
                                                                                                                                                                                                                                                       Page   2

M:ADDR CODE           CYCLES LINE SOURCELINE
                              261 ; 148  |        int *m_pBase;
                              262 ; 149  |        int m_iModulo;
                              263 ; 150  |        int m_iSize;
                              264 ; 151  |        int *m_pHead;
                              265 ; 152  |        int *m_pTail;
                              266 ; 153  |};
                              267 ; 154  |
                              268 ; 155  |struct ModuleEntry
                              269 ; 156  |{
                              270 ; 157  |    int m_iSignaledEventMask;
                              271 ; 158  |    int m_iWaitEventMask;
                              272 ; 159  |    int m_iResourceOfCode;
                              273 ; 160  |    struct MessageQueueDescriptor *m_pMessageQueue;
                              274 ; 161  |    int _asmfunc (*m_pProcessEntryPoint)(union WaitMask Signals,struct MessageQueueDescriptor *);
                              275 ; 162  |    int _asmfunc (*m_pInitFunction)(struct MessageQueueDescriptor *);
                              276 ; 163  |    int m_uTimeOutHigh;
                              277 ; 164  |    int m_uTimeOutLow;
                              278 ; 165  |    int _asmfunc (*m_pBackgroundFunction)(struct MessageQueueDescriptor *);
                              279 ; 166  |};
                              280 ; 167  |
                              281 ; 168  |union WaitMask{
                              282 ; 169  |    struct B{
                              283 ; 170  |        unsigned int m_bNone     :1;
                              284 ; 171  |        unsigned int m_bMessage  :1;
                              285 ; 172  |        unsigned int m_bTimer    :1;
                              286 ; 173  |        unsigned int m_bButton   :1;
                              287 ; 174  |    } B;
                              288 ; 175  |    int I;
                              289 ; 176  |} ;
                              290 ; 177  |
                              291 ; 178  |
                              292 ; 179  |struct Button {
                              293 ; 180  |        WORD wButtonEvent;
                              294 ; 181  |        WORD wUnused[MAX_MSG_LENGTH];   
                              295 ; 182  |};
                              296 ; 183  |
                              297 ; 184  |struct Message {
                              298 ; 185  |        WORD wMsgLength;
                              299 ; 186  |        WORD wMsgCommand;
                              300 ; 187  |        WORD wMsgParms[MAX_MSG_LENGTH-1];
                              301 ; 188  |};
                              302 ; 189  |
                              303 ; 190  |union EventTypes {
                              304 ; 191  |        struct CMessage msg;
                              305 ; 192  |        struct Button Button ;
                              306 ; 193  |        struct Message Message;
                              307 ; 194  |};
                              308 ; 195  |
                              309 ; 196  |// next 2 used to get updater build to return correct protocol ver in scsi response.
                              310 ; 197  |#define BUILD_TYPE_UPDATER  0x100
                              311 ; 198  |#define BUILD_TYPE_HOSTLINK 0x101
                              312 ; 199  |#define BUILD_TYPE_PLAYER   0x102
                              313 ; 200  |
                              314 ; 201  |// Resets part if RETAIL build. DEBUG build executes debug instruction to halt.
                              315 ; 202  |#define SystemHalt() __asm(" include 'sysmacro.asm' \n error") 
                              316 ; 203  |#define assert(x)    if(!(x)) __asm(" include 'sysmacro.asm' \n error")
                              317 ; 204  |
                              318 ; 205  |#if DEBUG
                              319 ; 206  |// For DEBUG builds, DebugBuildAssert(condition) halts if condition evaluates to FALSE. 
                              320 ; 207  |#define DebugBuildAssert(x)    if(!(x)) __asm(" debug ")
                              321 ; 208  |#else 
                              322 ; 209  |// For RETAIL builds, DebugBuildAssert(condition) does nothing & execution continues rather than halt or reset. 
                              323 ; 210  |#define DebugBuildAssert(x)    
                              324 ; 211  |#endif
                              325 ; 212  |
                              326 ; 213  |// Do this in your C files to make a reminder that's displayed during the build.
                              327 ; 214  |//  #pragma asm
                              328 ; 215  |//  WARN 'Note to builder: reminder to do this after verifying that'
                              329 ; 216  |//  #pragma endasm
                              330 ; 217  |
                              331 ; 218  |
                              332 ; 219  |#ifdef COLOR_262K
                              333 ; 220  |#define RGB(r,g,b)    ((0x0000FC & (r)) << 10) | ((0x0000FC & (g)) << 4) | ((0x0000FC & (b)) >> 2)    //262k
                              334 ; 221  |#elif defined(COLOR_65K)
                              335 ; 222  |#define RGB(r,g,b)    ((0x0000F8 & (r)) << 8) | ((0x0000FC & (g)) << 3) | ((0x0000F8 & (b)) >> 3)  //65k
                              336 ; 223  |#else
                              337 ; 224  |#define RGB(r,g,b)       ((0x0000F0 & (r)) << 4) | (0x0000F0 & (g)) | ((0x0000F0 & (b)) >> 4)
                              338 ; 225  |#endif
                              339 ; 226  |    
                              340 ; 227  |#endif // #ifndef _TYPES_H
                              341 
                              343 
                              344 ; 17   |#include "project.h"
                              345 
                              347 
                              348 ; 1    |/////////////////////////////////////////////////////////////////////////////////
                              349 ; 2    |//  Copyright(C) SigmaTel, Inc. 2000-2004
                              350 ; 3    |//  Filename: project.inc
                              351 ; 4    |//  Description: 
                              352 ; 5    |/////////////////////////////////////////////////////////////////////////////////
                              353 ; 6    |
                              354 ; 7    |#if (!defined(_PROJECT_INC))
                              355 ; 8    |#define _PROJECT_INC 1
                              356 ; 9    |
                              357 ; 10   |#if defined(STMP_BUILD_PLAYER)
                              358 ; 11   |#include "hwequ.h"
                              359 ; 12   |#else 
                              360 ; 13   |//include "regscodec.inc"
                              361 ; 14   |#endif
                              362 ; 15   |
                              363 ; 16   |//////////////////////////////////////////////////////////////////////////////////
                              364 ; 17   |// Uncomment next define to allow player boot if you have stfm1000 macro enabled (defaults ON) & 
                              365 ; 18   |// your board crystal is not able to output nominal voltage range. Used in player main.asm. STMP00012148
                              366 ; 19   |// Defining this will result in lower battery life (price of using a lower quality crystal). 
                              367 ; 20   |// Those that want to save battery life and have good crystals that meet our HW team's specs can 
                              368 ; 21   |// comment out this line to reduce crystal bias current and so battery current in player mode.  
                              369 ; 22   |#define SUPPORT_MARGINAL_XTALS 1
                              370 ; 23   |
                              371 ; 24   |/////////////////////////////////////////////////////////////////////////////////
                              372 ; 25   |// BOOT SPEED CONFIG & ASSOCIATED BATTERY VOLTAGE CHECK ENABLE
                              373 ; 26   |/////////////////////////////////////////////////////////////////////////////////
                              374 ; 27   |// Users can enable one of ATTEMPT_FAST_BOOT or FASTEST boot or neither project define below by defining
                              375 ; 28   |// values as 0 or 1, else it defaults to the boot speed used in previous SDKs.
                              376 ; 29   |#define ATTEMPT_FAST_BOOT 1
                              377 ; 30   |#define ATTEMPT_FASTEST_BOOT 0   
                              378 ; 31   |// Changing this define to 0 removes Vbat threshholding & unconditionally gives fast boot config above- 
                              379 ; 32   |// disabling this check is suggested for profiling if you want to try to tweak down threshholds by maybe 50mV.
                              380 ; 33   |// Also the tests should clear the fast boot config defines to link & boot at normal speed.
                              381 ; 34   |#define SPEED_BOOT_BATTERY_CHECK 1
                              382 ; 35   |
                              383 ; 36   |/////////////////////////////////////////////////////////////////////////////////
                              384 ; 37   |// MEDIA DEFINITIONS
                              385 ; 38   |/////////////////////////////////////////////////////////////////////////////////
                              386 ; 39   |
                              387 ; 40   |/////////////////////////////////////////////////////////////////////////////////
                              388 ; 41   |// MNAND - Number of chips forming the internal physical device (i.e. # of NANDs)
                              389 ; 42   |#if defined(NAND1)
                              390 ; 43   |#define SM_INTERNAL_CHIPS 1
                              391 ; 44   |#else 
                              392 ; 45   |#if defined(NAND2)
                              393 ; 46   |#define SM_INTERNAL_CHIPS 2
                              394 ; 47   |#else 
                              395 ; 48   |#if defined(NAND3)
                              396 ; 49   |#define SM_INTERNAL_CHIPS 3
                              397 ; 50   |#else 
                              398 ; 51   |#if defined(NAND4)
                              399 ; 52   |#define SM_INTERNAL_CHIPS 4
                              400 ; 53   |#else 
                              401 ; 54   |#define SM_INTERNAL_CHIPS 1
                              402 ; 55   |#endif
                              403 ; 56   |#endif
                              404 ; 57   |#endif
                              405 ; 58   |#endif
                              406 ; 59   |
                              407 ; 60   |/////////////////////////////////////////////////////////////////////////////////
                              408 ; 61   |// If SMARTMEDIA_DETECT_ACTIVE_HIGH is defined:
                              409 ; 62   |//   SmartMedia will be detected as inserted if the GPIO pin reads 1 and removed if it reads 0.  
                              410 ; 63   |// If SMARTMEDIA_DETECT_ACTIVE_HIGH is not defined ** comment out next line **
                              411 ; 64   |//   SmartMedia will be detected as inserted if the GPIO pin reads 0 and removed if it reads 1.
                              412 ; 65   |//*** comment out if active high ****
                              413 ; 66   |//SMARTMEDIA_DETECT_ACTIVE_HIGH  equ     1
                              414 ; 67   |
                              415 ; 68   |#if defined(SMEDIA)
                              416 ; 69   |#define NUM_REMOVABLE_MEDIA 1
                              417 ; 70   |#define NUM_SM_EXTERNAL 1
                              418 ; 71   |#define MMC_MAX_PHYSICAL_DEVICES 0
                              419 ; 72   |#define SM_MAX_LOGICAL_DEVICES 2
                              420 ; 73   |#else 
                              421 ; 74   |#if defined(MMC)
                              422 ; 75   |#define NUM_REMOVABLE_MEDIA 1
                              423 ; 76   |#define NUM_SM_EXTERNAL 0
                              424 ; 77   |#define MMC_MAX_PHYSICAL_DEVICES 1
                              425 ; 78   |#define SM_MAX_LOGICAL_DEVICES 1
                              426 ; 79   |#else 
                              427 ; 80   |#define NUM_REMOVABLE_MEDIA 0
                              428 ; 81   |#define NUM_SM_EXTERNAL 0
                              429 ; 82   |#define MMC_MAX_PHYSICAL_DEVICES 0
                              430 ; 83   |#define SM_MAX_LOGICAL_DEVICES 1
                              431 ; 84   |#endif
                              432 ; 85   |#endif
                              433 ; 86   |
                              434 ; 87   |/////////////////////////////////////////////////////////////////////////////////
                              435 ; 88   |// Mass Storage Class definitions
                              436 ; 89   |/////////////////////////////////////////////////////////////////////////////////
                              437 ; 90   |// Set to 0 if Composite Device build is desired.    
                              438 ; 91   |#define MULTI_LUN_BUILD 1   
                              439 ; 92   |
                              440 ; 93   |////////////////////////////////////////////////////////////////////////////////
                              441 ; 94   |//  SCSI
                              442 ; 95   |#if (MULTI_LUN_BUILD==0)
                              443 ; 96   |  #if (NUM_REMOVABLE_MEDIA == 1)
                              444 ; 97   |    #define SCSI_NUM_TARGETS                        2
                              445 ; 98   |    #define SCSI_DEVICE_NUM_LUNS_DEV_0              1
                              446 ; 99   |    #define SCSI_DEVICE_NUM_LUNS_DEV_1              1
                              447 ; 100  |  #else
                              448 ; 101  |    #define SCSI_NUM_TARGETS                        1
                              449 ; 102  |    #define SCSI_DEVICE_NUM_LUNS_DEV_0              1
                              450 ; 103  |  #endif
                              451 ; 104  |#else
                              452 ; 105  |    #define SCSI_NUM_TARGETS                        1
                              453 ; 106  |  #if (NUM_REMOVABLE_MEDIA == 1)
                              454 ; 107  |    #define SCSI_DEVICE_NUM_LUNS_DEV_0              2
                              455 ; 108  |  #else
                              456 ; 109  |    #define SCSI_DEVICE_NUM_LUNS_DEV_0              1  
                              457 ; 110  |  #endif
                              458 ; 111  |#endif
                              459 ; 112  |
                              460 ; 113  |
                              461 ; 114  |#define USBMSC_NUM_DEVICES                      SCSI_NUM_TARGETS
                              462 ; 115  |
                              463 ; 116  |
                              464 ; 117  |////////////////////////////////////////////////////////////////////////////////
                              465 ; 118  |// Define number of logical medias and drives for three builds (MTP, USBMSC, and Player)
                              466 ; 119  |////////////////////////////////////////////////////////////////////////////////
                              467 ; 120  |#ifdef MMC
                              468 ; 121  |#ifdef MTP_BUILD
                              469 ; 122  |// --------------------
                              470 ; 123  |// MTP and MMC
                              471 ; 124  |// --------------------
                              472 ; 125  |#define NUM_LOGICAL_MEDIA       2
                              473 ; 126  |#define NUM_LOGICAL_DRIVES      8
                              474 ; 127  |#else  // ifndef MTP_BUILD
                              475 ; 128  |#ifdef STMP_BUILD_PLAYER
                              476 ; 129  |// --------------------
                              477 ; 130  |// Player and MMC
                              478 ; 131  |// --------------------
                              479 ; 132  |#else
                              480 ; 133  |// --------------------
                              481 ; 134  |// USBMSC and MMC
                              482 ; 135  |// --------------------
                              483 ; 136  |#define NUM_LOGICAL_MEDIA       3
                              484 ; 137  |#define NUM_LOGICAL_DRIVES      8
                              485 ; 138  |#endif // ifdef STMP_BUILD_PLAYER
                              486 ; 139  |#endif // ifdef MTP_BUILD
                              487 ; 140  |#else  // ifndef MMC
                              488 ; 141  |#ifdef MTP_BUILD
                              489 ; 142  |// --------------------
                              490 ; 143  |// MTP and NAND only
                              491 ; 144  |// --------------------
                              492 ; 145  |#define NUM_LOGICAL_MEDIA       1
                              493 ; 146  |#define NUM_LOGICAL_DRIVES      7
                              494 ; 147  |#else  // ifndef MTP_BUILD
                              495 ; 148  |#ifdef STMP_BUILD_PLAYER
                              496 ; 149  |// --------------------
                              497 ; 150  |// Player and NAND only
                              498 ; 151  |// --------------------
                              499 ; 152  |#else
                              500 ; 153  |// --------------------
                              501 ; 154  |// USBMSC and NAND only
                              502 ; 155  |// --------------------
                              503 ; 156  |#define NUM_LOGICAL_MEDIA       2
                              504 ; 157  |#define NUM_LOGICAL_DRIVES      7
                              505 ; 158  |#endif // ifdef STMP_BUILD_PLAYER
                              506 ; 159  |#endif // ifdef MTP_BUILD
                              507 ; 160  |#endif // ifdef MMC 
                              508 ; 161  |
                              509 ; 162  |// If we are in an MTP build then we don't use as many transfers buffers.
                              510 ; 163  |#if (defined(MTP_BUILD))
                              511 ; 164  |#define MAX_USB_TRANSFERS_QUEUED 16
                              512 ; 165  |
                              513 ; 166  |////!
TASKING DSP2410 assembler v1.5r1 Build 138 SN 00100122
                                                                                                                                                                                                                                                       Page   3

M:ADDR CODE           CYCLES LINE SOURCELINE
                              514 ; 167  |////! This varible holds the watchdog count for the store flush.
                              515 ; 168  |////!
                              516 ; 169  |///
                              517 ; 170  |#include <types.h>
                              518 ; 171  |extern volatile INT g_StoreWatchDogCount;
                              519 ; 172  |extern const INT g_StoreWatchDogTimeout;
                              520 ; 173  |#endif
                              521 ; 174  |
                              522 ; 175  |////////////////////////////////////////////////////////////////////////////////
                              523 ; 176  |// These are needed here for Mass Storage Class
                              524 ; 177  |// Needs to be cleaned up
                              525 ; 178  |////////////////////////////////////////////////////////////////////////////////
                              526 ; 179  |#if (!defined(STMP_BUILD_PLAYER))
                              527 ; 180  |#define SCRATCH_USER_Y_SIZE 512
                              528 ; 181  |#define SCRATCH_USER_X_SIZE 512
                              529 ; 182  |
                              530 ; 183  |#define BROWNOUT_LEVEL1_DETECTED                0x000001
                              531 ; 184  |
                              532 ; 185  |#endif
                              533 ; 186  |
                              534 ; 187  |
                              535 ; 188  |/////////////////////////////////////////////////////////////////////////////////
                              536 ; 189  |// SmartMedia/NAND defs
                              537 ; 190  |#define SM_MAX_PHYSICAL_DEVICES SM_INTERNAL_CHIPS+NUM_SM_EXTERNAL
                              538 ; 191  |#define SM_REMOVABLE_DEVICE_NUM SM_INTERNAL_CHIPS
                              539 ; 192  |
                              540 ; 193  |/////////////////////////////////////////////////////////////////////////////////
                              541 ; 194  |// Sysloadresources defs
                              542 ; 195  |#define SM_MAX_RESOURCE_DEVICES SM_INTERNAL_CHIPS+NUM_SM_EXTERNAL
                              543 ; 196  |
                              544 ; 197  |/////////////////////////////////////////////////////////////////////////////////
                              545 ; 198  |// MMC defs
                              546 ; 199  |#define MMC_MAX_PARTITIONS 1
                              547 ; 200  |#define MMC_MAX_LOGICAL_DEVICES MMC_MAX_PHYSICAL_DEVICES*MMC_MAX_PARTITIONS
                              548 ; 201  |
                              549 ; 202  |/////////////////////////////////////////////////////////////////////////////////
                              550 ; 203  |// SPI defs
                              551 ; 204  |#define SPI_MAX_DEVICES MMC_MAX_PHYSICAL_DEVICES
                              552 ; 205  |
                              553 ; 206  |/////////////////////////////////////////////////////////////////////////////////
                              554 ; 207  |// Global media defs
                              555 ; 208  |#define MAX_PHYSICAL_DEVICES SM_MAX_PHYSICAL_DEVICES+MMC_MAX_PHYSICAL_DEVICES
                              556 ; 209  |#define MAX_LOGICAL_DEVICES SM_MAX_LOGICAL_DEVICES+MMC_MAX_LOGICAL_DEVICES
                              557 ; 210  |
                              558 ; 211  |/////////////////////////////////////////////////////////////////////////////////
                              559 ; 212  |// DO NOT CHANGE THESE!!!
                              560 ; 213  |#define SM_MAX_PARTITIONS 4
                              561 ; 214  |#define MAX_HANDLES 2
                              562 ; 215  |/////////////////////////////////////////////////////////////////////////////////
                              563 ; 216  |
                              564 ; 217  |
                              565 ; 218  |/////////////////////////////////////////////////////////////////////////////////
                              566 ; 219  |// Battery LRADC Values 
                              567 ; 220  |/////////////////////////////////////////////////////////////////////////////////
                              568 ; 221  |// brownout trip point in mV (moved by RS)
                              569 ; 222  |// BATT_SAFETY_MARGIN:  percentage value used by:
                              570 ; 223  |//   * SysSaveSettings to determine if enough power is left to attempt a settings save. 
                              571 ; 224  |//   * Recorder to conditionally prevent the start or continuation of 
                              572 ; 225  |//     audio recording to media.
                              573 ; 226  |#define BATT_SAFETY_MARGIN 10
                              574 ; 227  |
                              575 ; 228  |//; player resource drive refresh allowed only when battery usable % is above this value. 
                              576 ; 229  |//; 50% of usable range [0.9V to 1.5V] is around 1.2V This is the safe target alkaline voltage to do a refresh.
                              577 ; 230  |//; LIION will also require 50% which will work but that could be changed in the future. 
                              578 ; 231  |//RESOURCE_REFRESH_MIN_BATT_PCT equ 50
                              579 ; 232  |
                              580 ; 233  |// stmp00005071 adds these for mp3 encode stability at low battery per battery type & mmc presence.
                              581 ; 234  |
                              582 ; 235  |//// Vbat threshholds empirically tuned by profiling max bat current for 3 HW cases: 
                              583 ; 236  |//// 1 GigaByte MMC, NAND flash only, & LiIon Buck mode. See voicemenu pre-encode Vbat check.
                              584 ; 237  |#if (!defined(CLCD))
                              585 ; 238  |#define MP3_ENC_MMC_MIN_V_BAT_MV 1100
                              586 ; 239  |#define MP3_ENC_NANDONLY_MIN_V_BAT_MV 1000
                              587 ; 240  |#else 
                              588 ; 241  |#define MP3_ENC_MMC_MIN_V_BAT_MV 1250
                              589 ; 242  |#define MP3_ENC_NANDONLY_MIN_V_BAT_MV 1150
                              590 ; 243  |#endif
                              591 ; 244  |#define MP3_ENC_BUCKMODE_MIN_V_BAT_MV 3300
                              592 ; 245  |
                              593 ; 246  |// These Vbat use-range-percentages are derived to correspond with target battery 
                              594 ; 247  |// voltages of 1.10V for MMC, 1.0V for nand only (alkaline or nimh), and 3.3V for any LiIon.
                              595 ; 248  |// See mp3 encoder overlay.
                              596 ; 249  |#define MP3_ENC_MMC_MIN_V_BAT_RANGE_PCT 33
                              597 ; 250  |#define MP3_ENC_NANDONLY_MIN_V_BAT_RANGE_PCT 17
                              598 ; 251  |#define MP3_ENC_BUCKMODE_MIN_V_BAT_RANGE_PCT 25
                              599 ; 252  |
                              600 ; 253  |/////////////////////////////////////////////////////////////////////////////////
                              601 ; 254  |// Voice recording filenames
                              602 ; 255  |// number of digits in filename Vxxx.wav
                              603 ; 256  |/////////////////////////////////////////////////////////////////////////////////
                              604 ; 257  |#define DIGITS_IN_VOICE_FILENAME 3   
                              605 ; 258  |
                              606 ; 259  |/////////////////////////////////////////////////////////////////////////////////
                              607 ; 260  |// Mic Bias: Set this enable to 1 to internally generate mic bias voltage. 
                              608 ; 261  |// Also below, must configure internal resistor value and pin to use for DC bias. 
                              609 ; 262  |// Can set to 0 to disable internally generated mic bias voltage at pin lradc1/2.
                              610 ; 263  |#if defined(DEVICE_3500)
                              611 ; 264  |#define ENABLE_INTERNALLY_GENERATED_MICBIAS 1 
                              612 ; 265  |// MIC BIAS circuit source selection: use Low Resolution ADC pin 2 or 1 to bias mic. 
                              613 ; 266  |// Per your layout: select LRADC 2 or 1 below 
                              614 ; 267  |//   (pin LRADC 2 for 35xx cpu card revB, LRADC 1 for 35xx cpu card revC, ref schematics, & demo player)
                              615 ; 268  |#define LRADC_NUM_FOR_MIC_BIAS 1 
                              616 ; 269  |// Sets internal mic bias R to value 2, 4, or 8 (in kOhms).
                              617 ; 270  |#define MICBIAS_CONFIGURED_RESISTOR_KOHMS 8
                              618 ; 271  |
                              619 ; 272  |// Allows mic bias to settle before sampling. This delay currently unused. For rec btn when bias not yet ready.
                              620 ; 273  |#define REC_BTN_INTERNAL_MIC_BIAS_SETTLING_DELAY_MS 400 
                              621 ; 274  |// Option always keeps bias enabled after mainmenu init. This allows for start pop prevention if you use rec button from outside voice menu.
                              622 ; 275  |// This selection costs 1 mWatt but gains the desired low record button to sampling latency in the record-from-music-menu use-case.
                              623 ; 276  |#define KEEP_MIC_BIAS_ENABLED 0
                              624 ; 277  |
                              625 ; 278  |#else 
                              626 ; 279  |// STMP3410
                              627 ; 280  |#define ENABLE_INTERNALLY_GENERATED_MICBIAS 0
                              628 ; 281  |#define LRADC_NUM_FOR_MIC_BIAS 1 
                              629 ; 282  |#define MICBIAS_CONFIGURED_RESISTOR_KOHMS 2
                              630 ; 283  |#endif
                              631 ; 284  |
                              632 ; 285  |/////////////////////////////////////////////////////////////////////////////////
                              633 ; 286  |// Number of available soft timers
                              634 ; 287  |/////////////////////////////////////////////////////////////////////////////////
                              635 ; 288  |#if defined(SYNC_LYRICS)
                              636 ; 289  |#define SOFT_TIMERS 10
                              637 ; 290  |#else 
                              638 ; 291  |#if defined(JPEG_DECODER)
                              639 ; 292  |#define SOFT_TIMERS 10
                              640 ; 293  |#else 
                              641 ; 294  |#define SOFT_TIMERS 9
                              642 ; 295  |#endif
                              643 ; 296  |#endif
                              644 ; 297  |
                              645 ; 298  |/////////////////////////////////////////////////////////////////////////////////
                              646 ; 299  |//  sizes
                              647 ; 300  |/////////////////////////////////////////////////////////////////////////////////
                              648 ; 301  |#if defined(MMC)
                              649 ; 302  |#if defined(USE_PLAYLIST5)
                              650 ; 303  |#define MENU_STACK_SIZE 1500
                              651 ; 304  |#else 
                              652 ; 305  |#define MENU_STACK_SIZE 1250
                              653 ; 306  |#endif //if @def('USE_PLAYLIST5')
                              654 ; 307  |#else 
                              655 ; 308  |#if defined(USE_PLAYLIST5)
                              656 ; 309  |#define MENU_STACK_SIZE 1500
                              657 ; 310  |#else 
                              658 ; 311  |#define MENU_STACK_SIZE 1250
                              659 ; 312  |#endif //if @def('USE_PLAYLIST5')
                              660 ; 313  |#endif //if @def('MMC')
                              661 ; 314  |
                              662 ; 315  |// NOTE: SDK2.6 USED 550 FOR NEXT LINE, BUT SDK3.0BETA USED 750. Should it be ifdef MTP 750 else 550 for other builds? TOVERIFY. MYALLOC
                              663 ; 316  |// 
                              664 ; 317  |#define STACK_L1_SIZE 750
                              665 ; 318  |#define STACK_L2_SIZE 100
                              666 ; 319  |#define STACK_L3_SIZE 160
                              667 ; 320  |
                              668 ; 321  |// If we are in MTP mode the overlay task stack can shrink.
                              669 ; 322  |// TODO shrink this stack for MTP, I will leave it at 500 until we verify that it 
                              670 ; 323  |// is ok with switching code.
                              671 ; 324  |#if defined(MTP_BUILD)
                              672 ; 325  |#define OVERLAY_MANAGER_STACK_SIZE 300
                              673 ; 326  |#endif
                              674 ; 327  |
                              675 ; 328  |/////////////////////////////////////////////////////////////////////////////////
                              676 ; 329  |// maximum number of nested funclets 
                              677 ; 330  |/////////////////////////////////////////////////////////////////////////////////
                              678 ; 331  |#define MAX_NESTED_FUNCLET 6 
                              679 ; 332  |
                              680 ; 333  |/////////////////////////////////////////////////////////////////////////////////
                              681 ; 334  |//    LCD DEFINITIONS
                              682 ; 335  |/////////////////////////////////////////////////////////////////////////////////
                              683 ; 336  |
                              684 ; 337  |#define SPACE_CHAR 0x000020          
                              685 ; 338  |#define ZERO_CHAR 0x000030
                              686 ; 339  |#define COLON_CHAR 0x00003A
                              687 ; 340  |#define PERIOD_CHAR 0x00002E
                              688 ; 341  |
                              689 ; 342  |#if (defined(S6B33B0A_LCD))
                              690 ; 343  |#define LCD_X_SIZE 128
                              691 ; 344  |#define LCD_Y_SIZE 159
                              692 ; 345  |#endif
                              693 ; 346  |
                              694 ; 347  |#if (defined(SED15XX_LCD))
                              695 ; 348  |#define LCD_X_SIZE 128
                              696 ; 349  |#define LCD_Y_SIZE 64
                              697 ; 350  |#endif
                              698 ; 351  |
                              699 ; 352  |
                              700 ; 353  |//////////////////////////////////////////////////////////////////////////////////
                              701 ; 354  |//   Details on Customizing Contrast
                              702 ; 355  |/////////////////////////////////////////////////////////////////////////////////
                              703 ; 356  |//   Max supported LCD range is 0 - 3F; however due to hardware/voltage differences
                              704 ; 357  |//   the range of visibility is usually smaller than this.  It is important to 
                              705 ; 358  |//   calibrate the visible range, because the contrast setting is saved.
                              706 ; 359  |//   If the user shuts off the player while lcd is not visible, the player is useless
                              707 ; 360  |//   unless the ezact sequence is remembered.
                              708 ; 361  |//   To find out what range your player supports: 
                              709 ; 362  |//   change these equs to full range or comment out (full range is default)
                              710 ; 363  |//;;;;;;
                              711 ; 364  |// uncomment the line below to build code that will provide raw contrast value
                              712 ; 365  |// recommended calibration using player -- uncomment 
                              713 ; 366  |//;;;;;;
                              714 ; 367  |//CONTRAST_CALIBRATION    equ  1
                              715 ; 368  |////////////////////////////
                              716 ; 369  |#if (defined(DEMO_HW))
                              717 ; 370  |// this is the setting for ET301 demos; Next 2 line have not been updated for new Shingyi LCD (June6'05)
                              718 ; 371  |#define LCD_MAX_CONTRAST 0x32 
                              719 ; 372  |#define LCD_MIN_CONTRAST 0x1E
                              720 ; 373  |#else 
                              721 ; 374  |
                              722 ; 375  |#if (defined(S6B33B0A_LCD))
                              723 ; 376  |#define LCD_MAX_CONTRAST 210
                              724 ; 377  |#define LCD_MIN_CONTRAST 160    
                              725 ; 378  |#endif
                              726 ; 379  |
                              727 ; 380  |#if (defined(SED15XX_LCD))
                              728 ; 381  |// Next 3 line comment was for OLD shingyi LCD: (default LCD before sdk2.6)
                              729 ; 382  |// Engineering board regs support range [17-37].
                              730 ; 383  |//   Engineering board DC/DC support range [24-46]. 
                              731 ; 384  |//   One default contrast range [24-42] works for both.
                              732 ; 385  |// The 3 sets of contrast ranges below are updated for SDK2.6 to support either 
                              733 ; 386  |// new or old ShingYih LCDs. "File" refers to \resource\shingyih\system_lcd_init_seq.src
                              734 ; 387  |// 3/10/05 - Use one of the 2 next contrast ranges depending on which
                              735 ; 388  |// ShingYih LCD you have.  See \resources\shingyi\readme.txt 
                              736 ; 389  |// Optimal for NEW LCD with NEW file (SDK2.6 default)  
                              737 ; 390  |// G098064-41 LCD module (present on engr board revH LCD card)
                              738 ; 391  |
                              739 ; 392  |#if (defined(NEWSHINGYIH))
                              740 ; 393  |#define LCD_MAX_CONTRAST 250
                              741 ; 394  |#define LCD_MIN_CONTRAST 0
                              742 ; 395  |#else 
                              743 ; 396  |//-----
                              744 ; 397  |// Near optimal for OLD LCD with NEW file. 
                              745 ; 398  |// NOT optimal for the new lcd but pretty good. So u may use this if u want 1 build for both LCDs.
                              746 ; 399  |#define LCD_MAX_CONTRAST 250
                              747 ; 400  |#define LCD_MIN_CONTRAST 0
                              748 ; 401  |
                              749 ; 402  |//=====
                              750 ; 403  |// Optimal for OLD ShingYih LCD with OLD file (as sdk2.521)
                              751 ; 404  |// Suggest going with default new init file & values above for your LCD instead of this historic ver.
                              752 ; 405  |//LCD_MAX_CONTRAST equ 42
                              753 ; 406  |//LCD_MIN_CONTRAST equ 24 
                              754 ; 407  |
                              755 ; 408  |#endif
                              756 ; 409  |#endif
                              757 ; 410  |
                              758 ; 411  |#endif
                              759 ; 412  |
                              760 ; 413  |//////////////////////////////////////////////////////////////////////////////////
                              761 ; 414  |// The default value of the lcd contrast in % of range
                              762 ; 415  |//   the default value is used when no settings.dat is available
                              763 ; 416  |//////////////////////////////////////////////////////////////////////////////////
                              764 ; 417  |
TASKING DSP2410 assembler v1.5r1 Build 138 SN 00100122
                                                                                                                                                                                                                                                       Page   4

M:ADDR CODE           CYCLES LINE SOURCELINE
                              765 ; 418  |#if (defined(S6B33B0A_LCD))
                              766 ; 419  |// 60% of range is default value
                              767 ; 420  |#define DEFAULT_CONTRAST 50 
                              768 ; 421  |#endif
                              769 ; 422  |
                              770 ; 423  |#if (defined(SED15XX_LCD))
                              771 ; 424  |// % of range is default value (was 60%)
                              772 ; 425  |#define DEFAULT_CONTRAST 50 
                              773 ; 426  |#endif
                              774 ; 427  |
                              775 ; 428  |
                              776 ; 429  |// percentage change per increment/decrement message (LCD_DEC_CONTRAST/LCD_INC_CONTRAST)
                              777 ; 430  |// make lower when doing calibration
                              778 ; 431  |#define LCD_STEPSIZE_CONTRAST 10  
                              779 ; 432  |
                              780 ; 433  |
                              781 ; 434  |/////////////////////////////////////////////////////////////////////////////////
                              782 ; 435  |// For FFWD and RWND
                              783 ; 436  |/////////////////////////////////////////////////////////////////////////////////
                              784 ; 437  |#define SECONDS_TO_SKIP 1
                              785 ; 438  |#define SECONDS_TO_SKIP1 3
                              786 ; 439  |#define SECONDS_TO_SKIP2 6
                              787 ; 440  |// number of seconds to cause reset to begin of song for PREV push
                              788 ; 441  |#define PREV_SONG_THRESHOLD 5  
                              789 ; 442  |// number of 300 mSec periods before the numbers of seconds to skip increases
                              790 ; 443  |#define FIRST_TIME_BOUNDARY 15 
                              791 ; 444  |// number of 300 mSec periods before the numbers of seconds to skip increases
                              792 ; 445  |#define SECOND_TIME_BOUNDARY 30 
                              793 ; 446  |
                              794 ; 447  |// For audible FFW/RWD
                              795 ; 448  |#define SECONDS_TO_SKIP_FOR_3X_RATE 1
                              796 ; 449  |#define SECONDS_TO_SKIP_FOR_60X_RATE 18
                              797 ; 450  |#define SECONDS_TO_SKIP_FOR_600X_RATE 180
                              798 ; 451  |#define SECONDS_TO_SKIP_FOR_1800X_RATE 540
                              799 ; 452  |// number of 300 mSec periods before the numbers of seconds to skip increases
                              800 ; 453  |#define LEVEL1_BOUNDARY 17 
                              801 ; 454  |// number of 300 mSec periods before the numbers of seconds to skip increases
                              802 ; 455  |#define LEVEL2_BOUNDARY 33 
                              803 ; 456  |// number of 300 mSec periods before the numbers of seconds to skip increases
                              804 ; 457  |#define LEVEL3_BOUNDARY 50 
                              805 ; 458  |// Stmp00010296 Ticket #71685:  for song shorter than the min. skip size
                              806 ; 459  |// if song_time < skip_size, bCurrentSongShort=>TRUE (ignore FWD/RWD commands)
                              807 ; 460  |// Short Song Time, songs too short to play.
                              808 ; 461  |#define SHORT_SONG_TIME SECONDS_TO_SKIP         
                              809 ; 462  |
                              810 ; 463  |/////////////////////////////////////////////////////////////////////////////////
                              811 ; 464  |// MP3 Sync Values
                              812 ; 465  |/////////////////////////////////////////////////////////////////////////////////
                              813 ; 466  |// # bytes to look for sync before marking it bad
                              814 ; 467  |#define MP3_SYNC_THRESHOLD 70000 
                              815 ; 468  |// # bytes to look for sync before slowing decoder isr frequency (to let menus run)
                              816 ; 469  |#define MP3_SYNC_THRESHOLD1 10000 
                              817 ; 470  |// once we have sync'd, the isr should be called this frequently
                              818 ; 471  |#define MP3_DECODERISR_FAST 7500  
                              819 ; 472  |// if decoder is having difficulty syncing, switch isr to be called less frequently
                              820 ; 473  |#define MP3_DECODERISR_SLOW 50000 
                              821 ; 474  |
                              822 ; 475  |
                              823 ; 476  |/////////////////////////////////////////////////////////////////////////////////
                              824 ; 477  |//// Multi-Stage Volume Control Definitions
                              825 ; 478  |/////////////////////////////////////////////////////////////////////////////////
                              826 ; 479  |//// Use Multi-Stage Volume
                              827 ; 480  |#define MULTI_STAGE_VOLUME 0x1                  
                              828 ; 481  |
                              829 ; 482  |//// Master Volume definitions
                              830 ; 483  |#define MIX_MSTR_MAX_VOL 0x0
                              831 ; 484  |#define NUM_MSTR_ATT_STEPS (0x1F-MIX_MSTR_MAX_VOL)
                              832 ; 485  |
                              833 ; 486  |//// DAC-Mode definitions
                              834 ; 487  |//// Adjusts 0dB point
                              835 ; 488  |#define MIX_DAC_NOM_VOL 0x6                  
                              836 ; 489  |#define MIX_DAC_MIN_VOL 0x1F
                              837 ; 490  |// For minimum clipping: Set MIX_DAC_MAX_VOL below to match MIX_DAC_NOM_VOL value 2 lines above.
                              838 ; 491  |// For additional gain (with possible clipping): Set MIX_DAC_MAX_VOL in range below. 
                              839 ; 492  |//                                               Each integer below MIX_DAC_NOM_VOL provides 1.5 dB gain on Stmp34x0; 
                              840 ; 493  |//                                               Max gain possible: 8 step diff would provide +12dB gain.   
                              841 ; 494  |// range: [0 to MIX_DAC_NOM_VOL] (0 for loudest volume)
                              842 ; 495  |#define MIX_DAC_MAX_VOL 0x0  
                              843 ; 496  |
                              844 ; 497  |#define NUM_DAC_ATT_STEPS (MIX_DAC_MIN_VOL-MIX_DAC_NOM_VOL+1)
                              845 ; 498  |#define NUM_DAC_GAIN_STEPS (MIX_DAC_NOM_VOL-MIX_DAC_MAX_VOL)
                              846 ; 499  |#define NUM_DAC_MODE_VOL_STEPS (NUM_DAC_ATT_STEPS+NUM_MSTR_ATT_STEPS+NUM_DAC_GAIN_STEPS+1)
                              847 ; 500  |
                              848 ; 501  |//// If there is no stored volume, set to 50% of DAC-Mode max; change if DAC Mode is not the default
                              849 ; 502  |//// STMP35xx has 2dB attenuation per step so default needs a few more steps above midpoint.
                              850 ; 503  |#define DEFAULT_VOLUME ((NUM_DAC_MODE_VOL_STEPS/2)+6)         
                              851 ; 504  |
                              852 ; 505  |//// Set maximum restored volume to 75% of DAC-Mode max; change if DAC Mode is not the default
                              853 ; 506  |#define MAX_RESTORED_VOLUME ((3*NUM_DAC_MODE_VOL_STEPS)/4)   
                              854 ; 507  |
                              855 ; 508  |
                              856 ; 509  |//// Line In definitions (used for Line-In 1)
                              857 ; 510  |//// 0dB point of the Line In
                              858 ; 511  |#define MIX_LINE_NOM_VOL 0x8                  
                              859 ; 512  |//// Minimum volume of Line In
                              860 ; 513  |#define MIX_LINE_MIN_VOL 0x1F                 
                              861 ; 514  |//// Maximum volume of Line In (can adjust extra gain)
                              862 ; 515  |#define MIX_LINE_MAX_VOL 0x6                  
                              863 ; 516  |#define NUM_LINE_ATT_STEPS (MIX_LINE_MIN_VOL-MIX_LINE_NOM_VOL+1)
                              864 ; 517  |#define NUM_LINE_GAIN_STEPS (MIX_LINE_NOM_VOL-MIX_LINE_MAX_VOL)
                              865 ; 518  |#define NUM_LINE_MODE_VOL_STEPS (NUM_LINE_ATT_STEPS+NUM_MSTR_ATT_STEPS+NUM_LINE_GAIN_STEPS+1)
                              866 ; 519  |
                              867 ; 520  |//// Line In definitions (used for FM tuner with 144 pin package)
                              868 ; 521  |//// 0dB point of the Line In
                              869 ; 522  |#define MIX_FM_NOM_VOL 0x8                  
                              870 ; 523  |//// Minimum volume of Line In
                              871 ; 524  |#define MIX_FM_MIN_VOL 0x1F                 
                              872 ; 525  |//// Maximum volume of Line In (can adjust extra gain)
                              873 ; 526  |#define MIX_FM_MAX_VOL 0x6                  
                              874 ; 527  |#define NUM_FM_ATT_STEPS (MIX_FM_MIN_VOL-MIX_FM_NOM_VOL+1)
                              875 ; 528  |#define NUM_FM_GAIN_STEPS (MIX_FM_NOM_VOL-MIX_FM_MAX_VOL)
                              876 ; 529  |#define NUM_FM_MODE_VOL_STEPS (NUM_FM_ATT_STEPS+NUM_MSTR_ATT_STEPS+NUM_FM_GAIN_STEPS+1)
                              877 ; 530  |
                              878 ; 531  |/////////////////////////////////////////////////////////////////////////////////
                              879 ; 532  |//// When enabled (1), periodically checks for one of several FM state machine invalid deadlock states & recovers. 
                              880 ; 533  |//// Define as 0 to disable FM-deadlock-state checking and recovery.
                              881 ; 534  |#define FM_WATCHDOG_ENABLE 1
                              882 ; 535  |
                              883 ; 536  |#if !defined(STMP_BUILD_PLAYER)
                              884 ; 537  |////
                              885 ; 538  |////! This varible holds the lcd display state for the mtp project.
                              886 ; 539  |////
                              887 ; 540  |///
                              888 ; 541  |#include <types.h>
                              889 
                              891 
                              892 ; 1    |////////////////////////////////////////////////////////////////////////////////
                              893 ; 2    |// Copyright(C) SigmaTel, Inc. 2000-2004
                              894 ; 3    |//
                              895 ; 4    |// Filename: types.h
                              896 ; 5    |// Description: Standard data types
                              897 ; 6    |////////////////////////////////////////////////////////////////////////////////
                              898 ; 7    |
                              899 ; 8    |#ifndef _TYPES_H
                              900 ; 9    |#define _TYPES_H
                              901 ; 10   |
                              902 ; 11   |// TODO:  move this outta here!
                              903 ; 12   |#if !defined(NOERROR)
                              904 ; 13   |#define NOERROR 0
                              905 ; 14   |#define SUCCESS 0
                              906 ; 15   |#endif 
                              907 ; 16   |#if !defined(SUCCESS)
                              908 ; 17   |#define SUCCESS  0
                              909 ; 18   |#endif
                              910 ; 19   |#if !defined(ERROR)
                              911 ; 20   |#define ERROR   -1
                              912 ; 21   |#endif
                              913 ; 22   |#if !defined(FALSE)
                              914 ; 23   |#define FALSE 0
                              915 ; 24   |#endif
                              916 ; 25   |#if !defined(TRUE)
                              917 ; 26   |#define TRUE  1
                              918 ; 27   |#endif
                              919 ; 28   |
                              920 ; 29   |#if !defined(NULL)
                              921 ; 30   |#define NULL 0
                              922 ; 31   |#endif
                              923 ; 32   |
                              924 ; 33   |#define MAX_INT     0x7FFFFF
                              925 ; 34   |#define MAX_LONG    0x7FFFFFffffff
                              926 ; 35   |        // max positive unsigned long value: -1 == 0xFFFFFFffffff
                              927 ; 36   |#define MAX_ULONG   (-1) 
                              928 ; 37   |
                              929 ; 38   |#define WORD_SIZE   24              // word size in bits
                              930 ; 39   |#define BYTES_PER_WORD 3            // 8 bit bytes
                              931 ; 40   |
                              932 ; 41   |
                              933 ; 42   |#define BYTE    unsigned char       // btVarName
                              934 ; 43   |#define CHAR    signed char         // cVarName
                              935 ; 44   |#define USHORT  unsigned short      // usVarName
                              936 ; 45   |#define SHORT   unsigned short      // sVarName
                              937 ; 46   |#define WORD    unsigned int        // wVarName
                              938 ; 47   |#define INT     signed int          // iVarName
                              939 ; 48   |#define DWORD   unsigned long       // dwVarName
                              940 ; 49   |#define LONG    signed long         // lVarName
                              941 ; 50   |#define BOOL    unsigned int        // bVarName
                              942 ; 51   |#define FRACT   _fract              // frVarName
                              943 ; 52   |#define LFRACT  long _fract         // lfrVarName
                              944 ; 53   |#define CIRC    _circ               // cp<type prefix>VarName (see below)
                              945 ; 54   |#define FLOAT   float               // fVarName
                              946 ; 55   |#define DBL     double              // dVarName
                              947 ; 56   |#define ENUM    enum                // eVarName
                              948 ; 57   |#define CMX     _complex            // cmxVarName
                              949 ; 58   |typedef WORD UCS3;                   // 
                              950 ; 59   |
                              951 ; 60   |#define UINT16  unsigned short
                              952 ; 61   |#define UINT8   unsigned char   
                              953 ; 62   |#define UINT32  unsigned long
                              954 ; 63   |#define UINT64  unsigned long   // need to figure out how to do 64 bit values.  Or port exisiting code to only use 48 bit
                              955 ; 64   |#define INT64   unsigned long   // need to figure out how to do 64 bit values.  Or port exisiting code to only use 48 bit
                              956 ; 65   |#define WCHAR   UINT16
                              957 ; 66   |
                              958 ; 67   |//UINT128 is 16 bytes or 6 words
                              959 ; 68   |typedef struct UINT128_3500 {   
                              960 ; 69   |    int val[6];     
                              961 ; 70   |} UINT128_3500;
                              962 ; 71   |
                              963 ; 72   |#define UINT128   UINT128_3500
                              964 ; 73   |
                              965 ; 74   |// Little endian word packed byte strings:   
                              966 ; 75   |//      _packed BYTE bTextVarName[]="a string";  bText is a packed byte string prefix
                              967 ; 76   |// Convert to big endian words by reordering bytes from high to low using swizzle.
                              968 ; 77   |// Little endian word packed byte strings:   
                              969 ; 78   |//      _packed BYTE bTextVarName[]="a string";  bText is a packed byte string prefix
                              970 ; 79   |// Convert to big endian words by reordering bytes from high to low using swizzle.
                              971 ; 80   |
                              972 ; 81   |// Declare Memory Spaces To Use When Coding
                              973 ; 82   |// A. Sector Buffers
                              974 ; 83   |#define SECTOR_BUFFER_MEM_X _X
                              975 ; 84   |#define SECTOR_BUFFER_MEM_Y _Y
                              976 ; 85   |#define SECTOR_BUFFER_MEM SECTOR_BUFFER_MEM_X
                              977 ; 86   |typedef WORD SECTOR_BUFFER_MEM SECTOR_BUFFER;
                              978 ; 87   |typedef SECTOR_BUFFER * P_SECTOR_BUFFER;
                              979 ; 88   |// B. Media DDI Memory
                              980 ; 89   |#define MEDIA_DDI_MEM _Y
                              981 ; 90   |
                              982 ; 91   |
                              983 ; 92   |
                              984 ; 93   |// Pointers to linear structures are labeled as: p<type prefix>VarName
                              985 ; 94   |// Examples of circular pointers:
                              986 ; 95   |//    INT CIRC cpiVarName
                              987 ; 96   |//    DWORD CIRC cpdwVarName
                              988 ; 97   |
                              989 ; 98   |#define RETCODE INT                 // rcVarName
                              990 ; 99   |
                              991 ; 100  |// generic bitfield structure
                              992 ; 101  |struct Bitfield {
                              993 ; 102  |    unsigned int B0  :1;
                              994 ; 103  |    unsigned int B1  :1;
                              995 ; 104  |    unsigned int B2  :1;
                              996 ; 105  |    unsigned int B3  :1;
                              997 ; 106  |    unsigned int B4  :1;
                              998 ; 107  |    unsigned int B5  :1;
                              999 ; 108  |    unsigned int B6  :1;
                             1000 ; 109  |    unsigned int B7  :1;
                             1001 ; 110  |    unsigned int B8  :1;
                             1002 ; 111  |    unsigned int B9  :1;
                             1003 ; 112  |    unsigned int B10 :1;
                             1004 ; 113  |    unsigned int B11 :1;
                             1005 ; 114  |    unsigned int B12 :1;
                             1006 ; 115  |    unsigned int B13 :1;
                             1007 ; 116  |    unsigned int B14 :1;
                             1008 ; 117  |    unsigned int B15 :1;
                             1009 ; 118  |    unsigned int B16 :1;
                             1010 ; 119  |    unsigned int B17 :1;
                             1011 ; 120  |    unsigned int B18 :1;
                             1012 ; 121  |    unsigned int B19 :1;
                             1013 ; 122  |    unsigned int B20 :1;
                             1014 ; 123  |    unsigned int B21 :1;
                             1015 ; 124  |    unsigned int B22 :1;
                             1016 ; 125  |    unsigned int B23 :1;
TASKING DSP2410 assembler v1.5r1 Build 138 SN 00100122
                                                                                                                                                                                                                                                       Page   5

M:ADDR CODE           CYCLES LINE SOURCELINE
                             1017 ; 126  |};
                             1018 ; 127  |
                             1019 ; 128  |union BitInt {
                             1020 ; 129  |        struct Bitfield B;
                             1021 ; 130  |        int        I;
                             1022 ; 131  |};
                             1023 ; 132  |
                             1024 ; 133  |#define MAX_MSG_LENGTH 10
                             1025 ; 134  |struct CMessage
                             1026 ; 135  |{
                             1027 ; 136  |        unsigned int m_uLength;
                             1028 ; 137  |        unsigned int m_uMsg[MAX_MSG_LENGTH];
                             1029 ; 138  |};
                             1030 ; 139  |
                             1031 ; 140  |typedef struct {
                             1032 ; 141  |    WORD m_wLength;
                             1033 ; 142  |    WORD m_wMessage;
                             1034 ; 143  |    WORD m_wParams[MAX_MSG_LENGTH];
                             1035 ; 144  |} Message;
                             1036 ; 145  |
                             1037 ; 146  |struct MessageQueueDescriptor
                             1038 ; 147  |{
                             1039 ; 148  |        int *m_pBase;
                             1040 ; 149  |        int m_iModulo;
                             1041 ; 150  |        int m_iSize;
                             1042 ; 151  |        int *m_pHead;
                             1043 ; 152  |        int *m_pTail;
                             1044 ; 153  |};
                             1045 ; 154  |
                             1046 ; 155  |struct ModuleEntry
                             1047 ; 156  |{
                             1048 ; 157  |    int m_iSignaledEventMask;
                             1049 ; 158  |    int m_iWaitEventMask;
                             1050 ; 159  |    int m_iResourceOfCode;
                             1051 ; 160  |    struct MessageQueueDescriptor *m_pMessageQueue;
                             1052 ; 161  |    int _asmfunc (*m_pProcessEntryPoint)(union WaitMask Signals,struct MessageQueueDescriptor *);
                             1053 ; 162  |    int _asmfunc (*m_pInitFunction)(struct MessageQueueDescriptor *);
                             1054 ; 163  |    int m_uTimeOutHigh;
                             1055 ; 164  |    int m_uTimeOutLow;
                             1056 ; 165  |    int _asmfunc (*m_pBackgroundFunction)(struct MessageQueueDescriptor *);
                             1057 ; 166  |};
                             1058 ; 167  |
                             1059 ; 168  |union WaitMask{
                             1060 ; 169  |    struct B{
                             1061 ; 170  |        unsigned int m_bNone     :1;
                             1062 ; 171  |        unsigned int m_bMessage  :1;
                             1063 ; 172  |        unsigned int m_bTimer    :1;
                             1064 ; 173  |        unsigned int m_bButton   :1;
                             1065 ; 174  |    } B;
                             1066 ; 175  |    int I;
                             1067 ; 176  |} ;
                             1068 ; 177  |
                             1069 ; 178  |
                             1070 ; 179  |struct Button {
                             1071 ; 180  |        WORD wButtonEvent;
                             1072 ; 181  |        WORD wUnused[MAX_MSG_LENGTH];   
                             1073 ; 182  |};
                             1074 ; 183  |
                             1075 ; 184  |struct Message {
                             1076 ; 185  |        WORD wMsgLength;
                             1077 ; 186  |        WORD wMsgCommand;
                             1078 ; 187  |        WORD wMsgParms[MAX_MSG_LENGTH-1];
                             1079 ; 188  |};
                             1080 ; 189  |
                             1081 ; 190  |union EventTypes {
                             1082 ; 191  |        struct CMessage msg;
                             1083 ; 192  |        struct Button Button ;
                             1084 ; 193  |        struct Message Message;
                             1085 ; 194  |};
                             1086 ; 195  |
                             1087 ; 196  |// next 2 used to get updater build to return correct protocol ver in scsi response.
                             1088 ; 197  |#define BUILD_TYPE_UPDATER  0x100
                             1089 ; 198  |#define BUILD_TYPE_HOSTLINK 0x101
                             1090 ; 199  |#define BUILD_TYPE_PLAYER   0x102
                             1091 ; 200  |
                             1092 ; 201  |// Resets part if RETAIL build. DEBUG build executes debug instruction to halt.
                             1093 ; 202  |#define SystemHalt() __asm(" include 'sysmacro.asm' \n error") 
                             1094 ; 203  |#define assert(x)    if(!(x)) __asm(" include 'sysmacro.asm' \n error")
                             1095 ; 204  |
                             1096 ; 205  |#if DEBUG
                             1097 ; 206  |// For DEBUG builds, DebugBuildAssert(condition) halts if condition evaluates to FALSE. 
                             1098 ; 207  |#define DebugBuildAssert(x)    if(!(x)) __asm(" debug ")
                             1099 ; 208  |#else 
                             1100 ; 209  |// For RETAIL builds, DebugBuildAssert(condition) does nothing & execution continues rather than halt or reset. 
                             1101 ; 210  |#define DebugBuildAssert(x)    
                             1102 ; 211  |#endif
                             1103 ; 212  |
                             1104 ; 213  |// Do this in your C files to make a reminder that's displayed during the build.
                             1105 ; 214  |//  #pragma asm
                             1106 ; 215  |//  WARN 'Note to builder: reminder to do this after verifying that'
                             1107 ; 216  |//  #pragma endasm
                             1108 ; 217  |
                             1109 ; 218  |
                             1110 ; 219  |#ifdef COLOR_262K
                             1111 ; 220  |#define RGB(r,g,b)    ((0x0000FC & (r)) << 10) | ((0x0000FC & (g)) << 4) | ((0x0000FC & (b)) >> 2)    //262k
                             1112 ; 221  |#elif defined(COLOR_65K)
                             1113 ; 222  |#define RGB(r,g,b)    ((0x0000F8 & (r)) << 8) | ((0x0000FC & (g)) << 3) | ((0x0000F8 & (b)) >> 3)  //65k
                             1114 ; 223  |#else
                             1115 ; 224  |#define RGB(r,g,b)       ((0x0000F0 & (r)) << 4) | (0x0000F0 & (g)) | ((0x0000F0 & (b)) >> 4)
                             1116 ; 225  |#endif
                             1117 ; 226  |    
                             1118 ; 227  |#endif // #ifndef _TYPES_H
                             1119 
                             1121 
                             1122 ; 542  |extern volatile WORD g_wActivityState;
                             1123 ; 543  |#endif // if !@def('STMP_BUILD_PLAYER')
                             1124 ; 544  |
                             1125 ; 545  |void _reentrant Init5VSense(void);
                             1126 ; 546  |void _reentrant ServiceDCDC(void);
                             1127 ; 547  |
                             1128 ; 548  |////////////////////////////////////////////////////////////////////////////
                             1129 ; 549  |//// JPEG Thumbnail Mode Setting
                             1130 ; 550  |//// number of column in thumbnail mode
                             1131 ; 551  |#define THUMBNAIL_X 2           
                             1132 ; 552  |//// number of row in  thumbnail mode
                             1133 ; 553  |#define THUMBNAIL_Y 2           
                             1134 ; 554  |//// thumbnail boundary offset x
                             1135 ; 555  |#define THUMBNAIL_X_OFFSET 4            
                             1136 ; 556  |//// thumbnail boundary offset y
                             1137 ; 557  |#define THUMBNAIL_Y_OFFSET 4            
                             1138 ; 558  |
                             1139 ; 559  |#endif // if (!@def(_PROJECT_INC))
                             1140 ; 560  |
                             1141 
                             1143 
                             1144 ; 18   |#include "usb_api.h"
                             1145 
                             1147 
                             1148 ; 1    |////////////////////////////////////////////////////////////////////////////////
                             1149 ; 2    |// Copyright(C) SigmaTel, Inc. 2002 - 2003
                             1150 ; 3    |//
                             1151 ; 4    |// File : USB_API.H
                             1152 ; 5    |// Description : USB_API.H defines and structures definition for USB device
                             1153 ; 6    |//               driver API.
                             1154 ; 7    |//               This 
                             1155 ; 8    |////////////////////////////////////////////////////////////////////////////////
                             1156 ; 9    |
                             1157 ; 10   |#ifndef __usb_api_h__
                             1158 ; 11   |#define __usb_api_h__ 1
                             1159 ; 12   |
                             1160 ; 13   |#include "types.h"
                             1161 
                             1163 
                             1164 ; 1    |////////////////////////////////////////////////////////////////////////////////
                             1165 ; 2    |// Copyright(C) SigmaTel, Inc. 2000-2004
                             1166 ; 3    |//
                             1167 ; 4    |// Filename: types.h
                             1168 ; 5    |// Description: Standard data types
                             1169 ; 6    |////////////////////////////////////////////////////////////////////////////////
                             1170 ; 7    |
                             1171 ; 8    |#ifndef _TYPES_H
                             1172 ; 9    |#define _TYPES_H
                             1173 ; 10   |
                             1174 ; 11   |// TODO:  move this outta here!
                             1175 ; 12   |#if !defined(NOERROR)
                             1176 ; 13   |#define NOERROR 0
                             1177 ; 14   |#define SUCCESS 0
                             1178 ; 15   |#endif 
                             1179 ; 16   |#if !defined(SUCCESS)
                             1180 ; 17   |#define SUCCESS  0
                             1181 ; 18   |#endif
                             1182 ; 19   |#if !defined(ERROR)
                             1183 ; 20   |#define ERROR   -1
                             1184 ; 21   |#endif
                             1185 ; 22   |#if !defined(FALSE)
                             1186 ; 23   |#define FALSE 0
                             1187 ; 24   |#endif
                             1188 ; 25   |#if !defined(TRUE)
                             1189 ; 26   |#define TRUE  1
                             1190 ; 27   |#endif
                             1191 ; 28   |
                             1192 ; 29   |#if !defined(NULL)
                             1193 ; 30   |#define NULL 0
                             1194 ; 31   |#endif
                             1195 ; 32   |
                             1196 ; 33   |#define MAX_INT     0x7FFFFF
                             1197 ; 34   |#define MAX_LONG    0x7FFFFFffffff
                             1198 ; 35   |        // max positive unsigned long value: -1 == 0xFFFFFFffffff
                             1199 ; 36   |#define MAX_ULONG   (-1) 
                             1200 ; 37   |
                             1201 ; 38   |#define WORD_SIZE   24              // word size in bits
                             1202 ; 39   |#define BYTES_PER_WORD 3            // 8 bit bytes
                             1203 ; 40   |
                             1204 ; 41   |
                             1205 ; 42   |#define BYTE    unsigned char       // btVarName
                             1206 ; 43   |#define CHAR    signed char         // cVarName
                             1207 ; 44   |#define USHORT  unsigned short      // usVarName
                             1208 ; 45   |#define SHORT   unsigned short      // sVarName
                             1209 ; 46   |#define WORD    unsigned int        // wVarName
                             1210 ; 47   |#define INT     signed int          // iVarName
                             1211 ; 48   |#define DWORD   unsigned long       // dwVarName
                             1212 ; 49   |#define LONG    signed long         // lVarName
                             1213 ; 50   |#define BOOL    unsigned int        // bVarName
                             1214 ; 51   |#define FRACT   _fract              // frVarName
                             1215 ; 52   |#define LFRACT  long _fract         // lfrVarName
                             1216 ; 53   |#define CIRC    _circ               // cp<type prefix>VarName (see below)
                             1217 ; 54   |#define FLOAT   float               // fVarName
                             1218 ; 55   |#define DBL     double              // dVarName
                             1219 ; 56   |#define ENUM    enum                // eVarName
                             1220 ; 57   |#define CMX     _complex            // cmxVarName
                             1221 ; 58   |typedef WORD UCS3;                   // 
                             1222 ; 59   |
                             1223 ; 60   |#define UINT16  unsigned short
                             1224 ; 61   |#define UINT8   unsigned char   
                             1225 ; 62   |#define UINT32  unsigned long
                             1226 ; 63   |#define UINT64  unsigned long   // need to figure out how to do 64 bit values.  Or port exisiting code to only use 48 bit
                             1227 ; 64   |#define INT64   unsigned long   // need to figure out how to do 64 bit values.  Or port exisiting code to only use 48 bit
                             1228 ; 65   |#define WCHAR   UINT16
                             1229 ; 66   |
                             1230 ; 67   |//UINT128 is 16 bytes or 6 words
                             1231 ; 68   |typedef struct UINT128_3500 {   
                             1232 ; 69   |    int val[6];     
                             1233 ; 70   |} UINT128_3500;
                             1234 ; 71   |
                             1235 ; 72   |#define UINT128   UINT128_3500
                             1236 ; 73   |
                             1237 ; 74   |// Little endian word packed byte strings:   
                             1238 ; 75   |//      _packed BYTE bTextVarName[]="a string";  bText is a packed byte string prefix
                             1239 ; 76   |// Convert to big endian words by reordering bytes from high to low using swizzle.
                             1240 ; 77   |// Little endian word packed byte strings:   
                             1241 ; 78   |//      _packed BYTE bTextVarName[]="a string";  bText is a packed byte string prefix
                             1242 ; 79   |// Convert to big endian words by reordering bytes from high to low using swizzle.
                             1243 ; 80   |
                             1244 ; 81   |// Declare Memory Spaces To Use When Coding
                             1245 ; 82   |// A. Sector Buffers
                             1246 ; 83   |#define SECTOR_BUFFER_MEM_X _X
                             1247 ; 84   |#define SECTOR_BUFFER_MEM_Y _Y
                             1248 ; 85   |#define SECTOR_BUFFER_MEM SECTOR_BUFFER_MEM_X
                             1249 ; 86   |typedef WORD SECTOR_BUFFER_MEM SECTOR_BUFFER;
                             1250 ; 87   |typedef SECTOR_BUFFER * P_SECTOR_BUFFER;
                             1251 ; 88   |// B. Media DDI Memory
                             1252 ; 89   |#define MEDIA_DDI_MEM _Y
                             1253 ; 90   |
                             1254 ; 91   |
                             1255 ; 92   |
                             1256 ; 93   |// Pointers to linear structures are labeled as: p<type prefix>VarName
                             1257 ; 94   |// Examples of circular pointers:
                             1258 ; 95   |//    INT CIRC cpiVarName
                             1259 ; 96   |//    DWORD CIRC cpdwVarName
                             1260 ; 97   |
                             1261 ; 98   |#define RETCODE INT                 // rcVarName
                             1262 ; 99   |
                             1263 ; 100  |// generic bitfield structure
                             1264 ; 101  |struct Bitfield {
                             1265 ; 102  |    unsigned int B0  :1;
                             1266 ; 103  |    unsigned int B1  :1;
                             1267 ; 104  |    unsigned int B2  :1;
                             1268 ; 105  |    unsigned int B3  :1;
                             1269 ; 106  |    unsigned int B4  :1;
                             1270 ; 107  |    unsigned int B5  :1;
                             1271 ; 108  |    unsigned int B6  :1;
TASKING DSP2410 assembler v1.5r1 Build 138 SN 00100122
                                                                                                                                                                                                                                                       Page   6

M:ADDR CODE           CYCLES LINE SOURCELINE
                             1272 ; 109  |    unsigned int B7  :1;
                             1273 ; 110  |    unsigned int B8  :1;
                             1274 ; 111  |    unsigned int B9  :1;
                             1275 ; 112  |    unsigned int B10 :1;
                             1276 ; 113  |    unsigned int B11 :1;
                             1277 ; 114  |    unsigned int B12 :1;
                             1278 ; 115  |    unsigned int B13 :1;
                             1279 ; 116  |    unsigned int B14 :1;
                             1280 ; 117  |    unsigned int B15 :1;
                             1281 ; 118  |    unsigned int B16 :1;
                             1282 ; 119  |    unsigned int B17 :1;
                             1283 ; 120  |    unsigned int B18 :1;
                             1284 ; 121  |    unsigned int B19 :1;
                             1285 ; 122  |    unsigned int B20 :1;
                             1286 ; 123  |    unsigned int B21 :1;
                             1287 ; 124  |    unsigned int B22 :1;
                             1288 ; 125  |    unsigned int B23 :1;
                             1289 ; 126  |};
                             1290 ; 127  |
                             1291 ; 128  |union BitInt {
                             1292 ; 129  |        struct Bitfield B;
                             1293 ; 130  |        int        I;
                             1294 ; 131  |};
                             1295 ; 132  |
                             1296 ; 133  |#define MAX_MSG_LENGTH 10
                             1297 ; 134  |struct CMessage
                             1298 ; 135  |{
                             1299 ; 136  |        unsigned int m_uLength;
                             1300 ; 137  |        unsigned int m_uMsg[MAX_MSG_LENGTH];
                             1301 ; 138  |};
                             1302 ; 139  |
                             1303 ; 140  |typedef struct {
                             1304 ; 141  |    WORD m_wLength;
                             1305 ; 142  |    WORD m_wMessage;
                             1306 ; 143  |    WORD m_wParams[MAX_MSG_LENGTH];
                             1307 ; 144  |} Message;
                             1308 ; 145  |
                             1309 ; 146  |struct MessageQueueDescriptor
                             1310 ; 147  |{
                             1311 ; 148  |        int *m_pBase;
                             1312 ; 149  |        int m_iModulo;
                             1313 ; 150  |        int m_iSize;
                             1314 ; 151  |        int *m_pHead;
                             1315 ; 152  |        int *m_pTail;
                             1316 ; 153  |};
                             1317 ; 154  |
                             1318 ; 155  |struct ModuleEntry
                             1319 ; 156  |{
                             1320 ; 157  |    int m_iSignaledEventMask;
                             1321 ; 158  |    int m_iWaitEventMask;
                             1322 ; 159  |    int m_iResourceOfCode;
                             1323 ; 160  |    struct MessageQueueDescriptor *m_pMessageQueue;
                             1324 ; 161  |    int _asmfunc (*m_pProcessEntryPoint)(union WaitMask Signals,struct MessageQueueDescriptor *);
                             1325 ; 162  |    int _asmfunc (*m_pInitFunction)(struct MessageQueueDescriptor *);
                             1326 ; 163  |    int m_uTimeOutHigh;
                             1327 ; 164  |    int m_uTimeOutLow;
                             1328 ; 165  |    int _asmfunc (*m_pBackgroundFunction)(struct MessageQueueDescriptor *);
                             1329 ; 166  |};
                             1330 ; 167  |
                             1331 ; 168  |union WaitMask{
                             1332 ; 169  |    struct B{
                             1333 ; 170  |        unsigned int m_bNone     :1;
                             1334 ; 171  |        unsigned int m_bMessage  :1;
                             1335 ; 172  |        unsigned int m_bTimer    :1;
                             1336 ; 173  |        unsigned int m_bButton   :1;
                             1337 ; 174  |    } B;
                             1338 ; 175  |    int I;
                             1339 ; 176  |} ;
                             1340 ; 177  |
                             1341 ; 178  |
                             1342 ; 179  |struct Button {
                             1343 ; 180  |        WORD wButtonEvent;
                             1344 ; 181  |        WORD wUnused[MAX_MSG_LENGTH];   
                             1345 ; 182  |};
                             1346 ; 183  |
                             1347 ; 184  |struct Message {
                             1348 ; 185  |        WORD wMsgLength;
                             1349 ; 186  |        WORD wMsgCommand;
                             1350 ; 187  |        WORD wMsgParms[MAX_MSG_LENGTH-1];
                             1351 ; 188  |};
                             1352 ; 189  |
                             1353 ; 190  |union EventTypes {
                             1354 ; 191  |        struct CMessage msg;
                             1355 ; 192  |        struct Button Button ;
                             1356 ; 193  |        struct Message Message;
                             1357 ; 194  |};
                             1358 ; 195  |
                             1359 ; 196  |// next 2 used to get updater build to return correct protocol ver in scsi response.
                             1360 ; 197  |#define BUILD_TYPE_UPDATER  0x100
                             1361 ; 198  |#define BUILD_TYPE_HOSTLINK 0x101
                             1362 ; 199  |#define BUILD_TYPE_PLAYER   0x102
                             1363 ; 200  |
                             1364 ; 201  |// Resets part if RETAIL build. DEBUG build executes debug instruction to halt.
                             1365 ; 202  |#define SystemHalt() __asm(" include 'sysmacro.asm' \n error") 
                             1366 ; 203  |#define assert(x)    if(!(x)) __asm(" include 'sysmacro.asm' \n error")
                             1367 ; 204  |
                             1368 ; 205  |#if DEBUG
                             1369 ; 206  |// For DEBUG builds, DebugBuildAssert(condition) halts if condition evaluates to FALSE. 
                             1370 ; 207  |#define DebugBuildAssert(x)    if(!(x)) __asm(" debug ")
                             1371 ; 208  |#else 
                             1372 ; 209  |// For RETAIL builds, DebugBuildAssert(condition) does nothing & execution continues rather than halt or reset. 
                             1373 ; 210  |#define DebugBuildAssert(x)    
                             1374 ; 211  |#endif
                             1375 ; 212  |
                             1376 ; 213  |// Do this in your C files to make a reminder that's displayed during the build.
                             1377 ; 214  |//  #pragma asm
                             1378 ; 215  |//  WARN 'Note to builder: reminder to do this after verifying that'
                             1379 ; 216  |//  #pragma endasm
                             1380 ; 217  |
                             1381 ; 218  |
                             1382 ; 219  |#ifdef COLOR_262K
                             1383 ; 220  |#define RGB(r,g,b)    ((0x0000FC & (r)) << 10) | ((0x0000FC & (g)) << 4) | ((0x0000FC & (b)) >> 2)    //262k
                             1384 ; 221  |#elif defined(COLOR_65K)
                             1385 ; 222  |#define RGB(r,g,b)    ((0x0000F8 & (r)) << 8) | ((0x0000FC & (g)) << 3) | ((0x0000F8 & (b)) >> 3)  //65k
                             1386 ; 223  |#else
                             1387 ; 224  |#define RGB(r,g,b)       ((0x0000F0 & (r)) << 4) | (0x0000F0 & (g)) | ((0x0000F0 & (b)) >> 4)
                             1388 ; 225  |#endif
                             1389 ; 226  |    
                             1390 ; 227  |#endif // #ifndef _TYPES_H
                             1391 
                             1393 
                             1394 ; 14   |#include "project.h"
                             1395 
                             1397 
                             1398 ; 1    |/////////////////////////////////////////////////////////////////////////////////
                             1399 ; 2    |//  Copyright(C) SigmaTel, Inc. 2000-2004
                             1400 ; 3    |//  Filename: project.inc
                             1401 ; 4    |//  Description: 
                             1402 ; 5    |/////////////////////////////////////////////////////////////////////////////////
                             1403 ; 6    |
                             1404 ; 7    |#if (!defined(_PROJECT_INC))
                             1405 ; 8    |#define _PROJECT_INC 1
                             1406 ; 9    |
                             1407 ; 10   |#if defined(STMP_BUILD_PLAYER)
                             1408 ; 11   |#include "hwequ.h"
                             1409 ; 12   |#else 
                             1410 ; 13   |//include "regscodec.inc"
                             1411 ; 14   |#endif
                             1412 ; 15   |
                             1413 ; 16   |//////////////////////////////////////////////////////////////////////////////////
                             1414 ; 17   |// Uncomment next define to allow player boot if you have stfm1000 macro enabled (defaults ON) & 
                             1415 ; 18   |// your board crystal is not able to output nominal voltage range. Used in player main.asm. STMP00012148
                             1416 ; 19   |// Defining this will result in lower battery life (price of using a lower quality crystal). 
                             1417 ; 20   |// Those that want to save battery life and have good crystals that meet our HW team's specs can 
                             1418 ; 21   |// comment out this line to reduce crystal bias current and so battery current in player mode.  
                             1419 ; 22   |#define SUPPORT_MARGINAL_XTALS 1
                             1420 ; 23   |
                             1421 ; 24   |/////////////////////////////////////////////////////////////////////////////////
                             1422 ; 25   |// BOOT SPEED CONFIG & ASSOCIATED BATTERY VOLTAGE CHECK ENABLE
                             1423 ; 26   |/////////////////////////////////////////////////////////////////////////////////
                             1424 ; 27   |// Users can enable one of ATTEMPT_FAST_BOOT or FASTEST boot or neither project define below by defining
                             1425 ; 28   |// values as 0 or 1, else it defaults to the boot speed used in previous SDKs.
                             1426 ; 29   |#define ATTEMPT_FAST_BOOT 1
                             1427 ; 30   |#define ATTEMPT_FASTEST_BOOT 0   
                             1428 ; 31   |// Changing this define to 0 removes Vbat threshholding & unconditionally gives fast boot config above- 
                             1429 ; 32   |// disabling this check is suggested for profiling if you want to try to tweak down threshholds by maybe 50mV.
                             1430 ; 33   |// Also the tests should clear the fast boot config defines to link & boot at normal speed.
                             1431 ; 34   |#define SPEED_BOOT_BATTERY_CHECK 1
                             1432 ; 35   |
                             1433 ; 36   |/////////////////////////////////////////////////////////////////////////////////
                             1434 ; 37   |// MEDIA DEFINITIONS
                             1435 ; 38   |/////////////////////////////////////////////////////////////////////////////////
                             1436 ; 39   |
                             1437 ; 40   |/////////////////////////////////////////////////////////////////////////////////
                             1438 ; 41   |// MNAND - Number of chips forming the internal physical device (i.e. # of NANDs)
                             1439 ; 42   |#if defined(NAND1)
                             1440 ; 43   |#define SM_INTERNAL_CHIPS 1
                             1441 ; 44   |#else 
                             1442 ; 45   |#if defined(NAND2)
                             1443 ; 46   |#define SM_INTERNAL_CHIPS 2
                             1444 ; 47   |#else 
                             1445 ; 48   |#if defined(NAND3)
                             1446 ; 49   |#define SM_INTERNAL_CHIPS 3
                             1447 ; 50   |#else 
                             1448 ; 51   |#if defined(NAND4)
                             1449 ; 52   |#define SM_INTERNAL_CHIPS 4
                             1450 ; 53   |#else 
                             1451 ; 54   |#define SM_INTERNAL_CHIPS 1
                             1452 ; 55   |#endif
                             1453 ; 56   |#endif
                             1454 ; 57   |#endif
                             1455 ; 58   |#endif
                             1456 ; 59   |
                             1457 ; 60   |/////////////////////////////////////////////////////////////////////////////////
                             1458 ; 61   |// If SMARTMEDIA_DETECT_ACTIVE_HIGH is defined:
                             1459 ; 62   |//   SmartMedia will be detected as inserted if the GPIO pin reads 1 and removed if it reads 0.  
                             1460 ; 63   |// If SMARTMEDIA_DETECT_ACTIVE_HIGH is not defined ** comment out next line **
                             1461 ; 64   |//   SmartMedia will be detected as inserted if the GPIO pin reads 0 and removed if it reads 1.
                             1462 ; 65   |//*** comment out if active high ****
                             1463 ; 66   |//SMARTMEDIA_DETECT_ACTIVE_HIGH  equ     1
                             1464 ; 67   |
                             1465 ; 68   |#if defined(SMEDIA)
                             1466 ; 69   |#define NUM_REMOVABLE_MEDIA 1
                             1467 ; 70   |#define NUM_SM_EXTERNAL 1
                             1468 ; 71   |#define MMC_MAX_PHYSICAL_DEVICES 0
                             1469 ; 72   |#define SM_MAX_LOGICAL_DEVICES 2
                             1470 ; 73   |#else 
                             1471 ; 74   |#if defined(MMC)
                             1472 ; 75   |#define NUM_REMOVABLE_MEDIA 1
                             1473 ; 76   |#define NUM_SM_EXTERNAL 0
                             1474 ; 77   |#define MMC_MAX_PHYSICAL_DEVICES 1
                             1475 ; 78   |#define SM_MAX_LOGICAL_DEVICES 1
                             1476 ; 79   |#else 
                             1477 ; 80   |#define NUM_REMOVABLE_MEDIA 0
                             1478 ; 81   |#define NUM_SM_EXTERNAL 0
                             1479 ; 82   |#define MMC_MAX_PHYSICAL_DEVICES 0
                             1480 ; 83   |#define SM_MAX_LOGICAL_DEVICES 1
                             1481 ; 84   |#endif
                             1482 ; 85   |#endif
                             1483 ; 86   |
                             1484 ; 87   |/////////////////////////////////////////////////////////////////////////////////
                             1485 ; 88   |// Mass Storage Class definitions
                             1486 ; 89   |/////////////////////////////////////////////////////////////////////////////////
                             1487 ; 90   |// Set to 0 if Composite Device build is desired.    
                             1488 ; 91   |#define MULTI_LUN_BUILD 1   
                             1489 ; 92   |
                             1490 ; 93   |////////////////////////////////////////////////////////////////////////////////
                             1491 ; 94   |//  SCSI
                             1492 ; 95   |#if (MULTI_LUN_BUILD==0)
                             1493 ; 96   |  #if (NUM_REMOVABLE_MEDIA == 1)
                             1494 ; 97   |    #define SCSI_NUM_TARGETS                        2
                             1495 ; 98   |    #define SCSI_DEVICE_NUM_LUNS_DEV_0              1
                             1496 ; 99   |    #define SCSI_DEVICE_NUM_LUNS_DEV_1              1
                             1497 ; 100  |  #else
                             1498 ; 101  |    #define SCSI_NUM_TARGETS                        1
                             1499 ; 102  |    #define SCSI_DEVICE_NUM_LUNS_DEV_0              1
                             1500 ; 103  |  #endif
                             1501 ; 104  |#else
                             1502 ; 105  |    #define SCSI_NUM_TARGETS                        1
                             1503 ; 106  |  #if (NUM_REMOVABLE_MEDIA == 1)
                             1504 ; 107  |    #define SCSI_DEVICE_NUM_LUNS_DEV_0              2
                             1505 ; 108  |  #else
                             1506 ; 109  |    #define SCSI_DEVICE_NUM_LUNS_DEV_0              1  
                             1507 ; 110  |  #endif
                             1508 ; 111  |#endif
                             1509 ; 112  |
                             1510 ; 113  |
                             1511 ; 114  |#define USBMSC_NUM_DEVICES                      SCSI_NUM_TARGETS
                             1512 ; 115  |
                             1513 ; 116  |
                             1514 ; 117  |////////////////////////////////////////////////////////////////////////////////
                             1515 ; 118  |// Define number of logical medias and drives for three builds (MTP, USBMSC, and Player)
                             1516 ; 119  |////////////////////////////////////////////////////////////////////////////////
                             1517 ; 120  |#ifdef MMC
                             1518 ; 121  |#ifdef MTP_BUILD
                             1519 ; 122  |// --------------------
                             1520 ; 123  |// MTP and MMC
                             1521 ; 124  |// --------------------
                             1522 ; 125  |#define NUM_LOGICAL_MEDIA       2
                             1523 ; 126  |#define NUM_LOGICAL_DRIVES      8
                             1524 ; 127  |#else  // ifndef MTP_BUILD
TASKING DSP2410 assembler v1.5r1 Build 138 SN 00100122
                                                                                                                                                                                                                                                       Page   7

M:ADDR CODE           CYCLES LINE SOURCELINE
                             1525 ; 128  |#ifdef STMP_BUILD_PLAYER
                             1526 ; 129  |// --------------------
                             1527 ; 130  |// Player and MMC
                             1528 ; 131  |// --------------------
                             1529 ; 132  |#else
                             1530 ; 133  |// --------------------
                             1531 ; 134  |// USBMSC and MMC
                             1532 ; 135  |// --------------------
                             1533 ; 136  |#define NUM_LOGICAL_MEDIA       3
                             1534 ; 137  |#define NUM_LOGICAL_DRIVES      8
                             1535 ; 138  |#endif // ifdef STMP_BUILD_PLAYER
                             1536 ; 139  |#endif // ifdef MTP_BUILD
                             1537 ; 140  |#else  // ifndef MMC
                             1538 ; 141  |#ifdef MTP_BUILD
                             1539 ; 142  |// --------------------
                             1540 ; 143  |// MTP and NAND only
                             1541 ; 144  |// --------------------
                             1542 ; 145  |#define NUM_LOGICAL_MEDIA       1
                             1543 ; 146  |#define NUM_LOGICAL_DRIVES      7
                             1544 ; 147  |#else  // ifndef MTP_BUILD
                             1545 ; 148  |#ifdef STMP_BUILD_PLAYER
                             1546 ; 149  |// --------------------
                             1547 ; 150  |// Player and NAND only
                             1548 ; 151  |// --------------------
                             1549 ; 152  |#else
                             1550 ; 153  |// --------------------
                             1551 ; 154  |// USBMSC and NAND only
                             1552 ; 155  |// --------------------
                             1553 ; 156  |#define NUM_LOGICAL_MEDIA       2
                             1554 ; 157  |#define NUM_LOGICAL_DRIVES      7
                             1555 ; 158  |#endif // ifdef STMP_BUILD_PLAYER
                             1556 ; 159  |#endif // ifdef MTP_BUILD
                             1557 ; 160  |#endif // ifdef MMC 
                             1558 ; 161  |
                             1559 ; 162  |// If we are in an MTP build then we don't use as many transfers buffers.
                             1560 ; 163  |#if (defined(MTP_BUILD))
                             1561 ; 164  |#define MAX_USB_TRANSFERS_QUEUED 16
                             1562 ; 165  |
                             1563 ; 166  |////!
                             1564 ; 167  |////! This varible holds the watchdog count for the store flush.
                             1565 ; 168  |////!
                             1566 ; 169  |///
                             1567 ; 170  |#include <types.h>
                             1568 ; 171  |extern volatile INT g_StoreWatchDogCount;
                             1569 ; 172  |extern const INT g_StoreWatchDogTimeout;
                             1570 ; 173  |#endif
                             1571 ; 174  |
                             1572 ; 175  |////////////////////////////////////////////////////////////////////////////////
                             1573 ; 176  |// These are needed here for Mass Storage Class
                             1574 ; 177  |// Needs to be cleaned up
                             1575 ; 178  |////////////////////////////////////////////////////////////////////////////////
                             1576 ; 179  |#if (!defined(STMP_BUILD_PLAYER))
                             1577 ; 180  |#define SCRATCH_USER_Y_SIZE 512
                             1578 ; 181  |#define SCRATCH_USER_X_SIZE 512
                             1579 ; 182  |
                             1580 ; 183  |#define BROWNOUT_LEVEL1_DETECTED                0x000001
                             1581 ; 184  |
                             1582 ; 185  |#endif
                             1583 ; 186  |
                             1584 ; 187  |
                             1585 ; 188  |/////////////////////////////////////////////////////////////////////////////////
                             1586 ; 189  |// SmartMedia/NAND defs
                             1587 ; 190  |#define SM_MAX_PHYSICAL_DEVICES SM_INTERNAL_CHIPS+NUM_SM_EXTERNAL
                             1588 ; 191  |#define SM_REMOVABLE_DEVICE_NUM SM_INTERNAL_CHIPS
                             1589 ; 192  |
                             1590 ; 193  |/////////////////////////////////////////////////////////////////////////////////
                             1591 ; 194  |// Sysloadresources defs
                             1592 ; 195  |#define SM_MAX_RESOURCE_DEVICES SM_INTERNAL_CHIPS+NUM_SM_EXTERNAL
                             1593 ; 196  |
                             1594 ; 197  |/////////////////////////////////////////////////////////////////////////////////
                             1595 ; 198  |// MMC defs
                             1596 ; 199  |#define MMC_MAX_PARTITIONS 1
                             1597 ; 200  |#define MMC_MAX_LOGICAL_DEVICES MMC_MAX_PHYSICAL_DEVICES*MMC_MAX_PARTITIONS
                             1598 ; 201  |
                             1599 ; 202  |/////////////////////////////////////////////////////////////////////////////////
                             1600 ; 203  |// SPI defs
                             1601 ; 204  |#define SPI_MAX_DEVICES MMC_MAX_PHYSICAL_DEVICES
                             1602 ; 205  |
                             1603 ; 206  |/////////////////////////////////////////////////////////////////////////////////
                             1604 ; 207  |// Global media defs
                             1605 ; 208  |#define MAX_PHYSICAL_DEVICES SM_MAX_PHYSICAL_DEVICES+MMC_MAX_PHYSICAL_DEVICES
                             1606 ; 209  |#define MAX_LOGICAL_DEVICES SM_MAX_LOGICAL_DEVICES+MMC_MAX_LOGICAL_DEVICES
                             1607 ; 210  |
                             1608 ; 211  |/////////////////////////////////////////////////////////////////////////////////
                             1609 ; 212  |// DO NOT CHANGE THESE!!!
                             1610 ; 213  |#define SM_MAX_PARTITIONS 4
                             1611 ; 214  |#define MAX_HANDLES 2
                             1612 ; 215  |/////////////////////////////////////////////////////////////////////////////////
                             1613 ; 216  |
                             1614 ; 217  |
                             1615 ; 218  |/////////////////////////////////////////////////////////////////////////////////
                             1616 ; 219  |// Battery LRADC Values 
                             1617 ; 220  |/////////////////////////////////////////////////////////////////////////////////
                             1618 ; 221  |// brownout trip point in mV (moved by RS)
                             1619 ; 222  |// BATT_SAFETY_MARGIN:  percentage value used by:
                             1620 ; 223  |//   * SysSaveSettings to determine if enough power is left to attempt a settings save. 
                             1621 ; 224  |//   * Recorder to conditionally prevent the start or continuation of 
                             1622 ; 225  |//     audio recording to media.
                             1623 ; 226  |#define BATT_SAFETY_MARGIN 10
                             1624 ; 227  |
                             1625 ; 228  |//; player resource drive refresh allowed only when battery usable % is above this value. 
                             1626 ; 229  |//; 50% of usable range [0.9V to 1.5V] is around 1.2V This is the safe target alkaline voltage to do a refresh.
                             1627 ; 230  |//; LIION will also require 50% which will work but that could be changed in the future. 
                             1628 ; 231  |//RESOURCE_REFRESH_MIN_BATT_PCT equ 50
                             1629 ; 232  |
                             1630 ; 233  |// stmp00005071 adds these for mp3 encode stability at low battery per battery type & mmc presence.
                             1631 ; 234  |
                             1632 ; 235  |//// Vbat threshholds empirically tuned by profiling max bat current for 3 HW cases: 
                             1633 ; 236  |//// 1 GigaByte MMC, NAND flash only, & LiIon Buck mode. See voicemenu pre-encode Vbat check.
                             1634 ; 237  |#if (!defined(CLCD))
                             1635 ; 238  |#define MP3_ENC_MMC_MIN_V_BAT_MV 1100
                             1636 ; 239  |#define MP3_ENC_NANDONLY_MIN_V_BAT_MV 1000
                             1637 ; 240  |#else 
                             1638 ; 241  |#define MP3_ENC_MMC_MIN_V_BAT_MV 1250
                             1639 ; 242  |#define MP3_ENC_NANDONLY_MIN_V_BAT_MV 1150
                             1640 ; 243  |#endif
                             1641 ; 244  |#define MP3_ENC_BUCKMODE_MIN_V_BAT_MV 3300
                             1642 ; 245  |
                             1643 ; 246  |// These Vbat use-range-percentages are derived to correspond with target battery 
                             1644 ; 247  |// voltages of 1.10V for MMC, 1.0V for nand only (alkaline or nimh), and 3.3V for any LiIon.
                             1645 ; 248  |// See mp3 encoder overlay.
                             1646 ; 249  |#define MP3_ENC_MMC_MIN_V_BAT_RANGE_PCT 33
                             1647 ; 250  |#define MP3_ENC_NANDONLY_MIN_V_BAT_RANGE_PCT 17
                             1648 ; 251  |#define MP3_ENC_BUCKMODE_MIN_V_BAT_RANGE_PCT 25
                             1649 ; 252  |
                             1650 ; 253  |/////////////////////////////////////////////////////////////////////////////////
                             1651 ; 254  |// Voice recording filenames
                             1652 ; 255  |// number of digits in filename Vxxx.wav
                             1653 ; 256  |/////////////////////////////////////////////////////////////////////////////////
                             1654 ; 257  |#define DIGITS_IN_VOICE_FILENAME 3   
                             1655 ; 258  |
                             1656 ; 259  |/////////////////////////////////////////////////////////////////////////////////
                             1657 ; 260  |// Mic Bias: Set this enable to 1 to internally generate mic bias voltage. 
                             1658 ; 261  |// Also below, must configure internal resistor value and pin to use for DC bias. 
                             1659 ; 262  |// Can set to 0 to disable internally generated mic bias voltage at pin lradc1/2.
                             1660 ; 263  |#if defined(DEVICE_3500)
                             1661 ; 264  |#define ENABLE_INTERNALLY_GENERATED_MICBIAS 1 
                             1662 ; 265  |// MIC BIAS circuit source selection: use Low Resolution ADC pin 2 or 1 to bias mic. 
                             1663 ; 266  |// Per your layout: select LRADC 2 or 1 below 
                             1664 ; 267  |//   (pin LRADC 2 for 35xx cpu card revB, LRADC 1 for 35xx cpu card revC, ref schematics, & demo player)
                             1665 ; 268  |#define LRADC_NUM_FOR_MIC_BIAS 1 
                             1666 ; 269  |// Sets internal mic bias R to value 2, 4, or 8 (in kOhms).
                             1667 ; 270  |#define MICBIAS_CONFIGURED_RESISTOR_KOHMS 8
                             1668 ; 271  |
                             1669 ; 272  |// Allows mic bias to settle before sampling. This delay currently unused. For rec btn when bias not yet ready.
                             1670 ; 273  |#define REC_BTN_INTERNAL_MIC_BIAS_SETTLING_DELAY_MS 400 
                             1671 ; 274  |// Option always keeps bias enabled after mainmenu init. This allows for start pop prevention if you use rec button from outside voice menu.
                             1672 ; 275  |// This selection costs 1 mWatt but gains the desired low record button to sampling latency in the record-from-music-menu use-case.
                             1673 ; 276  |#define KEEP_MIC_BIAS_ENABLED 0
                             1674 ; 277  |
                             1675 ; 278  |#else 
                             1676 ; 279  |// STMP3410
                             1677 ; 280  |#define ENABLE_INTERNALLY_GENERATED_MICBIAS 0
                             1678 ; 281  |#define LRADC_NUM_FOR_MIC_BIAS 1 
                             1679 ; 282  |#define MICBIAS_CONFIGURED_RESISTOR_KOHMS 2
                             1680 ; 283  |#endif
                             1681 ; 284  |
                             1682 ; 285  |/////////////////////////////////////////////////////////////////////////////////
                             1683 ; 286  |// Number of available soft timers
                             1684 ; 287  |/////////////////////////////////////////////////////////////////////////////////
                             1685 ; 288  |#if defined(SYNC_LYRICS)
                             1686 ; 289  |#define SOFT_TIMERS 10
                             1687 ; 290  |#else 
                             1688 ; 291  |#if defined(JPEG_DECODER)
                             1689 ; 292  |#define SOFT_TIMERS 10
                             1690 ; 293  |#else 
                             1691 ; 294  |#define SOFT_TIMERS 9
                             1692 ; 295  |#endif
                             1693 ; 296  |#endif
                             1694 ; 297  |
                             1695 ; 298  |/////////////////////////////////////////////////////////////////////////////////
                             1696 ; 299  |//  sizes
                             1697 ; 300  |/////////////////////////////////////////////////////////////////////////////////
                             1698 ; 301  |#if defined(MMC)
                             1699 ; 302  |#if defined(USE_PLAYLIST5)
                             1700 ; 303  |#define MENU_STACK_SIZE 1500
                             1701 ; 304  |#else 
                             1702 ; 305  |#define MENU_STACK_SIZE 1250
                             1703 ; 306  |#endif //if @def('USE_PLAYLIST5')
                             1704 ; 307  |#else 
                             1705 ; 308  |#if defined(USE_PLAYLIST5)
                             1706 ; 309  |#define MENU_STACK_SIZE 1500
                             1707 ; 310  |#else 
                             1708 ; 311  |#define MENU_STACK_SIZE 1250
                             1709 ; 312  |#endif //if @def('USE_PLAYLIST5')
                             1710 ; 313  |#endif //if @def('MMC')
                             1711 ; 314  |
                             1712 ; 315  |// NOTE: SDK2.6 USED 550 FOR NEXT LINE, BUT SDK3.0BETA USED 750. Should it be ifdef MTP 750 else 550 for other builds? TOVERIFY. MYALLOC
                             1713 ; 316  |// 
                             1714 ; 317  |#define STACK_L1_SIZE 750
                             1715 ; 318  |#define STACK_L2_SIZE 100
                             1716 ; 319  |#define STACK_L3_SIZE 160
                             1717 ; 320  |
                             1718 ; 321  |// If we are in MTP mode the overlay task stack can shrink.
                             1719 ; 322  |// TODO shrink this stack for MTP, I will leave it at 500 until we verify that it 
                             1720 ; 323  |// is ok with switching code.
                             1721 ; 324  |#if defined(MTP_BUILD)
                             1722 ; 325  |#define OVERLAY_MANAGER_STACK_SIZE 300
                             1723 ; 326  |#endif
                             1724 ; 327  |
                             1725 ; 328  |/////////////////////////////////////////////////////////////////////////////////
                             1726 ; 329  |// maximum number of nested funclets 
                             1727 ; 330  |/////////////////////////////////////////////////////////////////////////////////
                             1728 ; 331  |#define MAX_NESTED_FUNCLET 6 
                             1729 ; 332  |
                             1730 ; 333  |/////////////////////////////////////////////////////////////////////////////////
                             1731 ; 334  |//    LCD DEFINITIONS
                             1732 ; 335  |/////////////////////////////////////////////////////////////////////////////////
                             1733 ; 336  |
                             1734 ; 337  |#define SPACE_CHAR 0x000020          
                             1735 ; 338  |#define ZERO_CHAR 0x000030
                             1736 ; 339  |#define COLON_CHAR 0x00003A
                             1737 ; 340  |#define PERIOD_CHAR 0x00002E
                             1738 ; 341  |
                             1739 ; 342  |#if (defined(S6B33B0A_LCD))
                             1740 ; 343  |#define LCD_X_SIZE 128
                             1741 ; 344  |#define LCD_Y_SIZE 159
                             1742 ; 345  |#endif
                             1743 ; 346  |
                             1744 ; 347  |#if (defined(SED15XX_LCD))
                             1745 ; 348  |#define LCD_X_SIZE 128
                             1746 ; 349  |#define LCD_Y_SIZE 64
                             1747 ; 350  |#endif
                             1748 ; 351  |
                             1749 ; 352  |
                             1750 ; 353  |//////////////////////////////////////////////////////////////////////////////////
                             1751 ; 354  |//   Details on Customizing Contrast
                             1752 ; 355  |/////////////////////////////////////////////////////////////////////////////////
                             1753 ; 356  |//   Max supported LCD range is 0 - 3F; however due to hardware/voltage differences
                             1754 ; 357  |//   the range of visibility is usually smaller than this.  It is important to 
                             1755 ; 358  |//   calibrate the visible range, because the contrast setting is saved.
                             1756 ; 359  |//   If the user shuts off the player while lcd is not visible, the player is useless
                             1757 ; 360  |//   unless the ezact sequence is remembered.
                             1758 ; 361  |//   To find out what range your player supports: 
                             1759 ; 362  |//   change these equs to full range or comment out (full range is default)
                             1760 ; 363  |//;;;;;;
                             1761 ; 364  |// uncomment the line below to build code that will provide raw contrast value
                             1762 ; 365  |// recommended calibration using player -- uncomment 
                             1763 ; 366  |//;;;;;;
                             1764 ; 367  |//CONTRAST_CALIBRATION    equ  1
                             1765 ; 368  |////////////////////////////
                             1766 ; 369  |#if (defined(DEMO_HW))
                             1767 ; 370  |// this is the setting for ET301 demos; Next 2 line have not been updated for new Shingyi LCD (June6'05)
                             1768 ; 371  |#define LCD_MAX_CONTRAST 0x32 
                             1769 ; 372  |#define LCD_MIN_CONTRAST 0x1E
                             1770 ; 373  |#else 
                             1771 ; 374  |
                             1772 ; 375  |#if (defined(S6B33B0A_LCD))
                             1773 ; 376  |#define LCD_MAX_CONTRAST 210
                             1774 ; 377  |#define LCD_MIN_CONTRAST 160    
                             1775 ; 378  |#endif
TASKING DSP2410 assembler v1.5r1 Build 138 SN 00100122
                                                                                                                                                                                                                                                       Page   8

M:ADDR CODE           CYCLES LINE SOURCELINE
                             1776 ; 379  |
                             1777 ; 380  |#if (defined(SED15XX_LCD))
                             1778 ; 381  |// Next 3 line comment was for OLD shingyi LCD: (default LCD before sdk2.6)
                             1779 ; 382  |// Engineering board regs support range [17-37].
                             1780 ; 383  |//   Engineering board DC/DC support range [24-46]. 
                             1781 ; 384  |//   One default contrast range [24-42] works for both.
                             1782 ; 385  |// The 3 sets of contrast ranges below are updated for SDK2.6 to support either 
                             1783 ; 386  |// new or old ShingYih LCDs. "File" refers to \resource\shingyih\system_lcd_init_seq.src
                             1784 ; 387  |// 3/10/05 - Use one of the 2 next contrast ranges depending on which
                             1785 ; 388  |// ShingYih LCD you have.  See \resources\shingyi\readme.txt 
                             1786 ; 389  |// Optimal for NEW LCD with NEW file (SDK2.6 default)  
                             1787 ; 390  |// G098064-41 LCD module (present on engr board revH LCD card)
                             1788 ; 391  |
                             1789 ; 392  |#if (defined(NEWSHINGYIH))
                             1790 ; 393  |#define LCD_MAX_CONTRAST 250
                             1791 ; 394  |#define LCD_MIN_CONTRAST 0
                             1792 ; 395  |#else 
                             1793 ; 396  |//-----
                             1794 ; 397  |// Near optimal for OLD LCD with NEW file. 
                             1795 ; 398  |// NOT optimal for the new lcd but pretty good. So u may use this if u want 1 build for both LCDs.
                             1796 ; 399  |#define LCD_MAX_CONTRAST 250
                             1797 ; 400  |#define LCD_MIN_CONTRAST 0
                             1798 ; 401  |
                             1799 ; 402  |//=====
                             1800 ; 403  |// Optimal for OLD ShingYih LCD with OLD file (as sdk2.521)
                             1801 ; 404  |// Suggest going with default new init file & values above for your LCD instead of this historic ver.
                             1802 ; 405  |//LCD_MAX_CONTRAST equ 42
                             1803 ; 406  |//LCD_MIN_CONTRAST equ 24 
                             1804 ; 407  |
                             1805 ; 408  |#endif
                             1806 ; 409  |#endif
                             1807 ; 410  |
                             1808 ; 411  |#endif
                             1809 ; 412  |
                             1810 ; 413  |//////////////////////////////////////////////////////////////////////////////////
                             1811 ; 414  |// The default value of the lcd contrast in % of range
                             1812 ; 415  |//   the default value is used when no settings.dat is available
                             1813 ; 416  |//////////////////////////////////////////////////////////////////////////////////
                             1814 ; 417  |
                             1815 ; 418  |#if (defined(S6B33B0A_LCD))
                             1816 ; 419  |// 60% of range is default value
                             1817 ; 420  |#define DEFAULT_CONTRAST 50 
                             1818 ; 421  |#endif
                             1819 ; 422  |
                             1820 ; 423  |#if (defined(SED15XX_LCD))
                             1821 ; 424  |// % of range is default value (was 60%)
                             1822 ; 425  |#define DEFAULT_CONTRAST 50 
                             1823 ; 426  |#endif
                             1824 ; 427  |
                             1825 ; 428  |
                             1826 ; 429  |// percentage change per increment/decrement message (LCD_DEC_CONTRAST/LCD_INC_CONTRAST)
                             1827 ; 430  |// make lower when doing calibration
                             1828 ; 431  |#define LCD_STEPSIZE_CONTRAST 10  
                             1829 ; 432  |
                             1830 ; 433  |
                             1831 ; 434  |/////////////////////////////////////////////////////////////////////////////////
                             1832 ; 435  |// For FFWD and RWND
                             1833 ; 436  |/////////////////////////////////////////////////////////////////////////////////
                             1834 ; 437  |#define SECONDS_TO_SKIP 1
                             1835 ; 438  |#define SECONDS_TO_SKIP1 3
                             1836 ; 439  |#define SECONDS_TO_SKIP2 6
                             1837 ; 440  |// number of seconds to cause reset to begin of song for PREV push
                             1838 ; 441  |#define PREV_SONG_THRESHOLD 5  
                             1839 ; 442  |// number of 300 mSec periods before the numbers of seconds to skip increases
                             1840 ; 443  |#define FIRST_TIME_BOUNDARY 15 
                             1841 ; 444  |// number of 300 mSec periods before the numbers of seconds to skip increases
                             1842 ; 445  |#define SECOND_TIME_BOUNDARY 30 
                             1843 ; 446  |
                             1844 ; 447  |// For audible FFW/RWD
                             1845 ; 448  |#define SECONDS_TO_SKIP_FOR_3X_RATE 1
                             1846 ; 449  |#define SECONDS_TO_SKIP_FOR_60X_RATE 18
                             1847 ; 450  |#define SECONDS_TO_SKIP_FOR_600X_RATE 180
                             1848 ; 451  |#define SECONDS_TO_SKIP_FOR_1800X_RATE 540
                             1849 ; 452  |// number of 300 mSec periods before the numbers of seconds to skip increases
                             1850 ; 453  |#define LEVEL1_BOUNDARY 17 
                             1851 ; 454  |// number of 300 mSec periods before the numbers of seconds to skip increases
                             1852 ; 455  |#define LEVEL2_BOUNDARY 33 
                             1853 ; 456  |// number of 300 mSec periods before the numbers of seconds to skip increases
                             1854 ; 457  |#define LEVEL3_BOUNDARY 50 
                             1855 ; 458  |// Stmp00010296 Ticket #71685:  for song shorter than the min. skip size
                             1856 ; 459  |// if song_time < skip_size, bCurrentSongShort=>TRUE (ignore FWD/RWD commands)
                             1857 ; 460  |// Short Song Time, songs too short to play.
                             1858 ; 461  |#define SHORT_SONG_TIME SECONDS_TO_SKIP         
                             1859 ; 462  |
                             1860 ; 463  |/////////////////////////////////////////////////////////////////////////////////
                             1861 ; 464  |// MP3 Sync Values
                             1862 ; 465  |/////////////////////////////////////////////////////////////////////////////////
                             1863 ; 466  |// # bytes to look for sync before marking it bad
                             1864 ; 467  |#define MP3_SYNC_THRESHOLD 70000 
                             1865 ; 468  |// # bytes to look for sync before slowing decoder isr frequency (to let menus run)
                             1866 ; 469  |#define MP3_SYNC_THRESHOLD1 10000 
                             1867 ; 470  |// once we have sync'd, the isr should be called this frequently
                             1868 ; 471  |#define MP3_DECODERISR_FAST 7500  
                             1869 ; 472  |// if decoder is having difficulty syncing, switch isr to be called less frequently
                             1870 ; 473  |#define MP3_DECODERISR_SLOW 50000 
                             1871 ; 474  |
                             1872 ; 475  |
                             1873 ; 476  |/////////////////////////////////////////////////////////////////////////////////
                             1874 ; 477  |//// Multi-Stage Volume Control Definitions
                             1875 ; 478  |/////////////////////////////////////////////////////////////////////////////////
                             1876 ; 479  |//// Use Multi-Stage Volume
                             1877 ; 480  |#define MULTI_STAGE_VOLUME 0x1                  
                             1878 ; 481  |
                             1879 ; 482  |//// Master Volume definitions
                             1880 ; 483  |#define MIX_MSTR_MAX_VOL 0x0
                             1881 ; 484  |#define NUM_MSTR_ATT_STEPS (0x1F-MIX_MSTR_MAX_VOL)
                             1882 ; 485  |
                             1883 ; 486  |//// DAC-Mode definitions
                             1884 ; 487  |//// Adjusts 0dB point
                             1885 ; 488  |#define MIX_DAC_NOM_VOL 0x6                  
                             1886 ; 489  |#define MIX_DAC_MIN_VOL 0x1F
                             1887 ; 490  |// For minimum clipping: Set MIX_DAC_MAX_VOL below to match MIX_DAC_NOM_VOL value 2 lines above.
                             1888 ; 491  |// For additional gain (with possible clipping): Set MIX_DAC_MAX_VOL in range below. 
                             1889 ; 492  |//                                               Each integer below MIX_DAC_NOM_VOL provides 1.5 dB gain on Stmp34x0; 
                             1890 ; 493  |//                                               Max gain possible: 8 step diff would provide +12dB gain.   
                             1891 ; 494  |// range: [0 to MIX_DAC_NOM_VOL] (0 for loudest volume)
                             1892 ; 495  |#define MIX_DAC_MAX_VOL 0x0  
                             1893 ; 496  |
                             1894 ; 497  |#define NUM_DAC_ATT_STEPS (MIX_DAC_MIN_VOL-MIX_DAC_NOM_VOL+1)
                             1895 ; 498  |#define NUM_DAC_GAIN_STEPS (MIX_DAC_NOM_VOL-MIX_DAC_MAX_VOL)
                             1896 ; 499  |#define NUM_DAC_MODE_VOL_STEPS (NUM_DAC_ATT_STEPS+NUM_MSTR_ATT_STEPS+NUM_DAC_GAIN_STEPS+1)
                             1897 ; 500  |
                             1898 ; 501  |//// If there is no stored volume, set to 50% of DAC-Mode max; change if DAC Mode is not the default
                             1899 ; 502  |//// STMP35xx has 2dB attenuation per step so default needs a few more steps above midpoint.
                             1900 ; 503  |#define DEFAULT_VOLUME ((NUM_DAC_MODE_VOL_STEPS/2)+6)         
                             1901 ; 504  |
                             1902 ; 505  |//// Set maximum restored volume to 75% of DAC-Mode max; change if DAC Mode is not the default
                             1903 ; 506  |#define MAX_RESTORED_VOLUME ((3*NUM_DAC_MODE_VOL_STEPS)/4)   
                             1904 ; 507  |
                             1905 ; 508  |
                             1906 ; 509  |//// Line In definitions (used for Line-In 1)
                             1907 ; 510  |//// 0dB point of the Line In
                             1908 ; 511  |#define MIX_LINE_NOM_VOL 0x8                  
                             1909 ; 512  |//// Minimum volume of Line In
                             1910 ; 513  |#define MIX_LINE_MIN_VOL 0x1F                 
                             1911 ; 514  |//// Maximum volume of Line In (can adjust extra gain)
                             1912 ; 515  |#define MIX_LINE_MAX_VOL 0x6                  
                             1913 ; 516  |#define NUM_LINE_ATT_STEPS (MIX_LINE_MIN_VOL-MIX_LINE_NOM_VOL+1)
                             1914 ; 517  |#define NUM_LINE_GAIN_STEPS (MIX_LINE_NOM_VOL-MIX_LINE_MAX_VOL)
                             1915 ; 518  |#define NUM_LINE_MODE_VOL_STEPS (NUM_LINE_ATT_STEPS+NUM_MSTR_ATT_STEPS+NUM_LINE_GAIN_STEPS+1)
                             1916 ; 519  |
                             1917 ; 520  |//// Line In definitions (used for FM tuner with 144 pin package)
                             1918 ; 521  |//// 0dB point of the Line In
                             1919 ; 522  |#define MIX_FM_NOM_VOL 0x8                  
                             1920 ; 523  |//// Minimum volume of Line In
                             1921 ; 524  |#define MIX_FM_MIN_VOL 0x1F                 
                             1922 ; 525  |//// Maximum volume of Line In (can adjust extra gain)
                             1923 ; 526  |#define MIX_FM_MAX_VOL 0x6                  
                             1924 ; 527  |#define NUM_FM_ATT_STEPS (MIX_FM_MIN_VOL-MIX_FM_NOM_VOL+1)
                             1925 ; 528  |#define NUM_FM_GAIN_STEPS (MIX_FM_NOM_VOL-MIX_FM_MAX_VOL)
                             1926 ; 529  |#define NUM_FM_MODE_VOL_STEPS (NUM_FM_ATT_STEPS+NUM_MSTR_ATT_STEPS+NUM_FM_GAIN_STEPS+1)
                             1927 ; 530  |
                             1928 ; 531  |/////////////////////////////////////////////////////////////////////////////////
                             1929 ; 532  |//// When enabled (1), periodically checks for one of several FM state machine invalid deadlock states & recovers. 
                             1930 ; 533  |//// Define as 0 to disable FM-deadlock-state checking and recovery.
                             1931 ; 534  |#define FM_WATCHDOG_ENABLE 1
                             1932 ; 535  |
                             1933 ; 536  |#if !defined(STMP_BUILD_PLAYER)
                             1934 ; 537  |////
                             1935 ; 538  |////! This varible holds the lcd display state for the mtp project.
                             1936 ; 539  |////
                             1937 ; 540  |///
                             1938 ; 541  |#include <types.h>
                             1939 ; 542  |extern volatile WORD g_wActivityState;
                             1940 ; 543  |#endif // if !@def('STMP_BUILD_PLAYER')
                             1941 ; 544  |
                             1942 ; 545  |void _reentrant Init5VSense(void);
                             1943 ; 546  |void _reentrant ServiceDCDC(void);
                             1944 ; 547  |
                             1945 ; 548  |////////////////////////////////////////////////////////////////////////////
                             1946 ; 549  |//// JPEG Thumbnail Mode Setting
                             1947 ; 550  |//// number of column in thumbnail mode
                             1948 ; 551  |#define THUMBNAIL_X 2           
                             1949 ; 552  |//// number of row in  thumbnail mode
                             1950 ; 553  |#define THUMBNAIL_Y 2           
                             1951 ; 554  |//// thumbnail boundary offset x
                             1952 ; 555  |#define THUMBNAIL_X_OFFSET 4            
                             1953 ; 556  |//// thumbnail boundary offset y
                             1954 ; 557  |#define THUMBNAIL_Y_OFFSET 4            
                             1955 ; 558  |
                             1956 ; 559  |#endif // if (!@def(_PROJECT_INC))
                             1957 ; 560  |
                             1958 
                             1960 
                             1961 ; 15   |
                             1962 ; 16   |#ifndef _USB_MEM
                             1963 ; 17   |//if not overwridden, default to the compiler default memory space
                             1964 ; 18   |#define _USB_MEM
                             1965 ; 19   |#endif
                             1966 ; 20   |
                             1967 ; 21   |#define USB_LANGUAGE_ENGLISH 0x0409
                             1968 ; 22   |#define USB_LANGUAGE_CHINESE_PRC 0x0804
                             1969 ; 23   |#define USB_LANGUAGE_CHINESE_TAIWAN 0x0404
                             1970 ; 24   |#define USB_LANGUAGE_JAPANESE 0x0411
                             1971 ; 25   |
                             1972 ; 26   |#define MAX_STRING 30
                             1973 ; 27   |
                             1974 ; 28   |#define  USB_SPEED_FULL                      (0)
                             1975 ; 29   |#define  USB_SPEED_LOW                       (1)
                             1976 ; 30   |#define  USB_SPEED_HIGH                      (2)
                             1977 ; 31   |
                             1978 ; 32   |#define EP_FS_MAX_PACKET_SIZE               (64)    
                             1979 ; 33   |
                             1980 ; 34   |#define EP_HS_MAX_PACKET_SIZE               (512)   
                             1981 ; 35   |
                             1982 ; 36   |// Data transferred to devices based on Sigmatel 3500 chip may sometimes be 
                             1983 ; 37   |// corrupted. The corruption occurs when device is connected in USB High Speed 
                             1984 ; 38   |// mode, and size of the transfer in bytes is divisible by 128, but not 
                             1985 ; 39   |// divisible by the packet size. The workaround is implemented in Microsoft MTP 
                             1986 ; 40   |// driver to allow support for those devices.
                             1987 ; 41   |
                             1988 ; 42   |// the bug can corrupt the end of data buffer. It occurs when host sends out a 
                             1989 ; 43   |// short packet that is multiple of 128 bytes. During this scenario the USB core
                             1990 ; 44   |// does writes that are voided (byte enable == all zero), which was an undefined 
                             1991 ; 45   |// capability and thus the gasket did not apply a proper response. This should 
                             1992 ; 46   |// not affect Mass Storage applications because data transfers are 512 bytes and 
                             1993 ; 47   |// scsi commands are < 16 bytes. Other applications with their own driver will
                             1994 ; 48   |// need to pad the packets if they fall into the error case. "What this basically 
                             1995 ; 49   |// boils down to is that any time the host sends a short packet of 128, 256 or
                             1996 ; 50   |// 384 bytes to a high-speed connected player a number of bytes will be corrupted.
                             1997 ; 51   |// This is easiest to reproduce in SendObject commands but can strike any of the 
                             1998 ; 52   |// commands that take an arbitrary amount of data.
                             1999 ; 53   |#define ARC_HS_128_MODULO_BUG               (128)
                             2000 ; 54   |
                             2001 ; 55   |
                             2002 ; 56   |/* Error codes */
                             2003 ; 57   |#define USB_OK                              (0x00)
                             2004 ; 58   |#define USBERR_REGISTER_SERVICE             (0x01)  // Failed to register a service
                             2005 ; 59   |#define USBERR_NO_SERVICE                   (0x02)  // No registered service found 
                             2006 ; 60   |#define USBERR_TX_FAILED                    (0x03)  // Fail to prepare XD descriptor
                             2007 ; 61   |#define USBERR_SIZE_TOO_LARGE               (0x04)  // Number of bytes to transfer is too large
                             2008 ; 62   |#define USBERR_EP_INIT_FAILED               (0x05)  // Endpoint init fail
                             2009 ; 63   |#define USBERR_CONFIG_FAILED                (0x06)  // Error reported by the application
                             2010 ; 64   |                                                    // if the new config failed or not supported
                             2011 ; 65   |#define USBERR_DEVICE_NOT_CONFIGURED        (0x07)  // Error reported by the transfer function
                             2012 ; 66   |                                                    // if attempting to transfer while the device
                             2013 ; 67   |                                                    // is not configured
                             2014 ; 68   |#define USBERR_INIT_FAILED                  (0x08)  // Fail to initialize the USB API
                             2015 ; 69   |
                             2016 ; 70   |
                             2017 ; 71   |/* Endpoint types */
                             2018 ; 72   |#define  USB_CONTROL_ENDPOINT             (0)
                             2019 ; 73   |#define  USB_ISOCHRONOUS_ENDPOINT         (1)
                             2020 ; 74   |#define  USB_BULK_ENDPOINT                (2)
                             2021 ; 75   |#define  USB_INTERRUPT_ENDPOINT           (3)
                             2022 ; 76   |
                             2023 ; 77   |/* End point direction */
                             2024 ; 78   |#define  USB_OUT                         (0)
                             2025 ; 79   |#define  USB_IN                          (1)
                             2026 ; 80   |
                             2027 ; 81   |/* End point packed size */
TASKING DSP2410 assembler v1.5r1 Build 138 SN 00100122
                                                                                                                                                                                                                                                       Page   9

M:ADDR CODE           CYCLES LINE SOURCELINE
                             2028 ; 82   |#define  USB_FS_MAX_PACKET_SIZE           (64)
                             2029 ; 83   |#define  USB_HS_BULK_OUT_MAX_PACKET_SIZE  (256)
                             2030 ; 84   |#define  USB_HS_BULK_IN_MAX_PACKET_SIZE   (128)
                             2031 ; 85   |
                             2032 ; 86   |
                             2033 ; 87   |#define  USB_TEST_MODE_TEST_J             (0x01)
                             2034 ; 88   |#define  USB_TEST_MODE_TEST_K             (0x02)
                             2035 ; 89   |#define  USB_TEST_MODE_TEST_SE0_NAK       (0x03)
                             2036 ; 90   |#define  USB_TEST_MODE_TEST_PACKET        (0x04)
                             2037 ; 91   |
                             2038 ; 92   |/* Available service types */
                             2039 ; 93   |/* Services 0 through 15 are reserved for endpoints */
                             2040 ; 94   |#define  USB_SERVICE_EP0                  (0x00)
                             2041 ; 95   |#define  USB_SERVICE_EP1                  (0x01)
                             2042 ; 96   |#define  USB_SERVICE_EP2                  (0x02)
                             2043 ; 97   |#define  USB_SERVICE_EP3                  (0x03)
                             2044 ; 98   |#define  USB_SERVICE_EP4                  (0x04)
                             2045 ; 99   |#define  USB_SERVICE_EP5                  (0x05)
                             2046 ; 100  |#define  USB_SERVICE_EP6                  (0x06)
                             2047 ; 101  |#define  USB_SERVICE_EP7                  (0x07)
                             2048 ; 102  |#define  USB_SERVICE_EP8                  (0x08)
                             2049 ; 103  |#define  USB_SERVICE_EP9                  (0x09)
                             2050 ; 104  |#define  USB_SERVICE_EP10                 (0x0a)
                             2051 ; 105  |#define  USB_SERVICE_EP11                 (0x0b)
                             2052 ; 106  |#define  USB_SERVICE_EP12                 (0x0c)
                             2053 ; 107  |#define  USB_SERVICE_EP13                 (0x0d)
                             2054 ; 108  |#define  USB_SERVICE_EP14                 (0x0e)
                             2055 ; 109  |#define  USB_SERVICE_EP15                 (0x0f)
                             2056 ; 110  |#define  USB_SERVICE_BUS_RESET            (0x10)
                             2057 ; 111  |#define  USB_SERVICE_SUSPEND              (0x11)
                             2058 ; 112  |#define  USB_SERVICE_SOF                  (0x12)
                             2059 ; 113  |#define  USB_SERVICE_RESUME               (0x13)
                             2060 ; 114  |#define  USB_SERVICE_SLEEP                (0x14)
                             2061 ; 115  |#define  USB_SERVICE_SPEED_DETECTION      (0x15)
                             2062 ; 116  |#define  USB_SERVICE_TEST                 (0x16)
                             2063 ; 117  |#define  USB_SERVICE_CHANGE_CONFIG        (0x17)
                             2064 ; 118  |#define  USB_SERVICE_CHANGE_IFACE         (0x18)   
                             2065 ; 119  |#define  NON_EP_SERVICES                  (USB_SERVICE_SPEED_DETECTION - USB_SERVICE_EP15)
                             2066 ; 120  |
                             2067 ; 121  |// This is the maximum service structures allocated 
                             2068 ; 122  |// One for each End point + the common services (non endpoint services) 
                             2069 ; 123  |#define MAX_NUMBER_SERVICES               (MAX_NUM_EP + NON_EP_SERVICES)  
                             2070 ; 124  |
                             2071 ; 125  |#define NUMBER_BYTES_IN_SETUP               (8)
                             2072 ; 126  |
                             2073 ; 127  |// possible values of btStatus on the xd_struct
                             2074 ; 128  |#define  USB_STATUS_TRANSFER_IDLE           (0)
                             2075 ; 129  |#define  USB_STATUS_TRANSFER_SUCCESS        (1)            
                             2076 ; 130  |#define  USB_STATUS_TRANSFER_ACCEPTED       (2)
                             2077 ; 131  |#define  USB_STATUS_TRANSFER_IN_PROGRESS    (3)
                             2078 ; 132  |#define  USB_STATUS_TRANSFER_ERROR          (4)
                             2079 ; 133  |
                             2080 ; 134  |// types of status set/returned by set_status() and get_status()
                             2081 ; 135  |#define  USB_STATUS_DEVICE_STATE          (0x01)
                             2082 ; 136  |#define  USB_STATUS_INTERFACE             (0x02)
                             2083 ; 137  |#define  USB_STATUS_ADDRESS               (0x03)
                             2084 ; 138  |#define  USB_STATUS_CURRENT_CONFIG        (0x04)
                             2085 ; 139  |#define  USB_STATUS_SOF_COUNT             (0x05)
                             2086 ; 140  |#define  USB_STATUS                       (0x06)
                             2087 ; 141  |#define  USB_STATUS_TEST_MODE             (0x07)
                             2088 ; 142  |#define  USB_STATUS_DEVICE_SPEED          (0x08)  
                             2089 ; 143  |#define  USB_STATUS_DEVICE_TEST           (0x09)  
                             2090 ; 144  |#define  USB_STATUS_CURRENT_IFACE         (0x0a)
                             2091 ; 145  |#define  USB_STATUS_CONNECTION            (0x0b)  
                             2092 ; 146  |// For status endpoint, the endpoint number is coded in the less significant nibble
                             2093 ; 147  |#define  USB_STATUS_ENDPOINT              (0x10)
                             2094 ; 148  |#define  USB_STATUS_ENDPOINT_NUMBER_MASK  (0x0F)
                             2095 ; 149  |
                             2096 ; 150  |#define USB_MAX_SIZE_PER_TRANSFER       (0x4000)    // This is the maximum size that
                             2097 ; 151  |                                                    // we allow per transfer
                             2098 ; 152  |
                             2099 ; 153  |//Possible states the device can be in
                             2100 ; 154  |#define  USB_STATE_UNKNOWN                   (0xff)
                             2101 ; 155  |#define  USB_STATE_UNPLUGGED                 (0x05) // USB Cable unplugged
                             2102 ; 156  |#define  USB_STATE_PLUGGED                   (0x04) // USB Cable inserted
                             2103 ; 157  |#define  USB_STATE_POWERED                   (0x03)
                             2104 ; 158  |#define  USB_STATE_DEFAULT                   (0x02)
                             2105 ; 159  |#define  USB_STATE_ADDRESSED                 (0x01)
                             2106 ; 160  |#define  USB_STATE_CONFIGURED                (0x00)
                             2107 ; 161  |#define  USB_STATE_SUSPENDED                 (0x80)
                             2108 ; 162  |
                             2109 ; 163  |// Possible states the connection can be in
                             2110 ; 164  |//#define USB_STATE_UNKNOWN                 (0xff)
                             2111 ; 165  |#define USB_CONNECTED                       (0x00)
                             2112 ; 166  |#define USB_DISCONNECTED                    (0x01)
                             2113 ; 167  |
                             2114 ; 168  |
                             2115 ; 169  |
                             2116 ; 170  |typedef union
                             2117 ; 171  |{
                             2118 ; 172  |    struct
                             2119 ; 173  |    {
                             2120 ; 174  |        int Recipient               : 5;
                             2121 ; 175  |        int Type                    : 2;
                             2122 ; 176  |        int DataTransferDirection   : 1;
                             2123 ; 177  |        int Request                 : 8;
                             2124 ; 178  |        int                         : 8;
                             2125 ; 179  |    } B;
                             2126 ; 180  |    
                             2127 ; 181  |    int I;
                             2128 ; 182  |} USBRequestType ;
                             2129 
                             2143 
                             2144 ; 183  |
                             2145 ; 184  |typedef struct {
                             2146 ; 185  |   BYTE     bValid;
                             2147 ; 186  |   USBRequestType RequestType;
                             2148 ; 187  |   BYTE     btRequest;
                             2149 ; 188  |   WORD     wValue;
                             2150 ; 189  |   WORD     wIndex;
                             2151 ; 190  |   WORD     wLength;
                             2152 ; 191  |    } USB_SetupData;
                             2153 ; 192  |
                             2154 ; 193  |// Descriptor sizes in bytes
                             2155 ; 194  |#define SIZE_DEVICE_DESCRIPTOR_IN_BYTES     (18)
                             2156 ; 195  |#define SIZE_DEVICE_DESCRIPTOR_IN_WORDS     (6)
                             2157 ; 196  |#define SIZE_DEVICE_QUALIFIER_DESCRIPTOR_IN_BYTES   (10)
                             2158 ; 197  |#define SIZE_DEVICE_QUALIFIER_DESCRIPTOR_IN_WORDS   (4)
                             2159 ; 198  |#define SIZE_CONFIG_DESCRIPTOR_IN_BYTES     (9)
                             2160 ; 199  |#define SIZE_CONFIG_DESCRIPTOR_IN_WORDS     (3)
                             2161 ; 200  |#define SIZE_INTERFACE_DESCRIPTOR_IN_BYTES  (9)
                             2162 ; 201  |#define SIZE_INTERFACE_DESCRIPTOR_IN_WORDS  (3)
                             2163 ; 202  |#define SIZE_ENDPOINT_DESCRIPTOR_IN_BYTES   (7)
                             2164 ; 203  |
                             2165 ; 204  |
                             2166 ; 205  |// Descriptor types
                             2167 ; 206  |#define DESCRIPTOR_TYPE_DEVICE              (0x01)
                             2168 ; 207  |#define DESCRIPTOR_TYPE_CONFIG              (0x02)
                             2169 ; 208  |#define DESCRIPTOR_TYPE_STRING              (0x03)
                             2170 ; 209  |#define DESCRIPTOR_TYPE_INTERFACE           (0x04)
                             2171 ; 210  |#define DESCRIPTOR_TYPE_ENDPOINT            (0x05)
                             2172 ; 211  |#define DESCRIPTOR_TYPE_DEVICE_QUALIFIER    (0x06)
                             2173 ; 212  |#define DESCRIPTOR_TYPE_OTHER_SPEED_CONFIG  (0x07)
                             2174 ; 213  |#define DESCRIPTOR_TYPE_INTERFACE_POWER     (0x08)
                             2175 ; 214  |
                             2176 ; 215  |
                             2177 ; 216  |#define USB_REQUEST_DIRECTION_HOST_TO_DEVICE    ((WORD)0x000000)
                             2178 ; 217  |#define USB_REQUEST_DIRECTION_DEVICE_TO_HOST    ((WORD)0x000001)
                             2179 ; 218  |
                             2180 ; 219  |#define USB_REQUEST_TYPE_STANDARD               ((WORD)0x000000)
                             2181 ; 220  |#define USB_REQUEST_TYPE_CLASS                  ((WORD)0x000001)
                             2182 ; 221  |#define USB_REQUEST_TYPE_VENDOR                 ((WORD)0x000002)
                             2183 ; 222  |#define USB_REQUEST_TYPE_RESERVED               ((WORD)0x000003)
                             2184 ; 223  |
                             2185 ; 224  |#define USB_REQUEST_RECIPIENT_DEVICE            ((WORD)0x000000)
                             2186 ; 225  |#define USB_REQUEST_RECIPIENT_INTERFACE         ((WORD)0x000001)
                             2187 ; 226  |#define USB_REQUEST_RECIPIENT_ENDPOINT          ((WORD)0x000002)
                             2188 ; 227  |#define USB_REQUEST_RECIPIENT_OTHER             ((WORD)0x000003)
                             2189 ; 228  |
                             2190 ; 229  |#define USB_REQUEST_STANDARD_GET_STATUS         ((WORD)0x000000)
                             2191 ; 230  |#define USB_REQUEST_STANDARD_CLEAR_FEATURE      ((WORD)0x000001)
                             2192 ; 231  |#define USB_REQUEST_STANDARD_RESERVED_1         ((WORD)0x000002)
                             2193 ; 232  |#define USB_REQUEST_STANDARD_SET_FEATURE        ((WORD)0x000003)
                             2194 ; 233  |#define USB_REQUEST_STANDARD_RESERVED_2         ((WORD)0x000004)
                             2195 ; 234  |#define USB_REQUEST_STANDARD_SET_ADDRESS        ((WORD)0x000005)
                             2196 ; 235  |#define USB_REQUEST_STANDARD_GET_DESCRIPTOR     ((WORD)0x000006)
                             2197 ; 236  |#define USB_REQUEST_STANDARD_SET_DESCRIPTOR     ((WORD)0x000007)
                             2198 ; 237  |#define USB_REQUEST_STANDARD_GET_CONFIGURATION  ((WORD)0x000008)
                             2199 ; 238  |#define USB_REQUEST_STANDARD_SET_CONFIGURATION  ((WORD)0x000009)
                             2200 ; 239  |#define USB_REQUEST_STANDARD_GET_INTERFACE      ((WORD)0x00000A)
                             2201 ; 240  |#define USB_REQUEST_STANDARD_SET_INTERFACE      ((WORD)0x00000B)
                             2202 ; 241  |#define USB_REQUEST_STANDARD_SYNCH_FRAME        ((WORD)0x00000C)
                             2203 ; 242  |
                             2204 ; 243  |#define USB_CLEAR_FEATURE_ENDPOINT_HALT         (0)
                             2205 ; 244  |#define USB_CLEAR_FEATURE_REMOTE_WAKEUP         (1)
                             2206 ; 245  |
                             2207 ; 246  |
                             2208 ; 247  |// Struct Device Descriptor
                             2209 ; 248  |typedef struct {
                             2210 ; 249  |    BYTE    bLength;                // (0) Size of this descriptor in bytes (18)
                             2211 ; 250  |    BYTE    btDescriptorType;       // (1) Device descriptor type (1)
                             2212 ; 251  |    BYTE    btBcdUsbLsb;            // (2) USB specification release number (for version 2.00 0x00)
                             2213 ; 252  |    BYTE    btBcdUsbMsb;            // (3)                                  (for version 2.00 0x02)     
                             2214 ; 253  |    BYTE    btDeviceClass;          // (4) Class code
                             2215 ; 254  |    BYTE    btDeviceSubclass;       // (5) Subclass code
                             2216 ; 255  |    BYTE    btDeviceProtocol;       // (6) Protocol code
                             2217 ; 256  |    BYTE    btMaxPacketSize0;       // (7) Maximum packet size for endpoint 0 (8, 16, 32 or 64)
                             2218 ; 257  |    BYTE    btIdVendorLsb;          // (8) Vendor Id
                             2219 ; 258  |    BYTE    btIdVendorMsb;          // (9)
                             2220 ; 259  |    BYTE    btIdProductLsb;         // (10) Product Id
                             2221 ; 260  |    BYTE    btIdProductMsb;         // (11)
                             2222 ; 261  |    BYTE    btBcdReleaseLsb;        // (12) Device release number in BCD
                             2223 ; 262  |    BYTE    btBcdReleaseMsb;        // (13)
                             2224 ; 263  |    BYTE    btIndexManufacturer;    // (14) Index of string descriptor describing Manufacturer
                             2225 ; 264  |    BYTE    btIndexProduct;         // (15) Index of string descriptor describing Product
                             2226 ; 265  |    BYTE    btIndexSerialNumber;    // (16) Index of string descriptor describing Device Serial Number
                             2227 ; 266  |    BYTE    btNumConfigurations;    // (17) Number of possible configurations
                             2228 ; 267  |} Struct_Standard_Dev_Desc;
                             2229 ; 268  |
                             2230 ; 269  |// Struct Device Qualifier Descriptor
                             2231 ; 270  |typedef struct {
                             2232 ; 271  |    BYTE    bLength;                // (0) Size of this descriptor in bytes (10)
                             2233 ; 272  |    BYTE    btDescriptorType;       // (1) Device descriptor type (6)
                             2234 ; 273  |    BYTE    btBcdUsbLsb;            // (2) USB specification release number (for version 2.00 0x00)
                             2235 ; 274  |    BYTE    btBcdUsbMsb;            // (3)                                  (for version 2.00 0x02)     
                             2236 ; 275  |    BYTE    btDeviceClass;          // (4) Class code
                             2237 ; 276  |    BYTE    btDeviceSubclass;       // (5) Subclass code
                             2238 ; 277  |    BYTE    btDeviceProtocol;       // (6) Protocol code
                             2239 ; 278  |    BYTE    btMaxPacketSize0;       // (7) Maximum packet size for endpoint 0 other speed (8, 16, 32 or 64)
                             2240 ; 279  |    BYTE    btNumConfigurations;    // (8) Number of other-speed possible configurations
                             2241 ; 280  |    BYTE    btReserved;             // (9) Reserved for future use, must be 0
                             2242 ; 281  |} Struct_Dev_Qualifier_Desc;
                             2243 ; 282  |
                             2244 ; 283  |// Struct Configuration Descriptor
                             2245 ; 284  |typedef struct {
                             2246 ; 285  |    BYTE    bLength;                // (0) Size of this descriptor in bytes (9)
                             2247 ; 286  |    BYTE    btDescriptorType;       // (1) Device descriptor type (2 or 7)
                             2248 ; 287  |    BYTE    btTotalLengthLsb;       // (2) Total length of data returned for this config.
                             2249 ; 288  |    BYTE    btTotalLengthMsb;       // (3)                                  
                             2250 ; 289  |    BYTE    btNumInterfaces;        // (4) Number of Interfaces supported by this configuration
                             2251 ; 290  |    BYTE    btConfigurationValue;   // (5) Value to use as an argument to the SetConfiguration() request
                             2252 ; 291  |    BYTE    btIndexConfiguration;   // (6) Index of string descriptor describing this configuration
                             2253 ; 292  |    BYTE    btBitMapAttributes;     // (7) Configuration Characteristics
                             2254 ; 293  |                                    //     D7:      Reserved (set to one)
                             2255 ; 294  |                                    //     D6:      Self-powered
                             2256 ; 295  |                                    //     D5:      Remote Wakeup
                             2257 ; 296  |                                    //     D4..0:   Reserved (reset to zero)        
                             2258 ; 297  |    BYTE    btMaxPower;             // (8) Maximum power consumption expressed in 2mA units.
                             2259 ; 298  |} Struct_Standard_Config_Desc, Struct_Other_Speed_Config_Desc;
                             2260 ; 299  |
                             2261 ; 300  |// Struct Interface Descriptor
                             2262 ; 301  |typedef struct {
                             2263 ; 302  |    BYTE    bLength;                // (0) Size of this descriptor in bytes (9)
                             2264 ; 303  |    BYTE    btDescriptorType;       // (1) Device descriptor type (4)
                             2265 ; 304  |    BYTE    btInterfaceNum;         // (2) Number of this interface. Zero-based value.
                             2266 ; 305  |    BYTE    btAlternateSetting;     // (3)                                  
                             2267 ; 306  |    BYTE    btNumEndpoints;         // (4) Number of endpointsused by this interface (excluding endpoint 0).
                             2268 ; 307  |    BYTE    btInterfaceClass;       // (5) Class code
                             2269 ; 308  |    BYTE    btInterfaceSubClass;    // (6) Sub Class code
                             2270 ; 309  |    BYTE    btInterfaceProtocol;    // (7) Protocol Code
                             2271 ; 310  |    BYTE    btIndexInterface;       // (8) Index of string descriptor describing this interface
                             2272 ; 311  |} Struct_Standard_Interface_Desc;
                             2273 ; 312  |
                             2274 ; 313  |// Struct Endpoint Descriptor
                             2275 ; 314  |typedef struct {
                             2276 ; 315  |    BYTE    bLength;                // (0) Size of this descriptor in bytes (7)
                             2277 ; 316  |    BYTE    btDescriptorType;       // (1) Device descriptor type (5)
                             2278 ; 317  |    BYTE    btEndpointAddress;      // (2) Address of the endpoint on the USB device described by this descriptor
                             2279 ; 318  |                                    //      Bit 3..0: Endpoint number
                             2280 ; 319  |                                    //      Bit 6..4: Reserved, reset to zero
                             2281 ; 320  |                                    //      Bit 7:    Direction. Ignored for control endpoints (0 OUT, 1 IN)
                             2282 ; 321  |    BYTE    btBitMapAttributes;     // (3) Endpoint attributes
                             2283 ; 322  |                                    //      bits 1..0: Transfer Type (00 Control, 01 Iso, 10 Bulk, 11 Int)
                             2284 ; 323  |                                    //      bits 5..2: If not an iso endpoints, they are reserved and must be reset to zero.
                             2285 ; 324  |                                    //      bits 7..6: Reserved bits, must be reset to zero.                                    
                             2286 ; 325  |    BYTE    btMaxPacketSizeLsb;     // (4) Maximum packet size. Refer to standard for bits specification
                             2287 ; 326  |    BYTE    btMaxPacketSizeMsb;     // (5)
                             2288 ; 327  |    BYTE    btInterval;             // (6) Interval for polling endpoint for data transfers (refer to standard)
                             2289 ; 328  |} Struct_Standard_Endpoint_Desc;
                             2290 ; 329  |
                             2291 ; 330  |typedef struct {
TASKING DSP2410 assembler v1.5r1 Build 138 SN 00100122
                                                                                                                                                                                                                                                       Page  10

M:ADDR CODE           CYCLES LINE SOURCELINE
                             2292 ; 331  |    BYTE    btLength;                   // (0) Size of this descriptor in bytes (2*MAX_USB_LANG + 2)
                             2293 ; 332  |    BYTE    btDescriptorType;           // (1) String descriptor type (3)
                             2294 ; 333  |    BYTE    btString[MAX_STRING*2];       
                             2295 ; 334  |} Struct_String_Desc;
                             2296 ; 335  |
                             2297 ; 336  |//
                             2298 ; 337  |// Externals
                             2299 ; 338  |//
                             2300 ; 339  |extern void _reentrant usb_dci_chip_enable (void);
                             2301 ; 340  |extern void _reentrant usb_dci_shutdown(void);
                             2302 ; 341  |
                             2303 ; 342  |BYTE _reentrant usb_device_init(void);
                             2304 ; 343  |void _inline usb_device_shutdown(void)
                             2305 ; 344  |{
                             2306 ; 345  |    usb_dci_shutdown();
                             2307 ; 346  |}
                             2308 ; 347  |
                             2309 ; 348  |BYTE _reentrant usb_device_register_service(BYTE btType, void (* Service)(BOOL bSetup, BYTE btDirection, BYTE _USB_MEM * pbtBuffer, WORD wLength,WORD wPrivateData)); 
                             2310 ; 349  |//Remove unused function usb_device_get_service() to reclain _P memroy.
                             2311 ; 350  |//BYTE _reentrant usb_device_get_service(BYTE btType, void (* Service)(BOOL bSetup, BYTE btDirection, BYTE _USB_MEM * pbtBuffer, WORD wLength)); 
                             2312 ; 351  |
                             2313 ; 352  |BYTE _reentrant usb_device_init_endpoint(BYTE btEndpoint, USHORT usMaxPacketSize, BYTE btDirection, BYTE btType, BOOL bFlag);
                             2314 ; 353  |
                             2315 ; 354  |extern USB_SetupData *_reentrant usb_dci_get_setup_data(BYTE btEndpoint);
                             2316 
                             2325 
                             2326 ; 355  |#define usb_device_read_setup_data(btEndpoint) usb_dci_get_setup_data(btEndpoint)
                             2327 ; 356  |
                             2328 ; 357  |void _reentrant usb_device_get_status(BYTE btType, USHORT * pusStatus);
                             2329 ; 358  |void _reentrant usb_device_set_status(BYTE btType, USHORT usStatus);
                             2330 ; 359  |BYTE _reentrant usb_device_get_transfer_status(BYTE btEndpoint, BYTE btDirection);
                             2331 ; 360  |
                             2332 ; 361  |extern void _reentrant usb_dci_stall_endpoint(BYTE btEndpoint, BYTE btDirection);
                             2333 ; 362  |#define usb_device_stall_endpoint(btEndpoint, btDirection) usb_dci_stall_endpoint((btEndpoint), (btDirection))
                             2334 ; 363  |
                             2335 ; 364  |extern void _reentrant usb_dci_unstall_endpoint(BYTE btEndpoint, BYTE btDirection);
                             2336 ; 365  |#define usb_device_unstall_endpoint(btEndpoint, btDirection) usb_dci_unstall_endpoint((btEndpoint), (btDirection))
                             2337 ; 366  |
                             2338 ; 367  |extern void _reentrant usb_dci_finish_transaction(BYTE btEndpoint);
                             2339 ; 368  |#define usb_device_finish_transaction(btEndpoint) usb_dci_finish_transaction(btEndpoint);
                             2340 ; 369  |
                             2341 ; 370  |////////////////////////////////////////////////////////////////////////////////
                             2342 ; 371  |//
                             2343 ; 372  |//>  Name:          usb_device_enable
                             2344 ; 373  |//
                             2345 ; 374  |//   Type:          Function
                             2346 ; 375  |//
                             2347 ; 376  |//   Description:   Enables the USB device for transfers
                             2348 ; 377  |//
                             2349 ; 378  |//   Inputs:        none
                             2350 ; 379  |//
                             2351 ; 380  |//   Outputs:       USB_OK or error code
                             2352 ; 381  |//
                             2353 ; 382  |//   Notes:         none
                             2354 ; 383  |//<
                             2355 ; 384  |////////////////////////////////////////////////////////////////////////////////
                             2356 ; 385  |void _inline usb_device_enable(void)
                             2357 ; 386  |{
                             2358 ; 387  |    usb_dci_chip_enable();
                             2359 ; 388  |}
                             2360 ; 389  |
                             2361 ; 390  |void _reentrant usb_device_release(void);
                             2362 ; 391  |void _reentrant usb_device_hold(void);
                             2363 ; 392  |BYTE _reentrant usb_device_is_hold(void);
                             2364 ; 393  |void _reentrant usb_device_data_phase_required(void);
                             2365 ; 394  |
                             2366 ; 395  |BOOL _reentrant usb_device_is_first_init(void);
                             2367 ; 396  |void _reentrant usb_device_set_first_init(void);
                             2368 ; 397  |void _reentrant usb_device_clear_first_init(void);
                             2369 ; 398  |
                             2370 ; 399  |WORD _reentrant usb_get_current_limit(void);
                             2371 ; 400  |RETCODE _reentrant usb_set_current_limit(WORD);
                             2372 ; 401  |
                             2373 ; 402  |////////////////////////////////////////////////////////////////////
                             2374 ; 403  |extern BYTE _reentrant usb_dci_get_endpoint_status(BYTE btEndpoint);
                             2375 ; 404  |#define usb_device_get_endpoint_status(btEndpoint) usb_dci_get_endpoint_status(btEndpoint)
                             2376 ; 405  |
                             2377 ; 406  |#define USB_ENDPOINT_STATUS_OK                          0
                             2378 ; 407  |#define USB_ENDPOINT_STATUS_STALLED                     1
                             2379 ; 408  |#define USB_ENDPOINT_STATUS_RECIEVED_UNSTALL_REQUEST    2
                             2380 ; 409  |// WHQL
                             2381 ; 410  |#define USB_ENDPOINT_STATUS_HOST_STALLED                3
                             2382 ; 411  |////////////////////////////////////////////////////////////////////
                             2383 ; 412  |
                             2384 ; 413  |
                             2385 ; 414  |BYTE _reentrant usb_device_send_data(BYTE btEndpoint, WORD _X * pbtStmpWordAdd, BYTE btByteOffset, USHORT usSize, WORD wPrivateData, BOOL bIsDataPhase);
                             2386 ; 415  |BYTE _reentrant usb_device_recv_data(BYTE btEndpoint, WORD _X * pbtStmpWordAdd, BYTE btByteOffset, USHORT usSize, WORD wPrivateData, BOOL bIsDataPhase);
                             2387 ; 416  |void _reentrant ch9ServiceEp0(BOOL bSetup, BYTE btDirection, WORD _X *pbtBuffer, WORD wLength,WORD wPrivateData);
                             2388 ; 417  |BYTE _reentrant usb_device_transfer_data(BYTE btEndpoint, WORD _X* pbtStmpWordAdd, 
                             2389 ; 418  |                                         BYTE btByteOffset, USHORT usSize, WORD wPrivateData, 
                             2390 ; 419  |                                         BOOL bIsDataPhase, WORD wDirection);
                             2391 ; 420  |
                             2392 ; 421  |#ifndef CUSTOMIZE_UNICODE
                             2393 ; 422  |extern const BYTE g_Manufacturer[];
                             2394 ; 423  |extern const BYTE g_ProductName[];
                             2395 ; 424  |extern const BYTE g_ConfigString[];
                             2396 ; 425  |extern const BYTE g_Interface0String[];
                             2397 ; 426  |extern const BYTE g_Interface1String[];
                             2398 ; 427  |extern const BYTE g_MSOSDescriptorString[];
                             2399 ; 428  |#else   // CUSTOMIZE_UNICODE
                             2400 ; 429  |extern const WORD g_Manufacturer[];
                             2401 ; 430  |extern const WORD g_ProductName[];
                             2402 ; 431  |extern const WORD g_ConfigString[];
                             2403 ; 432  |extern const WORD g_Interface0String[];
                             2404 ; 433  |extern const WORD g_Interface1String[];
                             2405 ; 434  |extern const WORD g_MSOSDescriptorString[];
                             2406 ; 435  |#endif
                             2407 ; 436  |extern WORD g_LanguageList[];
                             2408 ; 437  |
                             2409 ; 438  |extern const BYTE g_SCSIVendorID[];
                             2410 ; 439  |extern const BYTE g_SCSIProductID[];
                             2411 ; 440  |extern void *g_pStrings[];
                             2412 ; 441  |
                             2413 ; 442  |extern WORD g_wUSBVendorID;
                             2414 ; 443  |extern WORD g_wUSBProductID;
                             2415 ; 444  |extern WORD g_wUSBReleaseID;
                             2416 ; 445  |
                             2417 ; 446  |#endif
                             2418 ; 447  |/* EOF */
                             2419 ; 448  |
                             2420 
                             2422 
                             2423 ; 19   |#include "usb_internal.h"
                             2424 
                             2426 
                             2427 ; 1    |#ifndef _USB_INTERNAL_H
                             2428 ; 2    |#define _USB_INTERNAL_H
                             2429 ; 3    |
                             2430 ; 4    |#include "project.h"
                             2431 
                             2433 
                             2434 ; 1    |/////////////////////////////////////////////////////////////////////////////////
                             2435 ; 2    |//  Copyright(C) SigmaTel, Inc. 2000-2004
                             2436 ; 3    |//  Filename: project.inc
                             2437 ; 4    |//  Description: 
                             2438 ; 5    |/////////////////////////////////////////////////////////////////////////////////
                             2439 ; 6    |
                             2440 ; 7    |#if (!defined(_PROJECT_INC))
                             2441 ; 8    |#define _PROJECT_INC 1
                             2442 ; 9    |
                             2443 ; 10   |#if defined(STMP_BUILD_PLAYER)
                             2444 ; 11   |#include "hwequ.h"
                             2445 ; 12   |#else 
                             2446 ; 13   |//include "regscodec.inc"
                             2447 ; 14   |#endif
                             2448 ; 15   |
                             2449 ; 16   |//////////////////////////////////////////////////////////////////////////////////
                             2450 ; 17   |// Uncomment next define to allow player boot if you have stfm1000 macro enabled (defaults ON) & 
                             2451 ; 18   |// your board crystal is not able to output nominal voltage range. Used in player main.asm. STMP00012148
                             2452 ; 19   |// Defining this will result in lower battery life (price of using a lower quality crystal). 
                             2453 ; 20   |// Those that want to save battery life and have good crystals that meet our HW team's specs can 
                             2454 ; 21   |// comment out this line to reduce crystal bias current and so battery current in player mode.  
                             2455 ; 22   |#define SUPPORT_MARGINAL_XTALS 1
                             2456 ; 23   |
                             2457 ; 24   |/////////////////////////////////////////////////////////////////////////////////
                             2458 ; 25   |// BOOT SPEED CONFIG & ASSOCIATED BATTERY VOLTAGE CHECK ENABLE
                             2459 ; 26   |/////////////////////////////////////////////////////////////////////////////////
                             2460 ; 27   |// Users can enable one of ATTEMPT_FAST_BOOT or FASTEST boot or neither project define below by defining
                             2461 ; 28   |// values as 0 or 1, else it defaults to the boot speed used in previous SDKs.
                             2462 ; 29   |#define ATTEMPT_FAST_BOOT 1
                             2463 ; 30   |#define ATTEMPT_FASTEST_BOOT 0   
                             2464 ; 31   |// Changing this define to 0 removes Vbat threshholding & unconditionally gives fast boot config above- 
                             2465 ; 32   |// disabling this check is suggested for profiling if you want to try to tweak down threshholds by maybe 50mV.
                             2466 ; 33   |// Also the tests should clear the fast boot config defines to link & boot at normal speed.
                             2467 ; 34   |#define SPEED_BOOT_BATTERY_CHECK 1
                             2468 ; 35   |
                             2469 ; 36   |/////////////////////////////////////////////////////////////////////////////////
                             2470 ; 37   |// MEDIA DEFINITIONS
                             2471 ; 38   |/////////////////////////////////////////////////////////////////////////////////
                             2472 ; 39   |
                             2473 ; 40   |/////////////////////////////////////////////////////////////////////////////////
                             2474 ; 41   |// MNAND - Number of chips forming the internal physical device (i.e. # of NANDs)
                             2475 ; 42   |#if defined(NAND1)
                             2476 ; 43   |#define SM_INTERNAL_CHIPS 1
                             2477 ; 44   |#else 
                             2478 ; 45   |#if defined(NAND2)
                             2479 ; 46   |#define SM_INTERNAL_CHIPS 2
                             2480 ; 47   |#else 
                             2481 ; 48   |#if defined(NAND3)
                             2482 ; 49   |#define SM_INTERNAL_CHIPS 3
                             2483 ; 50   |#else 
                             2484 ; 51   |#if defined(NAND4)
                             2485 ; 52   |#define SM_INTERNAL_CHIPS 4
                             2486 ; 53   |#else 
                             2487 ; 54   |#define SM_INTERNAL_CHIPS 1
                             2488 ; 55   |#endif
                             2489 ; 56   |#endif
                             2490 ; 57   |#endif
                             2491 ; 58   |#endif
                             2492 ; 59   |
                             2493 ; 60   |/////////////////////////////////////////////////////////////////////////////////
                             2494 ; 61   |// If SMARTMEDIA_DETECT_ACTIVE_HIGH is defined:
                             2495 ; 62   |//   SmartMedia will be detected as inserted if the GPIO pin reads 1 and removed if it reads 0.  
                             2496 ; 63   |// If SMARTMEDIA_DETECT_ACTIVE_HIGH is not defined ** comment out next line **
                             2497 ; 64   |//   SmartMedia will be detected as inserted if the GPIO pin reads 0 and removed if it reads 1.
                             2498 ; 65   |//*** comment out if active high ****
                             2499 ; 66   |//SMARTMEDIA_DETECT_ACTIVE_HIGH  equ     1
                             2500 ; 67   |
                             2501 ; 68   |#if defined(SMEDIA)
                             2502 ; 69   |#define NUM_REMOVABLE_MEDIA 1
                             2503 ; 70   |#define NUM_SM_EXTERNAL 1
                             2504 ; 71   |#define MMC_MAX_PHYSICAL_DEVICES 0
                             2505 ; 72   |#define SM_MAX_LOGICAL_DEVICES 2
                             2506 ; 73   |#else 
                             2507 ; 74   |#if defined(MMC)
                             2508 ; 75   |#define NUM_REMOVABLE_MEDIA 1
                             2509 ; 76   |#define NUM_SM_EXTERNAL 0
                             2510 ; 77   |#define MMC_MAX_PHYSICAL_DEVICES 1
                             2511 ; 78   |#define SM_MAX_LOGICAL_DEVICES 1
                             2512 ; 79   |#else 
                             2513 ; 80   |#define NUM_REMOVABLE_MEDIA 0
                             2514 ; 81   |#define NUM_SM_EXTERNAL 0
                             2515 ; 82   |#define MMC_MAX_PHYSICAL_DEVICES 0
                             2516 ; 83   |#define SM_MAX_LOGICAL_DEVICES 1
                             2517 ; 84   |#endif
                             2518 ; 85   |#endif
                             2519 ; 86   |
                             2520 ; 87   |/////////////////////////////////////////////////////////////////////////////////
                             2521 ; 88   |// Mass Storage Class definitions
                             2522 ; 89   |/////////////////////////////////////////////////////////////////////////////////
                             2523 ; 90   |// Set to 0 if Composite Device build is desired.    
                             2524 ; 91   |#define MULTI_LUN_BUILD 1   
                             2525 ; 92   |
                             2526 ; 93   |////////////////////////////////////////////////////////////////////////////////
                             2527 ; 94   |//  SCSI
                             2528 ; 95   |#if (MULTI_LUN_BUILD==0)
                             2529 ; 96   |  #if (NUM_REMOVABLE_MEDIA == 1)
                             2530 ; 97   |    #define SCSI_NUM_TARGETS                        2
                             2531 ; 98   |    #define SCSI_DEVICE_NUM_LUNS_DEV_0              1
                             2532 ; 99   |    #define SCSI_DEVICE_NUM_LUNS_DEV_1              1
                             2533 ; 100  |  #else
                             2534 ; 101  |    #define SCSI_NUM_TARGETS                        1
                             2535 ; 102  |    #define SCSI_DEVICE_NUM_LUNS_DEV_0              1
                             2536 ; 103  |  #endif
                             2537 ; 104  |#else
                             2538 ; 105  |    #define SCSI_NUM_TARGETS                        1
                             2539 ; 106  |  #if (NUM_REMOVABLE_MEDIA == 1)
                             2540 ; 107  |    #define SCSI_DEVICE_NUM_LUNS_DEV_0              2
                             2541 ; 108  |  #else
                             2542 ; 109  |    #define SCSI_DEVICE_NUM_LUNS_DEV_0              1  
                             2543 ; 110  |  #endif
                             2544 ; 111  |#endif
                             2545 ; 112  |
                             2546 ; 113  |
                             2547 ; 114  |#define USBMSC_NUM_DEVICES                      SCSI_NUM_TARGETS
                             2548 ; 115  |
                             2549 ; 116  |
                             2550 ; 117  |////////////////////////////////////////////////////////////////////////////////
                             2551 ; 118  |// Define number of logical medias and drives for three builds (MTP, USBMSC, and Player)
                             2552 ; 119  |////////////////////////////////////////////////////////////////////////////////
                             2553 ; 120  |#ifdef MMC
TASKING DSP2410 assembler v1.5r1 Build 138 SN 00100122
                                                                                                                                                                                                                                                       Page  11

M:ADDR CODE           CYCLES LINE SOURCELINE
                             2554 ; 121  |#ifdef MTP_BUILD
                             2555 ; 122  |// --------------------
                             2556 ; 123  |// MTP and MMC
                             2557 ; 124  |// --------------------
                             2558 ; 125  |#define NUM_LOGICAL_MEDIA       2
                             2559 ; 126  |#define NUM_LOGICAL_DRIVES      8
                             2560 ; 127  |#else  // ifndef MTP_BUILD
                             2561 ; 128  |#ifdef STMP_BUILD_PLAYER
                             2562 ; 129  |// --------------------
                             2563 ; 130  |// Player and MMC
                             2564 ; 131  |// --------------------
                             2565 ; 132  |#else
                             2566 ; 133  |// --------------------
                             2567 ; 134  |// USBMSC and MMC
                             2568 ; 135  |// --------------------
                             2569 ; 136  |#define NUM_LOGICAL_MEDIA       3
                             2570 ; 137  |#define NUM_LOGICAL_DRIVES      8
                             2571 ; 138  |#endif // ifdef STMP_BUILD_PLAYER
                             2572 ; 139  |#endif // ifdef MTP_BUILD
                             2573 ; 140  |#else  // ifndef MMC
                             2574 ; 141  |#ifdef MTP_BUILD
                             2575 ; 142  |// --------------------
                             2576 ; 143  |// MTP and NAND only
                             2577 ; 144  |// --------------------
                             2578 ; 145  |#define NUM_LOGICAL_MEDIA       1
                             2579 ; 146  |#define NUM_LOGICAL_DRIVES      7
                             2580 ; 147  |#else  // ifndef MTP_BUILD
                             2581 ; 148  |#ifdef STMP_BUILD_PLAYER
                             2582 ; 149  |// --------------------
                             2583 ; 150  |// Player and NAND only
                             2584 ; 151  |// --------------------
                             2585 ; 152  |#else
                             2586 ; 153  |// --------------------
                             2587 ; 154  |// USBMSC and NAND only
                             2588 ; 155  |// --------------------
                             2589 ; 156  |#define NUM_LOGICAL_MEDIA       2
                             2590 ; 157  |#define NUM_LOGICAL_DRIVES      7
                             2591 ; 158  |#endif // ifdef STMP_BUILD_PLAYER
                             2592 ; 159  |#endif // ifdef MTP_BUILD
                             2593 ; 160  |#endif // ifdef MMC 
                             2594 ; 161  |
                             2595 ; 162  |// If we are in an MTP build then we don't use as many transfers buffers.
                             2596 ; 163  |#if (defined(MTP_BUILD))
                             2597 ; 164  |#define MAX_USB_TRANSFERS_QUEUED 16
                             2598 ; 165  |
                             2599 ; 166  |////!
                             2600 ; 167  |////! This varible holds the watchdog count for the store flush.
                             2601 ; 168  |////!
                             2602 ; 169  |///
                             2603 ; 170  |#include <types.h>
                             2604 ; 171  |extern volatile INT g_StoreWatchDogCount;
                             2605 ; 172  |extern const INT g_StoreWatchDogTimeout;
                             2606 ; 173  |#endif
                             2607 ; 174  |
                             2608 ; 175  |////////////////////////////////////////////////////////////////////////////////
                             2609 ; 176  |// These are needed here for Mass Storage Class
                             2610 ; 177  |// Needs to be cleaned up
                             2611 ; 178  |////////////////////////////////////////////////////////////////////////////////
                             2612 ; 179  |#if (!defined(STMP_BUILD_PLAYER))
                             2613 ; 180  |#define SCRATCH_USER_Y_SIZE 512
                             2614 ; 181  |#define SCRATCH_USER_X_SIZE 512
                             2615 ; 182  |
                             2616 ; 183  |#define BROWNOUT_LEVEL1_DETECTED                0x000001
                             2617 ; 184  |
                             2618 ; 185  |#endif
                             2619 ; 186  |
                             2620 ; 187  |
                             2621 ; 188  |/////////////////////////////////////////////////////////////////////////////////
                             2622 ; 189  |// SmartMedia/NAND defs
                             2623 ; 190  |#define SM_MAX_PHYSICAL_DEVICES SM_INTERNAL_CHIPS+NUM_SM_EXTERNAL
                             2624 ; 191  |#define SM_REMOVABLE_DEVICE_NUM SM_INTERNAL_CHIPS
                             2625 ; 192  |
                             2626 ; 193  |/////////////////////////////////////////////////////////////////////////////////
                             2627 ; 194  |// Sysloadresources defs
                             2628 ; 195  |#define SM_MAX_RESOURCE_DEVICES SM_INTERNAL_CHIPS+NUM_SM_EXTERNAL
                             2629 ; 196  |
                             2630 ; 197  |/////////////////////////////////////////////////////////////////////////////////
                             2631 ; 198  |// MMC defs
                             2632 ; 199  |#define MMC_MAX_PARTITIONS 1
                             2633 ; 200  |#define MMC_MAX_LOGICAL_DEVICES MMC_MAX_PHYSICAL_DEVICES*MMC_MAX_PARTITIONS
                             2634 ; 201  |
                             2635 ; 202  |/////////////////////////////////////////////////////////////////////////////////
                             2636 ; 203  |// SPI defs
                             2637 ; 204  |#define SPI_MAX_DEVICES MMC_MAX_PHYSICAL_DEVICES
                             2638 ; 205  |
                             2639 ; 206  |/////////////////////////////////////////////////////////////////////////////////
                             2640 ; 207  |// Global media defs
                             2641 ; 208  |#define MAX_PHYSICAL_DEVICES SM_MAX_PHYSICAL_DEVICES+MMC_MAX_PHYSICAL_DEVICES
                             2642 ; 209  |#define MAX_LOGICAL_DEVICES SM_MAX_LOGICAL_DEVICES+MMC_MAX_LOGICAL_DEVICES
                             2643 ; 210  |
                             2644 ; 211  |/////////////////////////////////////////////////////////////////////////////////
                             2645 ; 212  |// DO NOT CHANGE THESE!!!
                             2646 ; 213  |#define SM_MAX_PARTITIONS 4
                             2647 ; 214  |#define MAX_HANDLES 2
                             2648 ; 215  |/////////////////////////////////////////////////////////////////////////////////
                             2649 ; 216  |
                             2650 ; 217  |
                             2651 ; 218  |/////////////////////////////////////////////////////////////////////////////////
                             2652 ; 219  |// Battery LRADC Values 
                             2653 ; 220  |/////////////////////////////////////////////////////////////////////////////////
                             2654 ; 221  |// brownout trip point in mV (moved by RS)
                             2655 ; 222  |// BATT_SAFETY_MARGIN:  percentage value used by:
                             2656 ; 223  |//   * SysSaveSettings to determine if enough power is left to attempt a settings save. 
                             2657 ; 224  |//   * Recorder to conditionally prevent the start or continuation of 
                             2658 ; 225  |//     audio recording to media.
                             2659 ; 226  |#define BATT_SAFETY_MARGIN 10
                             2660 ; 227  |
                             2661 ; 228  |//; player resource drive refresh allowed only when battery usable % is above this value. 
                             2662 ; 229  |//; 50% of usable range [0.9V to 1.5V] is around 1.2V This is the safe target alkaline voltage to do a refresh.
                             2663 ; 230  |//; LIION will also require 50% which will work but that could be changed in the future. 
                             2664 ; 231  |//RESOURCE_REFRESH_MIN_BATT_PCT equ 50
                             2665 ; 232  |
                             2666 ; 233  |// stmp00005071 adds these for mp3 encode stability at low battery per battery type & mmc presence.
                             2667 ; 234  |
                             2668 ; 235  |//// Vbat threshholds empirically tuned by profiling max bat current for 3 HW cases: 
                             2669 ; 236  |//// 1 GigaByte MMC, NAND flash only, & LiIon Buck mode. See voicemenu pre-encode Vbat check.
                             2670 ; 237  |#if (!defined(CLCD))
                             2671 ; 238  |#define MP3_ENC_MMC_MIN_V_BAT_MV 1100
                             2672 ; 239  |#define MP3_ENC_NANDONLY_MIN_V_BAT_MV 1000
                             2673 ; 240  |#else 
                             2674 ; 241  |#define MP3_ENC_MMC_MIN_V_BAT_MV 1250
                             2675 ; 242  |#define MP3_ENC_NANDONLY_MIN_V_BAT_MV 1150
                             2676 ; 243  |#endif
                             2677 ; 244  |#define MP3_ENC_BUCKMODE_MIN_V_BAT_MV 3300
                             2678 ; 245  |
                             2679 ; 246  |// These Vbat use-range-percentages are derived to correspond with target battery 
                             2680 ; 247  |// voltages of 1.10V for MMC, 1.0V for nand only (alkaline or nimh), and 3.3V for any LiIon.
                             2681 ; 248  |// See mp3 encoder overlay.
                             2682 ; 249  |#define MP3_ENC_MMC_MIN_V_BAT_RANGE_PCT 33
                             2683 ; 250  |#define MP3_ENC_NANDONLY_MIN_V_BAT_RANGE_PCT 17
                             2684 ; 251  |#define MP3_ENC_BUCKMODE_MIN_V_BAT_RANGE_PCT 25
                             2685 ; 252  |
                             2686 ; 253  |/////////////////////////////////////////////////////////////////////////////////
                             2687 ; 254  |// Voice recording filenames
                             2688 ; 255  |// number of digits in filename Vxxx.wav
                             2689 ; 256  |/////////////////////////////////////////////////////////////////////////////////
                             2690 ; 257  |#define DIGITS_IN_VOICE_FILENAME 3   
                             2691 ; 258  |
                             2692 ; 259  |/////////////////////////////////////////////////////////////////////////////////
                             2693 ; 260  |// Mic Bias: Set this enable to 1 to internally generate mic bias voltage. 
                             2694 ; 261  |// Also below, must configure internal resistor value and pin to use for DC bias. 
                             2695 ; 262  |// Can set to 0 to disable internally generated mic bias voltage at pin lradc1/2.
                             2696 ; 263  |#if defined(DEVICE_3500)
                             2697 ; 264  |#define ENABLE_INTERNALLY_GENERATED_MICBIAS 1 
                             2698 ; 265  |// MIC BIAS circuit source selection: use Low Resolution ADC pin 2 or 1 to bias mic. 
                             2699 ; 266  |// Per your layout: select LRADC 2 or 1 below 
                             2700 ; 267  |//   (pin LRADC 2 for 35xx cpu card revB, LRADC 1 for 35xx cpu card revC, ref schematics, & demo player)
                             2701 ; 268  |#define LRADC_NUM_FOR_MIC_BIAS 1 
                             2702 ; 269  |// Sets internal mic bias R to value 2, 4, or 8 (in kOhms).
                             2703 ; 270  |#define MICBIAS_CONFIGURED_RESISTOR_KOHMS 8
                             2704 ; 271  |
                             2705 ; 272  |// Allows mic bias to settle before sampling. This delay currently unused. For rec btn when bias not yet ready.
                             2706 ; 273  |#define REC_BTN_INTERNAL_MIC_BIAS_SETTLING_DELAY_MS 400 
                             2707 ; 274  |// Option always keeps bias enabled after mainmenu init. This allows for start pop prevention if you use rec button from outside voice menu.
                             2708 ; 275  |// This selection costs 1 mWatt but gains the desired low record button to sampling latency in the record-from-music-menu use-case.
                             2709 ; 276  |#define KEEP_MIC_BIAS_ENABLED 0
                             2710 ; 277  |
                             2711 ; 278  |#else 
                             2712 ; 279  |// STMP3410
                             2713 ; 280  |#define ENABLE_INTERNALLY_GENERATED_MICBIAS 0
                             2714 ; 281  |#define LRADC_NUM_FOR_MIC_BIAS 1 
                             2715 ; 282  |#define MICBIAS_CONFIGURED_RESISTOR_KOHMS 2
                             2716 ; 283  |#endif
                             2717 ; 284  |
                             2718 ; 285  |/////////////////////////////////////////////////////////////////////////////////
                             2719 ; 286  |// Number of available soft timers
                             2720 ; 287  |/////////////////////////////////////////////////////////////////////////////////
                             2721 ; 288  |#if defined(SYNC_LYRICS)
                             2722 ; 289  |#define SOFT_TIMERS 10
                             2723 ; 290  |#else 
                             2724 ; 291  |#if defined(JPEG_DECODER)
                             2725 ; 292  |#define SOFT_TIMERS 10
                             2726 ; 293  |#else 
                             2727 ; 294  |#define SOFT_TIMERS 9
                             2728 ; 295  |#endif
                             2729 ; 296  |#endif
                             2730 ; 297  |
                             2731 ; 298  |/////////////////////////////////////////////////////////////////////////////////
                             2732 ; 299  |//  sizes
                             2733 ; 300  |/////////////////////////////////////////////////////////////////////////////////
                             2734 ; 301  |#if defined(MMC)
                             2735 ; 302  |#if defined(USE_PLAYLIST5)
                             2736 ; 303  |#define MENU_STACK_SIZE 1500
                             2737 ; 304  |#else 
                             2738 ; 305  |#define MENU_STACK_SIZE 1250
                             2739 ; 306  |#endif //if @def('USE_PLAYLIST5')
                             2740 ; 307  |#else 
                             2741 ; 308  |#if defined(USE_PLAYLIST5)
                             2742 ; 309  |#define MENU_STACK_SIZE 1500
                             2743 ; 310  |#else 
                             2744 ; 311  |#define MENU_STACK_SIZE 1250
                             2745 ; 312  |#endif //if @def('USE_PLAYLIST5')
                             2746 ; 313  |#endif //if @def('MMC')
                             2747 ; 314  |
                             2748 ; 315  |// NOTE: SDK2.6 USED 550 FOR NEXT LINE, BUT SDK3.0BETA USED 750. Should it be ifdef MTP 750 else 550 for other builds? TOVERIFY. MYALLOC
                             2749 ; 316  |// 
                             2750 ; 317  |#define STACK_L1_SIZE 750
                             2751 ; 318  |#define STACK_L2_SIZE 100
                             2752 ; 319  |#define STACK_L3_SIZE 160
                             2753 ; 320  |
                             2754 ; 321  |// If we are in MTP mode the overlay task stack can shrink.
                             2755 ; 322  |// TODO shrink this stack for MTP, I will leave it at 500 until we verify that it 
                             2756 ; 323  |// is ok with switching code.
                             2757 ; 324  |#if defined(MTP_BUILD)
                             2758 ; 325  |#define OVERLAY_MANAGER_STACK_SIZE 300
                             2759 ; 326  |#endif
                             2760 ; 327  |
                             2761 ; 328  |/////////////////////////////////////////////////////////////////////////////////
                             2762 ; 329  |// maximum number of nested funclets 
                             2763 ; 330  |/////////////////////////////////////////////////////////////////////////////////
                             2764 ; 331  |#define MAX_NESTED_FUNCLET 6 
                             2765 ; 332  |
                             2766 ; 333  |/////////////////////////////////////////////////////////////////////////////////
                             2767 ; 334  |//    LCD DEFINITIONS
                             2768 ; 335  |/////////////////////////////////////////////////////////////////////////////////
                             2769 ; 336  |
                             2770 ; 337  |#define SPACE_CHAR 0x000020          
                             2771 ; 338  |#define ZERO_CHAR 0x000030
                             2772 ; 339  |#define COLON_CHAR 0x00003A
                             2773 ; 340  |#define PERIOD_CHAR 0x00002E
                             2774 ; 341  |
                             2775 ; 342  |#if (defined(S6B33B0A_LCD))
                             2776 ; 343  |#define LCD_X_SIZE 128
                             2777 ; 344  |#define LCD_Y_SIZE 159
                             2778 ; 345  |#endif
                             2779 ; 346  |
                             2780 ; 347  |#if (defined(SED15XX_LCD))
                             2781 ; 348  |#define LCD_X_SIZE 128
                             2782 ; 349  |#define LCD_Y_SIZE 64
                             2783 ; 350  |#endif
                             2784 ; 351  |
                             2785 ; 352  |
                             2786 ; 353  |//////////////////////////////////////////////////////////////////////////////////
                             2787 ; 354  |//   Details on Customizing Contrast
                             2788 ; 355  |/////////////////////////////////////////////////////////////////////////////////
                             2789 ; 356  |//   Max supported LCD range is 0 - 3F; however due to hardware/voltage differences
                             2790 ; 357  |//   the range of visibility is usually smaller than this.  It is important to 
                             2791 ; 358  |//   calibrate the visible range, because the contrast setting is saved.
                             2792 ; 359  |//   If the user shuts off the player while lcd is not visible, the player is useless
                             2793 ; 360  |//   unless the ezact sequence is remembered.
                             2794 ; 361  |//   To find out what range your player supports: 
                             2795 ; 362  |//   change these equs to full range or comment out (full range is default)
                             2796 ; 363  |//;;;;;;
                             2797 ; 364  |// uncomment the line below to build code that will provide raw contrast value
                             2798 ; 365  |// recommended calibration using player -- uncomment 
                             2799 ; 366  |//;;;;;;
                             2800 ; 367  |//CONTRAST_CALIBRATION    equ  1
                             2801 ; 368  |////////////////////////////
                             2802 ; 369  |#if (defined(DEMO_HW))
                             2803 ; 370  |// this is the setting for ET301 demos; Next 2 line have not been updated for new Shingyi LCD (June6'05)
                             2804 ; 371  |#define LCD_MAX_CONTRAST 0x32 
TASKING DSP2410 assembler v1.5r1 Build 138 SN 00100122
                                                                                                                                                                                                                                                       Page  12

M:ADDR CODE           CYCLES LINE SOURCELINE
                             2805 ; 372  |#define LCD_MIN_CONTRAST 0x1E
                             2806 ; 373  |#else 
                             2807 ; 374  |
                             2808 ; 375  |#if (defined(S6B33B0A_LCD))
                             2809 ; 376  |#define LCD_MAX_CONTRAST 210
                             2810 ; 377  |#define LCD_MIN_CONTRAST 160    
                             2811 ; 378  |#endif
                             2812 ; 379  |
                             2813 ; 380  |#if (defined(SED15XX_LCD))
                             2814 ; 381  |// Next 3 line comment was for OLD shingyi LCD: (default LCD before sdk2.6)
                             2815 ; 382  |// Engineering board regs support range [17-37].
                             2816 ; 383  |//   Engineering board DC/DC support range [24-46]. 
                             2817 ; 384  |//   One default contrast range [24-42] works for both.
                             2818 ; 385  |// The 3 sets of contrast ranges below are updated for SDK2.6 to support either 
                             2819 ; 386  |// new or old ShingYih LCDs. "File" refers to \resource\shingyih\system_lcd_init_seq.src
                             2820 ; 387  |// 3/10/05 - Use one of the 2 next contrast ranges depending on which
                             2821 ; 388  |// ShingYih LCD you have.  See \resources\shingyi\readme.txt 
                             2822 ; 389  |// Optimal for NEW LCD with NEW file (SDK2.6 default)  
                             2823 ; 390  |// G098064-41 LCD module (present on engr board revH LCD card)
                             2824 ; 391  |
                             2825 ; 392  |#if (defined(NEWSHINGYIH))
                             2826 ; 393  |#define LCD_MAX_CONTRAST 250
                             2827 ; 394  |#define LCD_MIN_CONTRAST 0
                             2828 ; 395  |#else 
                             2829 ; 396  |//-----
                             2830 ; 397  |// Near optimal for OLD LCD with NEW file. 
                             2831 ; 398  |// NOT optimal for the new lcd but pretty good. So u may use this if u want 1 build for both LCDs.
                             2832 ; 399  |#define LCD_MAX_CONTRAST 250
                             2833 ; 400  |#define LCD_MIN_CONTRAST 0
                             2834 ; 401  |
                             2835 ; 402  |//=====
                             2836 ; 403  |// Optimal for OLD ShingYih LCD with OLD file (as sdk2.521)
                             2837 ; 404  |// Suggest going with default new init file & values above for your LCD instead of this historic ver.
                             2838 ; 405  |//LCD_MAX_CONTRAST equ 42
                             2839 ; 406  |//LCD_MIN_CONTRAST equ 24 
                             2840 ; 407  |
                             2841 ; 408  |#endif
                             2842 ; 409  |#endif
                             2843 ; 410  |
                             2844 ; 411  |#endif
                             2845 ; 412  |
                             2846 ; 413  |//////////////////////////////////////////////////////////////////////////////////
                             2847 ; 414  |// The default value of the lcd contrast in % of range
                             2848 ; 415  |//   the default value is used when no settings.dat is available
                             2849 ; 416  |//////////////////////////////////////////////////////////////////////////////////
                             2850 ; 417  |
                             2851 ; 418  |#if (defined(S6B33B0A_LCD))
                             2852 ; 419  |// 60% of range is default value
                             2853 ; 420  |#define DEFAULT_CONTRAST 50 
                             2854 ; 421  |#endif
                             2855 ; 422  |
                             2856 ; 423  |#if (defined(SED15XX_LCD))
                             2857 ; 424  |// % of range is default value (was 60%)
                             2858 ; 425  |#define DEFAULT_CONTRAST 50 
                             2859 ; 426  |#endif
                             2860 ; 427  |
                             2861 ; 428  |
                             2862 ; 429  |// percentage change per increment/decrement message (LCD_DEC_CONTRAST/LCD_INC_CONTRAST)
                             2863 ; 430  |// make lower when doing calibration
                             2864 ; 431  |#define LCD_STEPSIZE_CONTRAST 10  
                             2865 ; 432  |
                             2866 ; 433  |
                             2867 ; 434  |/////////////////////////////////////////////////////////////////////////////////
                             2868 ; 435  |// For FFWD and RWND
                             2869 ; 436  |/////////////////////////////////////////////////////////////////////////////////
                             2870 ; 437  |#define SECONDS_TO_SKIP 1
                             2871 ; 438  |#define SECONDS_TO_SKIP1 3
                             2872 ; 439  |#define SECONDS_TO_SKIP2 6
                             2873 ; 440  |// number of seconds to cause reset to begin of song for PREV push
                             2874 ; 441  |#define PREV_SONG_THRESHOLD 5  
                             2875 ; 442  |// number of 300 mSec periods before the numbers of seconds to skip increases
                             2876 ; 443  |#define FIRST_TIME_BOUNDARY 15 
                             2877 ; 444  |// number of 300 mSec periods before the numbers of seconds to skip increases
                             2878 ; 445  |#define SECOND_TIME_BOUNDARY 30 
                             2879 ; 446  |
                             2880 ; 447  |// For audible FFW/RWD
                             2881 ; 448  |#define SECONDS_TO_SKIP_FOR_3X_RATE 1
                             2882 ; 449  |#define SECONDS_TO_SKIP_FOR_60X_RATE 18
                             2883 ; 450  |#define SECONDS_TO_SKIP_FOR_600X_RATE 180
                             2884 ; 451  |#define SECONDS_TO_SKIP_FOR_1800X_RATE 540
                             2885 ; 452  |// number of 300 mSec periods before the numbers of seconds to skip increases
                             2886 ; 453  |#define LEVEL1_BOUNDARY 17 
                             2887 ; 454  |// number of 300 mSec periods before the numbers of seconds to skip increases
                             2888 ; 455  |#define LEVEL2_BOUNDARY 33 
                             2889 ; 456  |// number of 300 mSec periods before the numbers of seconds to skip increases
                             2890 ; 457  |#define LEVEL3_BOUNDARY 50 
                             2891 ; 458  |// Stmp00010296 Ticket #71685:  for song shorter than the min. skip size
                             2892 ; 459  |// if song_time < skip_size, bCurrentSongShort=>TRUE (ignore FWD/RWD commands)
                             2893 ; 460  |// Short Song Time, songs too short to play.
                             2894 ; 461  |#define SHORT_SONG_TIME SECONDS_TO_SKIP         
                             2895 ; 462  |
                             2896 ; 463  |/////////////////////////////////////////////////////////////////////////////////
                             2897 ; 464  |// MP3 Sync Values
                             2898 ; 465  |/////////////////////////////////////////////////////////////////////////////////
                             2899 ; 466  |// # bytes to look for sync before marking it bad
                             2900 ; 467  |#define MP3_SYNC_THRESHOLD 70000 
                             2901 ; 468  |// # bytes to look for sync before slowing decoder isr frequency (to let menus run)
                             2902 ; 469  |#define MP3_SYNC_THRESHOLD1 10000 
                             2903 ; 470  |// once we have sync'd, the isr should be called this frequently
                             2904 ; 471  |#define MP3_DECODERISR_FAST 7500  
                             2905 ; 472  |// if decoder is having difficulty syncing, switch isr to be called less frequently
                             2906 ; 473  |#define MP3_DECODERISR_SLOW 50000 
                             2907 ; 474  |
                             2908 ; 475  |
                             2909 ; 476  |/////////////////////////////////////////////////////////////////////////////////
                             2910 ; 477  |//// Multi-Stage Volume Control Definitions
                             2911 ; 478  |/////////////////////////////////////////////////////////////////////////////////
                             2912 ; 479  |//// Use Multi-Stage Volume
                             2913 ; 480  |#define MULTI_STAGE_VOLUME 0x1                  
                             2914 ; 481  |
                             2915 ; 482  |//// Master Volume definitions
                             2916 ; 483  |#define MIX_MSTR_MAX_VOL 0x0
                             2917 ; 484  |#define NUM_MSTR_ATT_STEPS (0x1F-MIX_MSTR_MAX_VOL)
                             2918 ; 485  |
                             2919 ; 486  |//// DAC-Mode definitions
                             2920 ; 487  |//// Adjusts 0dB point
                             2921 ; 488  |#define MIX_DAC_NOM_VOL 0x6                  
                             2922 ; 489  |#define MIX_DAC_MIN_VOL 0x1F
                             2923 ; 490  |// For minimum clipping: Set MIX_DAC_MAX_VOL below to match MIX_DAC_NOM_VOL value 2 lines above.
                             2924 ; 491  |// For additional gain (with possible clipping): Set MIX_DAC_MAX_VOL in range below. 
                             2925 ; 492  |//                                               Each integer below MIX_DAC_NOM_VOL provides 1.5 dB gain on Stmp34x0; 
                             2926 ; 493  |//                                               Max gain possible: 8 step diff would provide +12dB gain.   
                             2927 ; 494  |// range: [0 to MIX_DAC_NOM_VOL] (0 for loudest volume)
                             2928 ; 495  |#define MIX_DAC_MAX_VOL 0x0  
                             2929 ; 496  |
                             2930 ; 497  |#define NUM_DAC_ATT_STEPS (MIX_DAC_MIN_VOL-MIX_DAC_NOM_VOL+1)
                             2931 ; 498  |#define NUM_DAC_GAIN_STEPS (MIX_DAC_NOM_VOL-MIX_DAC_MAX_VOL)
                             2932 ; 499  |#define NUM_DAC_MODE_VOL_STEPS (NUM_DAC_ATT_STEPS+NUM_MSTR_ATT_STEPS+NUM_DAC_GAIN_STEPS+1)
                             2933 ; 500  |
                             2934 ; 501  |//// If there is no stored volume, set to 50% of DAC-Mode max; change if DAC Mode is not the default
                             2935 ; 502  |//// STMP35xx has 2dB attenuation per step so default needs a few more steps above midpoint.
                             2936 ; 503  |#define DEFAULT_VOLUME ((NUM_DAC_MODE_VOL_STEPS/2)+6)         
                             2937 ; 504  |
                             2938 ; 505  |//// Set maximum restored volume to 75% of DAC-Mode max; change if DAC Mode is not the default
                             2939 ; 506  |#define MAX_RESTORED_VOLUME ((3*NUM_DAC_MODE_VOL_STEPS)/4)   
                             2940 ; 507  |
                             2941 ; 508  |
                             2942 ; 509  |//// Line In definitions (used for Line-In 1)
                             2943 ; 510  |//// 0dB point of the Line In
                             2944 ; 511  |#define MIX_LINE_NOM_VOL 0x8                  
                             2945 ; 512  |//// Minimum volume of Line In
                             2946 ; 513  |#define MIX_LINE_MIN_VOL 0x1F                 
                             2947 ; 514  |//// Maximum volume of Line In (can adjust extra gain)
                             2948 ; 515  |#define MIX_LINE_MAX_VOL 0x6                  
                             2949 ; 516  |#define NUM_LINE_ATT_STEPS (MIX_LINE_MIN_VOL-MIX_LINE_NOM_VOL+1)
                             2950 ; 517  |#define NUM_LINE_GAIN_STEPS (MIX_LINE_NOM_VOL-MIX_LINE_MAX_VOL)
                             2951 ; 518  |#define NUM_LINE_MODE_VOL_STEPS (NUM_LINE_ATT_STEPS+NUM_MSTR_ATT_STEPS+NUM_LINE_GAIN_STEPS+1)
                             2952 ; 519  |
                             2953 ; 520  |//// Line In definitions (used for FM tuner with 144 pin package)
                             2954 ; 521  |//// 0dB point of the Line In
                             2955 ; 522  |#define MIX_FM_NOM_VOL 0x8                  
                             2956 ; 523  |//// Minimum volume of Line In
                             2957 ; 524  |#define MIX_FM_MIN_VOL 0x1F                 
                             2958 ; 525  |//// Maximum volume of Line In (can adjust extra gain)
                             2959 ; 526  |#define MIX_FM_MAX_VOL 0x6                  
                             2960 ; 527  |#define NUM_FM_ATT_STEPS (MIX_FM_MIN_VOL-MIX_FM_NOM_VOL+1)
                             2961 ; 528  |#define NUM_FM_GAIN_STEPS (MIX_FM_NOM_VOL-MIX_FM_MAX_VOL)
                             2962 ; 529  |#define NUM_FM_MODE_VOL_STEPS (NUM_FM_ATT_STEPS+NUM_MSTR_ATT_STEPS+NUM_FM_GAIN_STEPS+1)
                             2963 ; 530  |
                             2964 ; 531  |/////////////////////////////////////////////////////////////////////////////////
                             2965 ; 532  |//// When enabled (1), periodically checks for one of several FM state machine invalid deadlock states & recovers. 
                             2966 ; 533  |//// Define as 0 to disable FM-deadlock-state checking and recovery.
                             2967 ; 534  |#define FM_WATCHDOG_ENABLE 1
                             2968 ; 535  |
                             2969 ; 536  |#if !defined(STMP_BUILD_PLAYER)
                             2970 ; 537  |////
                             2971 ; 538  |////! This varible holds the lcd display state for the mtp project.
                             2972 ; 539  |////
                             2973 ; 540  |///
                             2974 ; 541  |#include <types.h>
                             2975 ; 542  |extern volatile WORD g_wActivityState;
                             2976 ; 543  |#endif // if !@def('STMP_BUILD_PLAYER')
                             2977 ; 544  |
                             2978 ; 545  |void _reentrant Init5VSense(void);
                             2979 ; 546  |void _reentrant ServiceDCDC(void);
                             2980 ; 547  |
                             2981 ; 548  |////////////////////////////////////////////////////////////////////////////
                             2982 ; 549  |//// JPEG Thumbnail Mode Setting
                             2983 ; 550  |//// number of column in thumbnail mode
                             2984 ; 551  |#define THUMBNAIL_X 2           
                             2985 ; 552  |//// number of row in  thumbnail mode
                             2986 ; 553  |#define THUMBNAIL_Y 2           
                             2987 ; 554  |//// thumbnail boundary offset x
                             2988 ; 555  |#define THUMBNAIL_X_OFFSET 4            
                             2989 ; 556  |//// thumbnail boundary offset y
                             2990 ; 557  |#define THUMBNAIL_Y_OFFSET 4            
                             2991 ; 558  |
                             2992 ; 559  |#endif // if (!@def(_PROJECT_INC))
                             2993 ; 560  |
                             2994 
                             2996 
                             2997 ; 5    |
                             2998 ; 6    |#ifndef MAX_USB_STRINGS
                             2999 ; 7    |#define MAX_USB_STRINGS 9
                             3000 ; 8    |#endif
                             3001 ; 9    |
                             3002 ; 10   |
                             3003 ; 11   |#define  USB_SELF_POWERED                    (0x01)
                             3004 ; 12   |#define  USB_REMOTE_WAKEUP                   (0x02)
                             3005 ; 13   |
                             3006 ; 14   |#define MAX_DESC_SIZE       86      // (255/3)+1
                             3007 ; 15   |
                             3008 ; 16   |#define MS_OS_STRING_DESCRIPTOR_INDEX 0xEE
                             3009 ; 17   |#define MS_OS_STRING_DESCRIPTOR_INDEX_IN_ARRAY 7
                             3010 ; 18   |
                             3011 ; 19   |/* The USB Device State Structure */
                             3012 ; 20   |typedef struct {
                             3013 ; 21   |   BYTE         btSpeed;                // Speed of device when connected
                             3014 ; 22   |                                        // High Speed or Full Speed
                             3015 ; 23   |   BYTE         btCurConfig;            // Current configuration number (0 means not configured yet)
                             3016 ; 24   |                                        // or default interface
                             3017 ; 25   |   BYTE         btCurInterface;         // Current Alternate Interface (0 means not configured yet)                                                         
                             3018 ; 26   |   BYTE         btAddress;              // USB device address
                             3019 ; 27   |   USHORT       usUsbState;             // State USB (UNKNOWN, POWERED, DEFAULT, ADDRESSED, CONFIGURED, SUSPENDED)
                             3020 ; 28   |   USHORT       usUsbStatePriorSusp;    // Ste USB prior a SUSPEND. This state needs to be restore
                             3021 ; 29   |                                        // once the USB resumes
                             3022 ; 30   |   USHORT       usUsbDeviceState;       // State of the device (SelfPowered, Remote Wakeup)
                             3023 ; 31   |   USHORT       usSofCount;
                             3024 ; 32   |   BYTE         btBusResetting;         // Set during a reset phase
                             3025 ; 33   |   BYTE         btServicesRegistered;   // Number of services registered
                             3026 ; 34   |   WORD         wError;                 // Increments each time a USB Error Interrupt occurs
                             3027 ; 35   |   BOOL         bEnterTestMode;         // Set when entered in test mode. To clear the device
                             3028 ; 36   |                                        // must be powered down
                             3029 ; 37   |   USHORT       usConnectionState;      // State of the USB connection (CONNECTED, DISCONNECTED, UNKNOWN)                                         
                             3030 ; 38   |} Dev_State_Struct;
                             3031 ; 39   |
                             3032 ; 40   |typedef struct xd_struct_type{
                             3033 ; 41   |   BYTE         btEndpointNum;          // Endpoint number 
                             3034 ; 42   |   BYTE         btDirection;            // Direction : Send/Receive
                             3035 ; 43   |   BYTE         btEndpointType;         // Type of the endpoint: Ctrl, Isoch, Bulk,Int 
                             3036 ; 44   |   BYTE         btStatus;               // Current transfer status 
                             3037 ; 45   |   WORD _X *    pbtStartAddressWord;    // Address of first byte (DSP Word address in STMP space)
                             3038 ; 46   |   BYTE         btStartOffsetByte;      // Address of first byte (Word Byte offset in STMP space)
                             3039 ; 47   |   USHORT       usTotalLength;          // Number of bytes to send/recv 
                             3040 ; 48   |   USHORT       usMaxPacketSize;        // Max Packet size 
                             3041 ; 49   |   BYTE         btDontZeroTerminate;
                             3042 ; 50   |   BOOL         bIsDataPhase;           // Set to TRUE if the transfer is data phase
                             3043 ; 51   |                                        // of a setup transfer
                             3044 ; 52   |   struct xd_struct_type _USB_MEM*pNext;     // pointer to the next xd_struct
                             3045 ; 53   |   WORD         wPrivateData;           //data to be passed to the service handler
                             3046 ; 54   |   USHORT       usBytesCopied;          //number of bytes copied so far
                             3047 ; 55   |   WORD         wCurrentOffsetByte;
                             3048 ; 56   |   WORD _X*    pbtCurrentAddressWord;
                             3049 ; 57   |} xd_struct;
                             3050 ; 58   |
                             3051 ; 59   |// If MAX_NUM_EP is not defined, default to 4
                             3052 ; 60   |// *** NOTE: if you change this definition, change the equate for MAX_NUM_EP in usb20ddmem.asm as well.
                             3053 ; 61   |// The two definitions must be equivalent for proper operation.
                             3054 ; 62   |#define MAX_NUM_EP  4
                             3055 
                             3071 
TASKING DSP2410 assembler v1.5r1 Build 138 SN 00100122
                                                                                                                                                                                                                                                       Page  13

M:ADDR CODE           CYCLES LINE SOURCELINE
                             3072 ; 63   |
                             3073 ; 64   |extern Dev_State_Struct _USB_MEM stDeviceState;
                             3074 
                             3096 
                             3097 ; 65   |
                             3098 ; 66   |extern xd_struct _USB_MEM * g_dXD_Queues[MAX_NUM_EP][2];
                             3099 ; 67   |
                             3100 ; 68   |BYTE _reentrant usb_device_call_service(BYTE btType, BOOL bSetup, BYTE btDirection, WORD _X*ptbBuffer, WORD wLength, WORD wPrivateData);
                             3101 ; 69   |xd_struct _USB_MEM * GetEmptyXd(void);
                             3102 ; 70   |void FreeXd(xd_struct _USB_MEM * pTemp);
                             3103 ; 71   |void AddXdToQueue(xd_struct _USB_MEM *pHead,xd_struct _USB_MEM *pElement);
                             3104 ; 72   |void InitXdPool(void);
                             3105 ; 73   |_reentrant void usb_PackDescriptor(void* pDescriptor,void _X * pDestination, WORD startIndex);
                             3106 ; 74   |_reentrant void parse_strings(void);
                             3107 ; 75   |
                             3108 ; 76   |
                             3109 ; 77   |    // Service structures.
                             3110 ; 78   |    // Those are the structures storing the function handler for a specific
                             3111 ; 79   |    // USB service.
                             3112 ; 80   |    // There is a service per Endpoint + Reset + Suspend + Start Of Frame
                             3113 ; 81   |    //                                 + Resume + Sleep + Speed Detection  
                             3114 ; 82   |    // The service structs are setup by the USB application using the device driver
                             3115 ; 83   |typedef struct {
                             3116 ; 84   |   BYTE             btType;     // Which service type
                             3117 ; 85   |                                // Pointer to the service function
                             3118 ; 86   |   void (* Service)(BOOL bSetup, BYTE btDirection, WORD _X* pbtBuffer, WORD wLength, WORD wPrivateData);
                             3119 ; 87   |} Service_Struct;
                             3120 ; 88   |
                             3121 ; 89   |
                             3122 ; 90   |#endif
                             3123 
                             3125 
                             3126 ; 20   |#include "usb_dci.h"
                             3127 
                             3129 
                             3130 ; 1    |#ifndef _USB_DCI_H
                             3131 ; 2    |#define _USB_DCI_H
                             3132 ; 3    |
                             3133 ; 4    |#include "types.h"
                             3134 
                             3136 
                             3137 ; 1    |////////////////////////////////////////////////////////////////////////////////
                             3138 ; 2    |// Copyright(C) SigmaTel, Inc. 2000-2004
                             3139 ; 3    |//
                             3140 ; 4    |// Filename: types.h
                             3141 ; 5    |// Description: Standard data types
                             3142 ; 6    |////////////////////////////////////////////////////////////////////////////////
                             3143 ; 7    |
                             3144 ; 8    |#ifndef _TYPES_H
                             3145 ; 9    |#define _TYPES_H
                             3146 ; 10   |
                             3147 ; 11   |// TODO:  move this outta here!
                             3148 ; 12   |#if !defined(NOERROR)
                             3149 ; 13   |#define NOERROR 0
                             3150 ; 14   |#define SUCCESS 0
                             3151 ; 15   |#endif 
                             3152 ; 16   |#if !defined(SUCCESS)
                             3153 ; 17   |#define SUCCESS  0
                             3154 ; 18   |#endif
                             3155 ; 19   |#if !defined(ERROR)
                             3156 ; 20   |#define ERROR   -1
                             3157 ; 21   |#endif
                             3158 ; 22   |#if !defined(FALSE)
                             3159 ; 23   |#define FALSE 0
                             3160 ; 24   |#endif
                             3161 ; 25   |#if !defined(TRUE)
                             3162 ; 26   |#define TRUE  1
                             3163 ; 27   |#endif
                             3164 ; 28   |
                             3165 ; 29   |#if !defined(NULL)
                             3166 ; 30   |#define NULL 0
                             3167 ; 31   |#endif
                             3168 ; 32   |
                             3169 ; 33   |#define MAX_INT     0x7FFFFF
                             3170 ; 34   |#define MAX_LONG    0x7FFFFFffffff
                             3171 ; 35   |        // max positive unsigned long value: -1 == 0xFFFFFFffffff
                             3172 ; 36   |#define MAX_ULONG   (-1) 
                             3173 ; 37   |
                             3174 ; 38   |#define WORD_SIZE   24              // word size in bits
                             3175 ; 39   |#define BYTES_PER_WORD 3            // 8 bit bytes
                             3176 ; 40   |
                             3177 ; 41   |
                             3178 ; 42   |#define BYTE    unsigned char       // btVarName
                             3179 ; 43   |#define CHAR    signed char         // cVarName
                             3180 ; 44   |#define USHORT  unsigned short      // usVarName
                             3181 ; 45   |#define SHORT   unsigned short      // sVarName
                             3182 ; 46   |#define WORD    unsigned int        // wVarName
                             3183 ; 47   |#define INT     signed int          // iVarName
                             3184 ; 48   |#define DWORD   unsigned long       // dwVarName
                             3185 ; 49   |#define LONG    signed long         // lVarName
                             3186 ; 50   |#define BOOL    unsigned int        // bVarName
                             3187 ; 51   |#define FRACT   _fract              // frVarName
                             3188 ; 52   |#define LFRACT  long _fract         // lfrVarName
                             3189 ; 53   |#define CIRC    _circ               // cp<type prefix>VarName (see below)
                             3190 ; 54   |#define FLOAT   float               // fVarName
                             3191 ; 55   |#define DBL     double              // dVarName
                             3192 ; 56   |#define ENUM    enum                // eVarName
                             3193 ; 57   |#define CMX     _complex            // cmxVarName
                             3194 ; 58   |typedef WORD UCS3;                   // 
                             3195 ; 59   |
                             3196 ; 60   |#define UINT16  unsigned short
                             3197 ; 61   |#define UINT8   unsigned char   
                             3198 ; 62   |#define UINT32  unsigned long
                             3199 ; 63   |#define UINT64  unsigned long   // need to figure out how to do 64 bit values.  Or port exisiting code to only use 48 bit
                             3200 ; 64   |#define INT64   unsigned long   // need to figure out how to do 64 bit values.  Or port exisiting code to only use 48 bit
                             3201 ; 65   |#define WCHAR   UINT16
                             3202 ; 66   |
                             3203 ; 67   |//UINT128 is 16 bytes or 6 words
                             3204 ; 68   |typedef struct UINT128_3500 {   
                             3205 ; 69   |    int val[6];     
                             3206 ; 70   |} UINT128_3500;
                             3207 ; 71   |
                             3208 ; 72   |#define UINT128   UINT128_3500
                             3209 ; 73   |
                             3210 ; 74   |// Little endian word packed byte strings:   
                             3211 ; 75   |//      _packed BYTE bTextVarName[]="a string";  bText is a packed byte string prefix
                             3212 ; 76   |// Convert to big endian words by reordering bytes from high to low using swizzle.
                             3213 ; 77   |// Little endian word packed byte strings:   
                             3214 ; 78   |//      _packed BYTE bTextVarName[]="a string";  bText is a packed byte string prefix
                             3215 ; 79   |// Convert to big endian words by reordering bytes from high to low using swizzle.
                             3216 ; 80   |
                             3217 ; 81   |// Declare Memory Spaces To Use When Coding
                             3218 ; 82   |// A. Sector Buffers
                             3219 ; 83   |#define SECTOR_BUFFER_MEM_X _X
                             3220 ; 84   |#define SECTOR_BUFFER_MEM_Y _Y
                             3221 ; 85   |#define SECTOR_BUFFER_MEM SECTOR_BUFFER_MEM_X
                             3222 ; 86   |typedef WORD SECTOR_BUFFER_MEM SECTOR_BUFFER;
                             3223 ; 87   |typedef SECTOR_BUFFER * P_SECTOR_BUFFER;
                             3224 ; 88   |// B. Media DDI Memory
                             3225 ; 89   |#define MEDIA_DDI_MEM _Y
                             3226 ; 90   |
                             3227 ; 91   |
                             3228 ; 92   |
                             3229 ; 93   |// Pointers to linear structures are labeled as: p<type prefix>VarName
                             3230 ; 94   |// Examples of circular pointers:
                             3231 ; 95   |//    INT CIRC cpiVarName
                             3232 ; 96   |//    DWORD CIRC cpdwVarName
                             3233 ; 97   |
                             3234 ; 98   |#define RETCODE INT                 // rcVarName
                             3235 ; 99   |
                             3236 ; 100  |// generic bitfield structure
                             3237 ; 101  |struct Bitfield {
                             3238 ; 102  |    unsigned int B0  :1;
                             3239 ; 103  |    unsigned int B1  :1;
                             3240 ; 104  |    unsigned int B2  :1;
                             3241 ; 105  |    unsigned int B3  :1;
                             3242 ; 106  |    unsigned int B4  :1;
                             3243 ; 107  |    unsigned int B5  :1;
                             3244 ; 108  |    unsigned int B6  :1;
                             3245 ; 109  |    unsigned int B7  :1;
                             3246 ; 110  |    unsigned int B8  :1;
                             3247 ; 111  |    unsigned int B9  :1;
                             3248 ; 112  |    unsigned int B10 :1;
                             3249 ; 113  |    unsigned int B11 :1;
                             3250 ; 114  |    unsigned int B12 :1;
                             3251 ; 115  |    unsigned int B13 :1;
                             3252 ; 116  |    unsigned int B14 :1;
                             3253 ; 117  |    unsigned int B15 :1;
                             3254 ; 118  |    unsigned int B16 :1;
                             3255 ; 119  |    unsigned int B17 :1;
                             3256 ; 120  |    unsigned int B18 :1;
                             3257 ; 121  |    unsigned int B19 :1;
                             3258 ; 122  |    unsigned int B20 :1;
                             3259 ; 123  |    unsigned int B21 :1;
                             3260 ; 124  |    unsigned int B22 :1;
                             3261 ; 125  |    unsigned int B23 :1;
                             3262 ; 126  |};
                             3263 ; 127  |
                             3264 ; 128  |union BitInt {
                             3265 ; 129  |        struct Bitfield B;
                             3266 ; 130  |        int        I;
                             3267 ; 131  |};
                             3268 ; 132  |
                             3269 ; 133  |#define MAX_MSG_LENGTH 10
                             3270 ; 134  |struct CMessage
                             3271 ; 135  |{
                             3272 ; 136  |        unsigned int m_uLength;
                             3273 ; 137  |        unsigned int m_uMsg[MAX_MSG_LENGTH];
                             3274 ; 138  |};
                             3275 ; 139  |
                             3276 ; 140  |typedef struct {
                             3277 ; 141  |    WORD m_wLength;
                             3278 ; 142  |    WORD m_wMessage;
                             3279 ; 143  |    WORD m_wParams[MAX_MSG_LENGTH];
                             3280 ; 144  |} Message;
                             3281 ; 145  |
                             3282 ; 146  |struct MessageQueueDescriptor
                             3283 ; 147  |{
                             3284 ; 148  |        int *m_pBase;
                             3285 ; 149  |        int m_iModulo;
                             3286 ; 150  |        int m_iSize;
                             3287 ; 151  |        int *m_pHead;
                             3288 ; 152  |        int *m_pTail;
                             3289 ; 153  |};
                             3290 ; 154  |
                             3291 ; 155  |struct ModuleEntry
                             3292 ; 156  |{
                             3293 ; 157  |    int m_iSignaledEventMask;
                             3294 ; 158  |    int m_iWaitEventMask;
                             3295 ; 159  |    int m_iResourceOfCode;
                             3296 ; 160  |    struct MessageQueueDescriptor *m_pMessageQueue;
                             3297 ; 161  |    int _asmfunc (*m_pProcessEntryPoint)(union WaitMask Signals,struct MessageQueueDescriptor *);
                             3298 ; 162  |    int _asmfunc (*m_pInitFunction)(struct MessageQueueDescriptor *);
                             3299 ; 163  |    int m_uTimeOutHigh;
                             3300 ; 164  |    int m_uTimeOutLow;
                             3301 ; 165  |    int _asmfunc (*m_pBackgroundFunction)(struct MessageQueueDescriptor *);
                             3302 ; 166  |};
                             3303 ; 167  |
                             3304 ; 168  |union WaitMask{
                             3305 ; 169  |    struct B{
                             3306 ; 170  |        unsigned int m_bNone     :1;
                             3307 ; 171  |        unsigned int m_bMessage  :1;
                             3308 ; 172  |        unsigned int m_bTimer    :1;
                             3309 ; 173  |        unsigned int m_bButton   :1;
                             3310 ; 174  |    } B;
                             3311 ; 175  |    int I;
                             3312 ; 176  |} ;
                             3313 ; 177  |
                             3314 ; 178  |
                             3315 ; 179  |struct Button {
                             3316 ; 180  |        WORD wButtonEvent;
                             3317 ; 181  |        WORD wUnused[MAX_MSG_LENGTH];   
                             3318 ; 182  |};
                             3319 ; 183  |
                             3320 ; 184  |struct Message {
                             3321 ; 185  |        WORD wMsgLength;
                             3322 ; 186  |        WORD wMsgCommand;
                             3323 ; 187  |        WORD wMsgParms[MAX_MSG_LENGTH-1];
                             3324 ; 188  |};
                             3325 ; 189  |
                             3326 ; 190  |union EventTypes {
                             3327 ; 191  |        struct CMessage msg;
                             3328 ; 192  |        struct Button Button ;
                             3329 ; 193  |        struct Message Message;
                             3330 ; 194  |};
                             3331 ; 195  |
                             3332 ; 196  |// next 2 used to get updater build to return correct protocol ver in scsi response.
                             3333 ; 197  |#define BUILD_TYPE_UPDATER  0x100
                             3334 ; 198  |#define BUILD_TYPE_HOSTLINK 0x101
                             3335 ; 199  |#define BUILD_TYPE_PLAYER   0x102
                             3336 ; 200  |
                             3337 ; 201  |// Resets part if RETAIL build. DEBUG build executes debug instruction to halt.
                             3338 ; 202  |#define SystemHalt() __asm(" include 'sysmacro.asm' \n error") 
                             3339 ; 203  |#define assert(x)    if(!(x)) __asm(" include 'sysmacro.asm' \n error")
                             3340 ; 204  |
                             3341 ; 205  |#if DEBUG
                             3342 ; 206  |// For DEBUG builds, DebugBuildAssert(condition) halts if condition evaluates to FALSE. 
                             3343 ; 207  |#define DebugBuildAssert(x)    if(!(x)) __asm(" debug ")
                             3344 ; 208  |#else 
                             3345 ; 209  |// For RETAIL builds, DebugBuildAssert(condition) does nothing & execution continues rather than halt or reset. 
                             3346 ; 210  |#define DebugBuildAssert(x)    
TASKING DSP2410 assembler v1.5r1 Build 138 SN 00100122
                                                                                                                                                                                                                                                       Page  14

M:ADDR CODE           CYCLES LINE SOURCELINE
                             3347 ; 211  |#endif
                             3348 ; 212  |
                             3349 ; 213  |// Do this in your C files to make a reminder that's displayed during the build.
                             3350 ; 214  |//  #pragma asm
                             3351 ; 215  |//  WARN 'Note to builder: reminder to do this after verifying that'
                             3352 ; 216  |//  #pragma endasm
                             3353 ; 217  |
                             3354 ; 218  |
                             3355 ; 219  |#ifdef COLOR_262K
                             3356 ; 220  |#define RGB(r,g,b)    ((0x0000FC & (r)) << 10) | ((0x0000FC & (g)) << 4) | ((0x0000FC & (b)) >> 2)    //262k
                             3357 ; 221  |#elif defined(COLOR_65K)
                             3358 ; 222  |#define RGB(r,g,b)    ((0x0000F8 & (r)) << 8) | ((0x0000FC & (g)) << 3) | ((0x0000F8 & (b)) >> 3)  //65k
                             3359 ; 223  |#else
                             3360 ; 224  |#define RGB(r,g,b)       ((0x0000F0 & (r)) << 4) | (0x0000F0 & (g)) | ((0x0000F0 & (b)) >> 4)
                             3361 ; 225  |#endif
                             3362 ; 226  |    
                             3363 ; 227  |#endif // #ifndef _TYPES_H
                             3364 
                             3366 
                             3367 ; 5    |#include "usb_internal.h"
                             3368 
                             3370 
                             3371 ; 1    |#ifndef _USB_INTERNAL_H
                             3372 ; 2    |#define _USB_INTERNAL_H
                             3373 ; 3    |
                             3374 ; 4    |#include "project.h"
                             3375 ; 5    |
                             3376 ; 6    |#ifndef MAX_USB_STRINGS
                             3377 ; 7    |#define MAX_USB_STRINGS 9
                             3378 ; 8    |#endif
                             3379 ; 9    |
                             3380 ; 10   |
                             3381 ; 11   |#define  USB_SELF_POWERED                    (0x01)
                             3382 ; 12   |#define  USB_REMOTE_WAKEUP                   (0x02)
                             3383 ; 13   |
                             3384 ; 14   |#define MAX_DESC_SIZE       86      // (255/3)+1
                             3385 ; 15   |
                             3386 ; 16   |#define MS_OS_STRING_DESCRIPTOR_INDEX 0xEE
                             3387 ; 17   |#define MS_OS_STRING_DESCRIPTOR_INDEX_IN_ARRAY 7
                             3388 ; 18   |
                             3389 ; 19   |/* The USB Device State Structure */
                             3390 ; 20   |typedef struct {
                             3391 ; 21   |   BYTE         btSpeed;                // Speed of device when connected
                             3392 ; 22   |                                        // High Speed or Full Speed
                             3393 ; 23   |   BYTE         btCurConfig;            // Current configuration number (0 means not configured yet)
                             3394 ; 24   |                                        // or default interface
                             3395 ; 25   |   BYTE         btCurInterface;         // Current Alternate Interface (0 means not configured yet)                                                         
                             3396 ; 26   |   BYTE         btAddress;              // USB device address
                             3397 ; 27   |   USHORT       usUsbState;             // State USB (UNKNOWN, POWERED, DEFAULT, ADDRESSED, CONFIGURED, SUSPENDED)
                             3398 ; 28   |   USHORT       usUsbStatePriorSusp;    // Ste USB prior a SUSPEND. This state needs to be restore
                             3399 ; 29   |                                        // once the USB resumes
                             3400 ; 30   |   USHORT       usUsbDeviceState;       // State of the device (SelfPowered, Remote Wakeup)
                             3401 ; 31   |   USHORT       usSofCount;
                             3402 ; 32   |   BYTE         btBusResetting;         // Set during a reset phase
                             3403 ; 33   |   BYTE         btServicesRegistered;   // Number of services registered
                             3404 ; 34   |   WORD         wError;                 // Increments each time a USB Error Interrupt occurs
                             3405 ; 35   |   BOOL         bEnterTestMode;         // Set when entered in test mode. To clear the device
                             3406 ; 36   |                                        // must be powered down
                             3407 ; 37   |   USHORT       usConnectionState;      // State of the USB connection (CONNECTED, DISCONNECTED, UNKNOWN)                                         
                             3408 ; 38   |} Dev_State_Struct;
                             3409 ; 39   |
                             3410 ; 40   |typedef struct xd_struct_type{
                             3411 ; 41   |   BYTE         btEndpointNum;          // Endpoint number 
                             3412 ; 42   |   BYTE         btDirection;            // Direction : Send/Receive
                             3413 ; 43   |   BYTE         btEndpointType;         // Type of the endpoint: Ctrl, Isoch, Bulk,Int 
                             3414 ; 44   |   BYTE         btStatus;               // Current transfer status 
                             3415 ; 45   |   WORD _X *    pbtStartAddressWord;    // Address of first byte (DSP Word address in STMP space)
                             3416 ; 46   |   BYTE         btStartOffsetByte;      // Address of first byte (Word Byte offset in STMP space)
                             3417 ; 47   |   USHORT       usTotalLength;          // Number of bytes to send/recv 
                             3418 ; 48   |   USHORT       usMaxPacketSize;        // Max Packet size 
                             3419 ; 49   |   BYTE         btDontZeroTerminate;
                             3420 ; 50   |   BOOL         bIsDataPhase;           // Set to TRUE if the transfer is data phase
                             3421 ; 51   |                                        // of a setup transfer
                             3422 ; 52   |   struct xd_struct_type _USB_MEM*pNext;     // pointer to the next xd_struct
                             3423 ; 53   |   WORD         wPrivateData;           //data to be passed to the service handler
                             3424 ; 54   |   USHORT       usBytesCopied;          //number of bytes copied so far
                             3425 ; 55   |   WORD         wCurrentOffsetByte;
                             3426 ; 56   |   WORD _X*    pbtCurrentAddressWord;
                             3427 ; 57   |} xd_struct;
                             3428 ; 58   |
                             3429 ; 59   |// If MAX_NUM_EP is not defined, default to 4
                             3430 ; 60   |// *** NOTE: if you change this definition, change the equate for MAX_NUM_EP in usb20ddmem.asm as well.
                             3431 ; 61   |// The two definitions must be equivalent for proper operation.
                             3432 ; 62   |#define MAX_NUM_EP  4
                             3433 ; 63   |
                             3434 ; 64   |extern Dev_State_Struct _USB_MEM stDeviceState;
                             3435 ; 65   |
                             3436 ; 66   |extern xd_struct _USB_MEM * g_dXD_Queues[MAX_NUM_EP][2];
                             3437 ; 67   |
                             3438 ; 68   |BYTE _reentrant usb_device_call_service(BYTE btType, BOOL bSetup, BYTE btDirection, WORD _X*ptbBuffer, WORD wLength, WORD wPrivateData);
                             3439 ; 69   |xd_struct _USB_MEM * GetEmptyXd(void);
                             3440 ; 70   |void FreeXd(xd_struct _USB_MEM * pTemp);
                             3441 ; 71   |void AddXdToQueue(xd_struct _USB_MEM *pHead,xd_struct _USB_MEM *pElement);
                             3442 ; 72   |void InitXdPool(void);
                             3443 ; 73   |_reentrant void usb_PackDescriptor(void* pDescriptor,void _X * pDestination, WORD startIndex);
                             3444 ; 74   |_reentrant void parse_strings(void);
                             3445 ; 75   |
                             3446 ; 76   |
                             3447 ; 77   |    // Service structures.
                             3448 ; 78   |    // Those are the structures storing the function handler for a specific
                             3449 ; 79   |    // USB service.
                             3450 ; 80   |    // There is a service per Endpoint + Reset + Suspend + Start Of Frame
                             3451 ; 81   |    //                                 + Resume + Sleep + Speed Detection  
                             3452 ; 82   |    // The service structs are setup by the USB application using the device driver
                             3453 ; 83   |typedef struct {
                             3454 ; 84   |   BYTE             btType;     // Which service type
                             3455 ; 85   |                                // Pointer to the service function
                             3456 ; 86   |   void (* Service)(BOOL bSetup, BYTE btDirection, WORD _X* pbtBuffer, WORD wLength, WORD wPrivateData);
                             3457 ; 87   |} Service_Struct;
                             3458 ; 88   |
                             3459 ; 89   |
                             3460 ; 90   |#endif
                             3461 
                             3463 
                             3464 ; 6    |#include "usb_api.h"
                             3465 
                             3467 
                             3468 ; 1    |////////////////////////////////////////////////////////////////////////////////
                             3469 ; 2    |// Copyright(C) SigmaTel, Inc. 2002 - 2003
                             3470 ; 3    |//
                             3471 ; 4    |// File : USB_API.H
                             3472 ; 5    |// Description : USB_API.H defines and structures definition for USB device
                             3473 ; 6    |//               driver API.
                             3474 ; 7    |//               This 
                             3475 ; 8    |////////////////////////////////////////////////////////////////////////////////
                             3476 ; 9    |
                             3477 ; 10   |#ifndef __usb_api_h__
                             3478 ; 11   |#define __usb_api_h__ 1
                             3479 ; 12   |
                             3480 ; 13   |#include "types.h"
                             3481 ; 14   |#include "project.h"
                             3482 ; 15   |
                             3483 ; 16   |#ifndef _USB_MEM
                             3484 ; 17   |//if not overwridden, default to the compiler default memory space
                             3485 ; 18   |#define _USB_MEM
                             3486 ; 19   |#endif
                             3487 ; 20   |
                             3488 ; 21   |#define USB_LANGUAGE_ENGLISH 0x0409
                             3489 ; 22   |#define USB_LANGUAGE_CHINESE_PRC 0x0804
                             3490 ; 23   |#define USB_LANGUAGE_CHINESE_TAIWAN 0x0404
                             3491 ; 24   |#define USB_LANGUAGE_JAPANESE 0x0411
                             3492 ; 25   |
                             3493 ; 26   |#define MAX_STRING 30
                             3494 ; 27   |
                             3495 ; 28   |#define  USB_SPEED_FULL                      (0)
                             3496 ; 29   |#define  USB_SPEED_LOW                       (1)
                             3497 ; 30   |#define  USB_SPEED_HIGH                      (2)
                             3498 ; 31   |
                             3499 ; 32   |#define EP_FS_MAX_PACKET_SIZE               (64)    
                             3500 ; 33   |
                             3501 ; 34   |#define EP_HS_MAX_PACKET_SIZE               (512)   
                             3502 ; 35   |
                             3503 ; 36   |// Data transferred to devices based on Sigmatel 3500 chip may sometimes be 
                             3504 ; 37   |// corrupted. The corruption occurs when device is connected in USB High Speed 
                             3505 ; 38   |// mode, and size of the transfer in bytes is divisible by 128, but not 
                             3506 ; 39   |// divisible by the packet size. The workaround is implemented in Microsoft MTP 
                             3507 ; 40   |// driver to allow support for those devices.
                             3508 ; 41   |
                             3509 ; 42   |// the bug can corrupt the end of data buffer. It occurs when host sends out a 
                             3510 ; 43   |// short packet that is multiple of 128 bytes. During this scenario the USB core
                             3511 ; 44   |// does writes that are voided (byte enable == all zero), which was an undefined 
                             3512 ; 45   |// capability and thus the gasket did not apply a proper response. This should 
                             3513 ; 46   |// not affect Mass Storage applications because data transfers are 512 bytes and 
                             3514 ; 47   |// scsi commands are < 16 bytes. Other applications with their own driver will
                             3515 ; 48   |// need to pad the packets if they fall into the error case. "What this basically 
                             3516 ; 49   |// boils down to is that any time the host sends a short packet of 128, 256 or
                             3517 ; 50   |// 384 bytes to a high-speed connected player a number of bytes will be corrupted.
                             3518 ; 51   |// This is easiest to reproduce in SendObject commands but can strike any of the 
                             3519 ; 52   |// commands that take an arbitrary amount of data.
                             3520 ; 53   |#define ARC_HS_128_MODULO_BUG               (128)
                             3521 ; 54   |
                             3522 ; 55   |
                             3523 ; 56   |/* Error codes */
                             3524 ; 57   |#define USB_OK                              (0x00)
                             3525 ; 58   |#define USBERR_REGISTER_SERVICE             (0x01)  // Failed to register a service
                             3526 ; 59   |#define USBERR_NO_SERVICE                   (0x02)  // No registered service found 
                             3527 ; 60   |#define USBERR_TX_FAILED                    (0x03)  // Fail to prepare XD descriptor
                             3528 ; 61   |#define USBERR_SIZE_TOO_LARGE               (0x04)  // Number of bytes to transfer is too large
                             3529 ; 62   |#define USBERR_EP_INIT_FAILED               (0x05)  // Endpoint init fail
                             3530 ; 63   |#define USBERR_CONFIG_FAILED                (0x06)  // Error reported by the application
                             3531 ; 64   |                                                    // if the new config failed or not supported
                             3532 ; 65   |#define USBERR_DEVICE_NOT_CONFIGURED        (0x07)  // Error reported by the transfer function
                             3533 ; 66   |                                                    // if attempting to transfer while the device
                             3534 ; 67   |                                                    // is not configured
                             3535 ; 68   |#define USBERR_INIT_FAILED                  (0x08)  // Fail to initialize the USB API
                             3536 ; 69   |
                             3537 ; 70   |
                             3538 ; 71   |/* Endpoint types */
                             3539 ; 72   |#define  USB_CONTROL_ENDPOINT             (0)
                             3540 ; 73   |#define  USB_ISOCHRONOUS_ENDPOINT         (1)
                             3541 ; 74   |#define  USB_BULK_ENDPOINT                (2)
                             3542 ; 75   |#define  USB_INTERRUPT_ENDPOINT           (3)
                             3543 ; 76   |
                             3544 ; 77   |/* End point direction */
                             3545 ; 78   |#define  USB_OUT                         (0)
                             3546 ; 79   |#define  USB_IN                          (1)
                             3547 ; 80   |
                             3548 ; 81   |/* End point packed size */
                             3549 ; 82   |#define  USB_FS_MAX_PACKET_SIZE           (64)
                             3550 ; 83   |#define  USB_HS_BULK_OUT_MAX_PACKET_SIZE  (256)
                             3551 ; 84   |#define  USB_HS_BULK_IN_MAX_PACKET_SIZE   (128)
                             3552 ; 85   |
                             3553 ; 86   |
                             3554 ; 87   |#define  USB_TEST_MODE_TEST_J             (0x01)
                             3555 ; 88   |#define  USB_TEST_MODE_TEST_K             (0x02)
                             3556 ; 89   |#define  USB_TEST_MODE_TEST_SE0_NAK       (0x03)
                             3557 ; 90   |#define  USB_TEST_MODE_TEST_PACKET        (0x04)
                             3558 ; 91   |
                             3559 ; 92   |/* Available service types */
                             3560 ; 93   |/* Services 0 through 15 are reserved for endpoints */
                             3561 ; 94   |#define  USB_SERVICE_EP0                  (0x00)
                             3562 ; 95   |#define  USB_SERVICE_EP1                  (0x01)
                             3563 ; 96   |#define  USB_SERVICE_EP2                  (0x02)
                             3564 ; 97   |#define  USB_SERVICE_EP3                  (0x03)
                             3565 ; 98   |#define  USB_SERVICE_EP4                  (0x04)
                             3566 ; 99   |#define  USB_SERVICE_EP5                  (0x05)
                             3567 ; 100  |#define  USB_SERVICE_EP6                  (0x06)
                             3568 ; 101  |#define  USB_SERVICE_EP7                  (0x07)
                             3569 ; 102  |#define  USB_SERVICE_EP8                  (0x08)
                             3570 ; 103  |#define  USB_SERVICE_EP9                  (0x09)
                             3571 ; 104  |#define  USB_SERVICE_EP10                 (0x0a)
                             3572 ; 105  |#define  USB_SERVICE_EP11                 (0x0b)
                             3573 ; 106  |#define  USB_SERVICE_EP12                 (0x0c)
                             3574 ; 107  |#define  USB_SERVICE_EP13                 (0x0d)
                             3575 ; 108  |#define  USB_SERVICE_EP14                 (0x0e)
                             3576 ; 109  |#define  USB_SERVICE_EP15                 (0x0f)
                             3577 ; 110  |#define  USB_SERVICE_BUS_RESET            (0x10)
                             3578 ; 111  |#define  USB_SERVICE_SUSPEND              (0x11)
                             3579 ; 112  |#define  USB_SERVICE_SOF                  (0x12)
                             3580 ; 113  |#define  USB_SERVICE_RESUME               (0x13)
                             3581 ; 114  |#define  USB_SERVICE_SLEEP                (0x14)
                             3582 ; 115  |#define  USB_SERVICE_SPEED_DETECTION      (0x15)
                             3583 ; 116  |#define  USB_SERVICE_TEST                 (0x16)
                             3584 ; 117  |#define  USB_SERVICE_CHANGE_CONFIG        (0x17)
                             3585 ; 118  |#define  USB_SERVICE_CHANGE_IFACE         (0x18)   
                             3586 ; 119  |#define  NON_EP_SERVICES                  (USB_SERVICE_SPEED_DETECTION - USB_SERVICE_EP15)
                             3587 ; 120  |
                             3588 ; 121  |// This is the maximum service structures allocated 
                             3589 ; 122  |// One for each End point + the common services (non endpoint services) 
                             3590 ; 123  |#define MAX_NUMBER_SERVICES               (MAX_NUM_EP + NON_EP_SERVICES)  
                             3591 ; 124  |
                             3592 ; 125  |#define NUMBER_BYTES_IN_SETUP               (8)
                             3593 ; 126  |
                             3594 ; 127  |// possible values of btStatus on the xd_struct
                             3595 ; 128  |#define  USB_STATUS_TRANSFER_IDLE           (0)
                             3596 ; 129  |#define  USB_STATUS_TRANSFER_SUCCESS        (1)            
                             3597 ; 130  |#define  USB_STATUS_TRANSFER_ACCEPTED       (2)
                             3598 ; 131  |#define  USB_STATUS_TRANSFER_IN_PROGRESS    (3)
                             3599 ; 132  |#define  USB_STATUS_TRANSFER_ERROR          (4)
                             3600 ; 133  |
                             3601 ; 134  |// types of status set/returned by set_status() and get_status()
TASKING DSP2410 assembler v1.5r1 Build 138 SN 00100122
                                                                                                                                                                                                                                                       Page  15

M:ADDR CODE           CYCLES LINE SOURCELINE
                             3602 ; 135  |#define  USB_STATUS_DEVICE_STATE          (0x01)
                             3603 ; 136  |#define  USB_STATUS_INTERFACE             (0x02)
                             3604 ; 137  |#define  USB_STATUS_ADDRESS               (0x03)
                             3605 ; 138  |#define  USB_STATUS_CURRENT_CONFIG        (0x04)
                             3606 ; 139  |#define  USB_STATUS_SOF_COUNT             (0x05)
                             3607 ; 140  |#define  USB_STATUS                       (0x06)
                             3608 ; 141  |#define  USB_STATUS_TEST_MODE             (0x07)
                             3609 ; 142  |#define  USB_STATUS_DEVICE_SPEED          (0x08)  
                             3610 ; 143  |#define  USB_STATUS_DEVICE_TEST           (0x09)  
                             3611 ; 144  |#define  USB_STATUS_CURRENT_IFACE         (0x0a)
                             3612 ; 145  |#define  USB_STATUS_CONNECTION            (0x0b)  
                             3613 ; 146  |// For status endpoint, the endpoint number is coded in the less significant nibble
                             3614 ; 147  |#define  USB_STATUS_ENDPOINT              (0x10)
                             3615 ; 148  |#define  USB_STATUS_ENDPOINT_NUMBER_MASK  (0x0F)
                             3616 ; 149  |
                             3617 ; 150  |#define USB_MAX_SIZE_PER_TRANSFER       (0x4000)    // This is the maximum size that
                             3618 ; 151  |                                                    // we allow per transfer
                             3619 ; 152  |
                             3620 ; 153  |//Possible states the device can be in
                             3621 ; 154  |#define  USB_STATE_UNKNOWN                   (0xff)
                             3622 ; 155  |#define  USB_STATE_UNPLUGGED                 (0x05) // USB Cable unplugged
                             3623 ; 156  |#define  USB_STATE_PLUGGED                   (0x04) // USB Cable inserted
                             3624 ; 157  |#define  USB_STATE_POWERED                   (0x03)
                             3625 ; 158  |#define  USB_STATE_DEFAULT                   (0x02)
                             3626 ; 159  |#define  USB_STATE_ADDRESSED                 (0x01)
                             3627 ; 160  |#define  USB_STATE_CONFIGURED                (0x00)
                             3628 ; 161  |#define  USB_STATE_SUSPENDED                 (0x80)
                             3629 ; 162  |
                             3630 ; 163  |// Possible states the connection can be in
                             3631 ; 164  |//#define USB_STATE_UNKNOWN                 (0xff)
                             3632 ; 165  |#define USB_CONNECTED                       (0x00)
                             3633 ; 166  |#define USB_DISCONNECTED                    (0x01)
                             3634 ; 167  |
                             3635 ; 168  |
                             3636 ; 169  |
                             3637 ; 170  |typedef union
                             3638 ; 171  |{
                             3639 ; 172  |    struct
                             3640 ; 173  |    {
                             3641 ; 174  |        int Recipient               : 5;
                             3642 ; 175  |        int Type                    : 2;
                             3643 ; 176  |        int DataTransferDirection   : 1;
                             3644 ; 177  |        int Request                 : 8;
                             3645 ; 178  |        int                         : 8;
                             3646 ; 179  |    } B;
                             3647 ; 180  |    
                             3648 ; 181  |    int I;
                             3649 ; 182  |} USBRequestType ;
                             3650 ; 183  |
                             3651 ; 184  |typedef struct {
                             3652 ; 185  |   BYTE     bValid;
                             3653 ; 186  |   USBRequestType RequestType;
                             3654 ; 187  |   BYTE     btRequest;
                             3655 ; 188  |   WORD     wValue;
                             3656 ; 189  |   WORD     wIndex;
                             3657 ; 190  |   WORD     wLength;
                             3658 ; 191  |    } USB_SetupData;
                             3659 ; 192  |
                             3660 ; 193  |// Descriptor sizes in bytes
                             3661 ; 194  |#define SIZE_DEVICE_DESCRIPTOR_IN_BYTES     (18)
                             3662 ; 195  |#define SIZE_DEVICE_DESCRIPTOR_IN_WORDS     (6)
                             3663 ; 196  |#define SIZE_DEVICE_QUALIFIER_DESCRIPTOR_IN_BYTES   (10)
                             3664 ; 197  |#define SIZE_DEVICE_QUALIFIER_DESCRIPTOR_IN_WORDS   (4)
                             3665 ; 198  |#define SIZE_CONFIG_DESCRIPTOR_IN_BYTES     (9)
                             3666 ; 199  |#define SIZE_CONFIG_DESCRIPTOR_IN_WORDS     (3)
                             3667 ; 200  |#define SIZE_INTERFACE_DESCRIPTOR_IN_BYTES  (9)
                             3668 ; 201  |#define SIZE_INTERFACE_DESCRIPTOR_IN_WORDS  (3)
                             3669 ; 202  |#define SIZE_ENDPOINT_DESCRIPTOR_IN_BYTES   (7)
                             3670 ; 203  |
                             3671 ; 204  |
                             3672 ; 205  |// Descriptor types
                             3673 ; 206  |#define DESCRIPTOR_TYPE_DEVICE              (0x01)
                             3674 ; 207  |#define DESCRIPTOR_TYPE_CONFIG              (0x02)
                             3675 ; 208  |#define DESCRIPTOR_TYPE_STRING              (0x03)
                             3676 ; 209  |#define DESCRIPTOR_TYPE_INTERFACE           (0x04)
                             3677 ; 210  |#define DESCRIPTOR_TYPE_ENDPOINT            (0x05)
                             3678 ; 211  |#define DESCRIPTOR_TYPE_DEVICE_QUALIFIER    (0x06)
                             3679 ; 212  |#define DESCRIPTOR_TYPE_OTHER_SPEED_CONFIG  (0x07)
                             3680 ; 213  |#define DESCRIPTOR_TYPE_INTERFACE_POWER     (0x08)
                             3681 ; 214  |
                             3682 ; 215  |
                             3683 ; 216  |#define USB_REQUEST_DIRECTION_HOST_TO_DEVICE    ((WORD)0x000000)
                             3684 ; 217  |#define USB_REQUEST_DIRECTION_DEVICE_TO_HOST    ((WORD)0x000001)
                             3685 ; 218  |
                             3686 ; 219  |#define USB_REQUEST_TYPE_STANDARD               ((WORD)0x000000)
                             3687 ; 220  |#define USB_REQUEST_TYPE_CLASS                  ((WORD)0x000001)
                             3688 ; 221  |#define USB_REQUEST_TYPE_VENDOR                 ((WORD)0x000002)
                             3689 ; 222  |#define USB_REQUEST_TYPE_RESERVED               ((WORD)0x000003)
                             3690 ; 223  |
                             3691 ; 224  |#define USB_REQUEST_RECIPIENT_DEVICE            ((WORD)0x000000)
                             3692 ; 225  |#define USB_REQUEST_RECIPIENT_INTERFACE         ((WORD)0x000001)
                             3693 ; 226  |#define USB_REQUEST_RECIPIENT_ENDPOINT          ((WORD)0x000002)
                             3694 ; 227  |#define USB_REQUEST_RECIPIENT_OTHER             ((WORD)0x000003)
                             3695 ; 228  |
                             3696 ; 229  |#define USB_REQUEST_STANDARD_GET_STATUS         ((WORD)0x000000)
                             3697 ; 230  |#define USB_REQUEST_STANDARD_CLEAR_FEATURE      ((WORD)0x000001)
                             3698 ; 231  |#define USB_REQUEST_STANDARD_RESERVED_1         ((WORD)0x000002)
                             3699 ; 232  |#define USB_REQUEST_STANDARD_SET_FEATURE        ((WORD)0x000003)
                             3700 ; 233  |#define USB_REQUEST_STANDARD_RESERVED_2         ((WORD)0x000004)
                             3701 ; 234  |#define USB_REQUEST_STANDARD_SET_ADDRESS        ((WORD)0x000005)
                             3702 ; 235  |#define USB_REQUEST_STANDARD_GET_DESCRIPTOR     ((WORD)0x000006)
                             3703 ; 236  |#define USB_REQUEST_STANDARD_SET_DESCRIPTOR     ((WORD)0x000007)
                             3704 ; 237  |#define USB_REQUEST_STANDARD_GET_CONFIGURATION  ((WORD)0x000008)
                             3705 ; 238  |#define USB_REQUEST_STANDARD_SET_CONFIGURATION  ((WORD)0x000009)
                             3706 ; 239  |#define USB_REQUEST_STANDARD_GET_INTERFACE      ((WORD)0x00000A)
                             3707 ; 240  |#define USB_REQUEST_STANDARD_SET_INTERFACE      ((WORD)0x00000B)
                             3708 ; 241  |#define USB_REQUEST_STANDARD_SYNCH_FRAME        ((WORD)0x00000C)
                             3709 ; 242  |
                             3710 ; 243  |#define USB_CLEAR_FEATURE_ENDPOINT_HALT         (0)
                             3711 ; 244  |#define USB_CLEAR_FEATURE_REMOTE_WAKEUP         (1)
                             3712 ; 245  |
                             3713 ; 246  |
                             3714 ; 247  |// Struct Device Descriptor
                             3715 ; 248  |typedef struct {
                             3716 ; 249  |    BYTE    bLength;                // (0) Size of this descriptor in bytes (18)
                             3717 ; 250  |    BYTE    btDescriptorType;       // (1) Device descriptor type (1)
                             3718 ; 251  |    BYTE    btBcdUsbLsb;            // (2) USB specification release number (for version 2.00 0x00)
                             3719 ; 252  |    BYTE    btBcdUsbMsb;            // (3)                                  (for version 2.00 0x02)     
                             3720 ; 253  |    BYTE    btDeviceClass;          // (4) Class code
                             3721 ; 254  |    BYTE    btDeviceSubclass;       // (5) Subclass code
                             3722 ; 255  |    BYTE    btDeviceProtocol;       // (6) Protocol code
                             3723 ; 256  |    BYTE    btMaxPacketSize0;       // (7) Maximum packet size for endpoint 0 (8, 16, 32 or 64)
                             3724 ; 257  |    BYTE    btIdVendorLsb;          // (8) Vendor Id
                             3725 ; 258  |    BYTE    btIdVendorMsb;          // (9)
                             3726 ; 259  |    BYTE    btIdProductLsb;         // (10) Product Id
                             3727 ; 260  |    BYTE    btIdProductMsb;         // (11)
                             3728 ; 261  |    BYTE    btBcdReleaseLsb;        // (12) Device release number in BCD
                             3729 ; 262  |    BYTE    btBcdReleaseMsb;        // (13)
                             3730 ; 263  |    BYTE    btIndexManufacturer;    // (14) Index of string descriptor describing Manufacturer
                             3731 ; 264  |    BYTE    btIndexProduct;         // (15) Index of string descriptor describing Product
                             3732 ; 265  |    BYTE    btIndexSerialNumber;    // (16) Index of string descriptor describing Device Serial Number
                             3733 ; 266  |    BYTE    btNumConfigurations;    // (17) Number of possible configurations
                             3734 ; 267  |} Struct_Standard_Dev_Desc;
                             3735 ; 268  |
                             3736 ; 269  |// Struct Device Qualifier Descriptor
                             3737 ; 270  |typedef struct {
                             3738 ; 271  |    BYTE    bLength;                // (0) Size of this descriptor in bytes (10)
                             3739 ; 272  |    BYTE    btDescriptorType;       // (1) Device descriptor type (6)
                             3740 ; 273  |    BYTE    btBcdUsbLsb;            // (2) USB specification release number (for version 2.00 0x00)
                             3741 ; 274  |    BYTE    btBcdUsbMsb;            // (3)                                  (for version 2.00 0x02)     
                             3742 ; 275  |    BYTE    btDeviceClass;          // (4) Class code
                             3743 ; 276  |    BYTE    btDeviceSubclass;       // (5) Subclass code
                             3744 ; 277  |    BYTE    btDeviceProtocol;       // (6) Protocol code
                             3745 ; 278  |    BYTE    btMaxPacketSize0;       // (7) Maximum packet size for endpoint 0 other speed (8, 16, 32 or 64)
                             3746 ; 279  |    BYTE    btNumConfigurations;    // (8) Number of other-speed possible configurations
                             3747 ; 280  |    BYTE    btReserved;             // (9) Reserved for future use, must be 0
                             3748 ; 281  |} Struct_Dev_Qualifier_Desc;
                             3749 ; 282  |
                             3750 ; 283  |// Struct Configuration Descriptor
                             3751 ; 284  |typedef struct {
                             3752 ; 285  |    BYTE    bLength;                // (0) Size of this descriptor in bytes (9)
                             3753 ; 286  |    BYTE    btDescriptorType;       // (1) Device descriptor type (2 or 7)
                             3754 ; 287  |    BYTE    btTotalLengthLsb;       // (2) Total length of data returned for this config.
                             3755 ; 288  |    BYTE    btTotalLengthMsb;       // (3)                                  
                             3756 ; 289  |    BYTE    btNumInterfaces;        // (4) Number of Interfaces supported by this configuration
                             3757 ; 290  |    BYTE    btConfigurationValue;   // (5) Value to use as an argument to the SetConfiguration() request
                             3758 ; 291  |    BYTE    btIndexConfiguration;   // (6) Index of string descriptor describing this configuration
                             3759 ; 292  |    BYTE    btBitMapAttributes;     // (7) Configuration Characteristics
                             3760 ; 293  |                                    //     D7:      Reserved (set to one)
                             3761 ; 294  |                                    //     D6:      Self-powered
                             3762 ; 295  |                                    //     D5:      Remote Wakeup
                             3763 ; 296  |                                    //     D4..0:   Reserved (reset to zero)        
                             3764 ; 297  |    BYTE    btMaxPower;             // (8) Maximum power consumption expressed in 2mA units.
                             3765 ; 298  |} Struct_Standard_Config_Desc, Struct_Other_Speed_Config_Desc;
                             3766 ; 299  |
                             3767 ; 300  |// Struct Interface Descriptor
                             3768 ; 301  |typedef struct {
                             3769 ; 302  |    BYTE    bLength;                // (0) Size of this descriptor in bytes (9)
                             3770 ; 303  |    BYTE    btDescriptorType;       // (1) Device descriptor type (4)
                             3771 ; 304  |    BYTE    btInterfaceNum;         // (2) Number of this interface. Zero-based value.
                             3772 ; 305  |    BYTE    btAlternateSetting;     // (3)                                  
                             3773 ; 306  |    BYTE    btNumEndpoints;         // (4) Number of endpointsused by this interface (excluding endpoint 0).
                             3774 ; 307  |    BYTE    btInterfaceClass;       // (5) Class code
                             3775 ; 308  |    BYTE    btInterfaceSubClass;    // (6) Sub Class code
                             3776 ; 309  |    BYTE    btInterfaceProtocol;    // (7) Protocol Code
                             3777 ; 310  |    BYTE    btIndexInterface;       // (8) Index of string descriptor describing this interface
                             3778 ; 311  |} Struct_Standard_Interface_Desc;
                             3779 ; 312  |
                             3780 ; 313  |// Struct Endpoint Descriptor
                             3781 ; 314  |typedef struct {
                             3782 ; 315  |    BYTE    bLength;                // (0) Size of this descriptor in bytes (7)
                             3783 ; 316  |    BYTE    btDescriptorType;       // (1) Device descriptor type (5)
                             3784 ; 317  |    BYTE    btEndpointAddress;      // (2) Address of the endpoint on the USB device described by this descriptor
                             3785 ; 318  |                                    //      Bit 3..0: Endpoint number
                             3786 ; 319  |                                    //      Bit 6..4: Reserved, reset to zero
                             3787 ; 320  |                                    //      Bit 7:    Direction. Ignored for control endpoints (0 OUT, 1 IN)
                             3788 ; 321  |    BYTE    btBitMapAttributes;     // (3) Endpoint attributes
                             3789 ; 322  |                                    //      bits 1..0: Transfer Type (00 Control, 01 Iso, 10 Bulk, 11 Int)
                             3790 ; 323  |                                    //      bits 5..2: If not an iso endpoints, they are reserved and must be reset to zero.
                             3791 ; 324  |                                    //      bits 7..6: Reserved bits, must be reset to zero.                                    
                             3792 ; 325  |    BYTE    btMaxPacketSizeLsb;     // (4) Maximum packet size. Refer to standard for bits specification
                             3793 ; 326  |    BYTE    btMaxPacketSizeMsb;     // (5)
                             3794 ; 327  |    BYTE    btInterval;             // (6) Interval for polling endpoint for data transfers (refer to standard)
                             3795 ; 328  |} Struct_Standard_Endpoint_Desc;
                             3796 ; 329  |
                             3797 ; 330  |typedef struct {
                             3798 ; 331  |    BYTE    btLength;                   // (0) Size of this descriptor in bytes (2*MAX_USB_LANG + 2)
                             3799 ; 332  |    BYTE    btDescriptorType;           // (1) String descriptor type (3)
                             3800 ; 333  |    BYTE    btString[MAX_STRING*2];       
                             3801 ; 334  |} Struct_String_Desc;
                             3802 ; 335  |
                             3803 ; 336  |//
                             3804 ; 337  |// Externals
                             3805 ; 338  |//
                             3806 ; 339  |extern void _reentrant usb_dci_chip_enable (void);
                             3807 ; 340  |extern void _reentrant usb_dci_shutdown(void);
                             3808 ; 341  |
                             3809 ; 342  |BYTE _reentrant usb_device_init(void);
                             3810 ; 343  |void _inline usb_device_shutdown(void)
                             3811 ; 344  |{
                             3812 ; 345  |    usb_dci_shutdown();
                             3813 ; 346  |}
                             3814 ; 347  |
                             3815 ; 348  |BYTE _reentrant usb_device_register_service(BYTE btType, void (* Service)(BOOL bSetup, BYTE btDirection, BYTE _USB_MEM * pbtBuffer, WORD wLength,WORD wPrivateData)); 
                             3816 ; 349  |//Remove unused function usb_device_get_service() to reclain _P memroy.
                             3817 ; 350  |//BYTE _reentrant usb_device_get_service(BYTE btType, void (* Service)(BOOL bSetup, BYTE btDirection, BYTE _USB_MEM * pbtBuffer, WORD wLength)); 
                             3818 ; 351  |
                             3819 ; 352  |BYTE _reentrant usb_device_init_endpoint(BYTE btEndpoint, USHORT usMaxPacketSize, BYTE btDirection, BYTE btType, BOOL bFlag);
                             3820 ; 353  |
                             3821 ; 354  |extern USB_SetupData *_reentrant usb_dci_get_setup_data(BYTE btEndpoint);
                             3822 ; 355  |#define usb_device_read_setup_data(btEndpoint) usb_dci_get_setup_data(btEndpoint)
                             3823 ; 356  |
                             3824 ; 357  |void _reentrant usb_device_get_status(BYTE btType, USHORT * pusStatus);
                             3825 ; 358  |void _reentrant usb_device_set_status(BYTE btType, USHORT usStatus);
                             3826 ; 359  |BYTE _reentrant usb_device_get_transfer_status(BYTE btEndpoint, BYTE btDirection);
                             3827 ; 360  |
                             3828 ; 361  |extern void _reentrant usb_dci_stall_endpoint(BYTE btEndpoint, BYTE btDirection);
                             3829 ; 362  |#define usb_device_stall_endpoint(btEndpoint, btDirection) usb_dci_stall_endpoint((btEndpoint), (btDirection))
                             3830 ; 363  |
                             3831 ; 364  |extern void _reentrant usb_dci_unstall_endpoint(BYTE btEndpoint, BYTE btDirection);
                             3832 ; 365  |#define usb_device_unstall_endpoint(btEndpoint, btDirection) usb_dci_unstall_endpoint((btEndpoint), (btDirection))
                             3833 ; 366  |
                             3834 ; 367  |extern void _reentrant usb_dci_finish_transaction(BYTE btEndpoint);
                             3835 ; 368  |#define usb_device_finish_transaction(btEndpoint) usb_dci_finish_transaction(btEndpoint);
                             3836 ; 369  |
                             3837 ; 370  |////////////////////////////////////////////////////////////////////////////////
                             3838 ; 371  |//
                             3839 ; 372  |//>  Name:          usb_device_enable
                             3840 ; 373  |//
                             3841 ; 374  |//   Type:          Function
                             3842 ; 375  |//
                             3843 ; 376  |//   Description:   Enables the USB device for transfers
                             3844 ; 377  |//
                             3845 ; 378  |//   Inputs:        none
                             3846 ; 379  |//
                             3847 ; 380  |//   Outputs:       USB_OK or error code
                             3848 ; 381  |//
                             3849 ; 382  |//   Notes:         none
                             3850 ; 383  |//<
                             3851 ; 384  |////////////////////////////////////////////////////////////////////////////////
                             3852 ; 385  |void _inline usb_device_enable(void)
TASKING DSP2410 assembler v1.5r1 Build 138 SN 00100122
                                                                                                                                                                                                                                                       Page  16

M:ADDR CODE           CYCLES LINE SOURCELINE
                             3853 ; 386  |{
                             3854 ; 387  |    usb_dci_chip_enable();
                             3855 ; 388  |}
                             3856 ; 389  |
                             3857 ; 390  |void _reentrant usb_device_release(void);
                             3858 ; 391  |void _reentrant usb_device_hold(void);
                             3859 ; 392  |BYTE _reentrant usb_device_is_hold(void);
                             3860 ; 393  |void _reentrant usb_device_data_phase_required(void);
                             3861 ; 394  |
                             3862 ; 395  |BOOL _reentrant usb_device_is_first_init(void);
                             3863 ; 396  |void _reentrant usb_device_set_first_init(void);
                             3864 ; 397  |void _reentrant usb_device_clear_first_init(void);
                             3865 ; 398  |
                             3866 ; 399  |WORD _reentrant usb_get_current_limit(void);
                             3867 ; 400  |RETCODE _reentrant usb_set_current_limit(WORD);
                             3868 ; 401  |
                             3869 ; 402  |////////////////////////////////////////////////////////////////////
                             3870 ; 403  |extern BYTE _reentrant usb_dci_get_endpoint_status(BYTE btEndpoint);
                             3871 ; 404  |#define usb_device_get_endpoint_status(btEndpoint) usb_dci_get_endpoint_status(btEndpoint)
                             3872 ; 405  |
                             3873 ; 406  |#define USB_ENDPOINT_STATUS_OK                          0
                             3874 ; 407  |#define USB_ENDPOINT_STATUS_STALLED                     1
                             3875 ; 408  |#define USB_ENDPOINT_STATUS_RECIEVED_UNSTALL_REQUEST    2
                             3876 ; 409  |// WHQL
                             3877 ; 410  |#define USB_ENDPOINT_STATUS_HOST_STALLED                3
                             3878 ; 411  |////////////////////////////////////////////////////////////////////
                             3879 ; 412  |
                             3880 ; 413  |
                             3881 ; 414  |BYTE _reentrant usb_device_send_data(BYTE btEndpoint, WORD _X * pbtStmpWordAdd, BYTE btByteOffset, USHORT usSize, WORD wPrivateData, BOOL bIsDataPhase);
                             3882 ; 415  |BYTE _reentrant usb_device_recv_data(BYTE btEndpoint, WORD _X * pbtStmpWordAdd, BYTE btByteOffset, USHORT usSize, WORD wPrivateData, BOOL bIsDataPhase);
                             3883 ; 416  |void _reentrant ch9ServiceEp0(BOOL bSetup, BYTE btDirection, WORD _X *pbtBuffer, WORD wLength,WORD wPrivateData);
                             3884 ; 417  |BYTE _reentrant usb_device_transfer_data(BYTE btEndpoint, WORD _X* pbtStmpWordAdd, 
                             3885 ; 418  |                                         BYTE btByteOffset, USHORT usSize, WORD wPrivateData, 
                             3886 ; 419  |                                         BOOL bIsDataPhase, WORD wDirection);
                             3887 ; 420  |
                             3888 ; 421  |#ifndef CUSTOMIZE_UNICODE
                             3889 ; 422  |extern const BYTE g_Manufacturer[];
                             3890 ; 423  |extern const BYTE g_ProductName[];
                             3891 ; 424  |extern const BYTE g_ConfigString[];
                             3892 ; 425  |extern const BYTE g_Interface0String[];
                             3893 ; 426  |extern const BYTE g_Interface1String[];
                             3894 ; 427  |extern const BYTE g_MSOSDescriptorString[];
                             3895 ; 428  |#else   // CUSTOMIZE_UNICODE
                             3896 ; 429  |extern const WORD g_Manufacturer[];
                             3897 ; 430  |extern const WORD g_ProductName[];
                             3898 ; 431  |extern const WORD g_ConfigString[];
                             3899 ; 432  |extern const WORD g_Interface0String[];
                             3900 ; 433  |extern const WORD g_Interface1String[];
                             3901 ; 434  |extern const WORD g_MSOSDescriptorString[];
                             3902 ; 435  |#endif
                             3903 ; 436  |extern WORD g_LanguageList[];
                             3904 ; 437  |
                             3905 ; 438  |extern const BYTE g_SCSIVendorID[];
                             3906 ; 439  |extern const BYTE g_SCSIProductID[];
                             3907 ; 440  |extern void *g_pStrings[];
                             3908 ; 441  |
                             3909 ; 442  |extern WORD g_wUSBVendorID;
                             3910 ; 443  |extern WORD g_wUSBProductID;
                             3911 ; 444  |extern WORD g_wUSBReleaseID;
                             3912 ; 445  |
                             3913 ; 446  |#endif
                             3914 ; 447  |/* EOF */
                             3915 ; 448  |
                             3916 
                             3918 
                             3919 ; 7    |
                             3920 ; 8    |
                             3921 ; 9    |BYTE _reentrant usb_dci_init                (Dev_State_Struct _USB_MEM * pStDeviceState);
                             3922 ; 10   |#define usb_dci_chip_init(pStDeviceState) /* Do Nothing */
                             3923 ; 11   |void _reentrant usb_dci_process_reset       (Dev_State_Struct _USB_MEM * pStDeviceState);
                             3924 ; 12   |void _reentrant usb_dci_process_tr_complete (Dev_State_Struct _USB_MEM * pStDeviceState);
                             3925 ; 13   |void _reentrant usb_dci_process_suspend     (Dev_State_Struct _USB_MEM * pStDeviceState);
                             3926 ; 14   |void _reentrant usb_dci_process_port_change (Dev_State_Struct _USB_MEM * pStDeviceState);
                             3927 ; 15   |BYTE _reentrant usb_dci_init_endpoint       (xd_struct _USB_MEM * pStXD);
                             3928 ; 16   |USB_SetupData *_reentrant usb_dci_get_setup_data(BYTE btEndpoint);
                             3929 ; 17   |BYTE _reentrant usb_dci_get_endpoint_status(BYTE btEndpoint);
                             3930 ; 18   |void _reentrant usb_dci_set_endpoint_status(BYTE btEndpoint, USHORT usStatus);
                             3931 ; 19   |void _reentrant usb_dci_set_address(BYTE btAddress);
                             3932 ; 20   |BYTE _reentrant usb_dci_get_transfer_status(BYTE btEndpoint, BYTE btDirection);
                             3933 ; 21   |void _reentrant usb_dci_stall_endpoint(BYTE btEndpoint, BYTE btDirection);
                             3934 ; 22   |void _reentrant usb_dci_host_stall_endpoint(BYTE btEndpoint, BYTE btDirection);
                             3935 ; 23   |void _reentrant usb_dci_unstall_endpoint(BYTE btEndpoint, BYTE btDirection);
                             3936 ; 24   |void _reentrant usb_dci_init_data_toggle_endpoint(BYTE btEndpoint);
                             3937 ; 25   |BYTE _reentrant usb_dci_transfer_data(xd_struct _USB_MEM * pStXd);
                             3938 ; 26   |void _reentrant usb_dci_finish_transaction(BYTE btEndpoint);
                             3939 ; 27   |void _reentrant usb_dci_update_connection_status(void);
                             3940 ; 28   |void _reentrant usb_dci_shutdown(void);
                             3941 ; 29   |void _reentrant usb_dci_set_test_mode(USHORT usTest); 
                             3942 ; 30   |
                             3943 ; 31   |void _reentrant usb_dci_chip_enable (void);
                             3944 ; 32   |#endif
                             3945 
                             3947 
                             3948 ; 21   |#include "sysirq.h"
                             3949 
                             3951 
                             3952 ; 1    |////////////////////////////////////////////////////////////////////////////////
                             3953 ; 2    |// Copyright(C) SigmaTel, Inc. 2000-2001
                             3954 ; 3    |//
                             3955 ; 4    |// Filename: sysirq.h
                             3956 ; 5    |// Description: 
                             3957 ; 6    |////////////////////////////////////////////////////////////////////////////////
                             3958 ; 7    |
                             3959 ; 8    |#ifndef _SYSIRQ_H
                             3960 ; 9    |#define _SYSIRQ_H
                             3961 ; 10   |
                             3962 ; 11   |///////////////////////////////////////////////////////////////////////////////
                             3963 ; 12   |// Defs
                             3964 ; 13   |///////////////////////////////////////////////////////////////////////////////
                             3965 ; 14   |
                             3966 ; 15   |#define     INTERRUPTS_UNMASK_ALL   0x000000
                             3967 ; 16   |
                             3968 ; 17   |///////////////////////////////////////////////////////////////////////////////
                             3969 ; 18   |// Structure definitions
                             3970 ; 19   |///////////////////////////////////////////////////////////////////////////////
                             3971 ; 20   |
                             3972 ; 21   |///////////////////////////////////////////////////////////////////////////////
                             3973 ; 22   |// Prototypes
                             3974 ; 23   |///////////////////////////////////////////////////////////////////////////////
                             3975 ; 24   |
                             3976 ; 25   |WORD _reentrant SysMaskAllInterrupts(void);
                             3977 ; 26   |void _reentrant SysUnMaskAllInterrupts(WORD wLevel);
                             3978 ; 27   |WORD _reentrant SysGetIrqLevel(void);
                             3979 ; 28   |RETCODE _reentrant SysSetIrqLevel(WORD wIrqLevel);
                             3980 ; 29   |
                             3981 ; 30   |#endif // #ifndef _SYSIRQ_H
                             3982 
                             3984 
                             3985 ; 22   |
                             3986 ; 23   |////////////////////////////////////////////////////////////////////////////////
                             3987 ; 24   |//  External Definitions
                             3988 ; 25   |////////////////////////////////////////////////////////////////////////////////
                             3989 ; 26   |#ifdef FUNCLET
                             3990 ; 27   |#pragma asm
                             3991 ; 28   |    extern SysCallFunclet
                             3992 ; 29   |#pragma endasm
                             3993 ; 30   |#endif // ifdef FUNCLET
                             3994 ; 31   |
                             3995 ; 32   |////////////////////////////////////////////////////////////////////////////////
                             3996 ; 33   |//  External References
                             3997 ; 34   |////////////////////////////////////////////////////////////////////////////////
                             3998 ; 35   |xd_struct _USB_MEM * g_dXD_Queues[MAX_NUM_EP][2];
                             3999 ; 36   |extern BYTE _USB_MEM * ConfigStruct[];
                             4000 ; 37   |
                             4001 ; 38   |////////////////////////////////////////////////////////////////////////////////
                             4002 ; 39   |//  Equates
                             4003 ; 40   |////////////////////////////////////////////////////////////////////////////////
                             4004 ; 41   |
                             4005 ; 42   |////////////////////////////////////////////////////////////////////////////////
                             4006 ; 43   |//  Prototypes
                             4007 ; 44   |////////////////////////////////////////////////////////////////////////////////
                             4008 ; 45   |xd_struct _USB_MEM * GetEmptyXd(void);
                             4009 ; 46   |void FreeXd(xd_struct _USB_MEM * );
                             4010 ; 47   |void AddXdToQueue(xd_struct _USB_MEM *,xd_struct _USB_MEM *);
                             4011 ; 48   |
                             4012 ; 49   |////////////////////////////////////////////////////////////////////////////////
                             4013 ; 50   |//  X Memory
                             4014 ; 51   |////////////////////////////////////////////////////////////////////////////////
                             4015 ; 52   |Dev_State_Struct _USB_MEM stDeviceState;
                             4016 
                             4024 
                             4025 ; 53   |Service_Struct      _X Services[MAX_NUMBER_SERVICES];       
                             4026 ; 54   | 
                             4027 ; 55   |xd_struct _USB_MEM stTemp;
                             4028 ; 56   |
                             4029 ; 57   |static BYTE s_btHoldOffEP0 = TRUE;
                             4030 
                             4031 
Y:0000                       4032         org     y,".ydatausb_api",init:
                             4033 Fs_btHoldOffEP0:
Y:0000 000001                4034         dc      $01
                             4036 
                             4037 ; 58   |static BYTE s_btStatusPhase = FALSE;
                             4038 
                             4039 Fs_btStatusPhase:
Y:0001 000000                4040         dc      $00
                             4042 
                             4043 ; 59   |static BOOL s_bUsbFirstInit = TRUE;
                             4044 
                             4045 Fs_bUsbFirstInit:
Y:0002 000001                4046         dc      $000001
                             4048 
                             4049 ; 60   |
                             4050 ; 61   |
                             4051 ; 62   |
                             4052 ; 63   |////////////////////////////////////////////////////////////////////////////////
                             4053 ; 64   |//  Y Memory
                             4054 ; 65   |////////////////////////////////////////////////////////////////////////////////
                             4055 ; 66   |#ifndef MAX_USB_TRANSFERS_QUEUED
                             4056 ; 67   |#define MAX_USB_TRANSFERS_QUEUED 48
                             4057 ; 68   |#endif
                             4058 ; 69   |xd_struct _USB_MEM g_XdPool[MAX_USB_TRANSFERS_QUEUED];
                             4059 ; 70   |
                             4060 ; 71   |////////////////////////////////////////////////////////////////////////////////
                             4061 ; 72   |//  P Memory
                             4062 ; 73   |////////////////////////////////////////////////////////////////////////////////
                             4063 ; 74   |
                             4064 ; 75   |
                             4065 ; 76   |////////////////////////////////////////////////////////////////////////////////
                             4066 ; 77   |//
                             4067 ; 78   |//>  Name:          usb_device_register_service
                             4068 ; 79   |//
                             4069 ; 80   |//   Type:          Function
                             4070 ; 81   |//
                             4071 ; 82   |//   Description:   Registers a function service for a specified endpoint
                             4072 ; 83   |//                  or event
                             4073 ; 84   |//
                             4074 ; 85   |//   Inputs:        
                             4075 ; 86   |//                  type    : Service type
                             4076 ; 87   |//                  service : Pointer to the service function
                             4077 ; 88   |//   Outputs:       USB_OK or error code
                             4078 ; 89   |//
                             4079 ; 90   |//   Notes:         none
                             4080 ; 91   |//<
                             4081 ; 92   |////////////////////////////////////////////////////////////////////////////////
                             4082 ; 93   |BYTE _reentrant usb_device_register_service(BYTE btType, void (* Service)(BOOL bSetup, BYTE btDirection, BYTE _USB_MEM  * pbtBuffer, WORD wLength,WORD wPrivateData)) 
                             4083 ; 94   |{ /* Body */
                             4084 
P:0000                       4085         org     p,".ptextusb_api":
                             4095 Fusb_device_register_service:
P:0000 055F7C         2    2 4096         movec   ssh,y:(r7)+
P:0001 205F00         2    4 4099         move    (r7)+
P:0002 205F00         2    6 4100         move    (r7)+
                             4115 
                             4116 ; 95   |   INT          i;
                             4117 ; 96   |   BOOL         bNewService;
                             4118 ; 97   |   WORD                 wOldInterrupt;
                             4119 
P:0003 045FA0         2    8 4121         movec   m0,n7
P:0004 000000         2   10 4122         nop
P:0005 686F00         4   14 4123         move    r0,y:(r7+n7)
P:0006 77F400 FFFFFE  3   17 4126         move    #-2,n7
P:0008 000000         2   19 4127         nop
P:0009 5C6F00         4   23 4128         move    a1,y:(r7+n7)
                             4131 
                             4132 ; 98   |   wOldInterrupt = SysMaskAllInterrupts();
                             4133 
P:000A 0BF080 rrrrrr  6   29 4135         jsr     FSysMaskAllInterrupts
                             4137 
                             4138 ; 99   |   
                             4139 ; 100  |   bNewService = TRUE;
                             4140 
P:000C 47F400 000001  3   32 4142         move    #>1,y1
P:000E 20E500         2   34 4143         move    y1,x1
                             4145 
                             4146 ; 101  |       
                             4147 ; 102  |    for(i = 0 ; i < stDeviceState.btServicesRegistered ; i++)
                             4148 
P:000F 79F000 rrrrrr  3   37 4150         move    y:FstDeviceState+9,n1
P:0011 232F00         2   39 4151         move    n1,b
P:0012 240000         2   41 4152         move    #0,x0
TASKING DSP2410 assembler v1.5r1 Build 138 SN 00100122
                                                                                                                                                                                                                                                       Page  17

M:ADDR CODE           CYCLES LINE SOURCELINE
P:0013 64F400 rrrrrr  3   44 4154         move    #FServices,r4
P:0015 20000B         2   46 4155         tst     b
P:0016 0AF0AF rrrrrr  6   52 4156         jle     L12
P:0018 06CD00 rrrrrr  6   58 4157         do      b1,L12
                             4159 
                             4160 ; 103  |    {
                             4161 ; 104  |        if(Services[i].btType == btType)
                             4162 
P:001A 200049         2   60 4164         tfr     x0,b
P:001B 20003B         2   62 4165         lsl     b
P:001C 21BC00         2   64 4166         move    b1,n4
P:001D 000000         2   66 4167         nop
P:001E 044C13         4   70 4168         lua     (r4)+n4,r3
P:001F 000000         2   72 4169         nop
P:0020 57E300         2   74 4170         move    x:(r3),b
P:0021 77F400 FFFFFE  3   77 4171         move    #-2,n7
P:0023 000000         2   79 4172         nop
P:0024 4EEF00         4   83 4173         move    y:(r7+n7),y0
P:0025 20005D         2   85 4174         cmp     y0,b
P:0026 0AF0A2 rrrrrr  6   91 4175         jne     L4
                             4176 
                             4177 ; 105  |        {
                             4178 ; 106  |            bNewService = FALSE;            // We want to replace a service
                             4179 
P:0028 250000         2   93 4181         move    #0,x1
                             4182 
                             4183 ; 107  |            break;
                             4184 
P:0029 00008C         2   95 4186         enddo
P:002A 0AF080 rrrrrr  6  101 4188         jmp     L6
                             4189 
                             4190 ; 108  |        }            
                             4191 
                             4193 L4:
P:002C 200049         2  103 4195         tfr     x0,b
P:002D 200078         2  105 4196         add     y1,b
P:002E 21A400         2  107 4199         move    b1,x0
                        (49) 4202 L12:
                             4204 
                             4205 ; 109  |    }            
                             4206 ; 110  |            
                             4207 ; 111  |    if(bNewService == TRUE)
                             4208 
P:002F 200069         2  109 4210 L6:     tfr     x1,b
P:0030 2B0000         2  111 4211         move    #0,b2
P:0031 20007D         2  113 4212         cmp     y1,b
P:0032 0AF0A2 rrrrrr  6  119 4215         jne     L8
                             4216 
                             4217 ; 112  |    {
                             4218 ; 113  |        // Case of installing a new service
                             4219 ; 114  |        
                             4220 ; 115  |        // Check if number of service registered maxed
                             4221 ; 116  |        if(stDeviceState.btServicesRegistered >= (MAX_NUMBER_SERVICES - 1))
                             4222 
P:0034 232F00         2  121 4224         move    n1,b
P:0035 46F400 000009  3  124 4226         move    #>9,y0
P:0037 20005D         2  126 4227         cmp     y0,b
P:0038 0AF0A9 rrrrrr  6  132 4228         jlt     L7
                             4229 
                             4230 ; 117  |        {
                             4231 ; 118  |                        SysUnMaskAllInterrupts(wOldInterrupt);
                             4232 
P:003A 0BF080 rrrrrr  6  138 4234         jsr     FSysUnMaskAllInterrupts
                             4237 
                             4238 ; 119  |            return USBERR_REGISTER_SERVICE;
                             4239 
P:003C 56F400 000001  3  141 4241         move    #>1,a
P:003E 0AF080 rrrrrr  6  147 4242         jmp     L10
                             4243 
                             4244 ; 120  |        }
                             4245 ; 121  |        
                             4246 ; 122  |        // Register new service
                             4247 ; 123  |        Services[stDeviceState.btServicesRegistered].btType = btType;
                             4248 
P:0040 5FF000 rrrrrr  3  150 4250 L7:     move    y:FstDeviceState+9,b
P:0042 20003B         2  152 4251         lsl     b
P:0043 21BE00         2  154 4252         move    b1,n6
P:0044 66F400 rrrrrr  3  157 4253         move    #FServices,r6
P:0046 000000         2  159 4254         nop
P:0047 044E13         4  163 4255         lua     (r6)+n6,r3
P:0048 77F400 FFFFFE  3  166 4256         move    #-2,n7
P:004A 000000         2  168 4257         nop
P:004B 4EEF00         4  172 4258         move    y:(r7+n7),y0
P:004C 466300         2  174 4259         move    y0,x:(r3)
                             4262 
                             4263 ; 124  |        Services[stDeviceState.btServicesRegistered].Service = Service;
                             4264 
P:004D 5FF000 rrrrrr  3  177 4266         move    y:FstDeviceState+9,b
P:004F 21A600         2  179 4267         move    b1,y0
P:0050 20003B         2  181 4268         lsl     b
P:0051 21BE00         2  183 4270         move    b1,n6
P:0052 66F400 rrrrrr  3  186 4271         move    #FServices+1,r6
P:0054 000000         2  188 4272         nop
P:0055 044E13         4  192 4273         lua     (r6)+n6,r3
P:0056 045FA0         2  194 4274         movec   m0,n7
P:0057 000000         2  196 4275         nop
P:0058 6EEF00         4  200 4276         move    y:(r7+n7),r6
P:0059 666300         2  202 4277         move    r6,x:(r3)
                             4280 
                             4281 ; 125  |        
                             4282 ; 126  |        // Increment number of registered services
                             4283 ; 127  |        stDeviceState.btServicesRegistered++;       
                             4284 
P:005A 57F400 000001  3  205 4286         move    #>1,b
P:005C 200058         2  207 4287         add     y0,b
P:005D 5D7000 rrrrrr  3  210 4288         move    b1,y:FstDeviceState+9
                             4289 
                             4290 ; 128  |    }
                             4291 
P:005F 0AF080 rrrrrr  6  216 4293         jmp     L9
                             4294 
                             4295 ; 129  |    else
                             4296 ; 130  |    {
                             4297 ; 131  |        // Case of service replacement
                             4298 ; 132  |        Services[i].Service = Service;
                             4299 
                             4301 L8:
P:0061 200049         2  218 4305         tfr     x0,b
P:0062 20003B         2  220 4306         lsl     b
P:0063 21BE00         2  222 4310         move    b1,n6
P:0064 66F400 rrrrrr  3  225 4311         move    #FServices+1,r6
P:0066 000000         2  227 4312         nop
P:0067 044E13         4  231 4313         lua     (r6)+n6,r3
P:0068 045FA0         2  233 4314         movec   m0,n7
P:0069 000000         2  235 4315         nop
P:006A 6EEF00         4  239 4316         move    y:(r7+n7),r6
P:006B 666300         2  241 4317         move    r6,x:(r3)
                             4320 
                             4321 ; 133  |    }    
                             4322 ; 134  |
                             4323 ; 135  |   SysUnMaskAllInterrupts(wOldInterrupt);
                             4324 
P:006C 0BF080 rrrrrr  6  247 4326 L9:     jsr     FSysUnMaskAllInterrupts
                             4328 
                             4329 ; 136  |   
                             4330 ; 137  |   return USB_OK;
                             4331 
P:006E 200013         2  249 4333         clr     a   
                             4334 
                             4335 ; 138  |} /* EndBody */
                             4336 
P:006F 205700         2  251 4338 L10:    move    (r7)-
P:0070 205700         2  253 4339         move    (r7)-
P:0071 05FF7C         4  257 4341         movec   y:-(r7),ssh
P:0072 000000         2  259 4344         nop
P:0073 00000C         4  263 4345         rts
                             4367 
                             4368 ; 139  |
                             4369 ; 140  |////////////////////////////////////////////////////////////////////////////////
                             4370 ; 141  |//
                             4371 ; 142  |//>  Name:          usb_device_init
                             4372 ; 143  |//
                             4373 ; 144  |//   Type:          Function
                             4374 ; 145  |//
                             4375 ; 146  |//   Description:   Initializes the USB device specific data structures
                             4376 ; 147  |//                  and calls the low level device controller chip
                             4377 ; 148  |//                  initialization routine.
                             4378 ; 149  |//
                             4379 ; 150  |//   Inputs:        none
                             4380 ; 151  |//
                             4381 ; 152  |//   Outputs:       USB_OK or error code
                             4382 ; 153  |//
                             4383 ; 154  |//   Notes:         none
                             4384 ; 155  |//<
                             4385 ; 156  |////////////////////////////////////////////////////////////////////////////////
                             4386 ; 157  |extern Struct_Standard_Dev_Desc _USB_MEM StDescDevice;
                             4387 ; 158  |
                             4388 ; 159  |#ifdef FUNCLET
                             4389 ; 160  |    #pragma asm
                             4390 ; 161  |        Fusb_device_init:
                             4391 ; 162  |
                             4392 ; 163  |        nolist
                             4393 ; 164  |        include "sysmacro.asm"
                             4394 ; 165  |        list
                             4395 ; 166  |
                             4396 ; 167  |        ;If using funclet, function will be executed via funclet kernel
                             4397 ; 168  |        extern RSRC_FUNCLET_USB_DEVICE_INIT
                             4398 ; 169  |        CallFunclet RSRC_FUNCLET_USB_DEVICE_INIT
                             4399 ; 170  |
                             4400 ; 171  |        org p,"SYSFUNCLET_USB_DEVICE_INIT_P":
                             4401 ; 172  |        dc      RSRC_FUNCLET_USB_DEVICE_INIT
                             4402 ; 173  |    #pragma endasm
                             4403 ; 174  |BYTE _reentrant usb_device_init_Funclet(void)
                             4404 ; 175  |#else
                             4405 ; 176  |BYTE _reentrant usb_device_init(void)
                             4406 ; 177  |#endif
                             4407 ; 178  |{
                             4408 
                             4413 Fusb_device_init:
P:0074 055F7C         2  265 4414         movec   ssh,y:(r7)+
                             4419 
                             4420 ; 179  |    BYTE     btError;
                             4421 ; 180  |   
                             4422 ; 181  |    _memset(&stDeviceState,0,sizeof(stDeviceState));
                             4423 
P:0075 65F400 rrrrrr  3  268 4425         move    #FstDeviceState,r5
P:0077 270000         2  270 4426         move    #0,y1
P:0078 060D80 rrrrrr  6  276 4427         do      #13,L15
P:007A 4F5D00         2  278 4429         move    y1,y:(r5)+
P:007B 000000         2  280 4430         nop
                         (4) 4431 L15:
                             4433 
                             4434 ; 182  |    
                             4435 ; 183  |    _memset(&g_XdPool,0,sizeof(g_XdPool));
                             4436 
P:007C 64F400 rrrrrr  3  283 4438         move    #Fg_XdPool,r4
P:007E 06D082 rrrrrr  6  289 4439         do      #720,L16
P:0080 4F5C00         2  291 4441         move    y1,y:(r4)+
P:0081 000000         2  293 4442         nop
                         (4) 4443 L16:
                             4445 
                             4446 ; 184  |    
                             4447 ; 185  |    
                             4448 ; 186  |    /* Initialize the device state structure */
                             4449 ; 187  |    stDeviceState.btSpeed = USB_SPEED_HIGH;
                             4450 
P:0082 3D0200         2  295 4452         move    #2,n5
P:0083 7D7000 rrrrrr  3  298 4453         move    n5,y:FstDeviceState
                             4454 
                             4455 ; 188  |    
                             4456 ; 189  |    stDeviceState.usUsbState = USB_STATE_UNKNOWN;
                             4457 
P:0085 46F400 0000FF  3  301 4459         move    #>$FF,y0
P:0087 4E7000 rrrrrr  3  304 4460         move    y0,y:FstDeviceState+4
                             4461 
                             4462 ; 190  |
                             4463 ; 191  |    StDescDevice.btIdVendorLsb = g_wUSBVendorID & 0xff;
                             4464 
P:0089 5CF000 rrrrrr  3  307 4466         move    y:Fg_wUSBVendorID,a1
P:008B 218F00         2  309 4467         move    a1,b
P:008C 200056         2  311 4468         and     y0,a
P:008D 5C7000 rrrrrr  3  314 4469         move    a1,y:FStDescDevice+8
                             4470 
                             4471 ; 192  |    StDescDevice.btIdVendorMsb = (g_wUSBVendorID>>8) & 0xff;
                             4472 
P:008F 060880 rrrrrr  6  320 4474         do      #8,L17
P:0091 20002B         2  322 4476         lsr     b
P:0092 000000         2  324 4477         nop
                         (4) 4478 L17:
P:0093 20005E         2  326 4480         and     y0,b
P:0094 5D7000 rrrrrr  3  329 4481         move    b1,y:FStDescDevice+9
                             4482 
                             4483 ; 193  |
                             4484 ; 194  |    StDescDevice.btIdProductLsb= g_wUSBProductID & 0xff;
                             4485 
P:0096 5EF000 rrrrrr  3  332 4487         move    y:Fg_wUSBProductID,a
P:0098 218D00         2  334 4488         move    a1,b1
P:0099 200056         2  336 4489         and     y0,a
P:009A 5C7000 rrrrrr  3  339 4490         move    a1,y:FStDescDevice+10
                             4491 
                             4492 ; 195  |    StDescDevice.btIdProductMsb= (g_wUSBProductID>>8) & 0xff;
TASKING DSP2410 assembler v1.5r1 Build 138 SN 00100122
                                                                                                                                                                                                                                                       Page  18

M:ADDR CODE           CYCLES LINE SOURCELINE
                             4493 
P:009C 060880 rrrrrr  6  345 4495         do      #8,L18
P:009E 20002B         2  347 4497         lsr     b
P:009F 000000         2  349 4498         nop
                         (4) 4499 L18:
P:00A0 20005E         2  351 4501         and     y0,b
P:00A1 5D7000 rrrrrr  3  354 4502         move    b1,y:FStDescDevice+11
                             4503 
                             4504 ; 196  |
                             4505 ; 197  |    StDescDevice.btBcdReleaseLsb= g_wUSBReleaseID & 0xff;
                             4506 
P:00A3 5DF000 rrrrrr  3  357 4508         move    y:Fg_wUSBReleaseID,b1
P:00A5 21AC00         2  359 4509         move    b1,a1
P:00A6 20005E         2  361 4510         and     y0,b
P:00A7 5D7000 rrrrrr  3  364 4511         move    b1,y:FStDescDevice+12
                             4512 
                             4513 ; 198  |    StDescDevice.btBcdReleaseMsb= (g_wUSBReleaseID>>8) & 0xff;
                             4514 
P:00A9 060880 rrrrrr  6  370 4516         do      #8,L19
P:00AB 200023         2  372 4518         lsr     a
P:00AC 000000         2  374 4519         nop
                         (4) 4520 L19:
P:00AD 200056         2  376 4522         and     y0,a
P:00AE 5C7000 rrrrrr  3  379 4523         move    a1,y:FStDescDevice+13
                             4524 
                             4525 ; 199  |
                             4526 ; 200  |    usb_device_register_service(USB_SERVICE_EP0, ch9ServiceEp0); 
                             4527 
P:00B0 200013         2  381 4529         clr     a   
P:00B1 60F400 rrrrrr  3  384 4530         move    #Fch9ServiceEp0,r0
P:00B3 0BF080 rrrrrr  6  390 4531         jsr     Fusb_device_register_service
                             4532 
                             4533 ; 201  |
                             4534 ; 202  |    /* Initialize the USB controller chip */
                             4535 ; 203  |    btError = usb_dci_init(&stDeviceState);
                             4536 
P:00B5 60F400 rrrrrr  3  393 4538         move    #FstDeviceState,r0
P:00B7 0BF080 rrrrrr  6  399 4539         jsr     Fusb_dci_init
                             4541 
                             4542 ; 204  |
                             4543 ; 205  |    if (btError) {
                             4544 
P:00B9 2A0000         2  401 4546         move    #0,a2
P:00BA 200003         2  403 4547         tst     a
                             4548 
                             4549 ; 206  |        return USBERR_INIT_FAILED;
                             4550 
P:00BB 56F400 000008  3  406 4552         move    #>8,a
P:00BD 0AF0A2 rrrrrr  6  412 4554         jne     L14
                             4555 
                             4556 ; 207  |    } /* Endif */
                             4557 ; 208  |    
                             4558 ; 209  |
                             4559 ; 210  |    return USB_OK;
                             4560 
P:00BF 200013         2  414 4562         clr     a   
                             4563 
                             4564 ; 211  |
                             4565 ; 212  |}
                             4566 
P:00C0 05FF7C         4  418 4568 L14:    movec   y:-(r7),ssh
P:00C1 000000         2  420 4571         nop
P:00C2 00000C         4  424 4572         rts
                             4574 
                             4575 ; 213  |//
                             4576 ; 214  |// Reset the section.
                             4577 ; 215  |//
                             4578 ; 216  |#ifdef FUNCLET
                             4579 ; 217  |    #pragma asm
                             4580 ; 218  |        org p,".ptextusb_api":
                             4581 ; 219  |    #pragma endasm
                             4582 ; 220  |#endif // FUNCLET
                             4583 ; 221  |
                             4584 ; 222  |////////////////////////////////////////////////////////////////////////////////
                             4585 ; 223  |//
                             4586 ; 224  |//>  Name:          usb_device_call_service
                             4587 ; 225  |//
                             4588 ; 226  |//   Type:          Function
                             4589 ; 227  |//
                             4590 ; 228  |//   Description:   Calls the appropriate service for the specified type.
                             4591 ; 229  |//
                             4592 ; 230  |//   Inputs:        
                             4593 ; 231  |//                  btType      : Service type
                             4594 ; 232  |//                       Parameters to pass to the service function
                             4595 ; 233  |//                  bSetup      : Set if setup transfer
                             4596 ; 234  |//                  btDirection : Direction of transmission
                             4597 ; 235  |//                  ptbBuffer   : Pointer to a buffer
                             4598 ; 236  |//                  wLength     : Number of bytes in the transmission
                             4599 ; 237  |//                  wPrivateData: Word passed in 
                             4600 ; 238  |//
                             4601 ; 239  |//   Outputs:       USB_OK or error code
                             4602 ; 240  |//
                             4603 ; 241  |//   Notes:         
                             4604 ; 242  |//                  If no service registered, returns an error code 
                             4605 ; 243  |//<
                             4606 ; 244  |////////////////////////////////////////////////////////////////////////////////
                             4607 ; 245  |BYTE _reentrant usb_device_call_service(BYTE btType, BOOL bSetup, BYTE btDirection, WORD _X*ptbBuffer, WORD wLength, WORD wPrivateData)
                             4608 ; 246  |{ /* Body */
                             4609 
                             4614 Fusb_device_call_service:
P:00C3 055F7C         2  426 4615         movec   ssh,y:(r7)+
P:00C4 3F0700         2  428 4618         move    #7,n7
P:00C5 000000         2  430 4619         nop
P:00C6 204F00         2  432 4620         move    (r7)+n7
                             4638 
                             4639 ; 247  |   INT          i;
                             4640 ; 248  |   WORD         wOldInterrupt;   
                             4641 
P:00C7 77F400 FFFFFE  3  435 4643         move    #-2,n7
P:00C9 000000         2  437 4644         nop
P:00CA 4D6F00         4  441 4645         move    x1,y:(r7+n7)
P:00CB 77F400 FFFFFD  3  444 4648         move    #-3,n7
P:00CD 000000         2  446 4649         nop
P:00CE 4E6F00         4  450 4650         move    y0,y:(r7+n7)
P:00CF 77F400 FFFFFC  3  453 4653         move    #-4,n7
P:00D1 000000         2  455 4654         nop
P:00D2 686F00         4  459 4655         move    r0,y:(r7+n7)
P:00D3 77F400 FFFFFB  3  462 4658         move    #-5,n7
P:00D5 000000         2  464 4659         nop
P:00D6 4C6F00         4  468 4660         move    x0,y:(r7+n7)
P:00D7 77F400 FFFFFA  3  471 4663         move    #-6,n7
P:00D9 000000         2  473 4664         nop
P:00DA 5D6F00         4  477 4665         move    b1,y:(r7+n7)
P:00DB 77F400 FFFFF9  3  480 4668         move    #-7,n7
P:00DD 000000         2  482 4669         nop
P:00DE 5C6F00         4  486 4670         move    a1,y:(r7+n7)
                             4673 
                             4674 ; 249  |   /* Needs mutual exclusion */
                             4675 ; 250  |   wOldInterrupt = SysMaskAllInterrupts();
                             4676 
P:00DF 0BF080 rrrrrr  6  492 4678         jsr     FSysMaskAllInterrupts
P:00E1 045FA0         2  494 4679         movec   m0,n7
P:00E2 000000         2  496 4680         nop
P:00E3 5C6F00         4  500 4681         move    a1,y:(r7+n7)
                             4683 
                             4684 ; 251  |   
                             4685 ; 252  |
                             4686 ; 253  |    // Search for the existing service
                             4687 ; 254  |   for(i = 0 ; i < stDeviceState.btServicesRegistered ; i++)
                             4688 
P:00E4 200013         2  502 4690         clr     a   
P:00E5 74F400 rrrrrr  3  505 4692         move    #FServices,n4
P:00E7 66F400 rrrrrr  3  508 4693         move    #FServices+1,r6
P:00E9 45F400 000001  3  511 4694         move    #>1,x1
P:00EB 0AF080 rrrrrr  6  517 4695         jmp     L22
                             4696 
                             4697 ; 255  |   {
                             4698 ; 256  |       if(Services[i].btType == btType)
                             4699 
P:00ED 218F00         2  519 4701 L20:    move    a1,b
P:00EE 20003B         2  521 4702         lsl     b
P:00EF 21A700         2  523 4703         move    b1,y1
P:00F0 20F400         2  525 4704         move    y1,r4
P:00F1 000000         2  527 4705         nop
P:00F2 044C13         4  531 4706         lua     (r4)+n4,r3
P:00F3 000000         2  533 4707         nop
P:00F4 57E300         2  535 4708         move    x:(r3),b
P:00F5 77F400 FFFFF9  3  538 4709         move    #-7,n7
P:00F7 000000         2  540 4710         nop
P:00F8 4EEF00         4  544 4711         move    y:(r7+n7),y0
P:00F9 20005D         2  546 4712         cmp     y0,b
P:00FA 0AF0A2 rrrrrr  6  552 4713         jne     L21
                             4714 
                             4715 ; 257  |       {
                             4716 ; 258  |            Services[i].Service(bSetup, btDirection, ptbBuffer, wLength,wPrivateData);
                             4717 
P:00FC 20FE00         2  554 4719         move    y1,n6
P:00FD 000000         2  556 4720         nop
P:00FE 044E13         4  560 4721         lua     (r6)+n6,r3
P:00FF 000000         2  562 4722         nop
P:0100 66E300         2  564 4723         move    x:(r3),r6
P:0101 77F400 FFFFFE  3  567 4724         move    #-2,n7
P:0103 000000         2  569 4725         nop
P:0104 4EEF00         4  573 4726         move    y:(r7+n7),y0
P:0105 77F400 FFFFFD  3  576 4727         move    #-3,n7
P:0107 000000         2  578 4728         nop
P:0108 4CEF00         4  582 4729         move    y:(r7+n7),x0
P:0109 77F400 FFFFFC  3  585 4730         move    #-4,n7
P:010B 000000         2  587 4731         nop
P:010C 68EF00         4  591 4732         move    y:(r7+n7),r0
P:010D 77F400 FFFFFB  3  594 4733         move    #-5,n7
P:010F 000000         2  596 4734         nop
P:0110 5FEF00         4  600 4735         move    y:(r7+n7),b
P:0111 77F400 FFFFFA  3  603 4736         move    #-6,n7
P:0113 000000         2  605 4737         nop
P:0114 5EEF00         4  609 4738         move    y:(r7+n7),a
P:0115 0BE680         4  613 4739         jsr     (r6)
                             4756 
                             4757 ; 259  |            SysUnMaskAllInterrupts(wOldInterrupt);
                             4758 
P:0116 045FA0         2  615 4760         movec   m0,n7
P:0117 000000         2  617 4761         nop
P:0118 5EEF00         4  621 4762         move    y:(r7+n7),a
P:0119 0BF080 rrrrrr  6  627 4763         jsr     FSysUnMaskAllInterrupts
                             4767 
                             4768 ; 260  |            return USB_OK;
                             4769 
P:011B 200013         2  629 4771         clr     a   
P:011C 0AF080 rrrrrr  6  635 4772         jmp     L23
                             4773 
                             4774 ; 261  |       }            
                             4775 
                             4777 L21:
P:011E 200060         2  637 4785         add     x1,a
P:011F 4FF000 rrrrrr  3  640 4786 L22:    move    y:FstDeviceState+9,y1
P:0121 200075         2  642 4787         cmp     y1,a
P:0122 0AF0A9 rrrrrr  6  648 4788         jlt     L20
                             4789 
                             4790 ; 262  |   }            
                             4791 ; 263  |
                             4792 ; 264  |    // No service found
                             4793 ; 265  |    SysUnMaskAllInterrupts(wOldInterrupt);
                             4794 
P:0124 045FA0         2  650 4796         movec   m0,n7
P:0125 000000         2  652 4797         nop
P:0126 5EEF00         4  656 4798         move    y:(r7+n7),a
P:0127 0BF080 rrrrrr  6  662 4799         jsr     FSysUnMaskAllInterrupts
                             4801 
                             4802 ; 266  |    return USBERR_NO_SERVICE;
                             4803 
P:0129 56F400 000002  3  665 4805         move    #>2,a
                             4806 
                             4807 ; 267  |} /* EndBody */
                             4808 
P:012B 77F400 FFFFF8  3  668 4810 L23:    move    #-8,n7
P:012D 000000         2  670 4811         nop
P:012E 05EF7C         4  674 4812         movec   y:(r7+n7),ssh
P:012F 204F00         2  676 4814         move    (r7)+n7
P:0130 00000C         4  680 4816         rts
                             4824 
                             4825 ; 268  |
                             4826 ; 269  |////////////////////////////////////////////////////////////////////////////////
                             4827 ; 270  |//
                             4828 ; 271  |//>  Name:          usb_device_get_service
                             4829 ; 272  |//
                             4830 ; 273  |//   Type:          Function
                             4831 ; 274  |//
                             4832 ; 275  |//   Description:   Gets the appropriate service for the specified type.
                             4833 ; 276  |//
                             4834 ; 277  |//   Inputs:        
                             4835 ; 278  |//                  btType  : Service type
                             4836 ; 279  |//                  service : Pointer to the service function registered for the specified type
                             4837 ; 280  |//
                             4838 ; 281  |//   Outputs:       USB_OK or error code
                             4839 ; 282  |//
                             4840 ; 283  |//   Notes:         
                             4841 ; 284  |//                  If no service registered, returns an error code 
                             4842 ; 285  |//<
                             4843 ; 286  |////////////////////////////////////////////////////////////////////////////////
                             4844 ; 287  |#if 0   // Remove unused function to reclain _P memory.
                             4845 ; 288  |BYTE _reentrant usb_device_get_service(BYTE btType, void (* Service)(BOOL bSetup, BYTE btDirection, BYTE _USB_MEM  * pbtBuffer, WORD wLength)) 
TASKING DSP2410 assembler v1.5r1 Build 138 SN 00100122
                                                                                                                                                                                                                                                       Page  19

M:ADDR CODE           CYCLES LINE SOURCELINE
                             4846 ; 289  |{ /* Body */
                             4847 ; 290  |   INT          i;
                             4848 ; 291  |   
                             4849 ; 292  |    // Search for the existing service
                             4850 ; 293  |   for(i = 0 ; i < stDeviceState.btServicesRegistered ; i++)
                             4851 ; 294  |   {
                             4852 ; 295  |       if(Services[i].btType == btType)
                             4853 ; 296  |       {
                             4854 ; 297  |            Service = Services[i].Service;
                             4855 ; 298  |            return USB_OK;
                             4856 ; 299  |       }            
                             4857 ; 300  |   }            
                             4858 ; 301  |
                             4859 ; 302  |    // No service found
                             4860 ; 303  |    return USBERR_NO_SERVICE;
                             4861 ; 304  |} /* EndBody */
                             4862 ; 305  |#endif
                             4863 ; 306  |////////////////////////////////////////////////////////////////////////////////
                             4864 ; 307  |//
                             4865 ; 308  |//>  Name:          usb_device_init_endpoint
                             4866 ; 309  |//
                             4867 ; 310  |//   Type:          Function
                             4868 ; 311  |//
                             4869 ; 312  |//   Description:   Initializes the endpoint and data structures associated
                             4870 ; 313  |//
                             4871 ; 314  |//   Inputs:        
                             4872 ; 315  |//                  btEndpoint  : Endpoint to be initialized
                             4873 ; 316  |//                  usMaxPacketSize: Maximum packet size for endpoint
                             4874 ; 317  |//                  btDirection     : Direction Endpoint 
                             4875 ; 318  |//                  btType          : Type Endpoint
                             4876 ; 319  |//                  bFlag           : TRUE = Enable zero length packet to terminate
                             4877 ; 320  |//                                          transfers equal to a multiple of the
                             4878 ; 321  |//                                          maximum packet size.
                             4879 ; 322  |//                                    FALSE = Disables zero length packet to terminate
                             4880 ; 323  |//                                          transfers equal to a multiple of the
                             4881 ; 324  |//                                          maximum packet size.
                             4882 ; 325  |//   Outputs:       USB_OK or error code
                             4883 ; 326  |//
                             4884 ; 327  |//   Notes:         
                             4885 ; 328  |//                  If no service registered, returns an error code 
                             4886 ; 329  |//<
                             4887 ; 330  |////////////////////////////////////////////////////////////////////////////////
                             4888 ; 331  |BYTE _reentrant usb_device_init_endpoint(BYTE btEndpoint, USHORT usMaxPacketSize, BYTE btDirection, BYTE btType, BOOL bFlag)
                             4889 ; 332  |{ /* Body */
                             4890 
                             4895 Fusb_device_init_endpoint:
P:0131 055F7C         2  682 4896         movec   ssh,y:(r7)+
                             4911 
                             4912 ; 333  |   BYTE         btError;
                             4913 ; 334  |   
                             4914 ; 335  |    /* Initialize the transfer descriptor */
                             4915 ; 336  |    stTemp.btEndpointNum = btEndpoint;
                             4916 
P:0132 5C7000 rrrrrr  3  685 4918         move    a1,y:FstTemp
                             4919 
                             4920 ; 337  |    stTemp.btDirection = btDirection;
                             4921 
P:0134 4C7000 rrrrrr  3  688 4923         move    x0,y:FstTemp+1
                             4924 
                             4925 ; 338  |    stTemp.btEndpointType = btType;
                             4926 
P:0136 4E7000 rrrrrr  3  691 4928         move    y0,y:FstTemp+2
                             4929 
                             4930 ; 339  |    stTemp.usMaxPacketSize = usMaxPacketSize;
                             4931 
P:0138 5D7000 rrrrrr  3  694 4933         move    b1,y:FstTemp+7
                             4934 
                             4935 ; 340  |    if(bFlag == FALSE)
                             4936 
P:013A 200069         2  696 4938         tfr     x1,b
P:013B 2B0000         2  698 4939         move    #0,b2
P:013C 20000B         2  700 4940         tst     b
P:013D 0AF0A2 rrrrrr  6  706 4944         jne     L24
                             4945 
                             4946 ; 341  |        stTemp.btDontZeroTerminate = (BYTE)0x01;
                             4947 
P:013F 390100         2  708 4949         move    #1,n1
P:0140 797000 rrrrrr  3  711 4950         move    n1,y:FstTemp+8
P:0142 0AF080 rrrrrr  6  717 4951         jmp     L25
                             4952 
                             4953 ; 342  |    else
                             4954 ; 343  |        stTemp.btDontZeroTerminate = (BYTE)0x00;
                             4955 
P:0144 260000         2  719 4957 L24:    move    #0,y0
P:0145 4E7000 rrrrrr  3  722 4959         move    y0,y:FstTemp+8
                             4960 
                             4961 ; 344  |       
                             4962 ; 345  |   btError = usb_dci_init_endpoint(&stTemp);
                             4963 
P:0147 60F400 rrrrrr  3  725 4965 L25:    move    #FstTemp,r0
P:0149 0BF080 rrrrrr  6  731 4966         jsr     Fusb_dci_init_endpoint
                             4971 
                             4972 ; 346  |   
                             4973 ; 347  |   return btError;
                             4974 ; 348  |   
                             4975 ; 349  |} /* EndBody */
                             4976 
P:014B 05FF7C         4  735 4978         movec   y:-(r7),ssh
P:014C 000000         2  737 4981         nop
P:014D 00000C         4  741 4982         rts
                             4985 
                             4986 ; 350  |
                             4987 ; 351  |
                             4988 ; 352  |////////////////////////////////////////////////////////////////////////////////
                             4989 ; 353  |//
                             4990 ; 354  |//>  Name:          usb_device_read_setup_data
                             4991 ; 355  |//
                             4992 ; 356  |//   Type:          Function
                             4993 ; 357  |//
                             4994 ; 358  |//   Description:   Reads the setup data from the dQH
                             4995 ; 359  |//
                             4996 ; 360  |//   Inputs:        
                             4997 ; 361  |//                  btEndpoint  : Endpoint number
                             4998 ; 362  |//
                             4999 ; 363  |//   Outputs:       
                             5000 ; 364  |//                  a pointer to the setup structure
                             5001 ; 365  |//
                             5002 ; 366  |//   Notes:         
                             5003 ; 367  |//<
                             5004 ; 368  |////////////////////////////////////////////////////////////////////////////////
                             5005 ; 369  |
                             5006 ; 370  |////////////////////////////////////////////////////////////////////////////////
                             5007 ; 371  |//
                             5008 ; 372  |//>  Name:          usb_device_get_status
                             5009 ; 373  |//
                             5010 ; 374  |//   Type:          Function
                             5011 ; 375  |//
                             5012 ; 376  |//   Description:   Returns the USB internal state
                             5013 ; 377  |//
                             5014 ; 378  |//   Inputs:        
                             5015 ; 379  |//                  btType          : Status type
                             5016 ; 380  |//                  pusStatus      : Status
                             5017 ; 381  |//
                             5018 ; 382  |//   Outputs:       
                             5019 ; 383  |//                  none
                             5020 ; 384  |//
                             5021 ; 385  |//   Notes:         
                             5022 ; 386  |//<
                             5023 ; 387  |////////////////////////////////////////////////////////////////////////////////
                             5024 ; 388  |void _reentrant usb_device_get_status(BYTE btType, USHORT * pusStatus)
                             5025 ; 389  |{ /* Body */
                             5026 
                             5033 Fusb_device_get_status:
P:014E 055F7C         2  743 5034         movec   ssh,y:(r7)+
P:014F 205F00         2  745 5037         move    (r7)+
                             5043 
                             5044 ; 390  |
                             5045 ; 391  |    switch (btType) {
                             5046 
P:0150 218700         2  747 5048         move    a1,y1
P:0151 57F400 000001  3  750 5049         move    #>1,b
P:0153 2A0000         2  752 5050         move    #0,a2
P:0154 65F414 rrrrrr  3  755 5051         sub     b,a     #L47,r5
P:0156 0AF0A8 rrrrrr  6  761 5052         jcs     L35
P:0158 57F400 00000A  3  764 5053         move    #>10,b
P:015A 21DD05         2  766 5054         cmp     b,a     a,n5
P:015B 0AF0A7 rrrrrr  6  772 5055         jgt     L35
P:015D 07ED95         8  780 5056         movem   p:(r5+n5),r5
P:015E 000000         2  782 5057         nop
P:015F 0AE580         4  786 5058         jmp     (r5)
                             5059 
P:0160 rrrrrr                5060 L47:    dc      L26     ; case 1:
P:0161 rrrrrr                5061         dc      L46     ; case 2:
P:0162 rrrrrr                5062         dc      L30     ; case 3:
P:0163 rrrrrr                5063         dc      L31     ; case 4:
P:0164 rrrrrr                5064         dc      L33     ; case 5:
P:0165 rrrrrr                5065         dc      L29     ; case 6:
P:0166 rrrrrr                5066         dc      L35     ; default:
P:0167 rrrrrr                5067         dc      L27     ; case 8:
P:0168 rrrrrr                5068         dc      L28     ; case 9:
P:0169 rrrrrr                5069         dc      L32     ; case 10:
P:016A rrrrrr                5070         dc      L34     ; case 11:
                             5071 
                             5074 
                             5075 ; 392  |
                             5076 ; 393  |        case USB_STATUS_DEVICE_STATE:
                             5077 ; 394  |            *pusStatus = stDeviceState.usUsbDeviceState;
                             5078 
P:016B 4EF000 rrrrrr  3  789 5080 L26:    move    y:FstDeviceState+6,y0
P:016D 4E6000         2  791 5081         move    y0,y:(r0)
                             5082 
                             5083 ; 395  |            break;
                             5084 
P:016E 0AF080 rrrrrr  6  797 5086         jmp     L46
                             5087 
                             5088 ; 396  |
                             5089 ; 397  |        case USB_STATUS_DEVICE_SPEED:
                             5090 ; 398  |            *pusStatus = stDeviceState.btSpeed;
                             5091 
P:0170 4EF000 rrrrrr  3  800 5093 L27:    move    y:FstDeviceState,y0
P:0172 4E6000         2  802 5094         move    y0,y:(r0)
                             5095 
                             5096 ; 399  |            break;
                             5097 
P:0173 0AF080 rrrrrr  6  808 5099         jmp     L46
                             5100 
                             5101 ; 400  |
                             5102 ; 401  |        case USB_STATUS_DEVICE_TEST:
                             5103 ; 402  |            *pusStatus = (USHORT)stDeviceState.bEnterTestMode;
                             5104 
P:0175 4EF000 rrrrrr  3  811 5106 L28:    move    y:FstDeviceState+11,y0
P:0177 4E6000         2  813 5107         move    y0,y:(r0)
                             5108 
                             5109 ; 403  |            break;
                             5110 
P:0178 0AF080 rrrrrr  6  819 5112         jmp     L46
                             5113 
                             5114 ; 404  |
                             5115 ; 405  |        case USB_STATUS:
                             5116 ; 406  |            *pusStatus = stDeviceState.usUsbState;
                             5117 
P:017A 4EF000 rrrrrr  3  822 5119 L29:    move    y:FstDeviceState+4,y0
P:017C 4E6000         2  824 5120         move    y0,y:(r0)
                             5121 
                             5122 ; 407  |            break;
                             5123 ; 408  |
                             5124 ; 409  |        case USB_STATUS_INTERFACE:
                             5125 ; 410  |            break;
                             5126 
P:017D 0AF080 rrrrrr  6  830 5128         jmp     L46
                             5129 
                             5130 ; 411  |         
                             5131 ; 412  |        case USB_STATUS_ADDRESS:
                             5132 ; 413  |            *pusStatus = (USHORT)(stDeviceState.btAddress);
                             5133 
P:017F 4EF000 rrrrrr  3  833 5135 L30:    move    y:FstDeviceState+3,y0
P:0181 4E6000         2  835 5136         move    y0,y:(r0)
                             5137 
                             5138 ; 414  |            break;
                             5139 
P:0182 0AF080 rrrrrr  6  841 5141         jmp     L46
                             5142 
                             5143 ; 415  |         
                             5144 ; 416  |        case USB_STATUS_CURRENT_CONFIG:
                             5145 ; 417  |            *pusStatus = (USHORT)(stDeviceState.btCurConfig);
                             5146 
P:0184 4EF000 rrrrrr  3  844 5148 L31:    move    y:FstDeviceState+1,y0
P:0186 4E6000         2  846 5149         move    y0,y:(r0)
                             5150 
                             5151 ; 418  |            break;
                             5152 
P:0187 0AF080 rrrrrr  6  852 5154         jmp     L46
                             5155 
                             5156 ; 419  |
                             5157 ; 420  |        case USB_STATUS_CURRENT_IFACE:
                             5158 ; 421  |            *pusStatus = (USHORT)(stDeviceState.btCurInterface);
                             5159 
P:0189 4EF000 rrrrrr  3  855 5161 L32:    move    y:FstDeviceState+2,y0
P:018B 4E6000         2  857 5162         move    y0,y:(r0)
                             5163 
                             5164 ; 422  |            break;
TASKING DSP2410 assembler v1.5r1 Build 138 SN 00100122
                                                                                                                                                                                                                                                       Page  20

M:ADDR CODE           CYCLES LINE SOURCELINE
                             5165 
P:018C 0AF080 rrrrrr  6  863 5167         jmp     L46
                             5168 
                             5169 ; 423  |
                             5170 ; 424  |        case USB_STATUS_SOF_COUNT:
                             5171 ; 425  |            *pusStatus = stDeviceState.usSofCount;
                             5172 
P:018E 4EF000 rrrrrr  3  866 5174 L33:    move    y:FstDeviceState+7,y0
P:0190 4E6000         2  868 5175         move    y0,y:(r0)
                             5176 
                             5177 ; 426  |            break;
                             5178 
P:0191 0AF080 rrrrrr  6  874 5180         jmp     L46
                             5181 
                             5182 ; 427  |        
                             5183 ; 428  |        case USB_STATUS_CONNECTION:
                             5184 
P:0193 045FA0         2  876 5186 L34:    movec   m0,n7
P:0194 000000         2  878 5187         nop
P:0195 686F00         4  882 5188         move    r0,y:(r7+n7)
                             5191 
                             5192 ; 429  |            usb_dci_update_connection_status();
                             5193 
P:0196 0BF080 rrrrrr  6  888 5195         jsr     Fusb_dci_update_connection_status
                             5197 
                             5198 ; 430  |            *pusStatus = stDeviceState.usConnectionState;
                             5199 
P:0198 4EF000 rrrrrr  3  891 5201         move    y:FstDeviceState+12,y0
P:019A 045FA0         2  893 5202         movec   m0,n7
P:019B 000000         2  895 5203         nop
P:019C 6EEF00         4  899 5204         move    y:(r7+n7),r6
P:019D 000000         2  901 5205         nop
P:019E 4E6600         2  903 5206         move    y0,y:(r6)
                             5209 
                             5210 ; 431  |            break;
                             5211 
P:019F 0AF080 rrrrrr  6  909 5213         jmp     L46
                             5214 
                             5215 ; 432  |            
                             5216 ; 433  |        default:
                             5217 
                             5219 L35:
P:01A1 045FA0         2  911 5223         movec   m0,n7
P:01A2 000000         2  913 5224         nop
P:01A3 686F00         4  917 5225         move    r0,y:(r7+n7)
                             5228 
                             5229 ; 434  |            if (btType & USB_STATUS_ENDPOINT)
                             5230 
P:01A4 200071         2  919 5232         tfr     y1,a
P:01A5 46F400 000010  3  922 5233         move    #>16,y0
P:01A7 200056         2  924 5234         and     y0,a
P:01A8 0AF0AA rrrrrr  6  930 5235         jeq     L46
                             5236 
                             5237 ; 435  |                *pusStatus = usb_dci_get_endpoint_status(btType & (BYTE)USB_STATUS_ENDPOINT_NUMBER_MASK);
                             5238 
P:01AA 200071         2  932 5240         tfr     y1,a
P:01AB 47F400 00000F  3  935 5241         move    #>15,y1
P:01AD 200076         2  937 5242         and     y1,a
P:01AE 2A0000         2  939 5246         move    #0,a2
P:01AF 0BF080 rrrrrr  6  945 5247         jsr     Fusb_dci_get_endpoint_status
P:01B1 045FA0         2  947 5248         movec   m0,n7
P:01B2 000000         2  949 5249         nop
P:01B3 6EEF00         4  953 5250         move    y:(r7+n7),r6
P:01B4 000000         2  955 5251         nop
P:01B5 5C6600         2  957 5252         move    a1,y:(r6)
                             5255 
                             5256 ; 436  |            break;    
                             5257 ; 437  |
                             5258 ; 438  |    } /* Endswitch */
                             5259 
                             5261 L46:
                             5262 
                             5263 ; 439  |} /* EndBody */  
                             5264 
P:01B6 205700         2  959 5266         move    (r7)-
P:01B7 05FF7C         4  963 5268         movec   y:-(r7),ssh
P:01B8 000000         2  965 5271         nop
P:01B9 00000C         4  969 5272         rts
                             5275 
                             5276 ; 440  | 
                             5277 ; 441  |////////////////////////////////////////////////////////////////////////////////
                             5278 ; 442  |//
                             5279 ; 443  |//>  Name:          usb_device_set_status
                             5280 ; 444  |//
                             5281 ; 445  |//   Type:          Function
                             5282 ; 446  |//
                             5283 ; 447  |//   Description:   Sets the USB internal state
                             5284 ; 448  |//
                             5285 ; 449  |//   Inputs:        
                             5286 ; 450  |//                  btType          : Status type
                             5287 ; 451  |//                  pusStatus      : Status
                             5288 ; 452  |//
                             5289 ; 453  |//   Outputs:       
                             5290 ; 454  |//                  none
                             5291 ; 455  |//
                             5292 ; 456  |//   Notes:         
                             5293 ; 457  |//<
                             5294 ; 458  |////////////////////////////////////////////////////////////////////////////////
                             5295 ; 459  |void _reentrant usb_device_set_status(BYTE btType, USHORT usStatus)
                             5296 ; 460  |{ /* Body */
                             5297 
                             5302 Fusb_device_set_status:
P:01BA 055F7C         2  971 5303         movec   ssh,y:(r7)+
P:01BB 3F0300         2  973 5306         move    #3,n7
P:01BC 000000         2  975 5307         nop
P:01BD 204F00         2  977 5308         move    (r7)+n7
                             5316 
                             5317 ; 461  |    WORD         wOldInterrupt;   
                             5318 
P:01BE 77F400 FFFFFE  3  980 5320         move    #-2,n7
P:01C0 000000         2  982 5321         nop
P:01C1 5D6F00         4  986 5322         move    b1,y:(r7+n7)
P:01C2 77F400 FFFFFD  3  989 5325         move    #-3,n7
P:01C4 000000         2  991 5326         nop
P:01C5 5C6F00         4  995 5327         move    a1,y:(r7+n7)
                             5330 
                             5331 ; 462  |    wOldInterrupt = SysMaskAllInterrupts();
                             5332 
P:01C6 0BF080 rrrrrr  6 1001 5334         jsr     FSysMaskAllInterrupts
P:01C8 045FA0         2 1003 5335         movec   m0,n7
P:01C9 000000         2 1005 5336         nop
P:01CA 5C6F00         4 1009 5337         move    a1,y:(r7+n7)
                             5339 
                             5340 ; 463  |
                             5341 ; 464  |    switch (btType)
                             5342 
P:01CB 77F400 FFFFFD  3 1012 5344         move    #-3,n7
P:01CD 000000         2 1014 5345         nop
P:01CE 5EEF00         4 1018 5346         move    y:(r7+n7),a
P:01CF 218700         2 1020 5347         move    a1,y1
P:01D0 57F400 000001  3 1023 5348         move    #>1,b
P:01D2 2A0000         2 1025 5349         move    #0,a2
P:01D3 64F414 rrrrrr  3 1028 5350         sub     b,a     #L67,r4
P:01D5 0AF0A8 rrrrrr  6 1034 5351         jcs     L56
P:01D7 57F400 000009  3 1037 5352         move    #>9,b
P:01D9 21DC05         2 1039 5353         cmp     b,a     a,n4
P:01DA 0AF0A7 rrrrrr  6 1045 5354         jgt     L56
P:01DC 07EC94         8 1053 5355         movem   p:(r4+n4),r4
P:01DD 000000         2 1055 5356         nop
P:01DE 0AE480         4 1059 5357         jmp     (r4)
                             5358 
P:01DF rrrrrr                5359 L67:    dc      L48     ; case 1:
P:01E0 rrrrrr                5360         dc      L66     ; case 2:
P:01E1 rrrrrr                5361         dc      L51     ; case 3:
P:01E2 rrrrrr                5362         dc      L52     ; case 4:
P:01E3 rrrrrr                5363         dc      L54     ; case 5:
P:01E4 rrrrrr                5364         dc      L50     ; case 6:
P:01E5 rrrrrr                5365         dc      L55     ; case 7:
P:01E6 rrrrrr                5366         dc      L56     ; default:
P:01E7 rrrrrr                5367         dc      L49     ; case 9:
P:01E8 rrrrrr                5368         dc      L53     ; case 10:
                             5369 
                             5372 
                             5373 ; 465  |    {
                             5374 ; 466  |        case USB_STATUS_DEVICE_STATE:
                             5375 ; 467  |            stDeviceState.usUsbDeviceState = usStatus;
                             5376 
P:01E9 77F400 FFFFFE  3 1062 5378 L48:    move    #-2,n7
P:01EB 000000         2 1064 5379         nop
P:01EC 7CEF00         4 1068 5380         move    y:(r7+n7),n4
P:01ED 7C7000 rrrrrr  3 1071 5381         move    n4,y:FstDeviceState+6
                             5382 
                             5383 ; 468  |            break;
                             5384 
P:01EF 0AF080 rrrrrr  6 1077 5386         jmp     L66
                             5387 
                             5388 ; 469  |
                             5389 ; 470  |        case USB_STATUS_DEVICE_TEST:
                             5390 ; 471  |            stDeviceState.bEnterTestMode = (BOOL)usStatus;
                             5391 
P:01F1 77F400 FFFFFE  3 1080 5393 L49:    move    #-2,n7
P:01F3 000000         2 1082 5394         nop
P:01F4 5CEF00         4 1086 5395         move    y:(r7+n7),a1
P:01F5 5C7000 rrrrrr  3 1089 5396         move    a1,y:FstDeviceState+11
                             5397 
                             5398 ; 472  |            break;
                             5399 
P:01F7 0AF080 rrrrrr  6 1095 5401         jmp     L66
                             5402 
                             5403 ; 473  |
                             5404 ; 474  |        case USB_STATUS:
                             5405 ; 475  |            stDeviceState.usUsbState = usStatus;
                             5406 
P:01F9 77F400 FFFFFE  3 1098 5408 L50:    move    #-2,n7
P:01FB 000000         2 1100 5409         nop
P:01FC 79EF00         4 1104 5410         move    y:(r7+n7),n1
P:01FD 797000 rrrrrr  3 1107 5411         move    n1,y:FstDeviceState+4
                             5412 
                             5413 ; 476  |            break;
                             5414 ; 477  |
                             5415 ; 478  |        case USB_STATUS_INTERFACE:
                             5416 ; 479  |            break;
                             5417 
P:01FF 0AF080 rrrrrr  6 1113 5419         jmp     L66
                             5420 
                             5421 ; 480  |
                             5422 ; 481  |        case USB_STATUS_ADDRESS:
                             5423 ; 482  |            stDeviceState.btAddress = (BYTE)usStatus;
                             5424 
P:0201 77F400 FFFFFE  3 1116 5426 L51:    move    #-2,n7
P:0203 000000         2 1118 5427         nop
P:0204 5EEF00         4 1122 5428         move    y:(r7+n7),a
P:0205 5C7000 rrrrrr  3 1125 5429         move    a1,y:FstDeviceState+3
                             5432 
                             5433 ; 483  |            usb_dci_set_address(usStatus);
                             5434 
P:0207 0BF080 rrrrrr  6 1131 5436         jsr     Fusb_dci_set_address
                             5439 
                             5440 ; 484  |            break;
                             5441 
P:0209 0AF080 rrrrrr  6 1137 5443         jmp     L66
                             5444 
                             5445 ; 485  |
                             5446 ; 486  |        case USB_STATUS_CURRENT_CONFIG:
                             5447 ; 487  |            stDeviceState.btCurConfig = (BYTE)usStatus;
                             5448 
                             5450 L52:
P:020B 77F400 FFFFFE  3 1140 5452         move    #-2,n7
P:020D 000000         2 1142 5453         nop
P:020E 4EEF00         4 1146 5454         move    y:(r7+n7),y0
P:020F 4E7000 rrrrrr  3 1149 5455         move    y0,y:FstDeviceState+1
                             5456 
                             5457 ; 488  |            break;
                             5458 
P:0211 0AF080 rrrrrr  6 1155 5460         jmp     L66
                             5461 
                             5462 ; 489  |         
                             5463 ; 490  |        case USB_STATUS_CURRENT_IFACE:
                             5464 ; 491  |            stDeviceState.btCurInterface = (BYTE)usStatus;
                             5465 
P:0213 77F400 FFFFFE  3 1158 5467 L53:    move    #-2,n7
P:0215 000000         2 1160 5468         nop
P:0216 4DEF00         4 1164 5469         move    y:(r7+n7),x1
P:0217 4D7000 rrrrrr  3 1167 5470         move    x1,y:FstDeviceState+2
                             5471 
                             5472 ; 492  |            break;
                             5473 
P:0219 0AF080 rrrrrr  6 1173 5475         jmp     L66
                             5476 
                             5477 ; 493  |
                             5478 ; 494  |        case USB_STATUS_SOF_COUNT:
                             5479 ; 495  |            stDeviceState.usSofCount = usStatus;
                             5480 
P:021B 77F400 FFFFFE  3 1176 5482 L54:    move    #-2,n7
P:021D 000000         2 1178 5483         nop
P:021E 5FEF00         4 1182 5484         move    y:(r7+n7),b
P:021F 5D7000 rrrrrr  3 1185 5485         move    b1,y:FstDeviceState+7
                             5486 
                             5487 ; 496  |            break;
                             5488 
P:0221 0AF080 rrrrrr  6 1191 5490         jmp     L66
TASKING DSP2410 assembler v1.5r1 Build 138 SN 00100122
                                                                                                                                                                                                                                                       Page  21

M:ADDR CODE           CYCLES LINE SOURCELINE
                             5491 
                             5492 ; 497  |
                             5493 ; 498  |        case USB_STATUS_TEST_MODE:
                             5494 ; 499  |
                             5495 ; 500  |#if defined (DEVICE_3500)
                             5496 ; 501  |#ifndef BOOT_ROM
                             5497 ; 502  |            usb_dci_set_test_mode(usStatus);
                             5498 
P:0223 77F400 FFFFFE  3 1194 5500 L55:    move    #-2,n7
P:0225 000000         2 1196 5501         nop
P:0226 5EEF00         4 1200 5502         move    y:(r7+n7),a
P:0227 0BF080 rrrrrr  6 1206 5503         jsr     Fusb_dci_set_test_mode
                             5507 
                             5508 ; 503  |#endif // !defined (BOOT_ROM)
                             5509 ; 504  |#endif // defined (DEVICE_3500)
                             5510 ; 505  |
                             5511 ; 506  |            break;
                             5512 
P:0229 0AF080 rrrrrr  6 1212 5514         jmp     L66
                             5515 
                             5516 ; 507  |         
                             5517 ; 508  |        default:
                             5518 ; 509  |            if (btType & USB_STATUS_ENDPOINT)
                             5519 
                             5521 L56:
P:022B 200071         2 1214 5524         tfr     y1,a
P:022C 46F400 000010  3 1217 5525         move    #>16,y0
P:022E 200056         2 1219 5526         and     y0,a
P:022F 0AF0AA rrrrrr  6 1225 5527         jeq     L66
                             5528 
                             5529 ; 510  |                usb_dci_set_endpoint_status(btType & (BYTE)USB_STATUS_ENDPOINT_NUMBER_MASK, usStatus);
                             5530 
P:0231 200071         2 1227 5532         tfr     y1,a
P:0232 47F400 00000F  3 1230 5533         move    #>15,y1
P:0234 200076         2 1232 5534         and     y1,a
P:0235 77F400 FFFFFE  3 1235 5538         move    #-2,n7
P:0237 000000         2 1237 5539         nop
P:0238 5FEF00         4 1241 5540         move    y:(r7+n7),b
P:0239 2A0000         2 1243 5541         move    #0,a2
P:023A 0BF080 rrrrrr  6 1249 5542         jsr     Fusb_dci_set_endpoint_status
                             5546 
                             5547 ; 511  |
                             5548 ; 512  |            break;
                             5549 ; 513  |    } /* Endswitch */
                             5550 ; 514  |    
                             5551 ; 515  |    SysUnMaskAllInterrupts(wOldInterrupt);
                             5552 
P:023C 045FA0         2 1251 5554 L66:    movec   m0,n7
P:023D 000000         2 1253 5555         nop
P:023E 5EEF00         4 1257 5556         move    y:(r7+n7),a
P:023F 0BF080 rrrrrr  6 1263 5557         jsr     FSysUnMaskAllInterrupts
                             5561 
                             5562 ; 516  |
                             5563 ; 517  |} /* EndBody */
                             5564 
P:0241 77F400 FFFFFC  3 1266 5566         move    #-4,n7
P:0243 000000         2 1268 5567         nop
P:0244 05EF7C         4 1272 5568         movec   y:(r7+n7),ssh
P:0245 204F00         2 1274 5570         move    (r7)+n7
P:0246 00000C         4 1278 5572         rts
                             5574 
                             5575 ; 518  |
                             5576 ; 519  |////////////////////////////////////////////////////////////////////////////////
                             5577 ; 520  |//
                             5578 ; 521  |//>  Name:          usb_device_get_transfer_status
                             5579 ; 522  |//
                             5580 ; 523  |//   Type:          Functiorn
                             5581 ; 524  |//
                             5582 ; 525  |//   Description:   Gets the status of the last transfer on the specified
                             5583 ; 526  |//                  couple endpoint/direction
                             5584 ; 527  |//   Inputs:        
                             5585 ; 528  |//                  btEndpoint      : Endpoint
                             5586 ; 529  |//                  btDirection      : Direction
                             5587 ; 530  |//
                             5588 ; 531  |//   Outputs:       
                             5589 ; 532  |//                  Transfer status
                             5590 ; 533  |//
                             5591 ; 534  |//   Notes:
                             5592 ; 535  |//                  The status returned is the btStatus entry from the XD
                             5593 ; 536  |//                  associated with the couple endpoint/direction         
                             5594 ; 537  |//<
                             5595 ; 538  |////////////////////////////////////////////////////////////////////////////////
                             5596 ; 539  |
                             5597 ; 540  |
                             5598 ; 541  |////////////////////////////////////////////////////////////////////////////////
                             5599 ; 542  |//
                             5600 ; 543  |//>  Name:          usb_device_stall_endpoint
                             5601 ; 544  |//
                             5602 ; 545  |//   Type:          Functiorn
                             5603 ; 546  |//
                             5604 ; 547  |//   Description:   Stalls the specified endpoint for the specified direction
                             5605 ; 548  |//
                             5606 ; 549  |//   Inputs:        
                             5607 ; 550  |//                  btEndpoint      : Endpoint
                             5608 ; 551  |//                  btDirection      : Direction
                             5609 ; 552  |//
                             5610 ; 553  |//   Outputs:       
                             5611 ; 554  |//                  None
                             5612 ; 555  |//
                             5613 ; 556  |//   Notes:
                             5614 ; 557  |//<
                             5615 ; 558  |////////////////////////////////////////////////////////////////////////////////
                             5616 ; 559  |
                             5617 ; 560  |
                             5618 ; 561  |
                             5619 ; 562  |////////////////////////////////////////////////////////////////////////////////
                             5620 ; 563  |//
                             5621 ; 564  |//>  Name:          usb_device_init_data_toggle_endpoint
                             5622 ; 565  |//
                             5623 ; 566  |//   Type:          Functiorn
                             5624 ; 567  |//
                             5625 ; 568  |//   Description:   Reinitialize data toggle to DATA0
                             5626 ; 569  |//
                             5627 ; 570  |//   Inputs:        
                             5628 ; 571  |//                  btEndpoint      : Endpoint
                             5629 ; 572  |//
                             5630 ; 573  |//   Outputs:       
                             5631 ; 574  |//                  None
                             5632 ; 575  |//
                             5633 ; 576  |//   Notes:
                             5634 ; 577  |//<
                             5635 ; 578  |////////////////////////////////////////////////////////////////////////////////
                             5636 ; 579  |
                             5637 ; 580  |
                             5638 ; 581  |////////////////////////////////////////////////////////////////////////////////
                             5639 ; 582  |//
                             5640 ; 583  |//>  Name:          usb_device_unstall_endpoint
                             5641 ; 584  |//
                             5642 ; 585  |//   Type:          Functiorn
                             5643 ; 586  |//
                             5644 ; 587  |//   Description:   Unstalls the specified endpoint for the specified direction
                             5645 ; 588  |//
                             5646 ; 589  |//   Inputs:        
                             5647 ; 590  |//                  btEndpoint      : Endpoint
                             5648 ; 591  |//                  btDirection      : Direction
                             5649 ; 592  |//
                             5650 ; 593  |//   Outputs:       
                             5651 ; 594  |//                  None
                             5652 ; 595  |//
                             5653 ; 596  |//   Notes:
                             5654 ; 597  |//<
                             5655 ; 598  |////////////////////////////////////////////////////////////////////////////////
                             5656 ; 599  |
                             5657 ; 600  |////////////////////////////////////////////////////////////////////////////////
                             5658 ; 601  |//
                             5659 ; 602  |//>  Name:          usb_device_transfer_data
                             5660 ; 603  |//
                             5661 ; 604  |//   Type:          Function
                             5662 ; 605  |//
                             5663 ; 606  |//   Description:   transfers data on the specified endpoint - space savings
                             5664 ; 607  |//                  for usb_device_send_data and usb_device_recv_data
                             5665 ; 608  |//
                             5666 ; 609  |//   Inputs:        
                             5667 ; 610  |//                  btEndpoint      : Endpoint
                             5668 ; 611  |//                  usStmpWordAdd   : Buffer Start address (STMP space)
                             5669 ; 612  |//                  btByteOffset    : Byte offset in the buffer start address (0, 1, 2)
                             5670 ; 613  |//                  usSize          : Number byte to transfer 
                             5671 ; 614  |//                  bIsDataPhase    : TRUE if data phase during setup transaction
                             5672 ; 615  |//                  wDirection      : USB_IN or USB_OUT
                             5673 ; 616  |//
                             5674 ; 617  |//   Outputs:       
                             5675 ; 618  |//                  Error or USB_OK if no error
                             5676 ; 619  |//
                             5677 ; 620  |//   Notes:
                             5678 ; 621  |//<
                             5679 ; 622  |////////////////////////////////////////////////////////////////////////////////
                             5680 ; 623  |BYTE _reentrant usb_device_transfer_data(BYTE btEndpoint, WORD _X* pbtStmpWordAdd, 
                             5681 ; 624  |                                         BYTE btByteOffset, USHORT usSize, WORD wPrivateData, 
                             5682 ; 625  |                                         BOOL bIsDataPhase, WORD wDirection)
                             5683 ; 626  |{ /* Body */
                             5684 
                             5689 Fusb_device_transfer_data:
P:0247 055F7C         2 1280 5690         movec   ssh,y:(r7)+
P:0248 3F0C00         2 1282 5693         move    #12,n7
P:0249 000000         2 1284 5694         nop
P:024A 204F00         2 1286 5695         move    (r7)+n7
                             5717 
                             5718 ; 627  |    WORD         wOldInterrupt;   
                             5719 ; 628  |
                             5720 ; 629  |    xd_struct _USB_MEM  * pCurrentXd = NULL;
                             5721 
P:024B 209C00         2 1288 5723         move    x0,n4
P:024C 77F400 FFFFF5  3 1291 5726         move    #-11,n7
P:024E 000000         2 1293 5727         nop
P:024F 5C6F00         4 1297 5728         move    a1,y:(r7+n7)
P:0250 360000         2 1299 5731         move    #0,r6
                             5737 
                             5738 ; 630  |    xd_struct _USB_MEM  * pNewXd;
                             5739 ; 631  |    BYTE    btError = USB_OK;
                             5740 
P:0251 3B0000         2 1301 5742         move    #0,n3
                             5745 
                             5746 ; 632  |    USHORT      usStatus;
                             5747 ; 633  |
                             5748 ; 634  |    if(usSize > USB_MAX_SIZE_PER_TRANSFER)
                             5749 
P:0252 238E00         2 1303 5751         move    n4,a
P:0253 44F400 004000  3 1306 5752         move    #$4000,x0
P:0255 200045         2 1308 5753         cmp     x0,a
P:0256 0AF0AF rrrrrr  6 1314 5754         jle     L68
                             5755 
                             5756 ; 635  |        return(USBERR_SIZE_TOO_LARGE);
                             5757 
P:0258 56F400 000004  3 1317 5759         move    #>4,a
P:025A 0AF080 rrrrrr  6 1323 5760         jmp     L79
P:025C 77F400 FFFFFD  3 1326 5761 L68:    move    #-3,n7
P:025E 000000         2 1328 5762         nop
P:025F 7B6F00         4 1332 5763         move    n3,y:(r7+n7)
P:0260 77F400 FFFFFC  3 1335 5766         move    #-4,n7
P:0262 000000         2 1337 5767         nop
P:0263 6E6F00         4 1341 5768         move    r6,y:(r7+n7)
P:0264 77F400 FFFFFA  3 1344 5771         move    #-6,n7
P:0266 000000         2 1346 5772         nop
P:0267 4D6F00         4 1350 5773         move    x1,y:(r7+n7)
P:0268 77F400 FFFFF9  3 1353 5776         move    #-7,n7
P:026A 000000         2 1355 5777         nop
P:026B 4E6F00         4 1359 5778         move    y0,y:(r7+n7)
P:026C 77F400 FFFFF8  3 1362 5781         move    #-8,n7
P:026E 000000         2 1364 5782         nop
P:026F 7C6F00         4 1368 5783         move    n4,y:(r7+n7)
P:0270 77F400 FFFFF7  3 1371 5786         move    #-9,n7
P:0272 000000         2 1373 5787         nop
P:0273 5D6F00         4 1377 5788         move    b1,y:(r7+n7)
P:0274 77F400 FFFFF6  3 1380 5791         move    #-10,n7
P:0276 000000         2 1382 5792         nop
P:0277 686F00         4 1386 5793         move    r0,y:(r7+n7)
                             5796 
                             5797 ; 636  |
                             5798 ; 637  |    if (wDirection == USB_IN)
                             5799 
P:0278 200071         2 1388 5801         tfr     y1,a
P:0279 77F400 FFFFFB  3 1391 5802         move    #-5,n7
P:027B 000000         2 1393 5803         nop
P:027C 5C6F00         4 1397 5804         move    a1,y:(r7+n7)
P:027D 47F400 000001  3 1400 5805         move    #>1,y1
P:027F 2A0000         2 1402 5806         move    #0,a2
P:0280 200075         2 1404 5807         cmp     y1,a
P:0281 0AF0A2 rrrrrr  6 1410 5810         jne     L71
                             5811 
                             5812 ; 638  |    {
                             5813 ; 639  |        // Check if device is in the configuration state
                             5814 ; 640  |        // Only endpoint 0 is allow to transfer data in state other than configured
                             5815 ; 641  |        if(btEndpoint != 0)
                             5816 
P:0283 77F400 FFFFF5  3 1413 5818         move    #-11,n7
P:0285 000000         2 1415 5819         nop
P:0286 5FEF00         4 1419 5820         move    y:(r7+n7),b
P:0287 2B0000         2 1421 5821         move    #0,b2
P:0288 20000B         2 1423 5822         tst     b
P:0289 0AF0AA rrrrrr  6 1429 5823         jeq     L71
                             5824 
TASKING DSP2410 assembler v1.5r1 Build 138 SN 00100122
                                                                                                                                                                                                                                                       Page  22

M:ADDR CODE           CYCLES LINE SOURCELINE
                             5825 ; 642  |        {
                             5826 ; 643  |            usb_device_get_status(USB_STATUS, &usStatus);
                             5827 
P:028B 77F400 FFFFF4  3 1432 5829         move    #-12,n7
P:028D 000000         2 1434 5830         nop
P:028E 044F10         4 1438 5831         lua     (r7)+n7,r0
P:028F 56F400 000006  3 1441 5832         move    #>6,a
P:0291 0BF080 rrrrrr  6 1447 5833         jsr     Fusb_device_get_status
                             5834 
                             5835 ; 644  |            if(usStatus != USB_STATE_CONFIGURED)
                             5836 
P:0293 77F400 FFFFF4  3 1450 5838         move    #-12,n7
P:0295 000000         2 1452 5839         nop
P:0296 5FEF00         4 1456 5840         move    y:(r7+n7),b
P:0297 2B0000         2 1458 5841         move    #0,b2
P:0298 20000B         2 1460 5842         tst     b
P:0299 0AF0AA rrrrrr  6 1466 5843         jeq     L71
                             5844 
                             5845 ; 645  |                return USBERR_DEVICE_NOT_CONFIGURED;
                             5846 
P:029B 56F400 000007  3 1469 5848         move    #>7,a
P:029D 0AF080 rrrrrr  6 1475 5849         jmp     L79
                             5850 
                             5851 ; 646  |        }            
                             5852 ; 647  |    }
                             5853 ; 648  |    
                             5854 ; 649  |    wOldInterrupt = SysMaskAllInterrupts();
                             5855 
P:029F 0BF080 rrrrrr  6 1481 5857 L71:    jsr     FSysMaskAllInterrupts
                             5859 
                             5860 ; 650  |
                             5861 ; 651  |    if (wDirection == USB_OUT)
                             5862 
P:02A1 77F400 FFFFFB  3 1484 5864         move    #-5,n7
P:02A3 000000         2 1486 5865         nop
P:02A4 5FEF00         4 1490 5866         move    y:(r7+n7),b
P:02A5 21A600         2 1492 5867         move    b1,y0
P:02A6 2B0000         2 1494 5868         move    #0,b2
P:02A7 20000B         2 1496 5869         tst     b
P:02A8 0AF0A2 rrrrrr  6 1502 5872         jne     L72
                             5873 
                             5874 ; 652  |    {
                             5875 ; 653  |        pCurrentXd = g_dXD_Queues[btEndpoint][USB_OUT];
                             5876 
P:02AA 77F400 FFFFF5  3 1505 5878         move    #-11,n7
P:02AC 000000         2 1507 5879         nop
P:02AD 5FEF00         4 1511 5880         move    y:(r7+n7),b
P:02AE 20003B         2 1513 5881         lsl     b
P:02AF 21BB00         2 1515 5882         move    b1,n3
P:02B0 63F400 rrrrrr  3 1518 5883         move    #Fg_dXD_Queues,r3
P:02B2 000000         2 1520 5884         nop
P:02B3 6EEB00         4 1524 5885         move    y:(r3+n3),r6
P:02B4 77F400 FFFFFC  3 1527 5886         move    #-4,n7
P:02B6 000000         2 1529 5887         nop
P:02B7 6E6F00         4 1533 5888         move    r6,y:(r7+n7)
                             5889 
                             5890 ; 654  |    }
                             5891 
P:02B8 77F400 FFFFFE  3 1536 5893 L72:    move    #-2,n7
P:02BA 000000         2 1538 5894         nop
P:02BB 5C6F00         4 1542 5895         move    a1,y:(r7+n7)
P:02BC 77F400 FFFFFB  3 1545 5898         move    #-5,n7
P:02BE 000000         2 1547 5899         nop
P:02BF 4E6F00         4 1551 5900         move    y0,y:(r7+n7)
                             5903 
                             5904 ; 655  |
                             5905 ; 656  |
                             5906 ; 657  |    pNewXd = GetEmptyXd();
                             5907 
P:02C0 0BF080 rrrrrr  6 1557 5909         jsr     FGetEmptyXd
P:02C2 220F00         2 1559 5910         move    r0,b
                             5912 
                             5913 ; 658  |    assert(pNewXd);
                             5914 
P:02C3 21F400         2 1561 5916         move    b,r4
P:02C4 20000B         2 1563 5917         tst     b
P:02C5 0AF0A2 rrrrrr  6 1569 5918         jne     L73
                             5919 
                             5920 ; Start __asm() call number 1
                             5922  error
P:02C7 0C000C         4 1573 5922     jmp $000C ;Use vector at P:000C to shutdown & restart the STMP device. 
                             5922               ; Jmp to addr in low 12 bits is 1 word smaller than jsr. (changed apr 6 '05)
                             5923 ; End   __asm() call number 1
                             5924 
                             5925 ; 659  |    // Initialize the transfer descriptor
                             5926 ; 660  |    pNewXd->btEndpointNum = btEndpoint;
                             5927 
P:02C8 77F400 FFFFF5  3 1576 5929 L73:    move    #-11,n7
P:02CA 000000         2 1578 5930         nop
P:02CB 5EEF00         4 1582 5931         move    y:(r7+n7),a
P:02CC 5C6400         2 1584 5932         move    a1,y:(r4)
                             5935 
                             5936 ; 661  |    pNewXd->btDirection = wDirection;
                             5937 
P:02CD 46F400 000001  3 1587 5939         move    #>1,y0
P:02CF 045C16         4 1591 5940         lua     (r4)+,r6
P:02D0 77F400 FFFFFB  3 1594 5941         move    #-5,n7
P:02D2 000000         2 1596 5942         nop
P:02D3 5FEF00         4 1600 5943         move    y:(r7+n7),b
P:02D4 5D6600         2 1602 5944         move    b1,y:(r6)
                             5947 
                             5948 ; 662  |    pNewXd->btStatus = USB_STATUS_TRANSFER_IN_PROGRESS;
                             5949 
P:02D5 3E0300         2 1604 5951         move    #3,n6
P:02D6 229600         2 1606 5952         move    r4,r6
P:02D7 000000         2 1608 5953         nop
P:02D8 204E00         2 1610 5954         move    (r6)+n6
P:02D9 7E6600         2 1612 5955         move    n6,y:(r6)
                             5956 
                             5957 ; 663  |    pNewXd->pbtStartAddressWord = pbtStmpWordAdd;
                             5958 
P:02DA 3E0400         2 1614 5960         move    #4,n6
P:02DB 229600         2 1616 5961         move    r4,r6
P:02DC 000000         2 1618 5962         nop
P:02DD 204E00         2 1620 5963         move    (r6)+n6
P:02DE 77F400 FFFFF6  3 1623 5964         move    #-10,n7
P:02E0 000000         2 1625 5965         nop
P:02E1 6DEF00         4 1629 5966         move    y:(r7+n7),r5
P:02E2 6D6600         2 1631 5967         move    r5,y:(r6)
                             5970 
                             5971 ; 664  |    pNewXd->btStartOffsetByte = btByteOffset;
                             5972 
P:02E3 3E0500         2 1633 5974         move    #5,n6
P:02E4 229600         2 1635 5975         move    r4,r6
P:02E5 000000         2 1637 5976         nop
P:02E6 204E00         2 1639 5977         move    (r6)+n6
P:02E7 77F400 FFFFF7  3 1642 5978         move    #-9,n7
P:02E9 000000         2 1644 5979         nop
P:02EA 4FEF00         4 1648 5980         move    y:(r7+n7),y1
P:02EB 4F6600         2 1650 5981         move    y1,y:(r6)
                             5984 
                             5985 ; 665  |    pNewXd->usTotalLength = usSize;
                             5986 
P:02EC 3E0600         2 1652 5988         move    #6,n6
P:02ED 229600         2 1654 5989         move    r4,r6
P:02EE 000000         2 1656 5990         nop
P:02EF 204E00         2 1658 5991         move    (r6)+n6
P:02F0 77F400 FFFFF8  3 1661 5992         move    #-8,n7
P:02F2 000000         2 1663 5993         nop
P:02F3 7EEF00         4 1667 5994         move    y:(r7+n7),n6
P:02F4 7E6600         2 1669 5995         move    n6,y:(r6)
                             5998 
                             5999 ; 666  |    pNewXd->usBytesCopied = 0;
                             6000 
P:02F5 3E0C00         2 1671 6002         move    #12,n6
P:02F6 229600         2 1673 6004         move    r4,r6
P:02F7 000000         2 1675 6005         nop
P:02F8 204E00         2 1677 6006         move    (r6)+n6
P:02F9 3D0000         2 1679 6007         move    #0,n5
P:02FA 7D6600         2 1681 6008         move    n5,y:(r6)
                             6009 
                             6010 ; 667  |    pNewXd->bIsDataPhase = bIsDataPhase; 
                             6011 
P:02FB 3E0900         2 1683 6013         move    #9,n6
P:02FC 229600         2 1685 6014         move    r4,r6
P:02FD 000000         2 1687 6015         nop
P:02FE 204E00         2 1689 6016         move    (r6)+n6
P:02FF 77F400 FFFFFA  3 1692 6017         move    #-6,n7
P:0301 000000         2 1694 6018         nop
P:0302 4CEF00         4 1698 6019         move    y:(r7+n7),x0
P:0303 4C6600         2 1700 6020         move    x0,y:(r6)
                             6023 
                             6024 ; 668  |    pNewXd->wPrivateData = wPrivateData;
                             6025 
P:0304 3E0B00         2 1702 6027         move    #11,n6
P:0305 229600         2 1704 6028         move    r4,r6
P:0306 000000         2 1706 6029         nop
P:0307 204E00         2 1708 6030         move    (r6)+n6
P:0308 77F400 FFFFF9  3 1711 6031         move    #-7,n7
P:030A 000000         2 1713 6032         nop
P:030B 4DEF00         4 1717 6033         move    y:(r7+n7),x1
P:030C 4D6600         2 1719 6034         move    x1,y:(r6)
                             6037 
                             6038 ; 669  |    pNewXd->pbtCurrentAddressWord = pbtStmpWordAdd;
                             6039 
P:030D 3E0E00         2 1721 6041         move    #14,n6
P:030E 229600         2 1723 6042         move    r4,r6
P:030F 000000         2 1725 6043         nop
P:0310 204E00         2 1727 6044         move    (r6)+n6
P:0311 6D6600         2 1729 6045         move    r5,y:(r6)
                             6046 
                             6047 ; 670  |    pNewXd->wCurrentOffsetByte= btByteOffset;
                             6048 
P:0312 3E0D00         2 1731 6050         move    #13,n6
P:0313 229600         2 1733 6051         move    r4,r6
P:0314 000000         2 1735 6052         nop
P:0315 204E00         2 1737 6053         move    (r6)+n6
P:0316 4F6600         2 1739 6054         move    y1,y:(r6)
                             6055 
                             6056 ; 671  |
                             6057 ; 672  |    if (wDirection == USB_IN)
                             6058 
P:0317 2B0000         2 1741 6060         move    #0,b2
P:0318 20005D         2 1743 6061         cmp     y0,b
P:0319 0AF0A2 rrrrrr  6 1749 6062         jne     L74
                             6063 
                             6064 ; 673  |    {
                             6065 ; 674  |        // Get the specif Xd structure
                             6066 ; 675  |        // assign to the endpoint
                             6067 ; 676  |        pCurrentXd = g_dXD_Queues[btEndpoint][USB_IN]; 
                             6068 
P:031B 200033         2 1751 6070         lsl     a
P:031C 219E00         2 1753 6072         move    a1,n6
P:031D 66F400 rrrrrr  3 1756 6073         move    #Fg_dXD_Queues+1,r6
P:031F 000000         2 1758 6074         nop
P:0320 6EEE00         4 1762 6075         move    y:(r6+n6),r6
P:0321 77F400 FFFFFC  3 1765 6076         move    #-4,n7
P:0323 000000         2 1767 6077         nop
P:0324 6E6F00         4 1771 6078         move    r6,y:(r7+n7)
                             6079 
                             6080 ; 677  |    }                                                
                             6081 ; 678  |
                             6082 ; 679  |    if(pCurrentXd)
                             6083 
P:0325 77F400 FFFFFC  3 1774 6085 L74:    move    #-4,n7
P:0327 000000         2 1776 6086         nop
P:0328 5FEF00         4 1780 6087         move    y:(r7+n7),b
P:0329 21F000         2 1782 6088         move    b,r0
P:032A 20000B         2 1784 6089         tst     b
P:032B 0AF0AA rrrrrr  6 1790 6092         jeq     L75
                             6093 
                             6094 ; 680  |    {
                             6095 ; 681  |        AddXdToQueue(pCurrentXd,pNewXd);
                             6096 
P:032D 0BF080 rrrrrr  6 1796 6098         jsr     FAddXdToQueue
                             6106 
                             6107 ; 682  |    } 
                             6108 
P:032F 0AF080 rrrrrr  6 1802 6110         jmp     L77
                             6111 L75:
P:0331 045FA0         2 1804 6113         movec   m0,n7
P:0332 000000         2 1806 6114         nop
P:0333 6C6F00         4 1810 6115         move    r4,y:(r7+n7)
P:0334 229000         2 1812 6116         move    r4,r0
                             6121 
                             6122 ; 683  |    else
                             6123 ; 684  |    {
                             6124 ; 685  |        btError = usb_dci_transfer_data(pNewXd);
                             6125 
P:0335 0BF080 rrrrrr  6 1818 6127         jsr     Fusb_dci_transfer_data
P:0337 218F00         2 1820 6130         move    a1,b
                             6133 
                             6134 ; 686  |        if(btError)
                             6135 
P:0338 77F400 FFFFFD  3 1823 6137         move    #-3,n7
P:033A 000000         2 1825 6138         nop
P:033B 5D6F00         4 1829 6139         move    b1,y:(r7+n7)
P:033C 2B0000         2 1831 6140         move    #0,b2
P:033D 20000B         2 1833 6141         tst     b
P:033E 0AF0AA rrrrrr  6 1839 6144         jeq     L77
                             6145 
TASKING DSP2410 assembler v1.5r1 Build 138 SN 00100122
                                                                                                                                                                                                                                                       Page  23

M:ADDR CODE           CYCLES LINE SOURCELINE
                             6146 ; 687  |        {
                             6147 ; 688  |            FreeXd(pNewXd);
                             6148 
P:0340 045FA0         2 1841 6150         movec   m0,n7
P:0341 000000         2 1843 6151         nop
P:0342 68EF00         4 1847 6152         move    y:(r7+n7),r0
P:0343 0BF080 rrrrrr  6 1853 6153         jsr     FFreeXd
                             6157 
                             6158 ; 689  |        }
                             6159 ; 690  |    }
                             6160 ; 691  |   
                             6161 ; 692  |    SysUnMaskAllInterrupts(wOldInterrupt);
                             6162 
P:0345 77F400 FFFFFE  3 1856 6164 L77:    move    #-2,n7
P:0347 000000         2 1858 6165         nop
P:0348 5EEF00         4 1862 6166         move    y:(r7+n7),a
P:0349 0BF080 rrrrrr  6 1868 6167         jsr     FSysUnMaskAllInterrupts
                             6171 
                             6172 ; 693  |
                             6173 ; 694  |    return btError;
                             6174 
P:034B 77F400 FFFFFD  3 1871 6176         move    #-3,n7
P:034D 000000         2 1873 6177         nop
P:034E 5EEF00         4 1877 6178         move    y:(r7+n7),a
                             6181 
                             6182 ; 695  |
                             6183 ; 696  |} /* EndBody */
                             6184 
P:034F 77F400 FFFFF3  3 1880 6186 L79:    move    #-13,n7
P:0351 000000         2 1882 6187         nop
P:0352 05EF7C         4 1886 6188         movec   y:(r7+n7),ssh
P:0353 204F00         2 1888 6190         move    (r7)+n7
P:0354 00000C         4 1892 6192         rts
                             6195 
                             6196 ; 697  |
                             6197 ; 698  |////////////////////////////////////////////////////////////////////////////////
                             6198 ; 699  |//
                             6199 ; 700  |//>  Name:          usb_device_send_data
                             6200 ; 701  |//
                             6201 ; 702  |//   Type:          Function
                             6202 ; 703  |//
                             6203 ; 704  |//   Description:   Sends data on the specified endpoint
                             6204 ; 705  |//
                             6205 ; 706  |//   Inputs:        
                             6206 ; 707  |//                  btEndpoint      : Endpoint
                             6207 ; 708  |//                  usStmpWordAdd   : Buffer Start address (STMP space)
                             6208 ; 709  |//                  btByteOffset    : Byte offset in the buffer start address (0, 1, 2)
                             6209 ; 710  |//                  usSize          : Number byte to transfer 
                             6210 ; 711  |//                  bIsDataPhase    : TRUE if data phase during setup transaction
                             6211 ; 712  |//
                             6212 ; 713  |//   Outputs:       
                             6213 ; 714  |//                  Error or USB_OK if no error
                             6214 ; 715  |//
                             6215 ; 716  |//   Notes:
                             6216 ; 717  |//<
                             6217 ; 718  |////////////////////////////////////////////////////////////////////////////////
                             6218 ; 719  |BYTE _reentrant usb_device_send_data(BYTE btEndpoint, WORD _X* pbtStmpWordAdd, BYTE btByteOffset, USHORT usSize, WORD wPrivateData, BOOL bIsDataPhase)
                             6219 ; 720  |{ /* Body */
                             6220 
                             6225 Fusb_device_send_data:
P:0355 055F7C         2 1894 6226         movec   ssh,y:(r7)+
                             6241 
                             6242 ; 721  |  // I'd like to replace these at a future time, but it would change the API.
                             6243 ; 722  |    return usb_device_transfer_data(btEndpoint, pbtStmpWordAdd, btByteOffset, 
                             6244 ; 723  |                                    usSize, wPrivateData, bIsDataPhase, USB_IN);
                             6245 
P:0356 47F400 000001  3 1897 6247         move    #>1,y1
P:0358 0BF080 rrrrrr  6 1903 6248         jsr     Fusb_device_transfer_data
                             6255 
                             6256 ; 724  |
                             6257 ; 725  |} /* EndBody */
                             6258 
P:035A 05FF7C         4 1907 6260         movec   y:-(r7),ssh
P:035B 000000         2 1909 6263         nop
P:035C 00000C         4 1913 6264         rts
                             6266 
                             6267 ; 726  |
                             6268 ; 727  |
                             6269 ; 728  |////////////////////////////////////////////////////////////////////////////////
                             6270 ; 729  |//
                             6271 ; 730  |//>  Name:          usb_device_recv_data
                             6272 ; 731  |//
                             6273 ; 732  |//   Type:          Function
                             6274 ; 733  |//
                             6275 ; 734  |//   Description:   Receives data on the specified endpoint
                             6276 ; 735  |//
                             6277 ; 736  |//   Inputs:        
                             6278 ; 737  |//                  btEndpoint      : Endpoint
                             6279 ; 738  |//                  usStmpWordAdd   : Buffer Start address (STMP space)
                             6280 ; 739  |//                  btByteOffset    : Byte offset in the buffer start address (0, 1, 2)
                             6281 ; 740  |//                  usSize          : Number byte to transfer 
                             6282 ; 741  |//                  bIsDataPhase    : TRUE if data phase during setup transaction
                             6283 ; 742  |//
                             6284 ; 743  |//   Outputs:       
                             6285 ; 744  |//                  Error or USB_OK if no error
                             6286 ; 745  |//
                             6287 ; 746  |//   Notes:
                             6288 ; 747  |//<
                             6289 ; 748  |////////////////////////////////////////////////////////////////////////////////
                             6290 ; 749  |BYTE _reentrant usb_device_recv_data(BYTE btEndpoint, WORD _X* pbtStmpWordAdd, BYTE btByteOffset, USHORT usSize, WORD wPrivateData, BOOL bIsDataPhase)
                             6291 ; 750  |{ /* Body */
                             6292 
                             6297 Fusb_device_recv_data:
P:035D 055F7C         2 1915 6298         movec   ssh,y:(r7)+
                             6313 
                             6314 ; 751  |  // I'd like to replace these at a future time, but it would change the API.
                             6315 ; 752  |    return usb_device_transfer_data(btEndpoint, pbtStmpWordAdd, btByteOffset, 
                             6316 ; 753  |                                    usSize, wPrivateData, bIsDataPhase, USB_OUT);
                             6317 
P:035E 270000         2 1917 6319         move    #0,y1
P:035F 0BF080 rrrrrr  6 1923 6320         jsr     Fusb_device_transfer_data
                             6327 
                             6328 ; 754  |
                             6329 ; 755  |
                             6330 ; 756  |} /* EndBody */
                             6331 
P:0361 05FF7C         4 1927 6333         movec   y:-(r7),ssh
P:0362 000000         2 1929 6336         nop
P:0363 00000C         4 1933 6337         rts
                             6339 
                             6340 ; 757  |
                             6341 ; 758  |
                             6342 ; 759  |
                             6343 ; 760  |////////////////////////////////////////////////////////////////////////////////
                             6344 ; 761  |//
                             6345 ; 762  |//>  Name:          usb_device_release
                             6346 ; 763  |//
                             6347 ; 764  |//   Type:          Function
                             6348 ; 765  |//
                             6349 ; 766  |//   Description:   
                             6350 ; 767  |//
                             6351 ; 768  |//   Inputs:        
                             6352 ; 769  |//   Outputs:       
                             6353 ; 770  |//
                             6354 ; 771  |//   Notes:
                             6355 ; 772  |//<
                             6356 ; 773  |////////////////////////////////////////////////////////////////////////////////
                             6357 ; 774  |void _reentrant usb_device_release(void)
                             6358 ; 775  |{
                             6359 
                             6364 Fusb_device_release:
P:0364 055F7C         2 1935 6365         movec   ssh,y:(r7)+
                             6368 
                             6369 ; 776  |
                             6370 ; 777  |    s_btHoldOffEP0 = FALSE;
                             6371 
P:0365 340000         2 1937 6373         move    #0,r4
P:0366 6C7000 rrrrrr  3 1940 6374         move    r4,y:Fs_btHoldOffEP0
                             6375 
                             6376 ; 778  |
                             6377 ; 779  |    if(s_btStatusPhase == TRUE)
                             6378 
P:0368 5FF000 rrrrrr  3 1943 6380         move    y:Fs_btStatusPhase,b
P:036A 44F400 000001  3 1946 6381         move    #>1,x0
P:036C 20004D         2 1948 6382         cmp     x0,b
P:036D 0AF0A2 rrrrrr  6 1954 6383         jne     L80
                             6384 
                             6385 ; 780  |    {
                             6386 ; 781  |        // Prepare dTD for the status phase
                             6387 ; 782  |        usb_device_recv_data(0, 0, 0, 0, FALSE,0);
                             6388 
P:036F 300000         2 1956 6390         move    #0,r0
P:0370 228E00         2 1958 6391         move    r4,a
P:0371 228F00         2 1960 6392         move    r4,b
P:0372 228400         2 1962 6393         move    r4,x0
P:0373 228600         2 1964 6394         move    r4,y0
P:0374 250000         2 1966 6395         move    #0,x1
P:0375 0BF080 rrrrrr  6 1972 6396         jsr     Fusb_device_recv_data
                             6397 
                             6398 ; 783  |        
                             6399 ; 784  |        s_btStatusPhase = FALSE;
                             6400 
P:0377 200013         2 1974 6402         clr     a   
P:0378 5C7000 rrrrrr  3 1977 6403         move    a1,y:Fs_btStatusPhase
                             6404 
                             6405 ; 785  |    }
                             6406 
                             6408 L80:
                             6409 
                             6410 ; 786  |
                             6411 ; 787  |}
                             6412 
P:037A 05FF7C         4 1981 6414         movec   y:-(r7),ssh
P:037B 000000         2 1983 6417         nop
P:037C 00000C         4 1987 6418         rts
                             6420 
                             6421 ; 788  |
                             6422 ; 789  |////////////////////////////////////////////////////////////////////////////////
                             6423 ; 790  |//
                             6424 ; 791  |//>  Name:          usb_device_hold
                             6425 ; 792  |//
                             6426 ; 793  |//   Type:          Function
                             6427 ; 794  |//
                             6428 ; 795  |//   Description:   
                             6429 ; 796  |//
                             6430 ; 797  |//   Inputs:        
                             6431 ; 798  |//   Outputs:       
                             6432 ; 799  |//
                             6433 ; 800  |//   Notes:
                             6434 ; 801  |//<
                             6435 ; 802  |////////////////////////////////////////////////////////////////////////////////
                             6436 ; 803  |void _reentrant usb_device_hold(void)
                             6437 ; 804  |{
                             6438 
                             6443 Fusb_device_hold:
P:037D 055F7C         2 1989 6444         movec   ssh,y:(r7)+
                             6447 
                             6448 ; 805  |
                             6449 ; 806  |    if(!(usb_device_is_hold()))
                             6450 
P:037E 0BF080 rrrrrr  6 1995 6452         jsr     Fusb_device_is_hold
P:0380 2A0000         2 1997 6453         move    #0,a2
P:0381 200003         2 1999 6454         tst     a
P:0382 0AF0A2 rrrrrr  6 2005 6455         jne     L81
                             6456 
                             6457 ; 807  |    {
                             6458 ; 808  |        s_btHoldOffEP0 = TRUE;
                             6459 
P:0384 3B0100         2 2007 6461         move    #1,n3
P:0385 7B7000 rrrrrr  3 2010 6462         move    n3,y:Fs_btHoldOffEP0
                             6463 
                             6464 ; 809  |        s_btStatusPhase = FALSE;
                             6465 
P:0387 310000         2 2012 6467         move    #0,r1
P:0388 697000 rrrrrr  3 2015 6468         move    r1,y:Fs_btStatusPhase
                             6469 
                             6470 ; 810  |    }
                             6471 
                             6473 L81:
                             6474 
                             6475 ; 811  |}
                             6476 
P:038A 05FF7C         4 2019 6478         movec   y:-(r7),ssh
P:038B 000000         2 2021 6481         nop
P:038C 00000C         4 2025 6482         rts
                             6484 
                             6485 ; 812  |
                             6486 ; 813  |
                             6487 ; 814  |////////////////////////////////////////////////////////////////////////////////
                             6488 ; 815  |//
                             6489 ; 816  |//>  Name:          usb_device_is_hold
                             6490 ; 817  |//
                             6491 ; 818  |//   Type:          Function
                             6492 ; 819  |//
                             6493 ; 820  |//   Description:   
                             6494 ; 821  |//
                             6495 ; 822  |//   Inputs:        
                             6496 ; 823  |//   Outputs:       
                             6497 ; 824  |//
                             6498 ; 825  |//   Notes:
                             6499 ; 826  |//<
TASKING DSP2410 assembler v1.5r1 Build 138 SN 00100122
                                                                                                                                                                                                                                                       Page  24

M:ADDR CODE           CYCLES LINE SOURCELINE
                             6500 ; 827  |////////////////////////////////////////////////////////////////////////////////
                             6501 ; 828  |BYTE _reentrant usb_device_is_hold(void)
                             6502 ; 829  |{
                             6503 
                             6508 Fusb_device_is_hold:
                             6509 
                             6510 ; 830  |    return s_btHoldOffEP0;
                             6511 
P:038D 5EF000 rrrrrr  3 2028 6513         move    y:Fs_btHoldOffEP0,a
                             6514 
                             6515 ; 831  |}
                             6516 
P:038F 00000C         4 2032 6518         rts
                             6520 
                             6521 ; 832  |
                             6522 ; 833  |
                             6523 ; 834  |////////////////////////////////////////////////////////////////////////////////
                             6524 ; 835  |//
                             6525 ; 836  |//>  Name:          usb_device_data_phase_required
                             6526 ; 837  |//
                             6527 ; 838  |//   Type:          Function
                             6528 ; 839  |//
                             6529 ; 840  |//   Description:   
                             6530 ; 841  |//
                             6531 ; 842  |//   Inputs:        
                             6532 ; 843  |//   Outputs:       
                             6533 ; 844  |//
                             6534 ; 845  |//   Notes:
                             6535 ; 846  |//<
                             6536 ; 847  |////////////////////////////////////////////////////////////////////////////////
                             6537 ; 848  |void _reentrant usb_device_data_phase_required(void)
                             6538 ; 849  |{
                             6539 
                             6544 Fusb_device_data_phase_required:
                             6545 
                             6546 ; 850  |
                             6547 ; 851  |    s_btStatusPhase = TRUE;
                             6548 
P:0390 3C0100         2 2034 6550         move    #1,n4
P:0391 7C7000 rrrrrr  3 2037 6551         move    n4,y:Fs_btStatusPhase
                             6552 
                             6553 ; 852  |
                             6554 ; 853  |}
                             6555 
P:0393 00000C         4 2041 6557         rts
                             6559 
                             6560 ; 854  |
                             6561 ; 855  |//
                             6562 ; 856  |//
                             6563 ; 857  |//
                             6564 ; 858  |xd_struct _USB_MEM * GetEmptyXd(void)
                             6565 ; 859  |{
                             6566 
                             6571 FGetEmptyXd:
                             6576 
                             6577 ; 860  |    int i;
                             6578 ; 861  |    xd_struct _USB_MEM * pTemp=NULL;
                             6579 
P:0394 310000         2 2043 6581         move    #0,r1
P:0395 223000         2 2045 6582         move    r1,r0
                             6584 
                             6585 ; 862  |
                             6586 ; 863  |    for (i=0;i<MAX_USB_TRANSFERS_QUEUED;i++)
                             6587 
P:0396 20001B         2 2047 6589         clr     b   
P:0397 47F400 00000F  3 2050 6591         move    #>15,y1
P:0399 63F400 rrrrrr  3 2053 6592         move    #Fg_XdPool,r3
P:039B 44F400 000001  3 2056 6593         move    #>1,x0
P:039D 063080 rrrrrr  6 2062 6594         do      #48,L85
                             6596 
                             6597 ; 864  |    {
                             6598 ; 865  |        if(g_XdPool[i].btStatus == USB_STATUS_TRANSFER_IDLE)
                             6599 
P:039F 21A500         2 2064 6601         move    b1,x1
P:03A0 2000F0         2 2066 6602         mpy     x1,y1,a
P:03A1 200022         2 2068 6603         asr     a
P:03A2 211E00         2 2070 6604         move    a0,n6
P:03A3 66F400 rrrrrr  3 2073 6605         move    #Fg_XdPool+3,r6
P:03A5 000000         2 2075 6606         nop
P:03A6 204E00         2 2077 6607         move    (r6)+n6
P:03A7 5EE600         2 2079 6608         move    y:(r6),a
P:03A8 2A0000         2 2081 6609         move    #0,a2
P:03A9 200003         2 2083 6610         tst     a
P:03AA 0AF0A2 rrrrrr  6 2089 6611         jne     L83
                             6612 
                             6613 ; 866  |        {
                             6614 ; 867  |            pTemp = &g_XdPool[i];
                             6615 
P:03AC 23DB00         2 2091 6617         move    n6,n3
P:03AD 000000         2 2093 6618         nop
P:03AE 204B00         2 2095 6619         move    (r3)+n3
P:03AF 227000         2 2097 6620         move    r3,r0
                             6621 
                             6622 ; 868  |            pTemp ->pNext = NULL;
                             6623 
P:03B0 380A00         2 2099 6625         move    #10,n0
P:03B1 000000         2 2101 6626         nop
P:03B2 044816         4 2105 6627         lua     (r0)+n0,r6
P:03B3 000000         2 2107 6628         nop
P:03B4 696600         2 2109 6629         move    r1,y:(r6)
                             6630 
                             6631 ; 869  |            break;
                             6632 
P:03B5 00008C         2 2111 6634         enddo
P:03B6 00000C         4 2115 6636         rts
                             6637 
                             6638 ; 870  |        }
                             6639 
                             6641 L83:
P:03B7 200048         2 2117 6643         add     x0,b
P:03B8 000000         2 2119 6644         nop
                        (57) 6645 L85:
                             6647 
                             6648 ; 871  |    }
                             6649 ; 872  |
                             6650 ; 873  |    return pTemp;
                             6651 ; 874  |}
                             6652 
P:03B9 00000C         4 2123 6654         rts
                             6658 
                             6659 ; 875  |
                             6660 ; 876  |//
                             6661 ; 877  |//
                             6662 ; 878  |//
                             6663 ; 879  |void FreeXd(xd_struct _USB_MEM * pTemp)
                             6664 ; 880  |{
                             6665 
                             6670 FFreeXd:
                             6673 
                             6674 ; 881  |    pTemp->btStatus = USB_STATUS_TRANSFER_IDLE;
                             6675 
P:03BA 380300         2 2125 6677         move    #3,n0
P:03BB 000000         2 2127 6678         nop
P:03BC 044816         4 2131 6679         lua     (r0)+n0,r6
P:03BD 20001B         2 2133 6680         clr     b   
P:03BE 5D6600         2 2135 6681         move    b1,y:(r6)
                             6682 
                             6683 ; 882  |    pTemp->pNext = NULL;
                             6684 
P:03BF 380A00         2 2137 6686         move    #10,n0
P:03C0 000000         2 2139 6687         nop
P:03C1 044816         4 2143 6688         lua     (r0)+n0,r6
P:03C2 000000         2 2145 6689         nop
P:03C3 5D6600         2 2147 6690         move    b1,y:(r6)
                             6691 
                             6692 ; 883  |
                             6693 ; 884  |}
                             6694 
P:03C4 00000C         4 2151 6696         rts
                             6699 
                             6700 ; 885  |
                             6701 ; 886  |//
                             6702 ; 887  |//
                             6703 ; 888  |//
                             6704 ; 889  |void AddXdToQueue(xd_struct _USB_MEM *pHead,xd_struct _USB_MEM *pElement)
                             6705 ; 890  |{
                             6706 
                             6711 FAddXdToQueue:
                             6718 
                             6719 ; 891  |    int i=0;
                             6720 
P:03C5 260000         2 2153 6722         move    #0,y0
                             6724 
                             6725 ; 892  |    while(pHead->pNext)
                             6726 
P:03C6 56F400 000001  3 2156 6728         move    #>1,a
P:03C8 0AF080 rrrrrr  6 2162 6729         jmp     L87
                             6730 
                             6731 ; 893  |    {
                             6732 ; 894  |        pHead = pHead->pNext;
                             6733 
P:03CA 380A00         2 2164 6735 L86:    move    #10,n0
P:03CB 000000         2 2166 6736         nop
P:03CC 044816         4 2170 6737         lua     (r0)+n0,r6
P:03CD 000000         2 2172 6738         nop
P:03CE 68E600         2 2174 6739         move    y:(r6),r0
                             6740 
                             6741 ; 895  |        i++;
                             6742 
P:03CF 200059         2 2176 6744         tfr     y0,b
P:03D0 200018         2 2178 6745         add     a,b
P:03D1 21A600         2 2180 6748         move    b1,y0
P:03D2 380A00         2 2182 6752 L87:    move    #10,n0
P:03D3 000000         2 2184 6753         nop
P:03D4 044816         4 2188 6754         lua     (r0)+n0,r6
P:03D5 000000         2 2190 6755         nop
P:03D6 5FE600         2 2192 6756         move    y:(r6),b
P:03D7 21FE00         2 2194 6757         move    b,n6
P:03D8 20000B         2 2196 6758         tst     b
P:03D9 0AF0A2 rrrrrr  6 2202 6759         jne     L86
                             6760 
                             6761 ; 896  |    }
                             6762 ; 897  |    pHead->pNext = pElement;
                             6763 
P:03DB 6C6600         2 2204 6765         move    r4,y:(r6)
                             6766 
                             6767 ; 898  |}
                             6768 
P:03DC 00000C         4 2208 6770         rts
                             6775 
                             6776 ; 899  |
                             6777 ; 900  |////////////////////////////////////////////////////////////////////////////////
                             6778 ; 901  |//
                             6779 ; 902  |//>  Name:          usb_device_is_first_init
                             6780 ; 903  |//
                             6781 ; 904  |//   Type:          Function
                             6782 ; 905  |//
                             6783 ; 906  |//   Description:   
                             6784 ; 907  |//
                             6785 ; 908  |//   Inputs:        none
                             6786 ; 909  |//
                             6787 ; 910  |//   Outputs:       none
                             6788 ; 911  |//
                             6789 ; 912  |//   Notes:         none
                             6790 ; 913  |//<
                             6791 ; 914  |////////////////////////////////////////////////////////////////////////////////
                             6792 ; 915  |BOOL _reentrant usb_device_is_first_init(void)
                             6793 ; 916  |{
                             6794 
                             6799 Fusb_device_is_first_init:
                             6800 
                             6801 ; 917  |    return s_bUsbFirstInit;
                             6802 
P:03DD 5EF000 rrrrrr  3 2211 6804         move    y:Fs_bUsbFirstInit,a
                             6805 
                             6806 ; 918  |}
                             6807 
P:03DF 00000C         4 2215 6809         rts
                             6811 
                             6812 ; 919  |
                             6813 ; 920  |////////////////////////////////////////////////////////////////////////////////
                             6814 ; 921  |//
                             6815 ; 922  |//>  Name:          usb_device_set_first_init
                             6816 ; 923  |//
                             6817 ; 924  |//   Type:          Function
                             6818 ; 925  |//
                             6819 ; 926  |//   Description:   
                             6820 ; 927  |//
                             6821 ; 928  |//   Inputs:        none
                             6822 ; 929  |//
                             6823 ; 930  |//   Outputs:       none
                             6824 ; 931  |//
                             6825 ; 932  |//   Notes:         none
                             6826 ; 933  |//<
                             6827 ; 934  |////////////////////////////////////////////////////////////////////////////////
                             6828 ; 935  |void _reentrant usb_device_set_first_init(void)
                             6829 ; 936  |{
                             6830 
                             6835 Fusb_device_set_first_init:
                             6836 
                             6837 ; 937  |
TASKING DSP2410 assembler v1.5r1 Build 138 SN 00100122
                                                                                                                                                                                                                                                       Page  25

M:ADDR CODE           CYCLES LINE SOURCELINE
                             6838 ; 938  |    s_bUsbFirstInit = TRUE;
                             6839 
P:03E0 2D0100         2 2217 6841         move    #1,b1
P:03E1 5D7000 rrrrrr  3 2220 6842         move    b1,y:Fs_bUsbFirstInit
                             6843 
                             6844 ; 939  |}
                             6845 
P:03E3 00000C         4 2224 6847         rts
                             6849 
                             6850 ; 940  |
                             6851 ; 941  |////////////////////////////////////////////////////////////////////////////////
                             6852 ; 942  |//
                             6853 ; 943  |//>  Name:          usb_device_clear_first_init
                             6854 ; 944  |//
                             6855 ; 945  |//   Type:          Function
                             6856 ; 946  |//
                             6857 ; 947  |//   Description:   
                             6858 ; 948  |//
                             6859 ; 949  |//   Inputs:        none
                             6860 ; 950  |//
                             6861 ; 951  |//   Outputs:       none
                             6862 ; 952  |//
                             6863 ; 953  |//   Notes:         none
                             6864 ; 954  |//<
                             6865 ; 955  |////////////////////////////////////////////////////////////////////////////////
                             6866 ; 956  |void _reentrant usb_device_clear_first_init(void)
                             6867 ; 957  |{
                             6868 
                             6873 Fusb_device_clear_first_init:
                             6874 
                             6875 ; 958  |
                             6876 ; 959  |    s_bUsbFirstInit = FALSE;
                             6877 
P:03E4 2D0000         2 2226 6879         move    #0,b1
P:03E5 5D7000 rrrrrr  3 2229 6880         move    b1,y:Fs_bUsbFirstInit
                             6881 
                             6882 ; 960  |}
                             6883 
P:03E7 00000C         4 2233 6885         rts
                             6887 
                             6888 ; 961  |
                             6889 ; 962  |////////////////////////////////////////////////////////////////////////////////
                             6890 ; 963  |//
                             6891 ; 964  |//>  Name:          usb_get_current_limit
                             6892 ; 965  |//
                             6893 ; 966  |//   Type:          Function
                             6894 ; 967  |//
                             6895 ; 968  |//   Description:   
                             6896 ; 969  |//
                             6897 ; 970  |//   Inputs:        none
                             6898 ; 971  |//
                             6899 ; 972  |//   Outputs:       WORD current limit in the device descriptor 
                             6900 ; 973  |//
                             6901 ; 974  |//   Notes:         none
                             6902 ; 975  |//<
                             6903 ; 976  |////////////////////////////////////////////////////////////////////////////////
                             6904 ; 977  |WORD _reentrant usb_get_current_limit(void)
                             6905 ; 978  |{
                             6906 
                             6922 Fusb_get_current_limit:
                             6923 
                             6924 ; 979  |    //WORD wCurrent=0;
                             6925 ; 980  |    return (((Struct_Standard_Config_Desc*)(((BYTE _USB_MEM*)ConfigStruct[0])[0]))->btMaxPower)*2;
                             6926 
P:03E8 6EF000 rrrrrr  3 2236 6928         move    y:FConfigStruct,r6
P:03EA 000000         2 2238 6929         nop
P:03EB 6DE600         2 2240 6930         move    y:(r6),r5
P:03EC 3D0800         2 2242 6931         move    #8,n5
P:03ED 000000         2 2244 6932         nop
P:03EE 044D16         4 2248 6933         lua     (r5)+n5,r6
P:03EF 000000         2 2250 6934         nop
P:03F0 5EE600         2 2252 6935         move    y:(r6),a
P:03F1 200033         2 2254 6936         lsl     a
P:03F2 2A0000         2 2256 6937         move    #0,a2
                             6938 
                             6939 ; 981  |}
                             6940 
P:03F3 00000C         4 2260 6942         rts
                             6944 
                             6945 ; 982  |
                             6946 ; 983  |
                             6947 ; 984  |////////////////////////////////////////////////////////////////////////////////
                             6948 ; 985  |//
                             6949 ; 986  |//>  Name:          usb_set_current_limit
                             6950 ; 987  |//
                             6951 ; 988  |//   Type:          Function
                             6952 ; 989  |//
                             6953 ; 990  |//   Description:   
                             6954 ; 991  |//
                             6955 ; 992  |//   Inputs:        WORD wNewCurrent        new current limit
                             6956 ; 993  |//
                             6957 ; 994  |//   Outputs:       RETCODE 
                             6958 ; 995  |//
                             6959 ; 996  |//   Notes:         none
                             6960 ; 997  |//<
                             6961 ; 998  |////////////////////////////////////////////////////////////////////////////////
                             6962 ; 999  |RETCODE _reentrant usb_set_current_limit(WORD wNewCurrent)
                             6963 ; 1000 |{
                             6964 
                             6969 Fusb_set_current_limit:
                             6974 
                             6975 ; 1001 |    RETCODE rtn = !SUCCESS;
                             6976 
P:03F4 44F400 000001  3 2263 6978         move    #>1,x0
                             6980 
                             6981 ; 1002 |    if(wNewCurrent >= 100 && wNewCurrent <= 500)
                             6982 
P:03F6 46F400 000064  3 2266 6984         move    #>100,y0
P:03F8 2A0000         2 2268 6985         move    #0,a2
P:03F9 200055         2 2270 6986         cmp     y0,a
P:03FA 0AF0A9 rrrrrr  6 2276 6987         jlt     L89
P:03FC 47F400 0001F4  3 2279 6988         move    #500,y1
P:03FE 200075         2 2281 6989         cmp     y1,a
P:03FF 0AF0A7 rrrrrr  6 2287 6990         jgt     L89
                             6991 
                             6992 ; 1003 |    {
                             6993 ; 1004 |        rtn  = SUCCESS;
                             6994 
P:0401 240000         2 2289 6996         move    #0,x0
                             6997 
                             6998 ; 1005 |        ((Struct_Standard_Config_Desc*)(((BYTE _USB_MEM*)ConfigStruct[0])[0]))->btMaxPower = (wNewCurrent/2);
                             6999 
P:0402 200023         2 2291 7001         lsr     a
P:0403 6EF000 rrrrrr  3 2294 7003         move    y:FConfigStruct,r6
P:0405 000000         2 2296 7004         nop
P:0406 69E600         2 2298 7005         move    y:(r6),r1
P:0407 390800         2 2300 7006         move    #8,n1
P:0408 000000         2 2302 7007         nop
P:0409 044916         4 2306 7008         lua     (r1)+n1,r6
P:040A 000000         2 2308 7009         nop
P:040B 5C6600         2 2310 7010         move    a1,y:(r6)
                             7011 
                             7012 ; 1006 |    }
                             7013 ; 1007 |    return rtn;
                             7014 
P:040C 200041         2 2312 7016 L89:    tfr     x0,a
                             7019 
                             7020 ; 1008 |}
                             7021 
P:040D 00000C         4 2316 7023         rts
                             7029 
                             7033 
X:0000                       7034         org     x,".xbssusb_api",bss:
                             7035 FServices:
X:0000                       7036         ds      20
   |   RESERVED                   
X:0013
                             7067 
Y:0000                       7068         org     y,".ybssusb_api",bss:
                             7069 Fg_dXD_Queues:
Y:0000                       7070         ds      8
   |   RESERVED                   
Y:0007
                             7073 FstDeviceState:
Y:0008                       7074         ds      13
   |   RESERVED                   
Y:0014
                             7080 Fg_XdPool:
Y:0015                       7081         ds      720
   |   RESERVED                   
Y:02E4
                             7084 FstTemp:
Y:02E5                       7085         ds      15
   |   RESERVED                   
Y:02F3
                             7086 
                             7087         extern  y:FConfigStruct, y:FStDescDevice, FSysMaskAllInterrupts
                             7088         extern  FSysUnMaskAllInterrupts, Fch9ServiceEp0
                             7089         extern  y:Fg_wUSBProductID, y:Fg_wUSBReleaseID, y:Fg_wUSBVendorID
                             7090         extern  Fusb_dci_get_endpoint_status, Fusb_dci_init
                             7091         extern  Fusb_dci_init_endpoint, Fusb_dci_set_address
                             7092         extern  Fusb_dci_set_endpoint_status, Fusb_dci_set_test_mode
                             7093         extern  Fusb_dci_transfer_data, Fusb_dci_update_connection_status
                             7094 
                             7095         global  FAddXdToQueue, FFreeXd, FGetEmptyXd, FServices, Fg_XdPool
                             7096         global  Fg_dXD_Queues, FstDeviceState, FstTemp
                             7097         global  Fusb_device_call_service, Fusb_device_clear_first_init
                             7098         global  Fusb_device_data_phase_required, Fusb_device_get_status
                             7099         global  Fusb_device_hold, Fusb_device_init
                             7100         global  Fusb_device_init_endpoint, Fusb_device_is_first_init
                             7101         global  Fusb_device_is_hold, Fusb_device_recv_data
                             7102         global  Fusb_device_register_service, Fusb_device_release
                             7103         global  Fusb_device_send_data, Fusb_device_set_first_init
                             7104         global  Fusb_device_set_status, Fusb_device_transfer_data
                             7105         global  Fusb_get_current_limit, Fusb_set_current_limit
                             7106 
                             7107         local   Fs_bUsbFirstInit, Fs_btHoldOffEP0, Fs_btStatusPhase, L4, L6
                             7108         local   L7, L8, L9, L10, L12, L14, L15, L16, L17, L18, L19, L20
                             7109         local   L21, L22, L23, L24, L25, L26, L27, L28, L29, L30, L31, L32
                             7110         local   L33, L34, L35, L46, L47, L48, L49, L50, L51, L52, L53, L54
                             7111         local   L55, L56, L66, L67, L68, L71, L72, L73, L74, L75, L77, L79
                             7112         local   L80, L81, L83, L85, L86, L87, L89
                             7113 
                             7114         calls   "usb_device_call_service", "SysMaskAllInterrupts"
                             7115         calls   "usb_device_call_service", "SysUnMaskAllInterrupts"
                             7116         calls   "usb_device_get_status", "usb_dci_get_endpoint_status"
                             7117         calls   "usb_device_get_status", "usb_dci_update_connection_status"
                             7118         calls   "usb_device_hold", "usb_device_is_hold"
                             7119         calls   "usb_device_init", "usb_dci_init"
                             7120         calls   "usb_device_init", "usb_device_register_service"
                             7121         calls   "usb_device_init_endpoint", "usb_dci_init_endpoint"
                             7122         calls   "usb_device_recv_data", "usb_device_transfer_data"
                             7123         calls   "usb_device_register_service", "SysMaskAllInterrupts"
                             7124         calls   "usb_device_register_service", "SysUnMaskAllInterrupts"
                             7125         calls   "usb_device_release", "usb_device_recv_data"
                             7126         calls   "usb_device_send_data", "usb_device_transfer_data"
                             7127         calls   "usb_device_set_status", "SysMaskAllInterrupts"
                             7128         calls   "usb_device_set_status", "SysUnMaskAllInterrupts"
                             7129         calls   "usb_device_set_status", "usb_dci_set_address"
                             7130         calls   "usb_device_set_status", "usb_dci_set_endpoint_status"
                             7131         calls   "usb_device_set_status", "usb_dci_set_test_mode"
                             7132         calls   "usb_device_transfer_data", "AddXdToQueue", "FreeXd"
                             7133         calls   "usb_device_transfer_data", "GetEmptyXd"
                             7134         calls   "usb_device_transfer_data", "SysMaskAllInterrupts"
                             7135         calls   "usb_device_transfer_data", "SysUnMaskAllInterrupts"
                             7136         calls   "usb_device_transfer_data", "usb_dci_transfer_data"
                             7137         calls   "usb_device_transfer_data", "usb_device_get_status"
                             7138 
