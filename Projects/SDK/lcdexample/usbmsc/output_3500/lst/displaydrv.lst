TASKING DSP2410 assembler v1.5r1 Build 138 SN 00100122
                                                                                                                                                                                                                                                       Page   1
C:\STMP3XXX_SDK_FIRMWARE_320_finalfix\Projects\SDK\lcdexample\usbmsc\Make\cc8722db.src
M:ADDR CODE           CYCLES LINE SOURCELINE
                                1 ; TASKING DSP2410 C compiler v1.5r1 Build 208 SN 00100122
                                2 ; options: -OG -si -w68 -w66 -I..\output_3500\include
                                3 ;          -I..\..\..\..\..\Projects\sdk\lcdexample\usbmsc -I -I..\..
                                4 ;          -I..\..\..\..\..\inc -I..\..\..\..\..\System\Common
                                5 ;          -I..\..\..\..\..\System\Common\symbols -I
                                6 ;          -I..\..\..\..\..\Algorithms\DRM\janus\src\h
                                7 ;          -I..\..\..\..\..\devicedriver\media\ddildl
                                8 ;          -I..\..\..\..\..\devicedriver\media\ddildl\include
                                9 ;          -I..\..\..\..\..\devicedriver\media\MediaTypeMMC\DDI\include
                               10 ;          -I..\..\..\..\..\devicedriver\media\ddildl\include
                               11 ;          -I..\..\..\..\..\devicedriver\media\MediaTypeMMC\DDI\include
                               12 ;          -I..\..\..\..\..\devicedriver\media\MediaTypeMMC\DDI\Media
                               13 ;          -I..\..\..\..\..\devicedriver\media\MediaTypeMMC\HAL\include
                               14 ;          -I..\..\..\..\..\devicedriver\media\MediaTypeRAM\include
                               15 ;          -I..\..\..\..\..\devicedriver\media\MediaTypeRAM\DDI\DataDrive\include
                               16 ;          -I..\..\..\..\..\devicedriver\media\MediaTypeRAM\DDI\include
                               17 ;          -I..\..\..\..\..\devicedriver\media\MediaTypeRAM\HAL\include
                               18 ;          -I..\..\..\..\..\devicedriver\media\MediaTypeRAM\DDI\DataDrive
                               19 ;          -I..\..\..\..\..\devicedriver\media\MediaTypeRAM\include
                               20 ;          -I..\..\..\..\..\devicedriver\media\MediaTypeRAM\DDI\SystemDrive\include
                               21 ;          -I..\..\..\..\..\devicedriver\media\MediaTypeRAM\DDI\include
                               22 ;          -I..\..\..\..\..\devicedriver\media\MediaTypeRAM\HAL\include
                               23 ;          -I..\..\..\..\..\devicedriver\media\MediaTypeRAM\DDI\SystemDrive
                               24 ;          -I..\..\..\..\..\devicedriver\media\MediaTypeRAM\include
                               25 ;          -I..\..\..\..\..\devicedriver\media\MediaTypeRAM\DDI\Media\include
                               26 ;          -I..\..\..\..\..\devicedriver\media\MediaTypeRAM\DDI\include
                               27 ;          -I..\..\..\..\..\devicedriver\media\MediaTypeRAM\HAL\include
                               28 ;          -I..\..\..\..\..\devicedriver\media\MediaTypeRAM\DDI\Media
                               29 ;          -I..\..\..\..\..\devicedriver\media\MediaTypeRAM\include
                               30 ;          -I..\..\..\..\..\devicedriver\media\MediaTypeRAM\DDI\include
                               31 ;          -I..\..\..\..\..\devicedriver\media\MediaTypeRAM\HAL\include
                               32 ;          -I..\..\..\..\..\devicedriver\media\MediaTypeNAND\include
                               33 ;          -I..\..\..\..\..\devicedriver\media\MediaTypeNAND\DDI\DataDrive\include
                               34 ;          -I..\..\..\..\..\devicedriver\media\MediaTypeNAND\DDI\include
                               35 ;          -I..\..\..\..\..\devicedriver\media\MediaTypeNAND\HAL\include
                               36 ;          -I..\..\..\..\..\devicedriver\media\MediaTypeNAND\DDI\DataDrive
                               37 ;          -I..\..\..\..\..\devicedriver\media\ddildl\include -I
                               38 ;          -I..\..\..\..\..\FileSystem\Fat32\cmp\cmp_stdtype
                               39 ;          -I..\..\..\..\..\FileSystem\Fat32\cmp\cmp_debug
                               40 ;          -I..\..\..\..\..\FileSystem\Fat32\cmp\cmp_file_system
                               41 ;          -I..\..\..\..\..\DeviceDriver\Media\cmp\cmp_media_nand
                               42 ;          -I..\..\..\..\..\devicedriver\media\MediaTypeNAND\include
                               43 ;          -I..\..\..\..\..\devicedriver\media\MediaTypeNAND\DDI\Common\include
                               44 ;          -I..\..\..\..\..\devicedriver\media\MediaTypeNAND\DDI\include
                               45 ;          -I..\..\..\..\..\devicedriver\media\MediaTypeNAND\HAL\include
                               46 ;          -I..\..\..\..\..\devicedriver\media\MediaTypeNAND\DDI\Common
                               47 ;          -I..\..\..\..\..\devicedriver\media\MediaTypeNAND\include
                               48 ;          -I..\..\..\..\..\devicedriver\media\MediaTypeNAND\DDI\SystemDrive\include
                               49 ;          -I..\..\..\..\..\devicedriver\media\MediaTypeNAND\DDI\include
                               50 ;          -I..\..\..\..\..\devicedriver\media\MediaTypeNAND\HAL\include
                               51 ;          -I..\..\..\..\..\devicedriver\media\MediaTypeNAND\DDI\SystemDrive
                               52 ;          -I..\..\..\..\..\devicedriver\media\MediaTypeNAND\include
                               53 ;          -I..\..\..\..\..\devicedriver\media\MediaTypeNAND\DDI\Media\include
                               54 ;          -I..\..\..\..\..\devicedriver\media\MediaTypeNAND\DDI\include
                               55 ;          -I..\..\..\..\..\devicedriver\media\MediaTypeNAND\HAL\include
                               56 ;          -I..\..\..\..\..\devicedriver\media\MediaTypeNAND\DDI\Media
                               57 ;          -I..\..\..\..\..\devicedriver\media\include
                               58 ;          -I..\..\..\..\..\devicedriver\media\ddildl
                               59 ;          -I..\..\..\..\..\devicedriver\media\ddildl\include
                               60 ;          -I..\..\..\..\..\devicedriver\media\MediaTypeNAND\DDI\Common\include
                               61 ;          -I..\..\..\..\..\devicedriver\media\MediaTypeNAND\DDI\include
                               62 ;          -I..\..\..\..\..\DeviceDriver\Media\MediaTypeNAND\HAL
                               63 ;          -I..\..\..\..\..\DeviceDriver\Media\MediaTypeNAND\HAL\include
                               64 ;          -I..\..\..\..\..\DeviceDriver\Media\include
                               65 ;          -I..\..\..\..\..\DeviceDriver\Media\PortHIL\GPFlash\include
                               66 ;          -I..\..\..\..\..\DeviceDriver\Media\PortHIL\GPFlash
                               67 ;          -I..\..\..\..\..\system\common\resourcemanager -I..\..\..\..\..\inc
                               68 ;          -I..\..\..\..\..\DeviceDriver\Media\usb\Ch9
                               69 ;          -I..\..\..\..\..\DeviceDriver\Media\scsi
                               70 ;          -I..\..\..\..\..\DeviceDriver\Media\usbmsc
                               71 ;          -I..\..\..\..\..\DeviceDriver\Media\mtp
                               72 ;          -I..\..\..\..\..\System\Common\updater
                               73 ;          -I..\..\..\..\..\libsource\sysserialnumber -DALL -DD3500 -DMMC
                               74 ;          -DLIION -DTUNER_STFM1000 -DSTFM1000_LCD=TRUE -DDCDC_POWER_TRANSFER
                               75 ;          -DBACKLIGHT -DWMAAPI_NO_DRM -DREVB_ENGR_BD -DSED15XX_LCD -DFAT16
                               76 ;          -DDEVICE_3500 -DENGR_BD -DUSBMSC_BUILD -DBATTERY_TYPE_LI_ION
                               77 ;          -DBATTERY_CHARGE -DUSE_PLAYLIST3_HOST -DASCII_ONLY -DRETAIL
                               78 ;          -DDEVICE_3500 -DMMC -Dk_opt_performance_enhancement
                               79 ;          -I..\..\..\..\..\devicedriver\display
                               80 ;          -I..\..\..\..\..\System\MsgModules\Hardware\Display -g -O2 -R -Cs
                               81 ;          -MmyL
                               82 
                               90 
                               91 ;   displaydrv.c:
                               92 ; 1    |#include "types.h"
                               93 
                               95 
                               96 ; 1    |////////////////////////////////////////////////////////////////////////////////
                               97 ; 2    |// Copyright(C) SigmaTel, Inc. 2000-2004
                               98 ; 3    |//
                               99 ; 4    |// Filename: types.h
                              100 ; 5    |// Description: Standard data types
                              101 ; 6    |////////////////////////////////////////////////////////////////////////////////
                              102 ; 7    |
                              103 ; 8    |#ifndef _TYPES_H
                              104 ; 9    |#define _TYPES_H
                              105 ; 10   |
                              106 ; 11   |// TODO:  move this outta here!
                              107 ; 12   |#if !defined(NOERROR)
                              108 ; 13   |#define NOERROR 0
                              109 ; 14   |#define SUCCESS 0
                              110 ; 15   |#endif 
                              111 ; 16   |#if !defined(SUCCESS)
                              112 ; 17   |#define SUCCESS  0
                              113 ; 18   |#endif
                              114 ; 19   |#if !defined(ERROR)
                              115 ; 20   |#define ERROR   -1
                              116 ; 21   |#endif
                              117 ; 22   |#if !defined(FALSE)
                              118 ; 23   |#define FALSE 0
                              119 ; 24   |#endif
                              120 ; 25   |#if !defined(TRUE)
                              121 ; 26   |#define TRUE  1
                              122 ; 27   |#endif
                              123 ; 28   |
                              124 ; 29   |#if !defined(NULL)
                              125 ; 30   |#define NULL 0
                              126 ; 31   |#endif
                              127 ; 32   |
                              128 ; 33   |#define MAX_INT     0x7FFFFF
                              129 ; 34   |#define MAX_LONG    0x7FFFFFffffff
                              130 ; 35   |        // max positive unsigned long value: -1 == 0xFFFFFFffffff
                              131 ; 36   |#define MAX_ULONG   (-1) 
                              132 ; 37   |
                              133 ; 38   |#define WORD_SIZE   24              // word size in bits
                              134 ; 39   |#define BYTES_PER_WORD 3            // 8 bit bytes
                              135 ; 40   |
                              136 ; 41   |
                              137 ; 42   |#define BYTE    unsigned char       // btVarName
                              138 ; 43   |#define CHAR    signed char         // cVarName
                              139 ; 44   |#define USHORT  unsigned short      // usVarName
                              140 ; 45   |#define SHORT   unsigned short      // sVarName
                              141 ; 46   |#define WORD    unsigned int        // wVarName
                              142 ; 47   |#define INT     signed int          // iVarName
                              143 ; 48   |#define DWORD   unsigned long       // dwVarName
                              144 ; 49   |#define LONG    signed long         // lVarName
                              145 ; 50   |#define BOOL    unsigned int        // bVarName
                              146 ; 51   |#define FRACT   _fract              // frVarName
                              147 ; 52   |#define LFRACT  long _fract         // lfrVarName
                              148 ; 53   |#define CIRC    _circ               // cp<type prefix>VarName (see below)
                              149 ; 54   |#define FLOAT   float               // fVarName
                              150 ; 55   |#define DBL     double              // dVarName
                              151 ; 56   |#define ENUM    enum                // eVarName
                              152 ; 57   |#define CMX     _complex            // cmxVarName
                              153 ; 58   |typedef WORD UCS3;                   // 
                              154 ; 59   |
                              155 ; 60   |#define UINT16  unsigned short
                              156 ; 61   |#define UINT8   unsigned char   
                              157 ; 62   |#define UINT32  unsigned long
                              158 ; 63   |#define UINT64  unsigned long   // need to figure out how to do 64 bit values.  Or port exisiting code to only use 48 bit
                              159 ; 64   |#define INT64   unsigned long   // need to figure out how to do 64 bit values.  Or port exisiting code to only use 48 bit
                              160 ; 65   |#define WCHAR   UINT16
                              161 ; 66   |
                              162 ; 67   |//UINT128 is 16 bytes or 6 words
                              163 ; 68   |typedef struct UINT128_3500 {   
                              164 ; 69   |    int val[6];     
                              165 ; 70   |} UINT128_3500;
                              166 ; 71   |
                              167 ; 72   |#define UINT128   UINT128_3500
                              168 ; 73   |
                              169 ; 74   |// Little endian word packed byte strings:   
                              170 ; 75   |//      _packed BYTE bTextVarName[]="a string";  bText is a packed byte string prefix
                              171 ; 76   |// Convert to big endian words by reordering bytes from high to low using swizzle.
                              172 ; 77   |// Little endian word packed byte strings:   
                              173 ; 78   |//      _packed BYTE bTextVarName[]="a string";  bText is a packed byte string prefix
                              174 ; 79   |// Convert to big endian words by reordering bytes from high to low using swizzle.
                              175 ; 80   |
                              176 ; 81   |// Declare Memory Spaces To Use When Coding
                              177 ; 82   |// A. Sector Buffers
                              178 ; 83   |#define SECTOR_BUFFER_MEM_X _X
                              179 ; 84   |#define SECTOR_BUFFER_MEM_Y _Y
                              180 ; 85   |#define SECTOR_BUFFER_MEM SECTOR_BUFFER_MEM_X
                              181 ; 86   |typedef WORD SECTOR_BUFFER_MEM SECTOR_BUFFER;
                              182 
                              184 
                              185 ; 87   |typedef SECTOR_BUFFER * P_SECTOR_BUFFER;
                              186 ; 88   |// B. Media DDI Memory
                              187 ; 89   |#define MEDIA_DDI_MEM _Y
                              188 ; 90   |
                              189 ; 91   |
                              190 ; 92   |
                              191 ; 93   |// Pointers to linear structures are labeled as: p<type prefix>VarName
                              192 ; 94   |// Examples of circular pointers:
                              193 ; 95   |//    INT CIRC cpiVarName
                              194 ; 96   |//    DWORD CIRC cpdwVarName
                              195 ; 97   |
                              196 ; 98   |#define RETCODE INT                 // rcVarName
                              197 ; 99   |
                              198 ; 100  |// generic bitfield structure
                              199 ; 101  |struct Bitfield {
                              200 ; 102  |    unsigned int B0  :1;
                              201 ; 103  |    unsigned int B1  :1;
                              202 ; 104  |    unsigned int B2  :1;
                              203 ; 105  |    unsigned int B3  :1;
                              204 ; 106  |    unsigned int B4  :1;
                              205 ; 107  |    unsigned int B5  :1;
                              206 ; 108  |    unsigned int B6  :1;
                              207 ; 109  |    unsigned int B7  :1;
                              208 ; 110  |    unsigned int B8  :1;
                              209 ; 111  |    unsigned int B9  :1;
                              210 ; 112  |    unsigned int B10 :1;
                              211 ; 113  |    unsigned int B11 :1;
                              212 ; 114  |    unsigned int B12 :1;
                              213 ; 115  |    unsigned int B13 :1;
                              214 ; 116  |    unsigned int B14 :1;
                              215 ; 117  |    unsigned int B15 :1;
                              216 ; 118  |    unsigned int B16 :1;
                              217 ; 119  |    unsigned int B17 :1;
                              218 ; 120  |    unsigned int B18 :1;
                              219 ; 121  |    unsigned int B19 :1;
                              220 ; 122  |    unsigned int B20 :1;
                              221 ; 123  |    unsigned int B21 :1;
                              222 ; 124  |    unsigned int B22 :1;
                              223 ; 125  |    unsigned int B23 :1;
                              224 ; 126  |};
                              225 ; 127  |
                              226 ; 128  |union BitInt {
                              227 ; 129  |        struct Bitfield B;
                              228 ; 130  |        int        I;
                              229 ; 131  |};
                              230 ; 132  |
                              231 ; 133  |#define MAX_MSG_LENGTH 10
                              232 ; 134  |struct CMessage
                              233 ; 135  |{
                              234 ; 136  |        unsigned int m_uLength;
                              235 ; 137  |        unsigned int m_uMsg[MAX_MSG_LENGTH];
                              236 ; 138  |};
                              237 ; 139  |
                              238 ; 140  |typedef struct {
                              239 ; 141  |    WORD m_wLength;
                              240 ; 142  |    WORD m_wMessage;
                              241 ; 143  |    WORD m_wParams[MAX_MSG_LENGTH];
                              242 ; 144  |} Message;
                              243 ; 145  |
                              244 ; 146  |struct MessageQueueDescriptor
                              245 ; 147  |{
                              246 ; 148  |        int *m_pBase;
                              247 ; 149  |        int m_iModulo;
                              248 ; 150  |        int m_iSize;
                              249 ; 151  |        int *m_pHead;
                              250 ; 152  |        int *m_pTail;
                              251 ; 153  |};
                              252 ; 154  |
                              253 ; 155  |struct ModuleEntry
                              254 ; 156  |{
                              255 ; 157  |    int m_iSignaledEventMask;
                              256 ; 158  |    int m_iWaitEventMask;
                              257 ; 159  |    int m_iResourceOfCode;
                              258 ; 160  |    struct MessageQueueDescriptor *m_pMessageQueue;
                              259 ; 161  |    int _asmfunc (*m_pProcessEntryPoint)(union WaitMask Signals,struct MessageQueueDescriptor *);
                              260 ; 162  |    int _asmfunc (*m_pInitFunction)(struct MessageQueueDescriptor *);
TASKING DSP2410 assembler v1.5r1 Build 138 SN 00100122
                                                                                                                                                                                                                                                       Page   2

M:ADDR CODE           CYCLES LINE SOURCELINE
                              261 ; 163  |    int m_uTimeOutHigh;
                              262 ; 164  |    int m_uTimeOutLow;
                              263 ; 165  |    int _asmfunc (*m_pBackgroundFunction)(struct MessageQueueDescriptor *);
                              264 ; 166  |};
                              265 ; 167  |
                              266 ; 168  |union WaitMask{
                              267 ; 169  |    struct B{
                              268 ; 170  |        unsigned int m_bNone     :1;
                              269 ; 171  |        unsigned int m_bMessage  :1;
                              270 ; 172  |        unsigned int m_bTimer    :1;
                              271 ; 173  |        unsigned int m_bButton   :1;
                              272 ; 174  |    } B;
                              273 ; 175  |    int I;
                              274 ; 176  |} ;
                              275 ; 177  |
                              276 ; 178  |
                              277 ; 179  |struct Button {
                              278 ; 180  |        WORD wButtonEvent;
                              279 ; 181  |        WORD wUnused[MAX_MSG_LENGTH];   
                              280 ; 182  |};
                              281 ; 183  |
                              282 ; 184  |struct Message {
                              283 ; 185  |        WORD wMsgLength;
                              284 ; 186  |        WORD wMsgCommand;
                              285 ; 187  |        WORD wMsgParms[MAX_MSG_LENGTH-1];
                              286 ; 188  |};
                              287 ; 189  |
                              288 ; 190  |union EventTypes {
                              289 ; 191  |        struct CMessage msg;
                              290 ; 192  |        struct Button Button ;
                              291 ; 193  |        struct Message Message;
                              292 ; 194  |};
                              293 ; 195  |
                              294 ; 196  |// next 2 used to get updater build to return correct protocol ver in scsi response.
                              295 ; 197  |#define BUILD_TYPE_UPDATER  0x100
                              296 ; 198  |#define BUILD_TYPE_HOSTLINK 0x101
                              297 ; 199  |#define BUILD_TYPE_PLAYER   0x102
                              298 ; 200  |
                              299 ; 201  |// Resets part if RETAIL build. DEBUG build executes debug instruction to halt.
                              300 ; 202  |#define SystemHalt() __asm(" include 'sysmacro.asm' \n error") 
                              301 ; 203  |#define assert(x)    if(!(x)) __asm(" include 'sysmacro.asm' \n error")
                              302 ; 204  |
                              303 ; 205  |#if DEBUG
                              304 ; 206  |// For DEBUG builds, DebugBuildAssert(condition) halts if condition evaluates to FALSE. 
                              305 ; 207  |#define DebugBuildAssert(x)    if(!(x)) __asm(" debug ")
                              306 ; 208  |#else 
                              307 ; 209  |// For RETAIL builds, DebugBuildAssert(condition) does nothing & execution continues rather than halt or reset. 
                              308 ; 210  |#define DebugBuildAssert(x)    
                              309 ; 211  |#endif
                              310 ; 212  |
                              311 ; 213  |// Do this in your C files to make a reminder that's displayed during the build.
                              312 ; 214  |//  #pragma asm
                              313 ; 215  |//  WARN 'Note to builder: reminder to do this after verifying that'
                              314 ; 216  |//  #pragma endasm
                              315 ; 217  |
                              316 ; 218  |
                              317 ; 219  |#ifdef COLOR_262K
                              318 ; 220  |#define RGB(r,g,b)    ((0x0000FC & (r)) << 10) | ((0x0000FC & (g)) << 4) | ((0x0000FC & (b)) >> 2)    //262k
                              319 ; 221  |#elif defined(COLOR_65K)
                              320 ; 222  |#define RGB(r,g,b)    ((0x0000F8 & (r)) << 8) | ((0x0000FC & (g)) << 3) | ((0x0000F8 & (b)) >> 3)  //65k
                              321 ; 223  |#else
                              322 ; 224  |#define RGB(r,g,b)       ((0x0000F0 & (r)) << 4) | (0x0000F0 & (g)) | ((0x0000F0 & (b)) >> 4)
                              323 ; 225  |#endif
                              324 ; 226  |    
                              325 ; 227  |#endif // #ifndef _TYPES_H
                              326 
                              328 
                              329 ; 2    |#include "project.h"
                              330 
                              332 
                              333 ; 1    |/////////////////////////////////////////////////////////////////////////////////
                              334 ; 2    |//  Copyright(C) SigmaTel, Inc. 2000-2004
                              335 ; 3    |//  Filename: project.inc
                              336 ; 4    |//  Description: 
                              337 ; 5    |/////////////////////////////////////////////////////////////////////////////////
                              338 ; 6    |
                              339 ; 7    |#if (!defined(_PROJECT_INC))
                              340 ; 8    |#define _PROJECT_INC 1
                              341 ; 9    |
                              342 ; 10   |#if defined(STMP_BUILD_PLAYER)
                              343 ; 11   |#include "hwequ.h"
                              344 ; 12   |#else 
                              345 ; 13   |//include "regscodec.inc"
                              346 ; 14   |#endif
                              347 ; 15   |
                              348 ; 16   |//////////////////////////////////////////////////////////////////////////////////
                              349 ; 17   |// Uncomment next define to allow player boot if you have stfm1000 macro enabled (defaults ON) & 
                              350 ; 18   |// your board crystal is not able to output nominal voltage range. Used in player main.asm. STMP00012148
                              351 ; 19   |// Defining this will result in lower battery life (price of using a lower quality crystal). 
                              352 ; 20   |// Those that want to save battery life and have good crystals that meet our HW team's specs can 
                              353 ; 21   |// comment out this line to reduce crystal bias current and so battery current in player mode.  
                              354 ; 22   |#define SUPPORT_MARGINAL_XTALS 1
                              355 ; 23   |
                              356 ; 24   |/////////////////////////////////////////////////////////////////////////////////
                              357 ; 25   |// BOOT SPEED CONFIG & ASSOCIATED BATTERY VOLTAGE CHECK ENABLE
                              358 ; 26   |/////////////////////////////////////////////////////////////////////////////////
                              359 ; 27   |// Users can enable one of ATTEMPT_FAST_BOOT or FASTEST boot or neither project define below by defining
                              360 ; 28   |// values as 0 or 1, else it defaults to the boot speed used in previous SDKs.
                              361 ; 29   |#define ATTEMPT_FAST_BOOT 1
                              362 ; 30   |#define ATTEMPT_FASTEST_BOOT 0   
                              363 ; 31   |// Changing this define to 0 removes Vbat threshholding & unconditionally gives fast boot config above- 
                              364 ; 32   |// disabling this check is suggested for profiling if you want to try to tweak down threshholds by maybe 50mV.
                              365 ; 33   |// Also the tests should clear the fast boot config defines to link & boot at normal speed.
                              366 ; 34   |#define SPEED_BOOT_BATTERY_CHECK 1
                              367 ; 35   |
                              368 ; 36   |/////////////////////////////////////////////////////////////////////////////////
                              369 ; 37   |// MEDIA DEFINITIONS
                              370 ; 38   |/////////////////////////////////////////////////////////////////////////////////
                              371 ; 39   |
                              372 ; 40   |/////////////////////////////////////////////////////////////////////////////////
                              373 ; 41   |// MNAND - Number of chips forming the internal physical device (i.e. # of NANDs)
                              374 ; 42   |#if defined(NAND1)
                              375 ; 43   |#define SM_INTERNAL_CHIPS 1
                              376 ; 44   |#else 
                              377 ; 45   |#if defined(NAND2)
                              378 ; 46   |#define SM_INTERNAL_CHIPS 2
                              379 ; 47   |#else 
                              380 ; 48   |#if defined(NAND3)
                              381 ; 49   |#define SM_INTERNAL_CHIPS 3
                              382 ; 50   |#else 
                              383 ; 51   |#if defined(NAND4)
                              384 ; 52   |#define SM_INTERNAL_CHIPS 4
                              385 ; 53   |#else 
                              386 ; 54   |#define SM_INTERNAL_CHIPS 1
                              387 ; 55   |#endif
                              388 ; 56   |#endif
                              389 ; 57   |#endif
                              390 ; 58   |#endif
                              391 ; 59   |
                              392 ; 60   |/////////////////////////////////////////////////////////////////////////////////
                              393 ; 61   |// If SMARTMEDIA_DETECT_ACTIVE_HIGH is defined:
                              394 ; 62   |//   SmartMedia will be detected as inserted if the GPIO pin reads 1 and removed if it reads 0.  
                              395 ; 63   |// If SMARTMEDIA_DETECT_ACTIVE_HIGH is not defined ** comment out next line **
                              396 ; 64   |//   SmartMedia will be detected as inserted if the GPIO pin reads 0 and removed if it reads 1.
                              397 ; 65   |//*** comment out if active high ****
                              398 ; 66   |//SMARTMEDIA_DETECT_ACTIVE_HIGH  equ     1
                              399 ; 67   |
                              400 ; 68   |#if defined(SMEDIA)
                              401 ; 69   |#define NUM_REMOVABLE_MEDIA 1
                              402 ; 70   |#define NUM_SM_EXTERNAL 1
                              403 ; 71   |#define MMC_MAX_PHYSICAL_DEVICES 0
                              404 ; 72   |#define SM_MAX_LOGICAL_DEVICES 2
                              405 ; 73   |#else 
                              406 ; 74   |#if defined(MMC)
                              407 ; 75   |#define NUM_REMOVABLE_MEDIA 1
                              408 ; 76   |#define NUM_SM_EXTERNAL 0
                              409 ; 77   |#define MMC_MAX_PHYSICAL_DEVICES 1
                              410 ; 78   |#define SM_MAX_LOGICAL_DEVICES 1
                              411 ; 79   |#else 
                              412 ; 80   |#define NUM_REMOVABLE_MEDIA 0
                              413 ; 81   |#define NUM_SM_EXTERNAL 0
                              414 ; 82   |#define MMC_MAX_PHYSICAL_DEVICES 0
                              415 ; 83   |#define SM_MAX_LOGICAL_DEVICES 1
                              416 ; 84   |#endif
                              417 ; 85   |#endif
                              418 ; 86   |
                              419 ; 87   |/////////////////////////////////////////////////////////////////////////////////
                              420 ; 88   |// Mass Storage Class definitions
                              421 ; 89   |/////////////////////////////////////////////////////////////////////////////////
                              422 ; 90   |// Set to 0 if Composite Device build is desired.    
                              423 ; 91   |#define MULTI_LUN_BUILD 1   
                              424 ; 92   |
                              425 ; 93   |////////////////////////////////////////////////////////////////////////////////
                              426 ; 94   |//  SCSI
                              427 ; 95   |#if (MULTI_LUN_BUILD==0)
                              428 ; 96   |  #if (NUM_REMOVABLE_MEDIA == 1)
                              429 ; 97   |    #define SCSI_NUM_TARGETS                        2
                              430 ; 98   |    #define SCSI_DEVICE_NUM_LUNS_DEV_0              1
                              431 ; 99   |    #define SCSI_DEVICE_NUM_LUNS_DEV_1              1
                              432 ; 100  |  #else
                              433 ; 101  |    #define SCSI_NUM_TARGETS                        1
                              434 ; 102  |    #define SCSI_DEVICE_NUM_LUNS_DEV_0              1
                              435 ; 103  |  #endif
                              436 ; 104  |#else
                              437 ; 105  |    #define SCSI_NUM_TARGETS                        1
                              438 ; 106  |  #if (NUM_REMOVABLE_MEDIA == 1)
                              439 ; 107  |    #define SCSI_DEVICE_NUM_LUNS_DEV_0              2
                              440 ; 108  |  #else
                              441 ; 109  |    #define SCSI_DEVICE_NUM_LUNS_DEV_0              1  
                              442 ; 110  |  #endif
                              443 ; 111  |#endif
                              444 ; 112  |
                              445 ; 113  |
                              446 ; 114  |#define USBMSC_NUM_DEVICES                      SCSI_NUM_TARGETS
                              447 ; 115  |
                              448 ; 116  |
                              449 ; 117  |////////////////////////////////////////////////////////////////////////////////
                              450 ; 118  |// Define number of logical medias and drives for three builds (MTP, USBMSC, and Player)
                              451 ; 119  |////////////////////////////////////////////////////////////////////////////////
                              452 ; 120  |#ifdef MMC
                              453 ; 121  |#ifdef MTP_BUILD
                              454 ; 122  |// --------------------
                              455 ; 123  |// MTP and MMC
                              456 ; 124  |// --------------------
                              457 ; 125  |#define NUM_LOGICAL_MEDIA       2
                              458 ; 126  |#define NUM_LOGICAL_DRIVES      8
                              459 ; 127  |#else  // ifndef MTP_BUILD
                              460 ; 128  |#ifdef STMP_BUILD_PLAYER
                              461 ; 129  |// --------------------
                              462 ; 130  |// Player and MMC
                              463 ; 131  |// --------------------
                              464 ; 132  |#else
                              465 ; 133  |// --------------------
                              466 ; 134  |// USBMSC and MMC
                              467 ; 135  |// --------------------
                              468 ; 136  |#define NUM_LOGICAL_MEDIA       3
                              469 ; 137  |#define NUM_LOGICAL_DRIVES      8
                              470 ; 138  |#endif // ifdef STMP_BUILD_PLAYER
                              471 ; 139  |#endif // ifdef MTP_BUILD
                              472 ; 140  |#else  // ifndef MMC
                              473 ; 141  |#ifdef MTP_BUILD
                              474 ; 142  |// --------------------
                              475 ; 143  |// MTP and NAND only
                              476 ; 144  |// --------------------
                              477 ; 145  |#define NUM_LOGICAL_MEDIA       1
                              478 ; 146  |#define NUM_LOGICAL_DRIVES      7
                              479 ; 147  |#else  // ifndef MTP_BUILD
                              480 ; 148  |#ifdef STMP_BUILD_PLAYER
                              481 ; 149  |// --------------------
                              482 ; 150  |// Player and NAND only
                              483 ; 151  |// --------------------
                              484 ; 152  |#else
                              485 ; 153  |// --------------------
                              486 ; 154  |// USBMSC and NAND only
                              487 ; 155  |// --------------------
                              488 ; 156  |#define NUM_LOGICAL_MEDIA       2
                              489 ; 157  |#define NUM_LOGICAL_DRIVES      7
                              490 ; 158  |#endif // ifdef STMP_BUILD_PLAYER
                              491 ; 159  |#endif // ifdef MTP_BUILD
                              492 ; 160  |#endif // ifdef MMC 
                              493 ; 161  |
                              494 ; 162  |// If we are in an MTP build then we don't use as many transfers buffers.
                              495 ; 163  |#if (defined(MTP_BUILD))
                              496 ; 164  |#define MAX_USB_TRANSFERS_QUEUED 16
                              497 ; 165  |
                              498 ; 166  |////!
                              499 ; 167  |////! This varible holds the watchdog count for the store flush.
                              500 ; 168  |////!
                              501 ; 169  |///
                              502 ; 170  |#include <types.h>
                              503 ; 171  |extern volatile INT g_StoreWatchDogCount;
                              504 ; 172  |extern const INT g_StoreWatchDogTimeout;
                              505 ; 173  |#endif
                              506 ; 174  |
                              507 ; 175  |////////////////////////////////////////////////////////////////////////////////
                              508 ; 176  |// These are needed here for Mass Storage Class
                              509 ; 177  |// Needs to be cleaned up
                              510 ; 178  |////////////////////////////////////////////////////////////////////////////////
                              511 ; 179  |#if (!defined(STMP_BUILD_PLAYER))
                              512 ; 180  |#define SCRATCH_USER_Y_SIZE 512
                              513 ; 181  |#define SCRATCH_USER_X_SIZE 512
TASKING DSP2410 assembler v1.5r1 Build 138 SN 00100122
                                                                                                                                                                                                                                                       Page   3

M:ADDR CODE           CYCLES LINE SOURCELINE
                              514 ; 182  |
                              515 ; 183  |#define BROWNOUT_LEVEL1_DETECTED                0x000001
                              516 ; 184  |
                              517 ; 185  |#endif
                              518 ; 186  |
                              519 ; 187  |
                              520 ; 188  |/////////////////////////////////////////////////////////////////////////////////
                              521 ; 189  |// SmartMedia/NAND defs
                              522 ; 190  |#define SM_MAX_PHYSICAL_DEVICES SM_INTERNAL_CHIPS+NUM_SM_EXTERNAL
                              523 ; 191  |#define SM_REMOVABLE_DEVICE_NUM SM_INTERNAL_CHIPS
                              524 ; 192  |
                              525 ; 193  |/////////////////////////////////////////////////////////////////////////////////
                              526 ; 194  |// Sysloadresources defs
                              527 ; 195  |#define SM_MAX_RESOURCE_DEVICES SM_INTERNAL_CHIPS+NUM_SM_EXTERNAL
                              528 ; 196  |
                              529 ; 197  |/////////////////////////////////////////////////////////////////////////////////
                              530 ; 198  |// MMC defs
                              531 ; 199  |#define MMC_MAX_PARTITIONS 1
                              532 ; 200  |#define MMC_MAX_LOGICAL_DEVICES MMC_MAX_PHYSICAL_DEVICES*MMC_MAX_PARTITIONS
                              533 ; 201  |
                              534 ; 202  |/////////////////////////////////////////////////////////////////////////////////
                              535 ; 203  |// SPI defs
                              536 ; 204  |#define SPI_MAX_DEVICES MMC_MAX_PHYSICAL_DEVICES
                              537 ; 205  |
                              538 ; 206  |/////////////////////////////////////////////////////////////////////////////////
                              539 ; 207  |// Global media defs
                              540 ; 208  |#define MAX_PHYSICAL_DEVICES SM_MAX_PHYSICAL_DEVICES+MMC_MAX_PHYSICAL_DEVICES
                              541 ; 209  |#define MAX_LOGICAL_DEVICES SM_MAX_LOGICAL_DEVICES+MMC_MAX_LOGICAL_DEVICES
                              542 ; 210  |
                              543 ; 211  |/////////////////////////////////////////////////////////////////////////////////
                              544 ; 212  |// DO NOT CHANGE THESE!!!
                              545 ; 213  |#define SM_MAX_PARTITIONS 4
                              546 ; 214  |#define MAX_HANDLES 2
                              547 ; 215  |/////////////////////////////////////////////////////////////////////////////////
                              548 ; 216  |
                              549 ; 217  |
                              550 ; 218  |/////////////////////////////////////////////////////////////////////////////////
                              551 ; 219  |// Battery LRADC Values 
                              552 ; 220  |/////////////////////////////////////////////////////////////////////////////////
                              553 ; 221  |// brownout trip point in mV (moved by RS)
                              554 ; 222  |// BATT_SAFETY_MARGIN:  percentage value used by:
                              555 ; 223  |//   * SysSaveSettings to determine if enough power is left to attempt a settings save. 
                              556 ; 224  |//   * Recorder to conditionally prevent the start or continuation of 
                              557 ; 225  |//     audio recording to media.
                              558 ; 226  |#define BATT_SAFETY_MARGIN 10
                              559 ; 227  |
                              560 ; 228  |//; player resource drive refresh allowed only when battery usable % is above this value. 
                              561 ; 229  |//; 50% of usable range [0.9V to 1.5V] is around 1.2V This is the safe target alkaline voltage to do a refresh.
                              562 ; 230  |//; LIION will also require 50% which will work but that could be changed in the future. 
                              563 ; 231  |//RESOURCE_REFRESH_MIN_BATT_PCT equ 50
                              564 ; 232  |
                              565 ; 233  |// stmp00005071 adds these for mp3 encode stability at low battery per battery type & mmc presence.
                              566 ; 234  |
                              567 ; 235  |//// Vbat threshholds empirically tuned by profiling max bat current for 3 HW cases: 
                              568 ; 236  |//// 1 GigaByte MMC, NAND flash only, & LiIon Buck mode. See voicemenu pre-encode Vbat check.
                              569 ; 237  |#if (!defined(CLCD))
                              570 ; 238  |#define MP3_ENC_MMC_MIN_V_BAT_MV 1100
                              571 ; 239  |#define MP3_ENC_NANDONLY_MIN_V_BAT_MV 1000
                              572 ; 240  |#else 
                              573 ; 241  |#define MP3_ENC_MMC_MIN_V_BAT_MV 1250
                              574 ; 242  |#define MP3_ENC_NANDONLY_MIN_V_BAT_MV 1150
                              575 ; 243  |#endif
                              576 ; 244  |#define MP3_ENC_BUCKMODE_MIN_V_BAT_MV 3300
                              577 ; 245  |
                              578 ; 246  |// These Vbat use-range-percentages are derived to correspond with target battery 
                              579 ; 247  |// voltages of 1.10V for MMC, 1.0V for nand only (alkaline or nimh), and 3.3V for any LiIon.
                              580 ; 248  |// See mp3 encoder overlay.
                              581 ; 249  |#define MP3_ENC_MMC_MIN_V_BAT_RANGE_PCT 33
                              582 ; 250  |#define MP3_ENC_NANDONLY_MIN_V_BAT_RANGE_PCT 17
                              583 ; 251  |#define MP3_ENC_BUCKMODE_MIN_V_BAT_RANGE_PCT 25
                              584 ; 252  |
                              585 ; 253  |/////////////////////////////////////////////////////////////////////////////////
                              586 ; 254  |// Voice recording filenames
                              587 ; 255  |// number of digits in filename Vxxx.wav
                              588 ; 256  |/////////////////////////////////////////////////////////////////////////////////
                              589 ; 257  |#define DIGITS_IN_VOICE_FILENAME 3   
                              590 ; 258  |
                              591 ; 259  |/////////////////////////////////////////////////////////////////////////////////
                              592 ; 260  |// Mic Bias: Set this enable to 1 to internally generate mic bias voltage. 
                              593 ; 261  |// Also below, must configure internal resistor value and pin to use for DC bias. 
                              594 ; 262  |// Can set to 0 to disable internally generated mic bias voltage at pin lradc1/2.
                              595 ; 263  |#if defined(DEVICE_3500)
                              596 ; 264  |#define ENABLE_INTERNALLY_GENERATED_MICBIAS 1 
                              597 ; 265  |// MIC BIAS circuit source selection: use Low Resolution ADC pin 2 or 1 to bias mic. 
                              598 ; 266  |// Per your layout: select LRADC 2 or 1 below 
                              599 ; 267  |//   (pin LRADC 2 for 35xx cpu card revB, LRADC 1 for 35xx cpu card revC, ref schematics, & demo player)
                              600 ; 268  |#define LRADC_NUM_FOR_MIC_BIAS 1 
                              601 ; 269  |// Sets internal mic bias R to value 2, 4, or 8 (in kOhms).
                              602 ; 270  |#define MICBIAS_CONFIGURED_RESISTOR_KOHMS 8
                              603 ; 271  |
                              604 ; 272  |// Allows mic bias to settle before sampling. This delay currently unused. For rec btn when bias not yet ready.
                              605 ; 273  |#define REC_BTN_INTERNAL_MIC_BIAS_SETTLING_DELAY_MS 400 
                              606 ; 274  |// Option always keeps bias enabled after mainmenu init. This allows for start pop prevention if you use rec button from outside voice menu.
                              607 ; 275  |// This selection costs 1 mWatt but gains the desired low record button to sampling latency in the record-from-music-menu use-case.
                              608 ; 276  |#define KEEP_MIC_BIAS_ENABLED 0
                              609 ; 277  |
                              610 ; 278  |#else 
                              611 ; 279  |// STMP3410
                              612 ; 280  |#define ENABLE_INTERNALLY_GENERATED_MICBIAS 0
                              613 ; 281  |#define LRADC_NUM_FOR_MIC_BIAS 1 
                              614 ; 282  |#define MICBIAS_CONFIGURED_RESISTOR_KOHMS 2
                              615 ; 283  |#endif
                              616 ; 284  |
                              617 ; 285  |/////////////////////////////////////////////////////////////////////////////////
                              618 ; 286  |// Number of available soft timers
                              619 ; 287  |/////////////////////////////////////////////////////////////////////////////////
                              620 ; 288  |#if defined(SYNC_LYRICS)
                              621 ; 289  |#define SOFT_TIMERS 10
                              622 ; 290  |#else 
                              623 ; 291  |#if defined(JPEG_DECODER)
                              624 ; 292  |#define SOFT_TIMERS 10
                              625 ; 293  |#else 
                              626 ; 294  |#define SOFT_TIMERS 9
                              627 ; 295  |#endif
                              628 ; 296  |#endif
                              629 ; 297  |
                              630 ; 298  |/////////////////////////////////////////////////////////////////////////////////
                              631 ; 299  |//  sizes
                              632 ; 300  |/////////////////////////////////////////////////////////////////////////////////
                              633 ; 301  |#if defined(MMC)
                              634 ; 302  |#if defined(USE_PLAYLIST5)
                              635 ; 303  |#define MENU_STACK_SIZE 1500
                              636 ; 304  |#else 
                              637 ; 305  |#define MENU_STACK_SIZE 1250
                              638 ; 306  |#endif //if @def('USE_PLAYLIST5')
                              639 ; 307  |#else 
                              640 ; 308  |#if defined(USE_PLAYLIST5)
                              641 ; 309  |#define MENU_STACK_SIZE 1500
                              642 ; 310  |#else 
                              643 ; 311  |#define MENU_STACK_SIZE 1250
                              644 ; 312  |#endif //if @def('USE_PLAYLIST5')
                              645 ; 313  |#endif //if @def('MMC')
                              646 ; 314  |
                              647 ; 315  |// NOTE: SDK2.6 USED 550 FOR NEXT LINE, BUT SDK3.0BETA USED 750. Should it be ifdef MTP 750 else 550 for other builds? TOVERIFY. MYALLOC
                              648 ; 316  |// 
                              649 ; 317  |#define STACK_L1_SIZE 750
                              650 ; 318  |#define STACK_L2_SIZE 100
                              651 ; 319  |#define STACK_L3_SIZE 160
                              652 ; 320  |
                              653 ; 321  |// If we are in MTP mode the overlay task stack can shrink.
                              654 ; 322  |// TODO shrink this stack for MTP, I will leave it at 500 until we verify that it 
                              655 ; 323  |// is ok with switching code.
                              656 ; 324  |#if defined(MTP_BUILD)
                              657 ; 325  |#define OVERLAY_MANAGER_STACK_SIZE 300
                              658 ; 326  |#endif
                              659 ; 327  |
                              660 ; 328  |/////////////////////////////////////////////////////////////////////////////////
                              661 ; 329  |// maximum number of nested funclets 
                              662 ; 330  |/////////////////////////////////////////////////////////////////////////////////
                              663 ; 331  |#define MAX_NESTED_FUNCLET 6 
                              664 ; 332  |
                              665 ; 333  |/////////////////////////////////////////////////////////////////////////////////
                              666 ; 334  |//    LCD DEFINITIONS
                              667 ; 335  |/////////////////////////////////////////////////////////////////////////////////
                              668 ; 336  |
                              669 ; 337  |#define SPACE_CHAR 0x000020          
                              670 ; 338  |#define ZERO_CHAR 0x000030
                              671 ; 339  |#define COLON_CHAR 0x00003A
                              672 ; 340  |#define PERIOD_CHAR 0x00002E
                              673 ; 341  |
                              674 ; 342  |#if (defined(S6B33B0A_LCD))
                              675 ; 343  |#define LCD_X_SIZE 128
                              676 ; 344  |#define LCD_Y_SIZE 159
                              677 ; 345  |#endif
                              678 ; 346  |
                              679 ; 347  |#if (defined(SED15XX_LCD))
                              680 ; 348  |#define LCD_X_SIZE 128
                              681 ; 349  |#define LCD_Y_SIZE 64
                              682 ; 350  |#endif
                              683 ; 351  |
                              684 ; 352  |
                              685 ; 353  |//////////////////////////////////////////////////////////////////////////////////
                              686 ; 354  |//   Details on Customizing Contrast
                              687 ; 355  |/////////////////////////////////////////////////////////////////////////////////
                              688 ; 356  |//   Max supported LCD range is 0 - 3F; however due to hardware/voltage differences
                              689 ; 357  |//   the range of visibility is usually smaller than this.  It is important to 
                              690 ; 358  |//   calibrate the visible range, because the contrast setting is saved.
                              691 ; 359  |//   If the user shuts off the player while lcd is not visible, the player is useless
                              692 ; 360  |//   unless the ezact sequence is remembered.
                              693 ; 361  |//   To find out what range your player supports: 
                              694 ; 362  |//   change these equs to full range or comment out (full range is default)
                              695 ; 363  |//;;;;;;
                              696 ; 364  |// uncomment the line below to build code that will provide raw contrast value
                              697 ; 365  |// recommended calibration using player -- uncomment 
                              698 ; 366  |//;;;;;;
                              699 ; 367  |//CONTRAST_CALIBRATION    equ  1
                              700 ; 368  |////////////////////////////
                              701 ; 369  |#if (defined(DEMO_HW))
                              702 ; 370  |// this is the setting for ET301 demos; Next 2 line have not been updated for new Shingyi LCD (June6'05)
                              703 ; 371  |#define LCD_MAX_CONTRAST 0x32 
                              704 ; 372  |#define LCD_MIN_CONTRAST 0x1E
                              705 ; 373  |#else 
                              706 ; 374  |
                              707 ; 375  |#if (defined(S6B33B0A_LCD))
                              708 ; 376  |#define LCD_MAX_CONTRAST 210
                              709 ; 377  |#define LCD_MIN_CONTRAST 160    
                              710 ; 378  |#endif
                              711 ; 379  |
                              712 ; 380  |#if (defined(SED15XX_LCD))
                              713 ; 381  |// Next 3 line comment was for OLD shingyi LCD: (default LCD before sdk2.6)
                              714 ; 382  |// Engineering board regs support range [17-37].
                              715 ; 383  |//   Engineering board DC/DC support range [24-46]. 
                              716 ; 384  |//   One default contrast range [24-42] works for both.
                              717 ; 385  |// The 3 sets of contrast ranges below are updated for SDK2.6 to support either 
                              718 ; 386  |// new or old ShingYih LCDs. "File" refers to \resource\shingyih\system_lcd_init_seq.src
                              719 ; 387  |// 3/10/05 - Use one of the 2 next contrast ranges depending on which
                              720 ; 388  |// ShingYih LCD you have.  See \resources\shingyi\readme.txt 
                              721 ; 389  |// Optimal for NEW LCD with NEW file (SDK2.6 default)  
                              722 ; 390  |// G098064-41 LCD module (present on engr board revH LCD card)
                              723 ; 391  |
                              724 ; 392  |#if (defined(NEWSHINGYIH))
                              725 ; 393  |#define LCD_MAX_CONTRAST 250
                              726 ; 394  |#define LCD_MIN_CONTRAST 0
                              727 ; 395  |#else 
                              728 ; 396  |//-----
                              729 ; 397  |// Near optimal for OLD LCD with NEW file. 
                              730 ; 398  |// NOT optimal for the new lcd but pretty good. So u may use this if u want 1 build for both LCDs.
                              731 ; 399  |#define LCD_MAX_CONTRAST 250
                              732 ; 400  |#define LCD_MIN_CONTRAST 0
                              733 ; 401  |
                              734 ; 402  |//=====
                              735 ; 403  |// Optimal for OLD ShingYih LCD with OLD file (as sdk2.521)
                              736 ; 404  |// Suggest going with default new init file & values above for your LCD instead of this historic ver.
                              737 ; 405  |//LCD_MAX_CONTRAST equ 42
                              738 ; 406  |//LCD_MIN_CONTRAST equ 24 
                              739 ; 407  |
                              740 ; 408  |#endif
                              741 ; 409  |#endif
                              742 ; 410  |
                              743 ; 411  |#endif
                              744 ; 412  |
                              745 ; 413  |//////////////////////////////////////////////////////////////////////////////////
                              746 ; 414  |// The default value of the lcd contrast in % of range
                              747 ; 415  |//   the default value is used when no settings.dat is available
                              748 ; 416  |//////////////////////////////////////////////////////////////////////////////////
                              749 ; 417  |
                              750 ; 418  |#if (defined(S6B33B0A_LCD))
                              751 ; 419  |// 60% of range is default value
                              752 ; 420  |#define DEFAULT_CONTRAST 50 
                              753 ; 421  |#endif
                              754 ; 422  |
                              755 ; 423  |#if (defined(SED15XX_LCD))
                              756 ; 424  |// % of range is default value (was 60%)
                              757 ; 425  |#define DEFAULT_CONTRAST 50 
                              758 ; 426  |#endif
                              759 ; 427  |
                              760 ; 428  |
                              761 ; 429  |// percentage change per increment/decrement message (LCD_DEC_CONTRAST/LCD_INC_CONTRAST)
                              762 ; 430  |// make lower when doing calibration
                              763 ; 431  |#define LCD_STEPSIZE_CONTRAST 10  
                              764 ; 432  |
TASKING DSP2410 assembler v1.5r1 Build 138 SN 00100122
                                                                                                                                                                                                                                                       Page   4

M:ADDR CODE           CYCLES LINE SOURCELINE
                              765 ; 433  |
                              766 ; 434  |/////////////////////////////////////////////////////////////////////////////////
                              767 ; 435  |// For FFWD and RWND
                              768 ; 436  |/////////////////////////////////////////////////////////////////////////////////
                              769 ; 437  |#define SECONDS_TO_SKIP 1
                              770 ; 438  |#define SECONDS_TO_SKIP1 3
                              771 ; 439  |#define SECONDS_TO_SKIP2 6
                              772 ; 440  |// number of seconds to cause reset to begin of song for PREV push
                              773 ; 441  |#define PREV_SONG_THRESHOLD 5  
                              774 ; 442  |// number of 300 mSec periods before the numbers of seconds to skip increases
                              775 ; 443  |#define FIRST_TIME_BOUNDARY 15 
                              776 ; 444  |// number of 300 mSec periods before the numbers of seconds to skip increases
                              777 ; 445  |#define SECOND_TIME_BOUNDARY 30 
                              778 ; 446  |
                              779 ; 447  |// For audible FFW/RWD
                              780 ; 448  |#define SECONDS_TO_SKIP_FOR_3X_RATE 1
                              781 ; 449  |#define SECONDS_TO_SKIP_FOR_60X_RATE 18
                              782 ; 450  |#define SECONDS_TO_SKIP_FOR_600X_RATE 180
                              783 ; 451  |#define SECONDS_TO_SKIP_FOR_1800X_RATE 540
                              784 ; 452  |// number of 300 mSec periods before the numbers of seconds to skip increases
                              785 ; 453  |#define LEVEL1_BOUNDARY 17 
                              786 ; 454  |// number of 300 mSec periods before the numbers of seconds to skip increases
                              787 ; 455  |#define LEVEL2_BOUNDARY 33 
                              788 ; 456  |// number of 300 mSec periods before the numbers of seconds to skip increases
                              789 ; 457  |#define LEVEL3_BOUNDARY 50 
                              790 ; 458  |// Stmp00010296 Ticket #71685:  for song shorter than the min. skip size
                              791 ; 459  |// if song_time < skip_size, bCurrentSongShort=>TRUE (ignore FWD/RWD commands)
                              792 ; 460  |// Short Song Time, songs too short to play.
                              793 ; 461  |#define SHORT_SONG_TIME SECONDS_TO_SKIP         
                              794 ; 462  |
                              795 ; 463  |/////////////////////////////////////////////////////////////////////////////////
                              796 ; 464  |// MP3 Sync Values
                              797 ; 465  |/////////////////////////////////////////////////////////////////////////////////
                              798 ; 466  |// # bytes to look for sync before marking it bad
                              799 ; 467  |#define MP3_SYNC_THRESHOLD 70000 
                              800 ; 468  |// # bytes to look for sync before slowing decoder isr frequency (to let menus run)
                              801 ; 469  |#define MP3_SYNC_THRESHOLD1 10000 
                              802 ; 470  |// once we have sync'd, the isr should be called this frequently
                              803 ; 471  |#define MP3_DECODERISR_FAST 7500  
                              804 ; 472  |// if decoder is having difficulty syncing, switch isr to be called less frequently
                              805 ; 473  |#define MP3_DECODERISR_SLOW 50000 
                              806 ; 474  |
                              807 ; 475  |
                              808 ; 476  |/////////////////////////////////////////////////////////////////////////////////
                              809 ; 477  |//// Multi-Stage Volume Control Definitions
                              810 ; 478  |/////////////////////////////////////////////////////////////////////////////////
                              811 ; 479  |//// Use Multi-Stage Volume
                              812 ; 480  |#define MULTI_STAGE_VOLUME 0x1                  
                              813 ; 481  |
                              814 ; 482  |//// Master Volume definitions
                              815 ; 483  |#define MIX_MSTR_MAX_VOL 0x0
                              816 ; 484  |#define NUM_MSTR_ATT_STEPS (0x1F-MIX_MSTR_MAX_VOL)
                              817 ; 485  |
                              818 ; 486  |//// DAC-Mode definitions
                              819 ; 487  |//// Adjusts 0dB point
                              820 ; 488  |#define MIX_DAC_NOM_VOL 0x6                  
                              821 ; 489  |#define MIX_DAC_MIN_VOL 0x1F
                              822 ; 490  |// For minimum clipping: Set MIX_DAC_MAX_VOL below to match MIX_DAC_NOM_VOL value 2 lines above.
                              823 ; 491  |// For additional gain (with possible clipping): Set MIX_DAC_MAX_VOL in range below. 
                              824 ; 492  |//                                               Each integer below MIX_DAC_NOM_VOL provides 1.5 dB gain on Stmp34x0; 
                              825 ; 493  |//                                               Max gain possible: 8 step diff would provide +12dB gain.   
                              826 ; 494  |// range: [0 to MIX_DAC_NOM_VOL] (0 for loudest volume)
                              827 ; 495  |#define MIX_DAC_MAX_VOL 0x0  
                              828 ; 496  |
                              829 ; 497  |#define NUM_DAC_ATT_STEPS (MIX_DAC_MIN_VOL-MIX_DAC_NOM_VOL+1)
                              830 ; 498  |#define NUM_DAC_GAIN_STEPS (MIX_DAC_NOM_VOL-MIX_DAC_MAX_VOL)
                              831 ; 499  |#define NUM_DAC_MODE_VOL_STEPS (NUM_DAC_ATT_STEPS+NUM_MSTR_ATT_STEPS+NUM_DAC_GAIN_STEPS+1)
                              832 ; 500  |
                              833 ; 501  |//// If there is no stored volume, set to 50% of DAC-Mode max; change if DAC Mode is not the default
                              834 ; 502  |//// STMP35xx has 2dB attenuation per step so default needs a few more steps above midpoint.
                              835 ; 503  |#define DEFAULT_VOLUME ((NUM_DAC_MODE_VOL_STEPS/2)+6)         
                              836 ; 504  |
                              837 ; 505  |//// Set maximum restored volume to 75% of DAC-Mode max; change if DAC Mode is not the default
                              838 ; 506  |#define MAX_RESTORED_VOLUME ((3*NUM_DAC_MODE_VOL_STEPS)/4)   
                              839 ; 507  |
                              840 ; 508  |
                              841 ; 509  |//// Line In definitions (used for Line-In 1)
                              842 ; 510  |//// 0dB point of the Line In
                              843 ; 511  |#define MIX_LINE_NOM_VOL 0x8                  
                              844 ; 512  |//// Minimum volume of Line In
                              845 ; 513  |#define MIX_LINE_MIN_VOL 0x1F                 
                              846 ; 514  |//// Maximum volume of Line In (can adjust extra gain)
                              847 ; 515  |#define MIX_LINE_MAX_VOL 0x6                  
                              848 ; 516  |#define NUM_LINE_ATT_STEPS (MIX_LINE_MIN_VOL-MIX_LINE_NOM_VOL+1)
                              849 ; 517  |#define NUM_LINE_GAIN_STEPS (MIX_LINE_NOM_VOL-MIX_LINE_MAX_VOL)
                              850 ; 518  |#define NUM_LINE_MODE_VOL_STEPS (NUM_LINE_ATT_STEPS+NUM_MSTR_ATT_STEPS+NUM_LINE_GAIN_STEPS+1)
                              851 ; 519  |
                              852 ; 520  |//// Line In definitions (used for FM tuner with 144 pin package)
                              853 ; 521  |//// 0dB point of the Line In
                              854 ; 522  |#define MIX_FM_NOM_VOL 0x8                  
                              855 ; 523  |//// Minimum volume of Line In
                              856 ; 524  |#define MIX_FM_MIN_VOL 0x1F                 
                              857 ; 525  |//// Maximum volume of Line In (can adjust extra gain)
                              858 ; 526  |#define MIX_FM_MAX_VOL 0x6                  
                              859 ; 527  |#define NUM_FM_ATT_STEPS (MIX_FM_MIN_VOL-MIX_FM_NOM_VOL+1)
                              860 ; 528  |#define NUM_FM_GAIN_STEPS (MIX_FM_NOM_VOL-MIX_FM_MAX_VOL)
                              861 ; 529  |#define NUM_FM_MODE_VOL_STEPS (NUM_FM_ATT_STEPS+NUM_MSTR_ATT_STEPS+NUM_FM_GAIN_STEPS+1)
                              862 ; 530  |
                              863 ; 531  |/////////////////////////////////////////////////////////////////////////////////
                              864 ; 532  |//// When enabled (1), periodically checks for one of several FM state machine invalid deadlock states & recovers. 
                              865 ; 533  |//// Define as 0 to disable FM-deadlock-state checking and recovery.
                              866 ; 534  |#define FM_WATCHDOG_ENABLE 1
                              867 ; 535  |
                              868 ; 536  |#if !defined(STMP_BUILD_PLAYER)
                              869 ; 537  |////
                              870 ; 538  |////! This varible holds the lcd display state for the mtp project.
                              871 ; 539  |////
                              872 ; 540  |///
                              873 ; 541  |#include <types.h>
                              874 
                              876 
                              877 ; 1    |////////////////////////////////////////////////////////////////////////////////
                              878 ; 2    |// Copyright(C) SigmaTel, Inc. 2000-2004
                              879 ; 3    |//
                              880 ; 4    |// Filename: types.h
                              881 ; 5    |// Description: Standard data types
                              882 ; 6    |////////////////////////////////////////////////////////////////////////////////
                              883 ; 7    |
                              884 ; 8    |#ifndef _TYPES_H
                              885 ; 9    |#define _TYPES_H
                              886 ; 10   |
                              887 ; 11   |// TODO:  move this outta here!
                              888 ; 12   |#if !defined(NOERROR)
                              889 ; 13   |#define NOERROR 0
                              890 ; 14   |#define SUCCESS 0
                              891 ; 15   |#endif 
                              892 ; 16   |#if !defined(SUCCESS)
                              893 ; 17   |#define SUCCESS  0
                              894 ; 18   |#endif
                              895 ; 19   |#if !defined(ERROR)
                              896 ; 20   |#define ERROR   -1
                              897 ; 21   |#endif
                              898 ; 22   |#if !defined(FALSE)
                              899 ; 23   |#define FALSE 0
                              900 ; 24   |#endif
                              901 ; 25   |#if !defined(TRUE)
                              902 ; 26   |#define TRUE  1
                              903 ; 27   |#endif
                              904 ; 28   |
                              905 ; 29   |#if !defined(NULL)
                              906 ; 30   |#define NULL 0
                              907 ; 31   |#endif
                              908 ; 32   |
                              909 ; 33   |#define MAX_INT     0x7FFFFF
                              910 ; 34   |#define MAX_LONG    0x7FFFFFffffff
                              911 ; 35   |        // max positive unsigned long value: -1 == 0xFFFFFFffffff
                              912 ; 36   |#define MAX_ULONG   (-1) 
                              913 ; 37   |
                              914 ; 38   |#define WORD_SIZE   24              // word size in bits
                              915 ; 39   |#define BYTES_PER_WORD 3            // 8 bit bytes
                              916 ; 40   |
                              917 ; 41   |
                              918 ; 42   |#define BYTE    unsigned char       // btVarName
                              919 ; 43   |#define CHAR    signed char         // cVarName
                              920 ; 44   |#define USHORT  unsigned short      // usVarName
                              921 ; 45   |#define SHORT   unsigned short      // sVarName
                              922 ; 46   |#define WORD    unsigned int        // wVarName
                              923 ; 47   |#define INT     signed int          // iVarName
                              924 ; 48   |#define DWORD   unsigned long       // dwVarName
                              925 ; 49   |#define LONG    signed long         // lVarName
                              926 ; 50   |#define BOOL    unsigned int        // bVarName
                              927 ; 51   |#define FRACT   _fract              // frVarName
                              928 ; 52   |#define LFRACT  long _fract         // lfrVarName
                              929 ; 53   |#define CIRC    _circ               // cp<type prefix>VarName (see below)
                              930 ; 54   |#define FLOAT   float               // fVarName
                              931 ; 55   |#define DBL     double              // dVarName
                              932 ; 56   |#define ENUM    enum                // eVarName
                              933 ; 57   |#define CMX     _complex            // cmxVarName
                              934 ; 58   |typedef WORD UCS3;                   // 
                              935 ; 59   |
                              936 ; 60   |#define UINT16  unsigned short
                              937 ; 61   |#define UINT8   unsigned char   
                              938 ; 62   |#define UINT32  unsigned long
                              939 ; 63   |#define UINT64  unsigned long   // need to figure out how to do 64 bit values.  Or port exisiting code to only use 48 bit
                              940 ; 64   |#define INT64   unsigned long   // need to figure out how to do 64 bit values.  Or port exisiting code to only use 48 bit
                              941 ; 65   |#define WCHAR   UINT16
                              942 ; 66   |
                              943 ; 67   |//UINT128 is 16 bytes or 6 words
                              944 ; 68   |typedef struct UINT128_3500 {   
                              945 ; 69   |    int val[6];     
                              946 ; 70   |} UINT128_3500;
                              947 ; 71   |
                              948 ; 72   |#define UINT128   UINT128_3500
                              949 ; 73   |
                              950 ; 74   |// Little endian word packed byte strings:   
                              951 ; 75   |//      _packed BYTE bTextVarName[]="a string";  bText is a packed byte string prefix
                              952 ; 76   |// Convert to big endian words by reordering bytes from high to low using swizzle.
                              953 ; 77   |// Little endian word packed byte strings:   
                              954 ; 78   |//      _packed BYTE bTextVarName[]="a string";  bText is a packed byte string prefix
                              955 ; 79   |// Convert to big endian words by reordering bytes from high to low using swizzle.
                              956 ; 80   |
                              957 ; 81   |// Declare Memory Spaces To Use When Coding
                              958 ; 82   |// A. Sector Buffers
                              959 ; 83   |#define SECTOR_BUFFER_MEM_X _X
                              960 ; 84   |#define SECTOR_BUFFER_MEM_Y _Y
                              961 ; 85   |#define SECTOR_BUFFER_MEM SECTOR_BUFFER_MEM_X
                              962 ; 86   |typedef WORD SECTOR_BUFFER_MEM SECTOR_BUFFER;
                              963 ; 87   |typedef SECTOR_BUFFER * P_SECTOR_BUFFER;
                              964 ; 88   |// B. Media DDI Memory
                              965 ; 89   |#define MEDIA_DDI_MEM _Y
                              966 ; 90   |
                              967 ; 91   |
                              968 ; 92   |
                              969 ; 93   |// Pointers to linear structures are labeled as: p<type prefix>VarName
                              970 ; 94   |// Examples of circular pointers:
                              971 ; 95   |//    INT CIRC cpiVarName
                              972 ; 96   |//    DWORD CIRC cpdwVarName
                              973 ; 97   |
                              974 ; 98   |#define RETCODE INT                 // rcVarName
                              975 ; 99   |
                              976 ; 100  |// generic bitfield structure
                              977 ; 101  |struct Bitfield {
                              978 ; 102  |    unsigned int B0  :1;
                              979 ; 103  |    unsigned int B1  :1;
                              980 ; 104  |    unsigned int B2  :1;
                              981 ; 105  |    unsigned int B3  :1;
                              982 ; 106  |    unsigned int B4  :1;
                              983 ; 107  |    unsigned int B5  :1;
                              984 ; 108  |    unsigned int B6  :1;
                              985 ; 109  |    unsigned int B7  :1;
                              986 ; 110  |    unsigned int B8  :1;
                              987 ; 111  |    unsigned int B9  :1;
                              988 ; 112  |    unsigned int B10 :1;
                              989 ; 113  |    unsigned int B11 :1;
                              990 ; 114  |    unsigned int B12 :1;
                              991 ; 115  |    unsigned int B13 :1;
                              992 ; 116  |    unsigned int B14 :1;
                              993 ; 117  |    unsigned int B15 :1;
                              994 ; 118  |    unsigned int B16 :1;
                              995 ; 119  |    unsigned int B17 :1;
                              996 ; 120  |    unsigned int B18 :1;
                              997 ; 121  |    unsigned int B19 :1;
                              998 ; 122  |    unsigned int B20 :1;
                              999 ; 123  |    unsigned int B21 :1;
                             1000 ; 124  |    unsigned int B22 :1;
                             1001 ; 125  |    unsigned int B23 :1;
                             1002 ; 126  |};
                             1003 ; 127  |
                             1004 ; 128  |union BitInt {
                             1005 ; 129  |        struct Bitfield B;
                             1006 ; 130  |        int        I;
                             1007 ; 131  |};
                             1008 ; 132  |
                             1009 ; 133  |#define MAX_MSG_LENGTH 10
                             1010 ; 134  |struct CMessage
                             1011 ; 135  |{
                             1012 ; 136  |        unsigned int m_uLength;
                             1013 ; 137  |        unsigned int m_uMsg[MAX_MSG_LENGTH];
                             1014 ; 138  |};
                             1015 ; 139  |
                             1016 ; 140  |typedef struct {
TASKING DSP2410 assembler v1.5r1 Build 138 SN 00100122
                                                                                                                                                                                                                                                       Page   5

M:ADDR CODE           CYCLES LINE SOURCELINE
                             1017 ; 141  |    WORD m_wLength;
                             1018 ; 142  |    WORD m_wMessage;
                             1019 ; 143  |    WORD m_wParams[MAX_MSG_LENGTH];
                             1020 ; 144  |} Message;
                             1021 ; 145  |
                             1022 ; 146  |struct MessageQueueDescriptor
                             1023 ; 147  |{
                             1024 ; 148  |        int *m_pBase;
                             1025 ; 149  |        int m_iModulo;
                             1026 ; 150  |        int m_iSize;
                             1027 ; 151  |        int *m_pHead;
                             1028 ; 152  |        int *m_pTail;
                             1029 ; 153  |};
                             1030 ; 154  |
                             1031 ; 155  |struct ModuleEntry
                             1032 ; 156  |{
                             1033 ; 157  |    int m_iSignaledEventMask;
                             1034 ; 158  |    int m_iWaitEventMask;
                             1035 ; 159  |    int m_iResourceOfCode;
                             1036 ; 160  |    struct MessageQueueDescriptor *m_pMessageQueue;
                             1037 ; 161  |    int _asmfunc (*m_pProcessEntryPoint)(union WaitMask Signals,struct MessageQueueDescriptor *);
                             1038 ; 162  |    int _asmfunc (*m_pInitFunction)(struct MessageQueueDescriptor *);
                             1039 ; 163  |    int m_uTimeOutHigh;
                             1040 ; 164  |    int m_uTimeOutLow;
                             1041 ; 165  |    int _asmfunc (*m_pBackgroundFunction)(struct MessageQueueDescriptor *);
                             1042 ; 166  |};
                             1043 ; 167  |
                             1044 ; 168  |union WaitMask{
                             1045 ; 169  |    struct B{
                             1046 ; 170  |        unsigned int m_bNone     :1;
                             1047 ; 171  |        unsigned int m_bMessage  :1;
                             1048 ; 172  |        unsigned int m_bTimer    :1;
                             1049 ; 173  |        unsigned int m_bButton   :1;
                             1050 ; 174  |    } B;
                             1051 ; 175  |    int I;
                             1052 ; 176  |} ;
                             1053 ; 177  |
                             1054 ; 178  |
                             1055 ; 179  |struct Button {
                             1056 ; 180  |        WORD wButtonEvent;
                             1057 ; 181  |        WORD wUnused[MAX_MSG_LENGTH];   
                             1058 ; 182  |};
                             1059 ; 183  |
                             1060 ; 184  |struct Message {
                             1061 ; 185  |        WORD wMsgLength;
                             1062 ; 186  |        WORD wMsgCommand;
                             1063 ; 187  |        WORD wMsgParms[MAX_MSG_LENGTH-1];
                             1064 ; 188  |};
                             1065 ; 189  |
                             1066 ; 190  |union EventTypes {
                             1067 ; 191  |        struct CMessage msg;
                             1068 ; 192  |        struct Button Button ;
                             1069 ; 193  |        struct Message Message;
                             1070 ; 194  |};
                             1071 ; 195  |
                             1072 ; 196  |// next 2 used to get updater build to return correct protocol ver in scsi response.
                             1073 ; 197  |#define BUILD_TYPE_UPDATER  0x100
                             1074 ; 198  |#define BUILD_TYPE_HOSTLINK 0x101
                             1075 ; 199  |#define BUILD_TYPE_PLAYER   0x102
                             1076 ; 200  |
                             1077 ; 201  |// Resets part if RETAIL build. DEBUG build executes debug instruction to halt.
                             1078 ; 202  |#define SystemHalt() __asm(" include 'sysmacro.asm' \n error") 
                             1079 ; 203  |#define assert(x)    if(!(x)) __asm(" include 'sysmacro.asm' \n error")
                             1080 ; 204  |
                             1081 ; 205  |#if DEBUG
                             1082 ; 206  |// For DEBUG builds, DebugBuildAssert(condition) halts if condition evaluates to FALSE. 
                             1083 ; 207  |#define DebugBuildAssert(x)    if(!(x)) __asm(" debug ")
                             1084 ; 208  |#else 
                             1085 ; 209  |// For RETAIL builds, DebugBuildAssert(condition) does nothing & execution continues rather than halt or reset. 
                             1086 ; 210  |#define DebugBuildAssert(x)    
                             1087 ; 211  |#endif
                             1088 ; 212  |
                             1089 ; 213  |// Do this in your C files to make a reminder that's displayed during the build.
                             1090 ; 214  |//  #pragma asm
                             1091 ; 215  |//  WARN 'Note to builder: reminder to do this after verifying that'
                             1092 ; 216  |//  #pragma endasm
                             1093 ; 217  |
                             1094 ; 218  |
                             1095 ; 219  |#ifdef COLOR_262K
                             1096 ; 220  |#define RGB(r,g,b)    ((0x0000FC & (r)) << 10) | ((0x0000FC & (g)) << 4) | ((0x0000FC & (b)) >> 2)    //262k
                             1097 ; 221  |#elif defined(COLOR_65K)
                             1098 ; 222  |#define RGB(r,g,b)    ((0x0000F8 & (r)) << 8) | ((0x0000FC & (g)) << 3) | ((0x0000F8 & (b)) >> 3)  //65k
                             1099 ; 223  |#else
                             1100 ; 224  |#define RGB(r,g,b)       ((0x0000F0 & (r)) << 4) | (0x0000F0 & (g)) | ((0x0000F0 & (b)) >> 4)
                             1101 ; 225  |#endif
                             1102 ; 226  |    
                             1103 ; 227  |#endif // #ifndef _TYPES_H
                             1104 
                             1106 
                             1107 ; 542  |extern volatile WORD g_wActivityState;
                             1108 ; 543  |#endif // if !@def('STMP_BUILD_PLAYER')
                             1109 ; 544  |
                             1110 ; 545  |void _reentrant Init5VSense(void);
                             1111 ; 546  |void _reentrant ServiceDCDC(void);
                             1112 ; 547  |
                             1113 ; 548  |////////////////////////////////////////////////////////////////////////////
                             1114 ; 549  |//// JPEG Thumbnail Mode Setting
                             1115 ; 550  |//// number of column in thumbnail mode
                             1116 ; 551  |#define THUMBNAIL_X 2           
                             1117 ; 552  |//// number of row in  thumbnail mode
                             1118 ; 553  |#define THUMBNAIL_Y 2           
                             1119 ; 554  |//// thumbnail boundary offset x
                             1120 ; 555  |#define THUMBNAIL_X_OFFSET 4            
                             1121 ; 556  |//// thumbnail boundary offset y
                             1122 ; 557  |#define THUMBNAIL_Y_OFFSET 4            
                             1123 ; 558  |
                             1124 ; 559  |#endif // if (!@def(_PROJECT_INC))
                             1125 ; 560  |
                             1126 
                             1128 
                             1129 ; 3    |#include "stringlib.h"
                             1130 
                             1132 
                             1133 ; 1    |#ifndef STRINGLIB_H
                             1134 ; 2    |#define STRINGLIB_H
                             1135 
                             1137 
                             1138 ; 3    |_asmfunc int pack_string(UCS3 _Y * _Y pUnpacked, _packed BYTE _Y * _Y pPacked);
                             1139 ; 4    |_asmfunc int unpack_string( _packed BYTE _Y * _Y pPacked,  UCS3 _Y * _Y pUnpacked);
                             1140 ; 5    |_asmfunc int unpack_data( _packed BYTE _Y * _Y pPacked,  BYTE _Y * _Y pUnpacked, INT iCount);
                             1141 ; 6    |
                             1142 ; 7    |_asmfunc BYTE GetByteFromArrayInX( void _X * p,int n);
                             1143 ; 8    |_asmfunc void PutByteInArrayInX( void _X * p,int n, int newchar);
                             1144 ; 9    |_asmfunc BYTE GetByteFromArrayInY( void _Y * p,int n);
                             1145 ; 10   |_asmfunc void PutByteInArrayInY( void _Y * p,int n, int newchar);
                             1146 ; 11   |
                             1147 ; 12   |_asmfunc BYTE packed_get( _packed BYTE _Y * p,int n);
                             1148 ; 13   |_asmfunc void packed_set( _packed BYTE _Y * p,int n, int newchar);
                             1149 ; 14   |
                             1150 ; 15   |_asmfunc int packed_strlen( _packed BYTE _Y * _Y p);
                             1151 ; 16   |
                             1152 ; 17   |_asmfunc _packed BYTE _Y * packed_strncpy( _packed BYTE _Y * _Y pDest,_packed BYTE _Y * _Y pSrc, int iCount);
                             1153 ; 18   |_asmfunc _packed BYTE _Y * packed_strcpy ( _packed BYTE _Y * _Y pDest,_packed BYTE _Y * _Y pSrc);
                             1154 ; 19   |
                             1155 ; 20   |
                             1156 ; 21   |_asmfunc int packed_strncmp( _packed BYTE _Y * _Y pLeft,_packed BYTE _Y * _Y pRight, int iCount);
                             1157 ; 22   |_asmfunc int packed_strcmp ( _packed BYTE _Y * _Y pLeft,_packed BYTE _Y * _Y pRight);
                             1158 ; 23   |
                             1159 ; 24   |_asmfunc int packed_strncat( _packed BYTE _Y * _Y pDest,_packed BYTE _Y * _Y pSource, int iCount);
                             1160 ; 25   |_asmfunc int packed_strcat ( _packed BYTE _Y * _Y pDest,_packed BYTE _Y * _Y pSource);
                             1161 ; 26   |
                             1162 ; 27   |
                             1163 ; 28   |_asmfunc int strlen(UCS3 _Y * _Y p);
                             1164 ; 29   |
                             1165 ; 30   |_asmfunc UCS3 *strchr(UCS3 _Y * _Y pUnpacked, UCS3 CharToFind);
                             1166 ; 31   |_asmfunc UCS3 *strrchr(UCS3 _Y * _Y pUnpacked, UCS3 CharToFind);
                             1167 ; 32   |
                             1168 ; 33   |_asmfunc void strncpy(UCS3 _Y * _Y pDest, UCS3 _Y * _Y pSource, BYTE iCount);
                             1169 ; 34   |_asmfunc void strcpy(UCS3 _Y * _Y pDest, UCS3 _Y * _Y pSource);
                             1170 ; 35   |
                             1171 ; 36   |_asmfunc char *strncat(UCS3 _Y * _Y pDest, UCS3 _Y * _Y pSource, int iCount);
                             1172 ; 37   |_asmfunc char *strcat(UCS3 _Y * _Y pDest, UCS3 _Y * _Y pSource);
                             1173 ; 38   |
                             1174 ; 39   |_asmfunc int strncmp(UCS3 _Y * _Y pDest, UCS3 _Y * _Y pSource, int iCount);
                             1175 ; 40   |_asmfunc int strcmp(UCS3 _Y * _Y pDest, UCS3 _Y * _Y pSource);
                             1176 ; 41   |
                             1177 ; 42   |#endif
                             1178 
                             1180 
                             1181 ; 4    |#include "SysResourceApi.h"
                             1182 
                             1184 
                             1185 ; 1    |////////////////////////////////////////////////////////////////////////////////
                             1186 ; 2    |// Copyright(C) SigmaTel, Inc. 2002 - 2003
                             1187 ; 3    |//
                             1188 ; 4    |// File : SysResourceApi.h
                             1189 ; 5    |// Description : Structures and Functions Definitions for System Resource API
                             1190 ; 6    |////////////////////////////////////////////////////////////////////////////////
                             1191 ; 7    |
                             1192 ; 8    |#ifndef __SysResourceApi_h__
                             1193 ; 9    |#define __SysResourceApi_h__ 1
                             1194 ; 10   |
                             1195 ; 11   |#include "types.h"
                             1196 
                             1198 
                             1199 ; 1    |////////////////////////////////////////////////////////////////////////////////
                             1200 ; 2    |// Copyright(C) SigmaTel, Inc. 2000-2004
                             1201 ; 3    |//
                             1202 ; 4    |// Filename: types.h
                             1203 ; 5    |// Description: Standard data types
                             1204 ; 6    |////////////////////////////////////////////////////////////////////////////////
                             1205 ; 7    |
                             1206 ; 8    |#ifndef _TYPES_H
                             1207 ; 9    |#define _TYPES_H
                             1208 ; 10   |
                             1209 ; 11   |// TODO:  move this outta here!
                             1210 ; 12   |#if !defined(NOERROR)
                             1211 ; 13   |#define NOERROR 0
                             1212 ; 14   |#define SUCCESS 0
                             1213 ; 15   |#endif 
                             1214 ; 16   |#if !defined(SUCCESS)
                             1215 ; 17   |#define SUCCESS  0
                             1216 ; 18   |#endif
                             1217 ; 19   |#if !defined(ERROR)
                             1218 ; 20   |#define ERROR   -1
                             1219 ; 21   |#endif
                             1220 ; 22   |#if !defined(FALSE)
                             1221 ; 23   |#define FALSE 0
                             1222 ; 24   |#endif
                             1223 ; 25   |#if !defined(TRUE)
                             1224 ; 26   |#define TRUE  1
                             1225 ; 27   |#endif
                             1226 ; 28   |
                             1227 ; 29   |#if !defined(NULL)
                             1228 ; 30   |#define NULL 0
                             1229 ; 31   |#endif
                             1230 ; 32   |
                             1231 ; 33   |#define MAX_INT     0x7FFFFF
                             1232 ; 34   |#define MAX_LONG    0x7FFFFFffffff
                             1233 ; 35   |        // max positive unsigned long value: -1 == 0xFFFFFFffffff
                             1234 ; 36   |#define MAX_ULONG   (-1) 
                             1235 ; 37   |
                             1236 ; 38   |#define WORD_SIZE   24              // word size in bits
                             1237 ; 39   |#define BYTES_PER_WORD 3            // 8 bit bytes
                             1238 ; 40   |
                             1239 ; 41   |
                             1240 ; 42   |#define BYTE    unsigned char       // btVarName
                             1241 ; 43   |#define CHAR    signed char         // cVarName
                             1242 ; 44   |#define USHORT  unsigned short      // usVarName
                             1243 ; 45   |#define SHORT   unsigned short      // sVarName
                             1244 ; 46   |#define WORD    unsigned int        // wVarName
                             1245 ; 47   |#define INT     signed int          // iVarName
                             1246 ; 48   |#define DWORD   unsigned long       // dwVarName
                             1247 ; 49   |#define LONG    signed long         // lVarName
                             1248 ; 50   |#define BOOL    unsigned int        // bVarName
                             1249 ; 51   |#define FRACT   _fract              // frVarName
                             1250 ; 52   |#define LFRACT  long _fract         // lfrVarName
                             1251 ; 53   |#define CIRC    _circ               // cp<type prefix>VarName (see below)
                             1252 ; 54   |#define FLOAT   float               // fVarName
                             1253 ; 55   |#define DBL     double              // dVarName
                             1254 ; 56   |#define ENUM    enum                // eVarName
                             1255 ; 57   |#define CMX     _complex            // cmxVarName
                             1256 ; 58   |typedef WORD UCS3;                   // 
                             1257 ; 59   |
                             1258 ; 60   |#define UINT16  unsigned short
                             1259 ; 61   |#define UINT8   unsigned char   
                             1260 ; 62   |#define UINT32  unsigned long
                             1261 ; 63   |#define UINT64  unsigned long   // need to figure out how to do 64 bit values.  Or port exisiting code to only use 48 bit
                             1262 ; 64   |#define INT64   unsigned long   // need to figure out how to do 64 bit values.  Or port exisiting code to only use 48 bit
                             1263 ; 65   |#define WCHAR   UINT16
                             1264 ; 66   |
                             1265 ; 67   |//UINT128 is 16 bytes or 6 words
                             1266 ; 68   |typedef struct UINT128_3500 {   
                             1267 ; 69   |    int val[6];     
                             1268 ; 70   |} UINT128_3500;
                             1269 ; 71   |
                             1270 ; 72   |#define UINT128   UINT128_3500
                             1271 ; 73   |
                             1272 ; 74   |// Little endian word packed byte strings:   
                             1273 ; 75   |//      _packed BYTE bTextVarName[]="a string";  bText is a packed byte string prefix
                             1274 ; 76   |// Convert to big endian words by reordering bytes from high to low using swizzle.
TASKING DSP2410 assembler v1.5r1 Build 138 SN 00100122
                                                                                                                                                                                                                                                       Page   6

M:ADDR CODE           CYCLES LINE SOURCELINE
                             1275 ; 77   |// Little endian word packed byte strings:   
                             1276 ; 78   |//      _packed BYTE bTextVarName[]="a string";  bText is a packed byte string prefix
                             1277 ; 79   |// Convert to big endian words by reordering bytes from high to low using swizzle.
                             1278 ; 80   |
                             1279 ; 81   |// Declare Memory Spaces To Use When Coding
                             1280 ; 82   |// A. Sector Buffers
                             1281 ; 83   |#define SECTOR_BUFFER_MEM_X _X
                             1282 ; 84   |#define SECTOR_BUFFER_MEM_Y _Y
                             1283 ; 85   |#define SECTOR_BUFFER_MEM SECTOR_BUFFER_MEM_X
                             1284 ; 86   |typedef WORD SECTOR_BUFFER_MEM SECTOR_BUFFER;
                             1285 ; 87   |typedef SECTOR_BUFFER * P_SECTOR_BUFFER;
                             1286 ; 88   |// B. Media DDI Memory
                             1287 ; 89   |#define MEDIA_DDI_MEM _Y
                             1288 ; 90   |
                             1289 ; 91   |
                             1290 ; 92   |
                             1291 ; 93   |// Pointers to linear structures are labeled as: p<type prefix>VarName
                             1292 ; 94   |// Examples of circular pointers:
                             1293 ; 95   |//    INT CIRC cpiVarName
                             1294 ; 96   |//    DWORD CIRC cpdwVarName
                             1295 ; 97   |
                             1296 ; 98   |#define RETCODE INT                 // rcVarName
                             1297 ; 99   |
                             1298 ; 100  |// generic bitfield structure
                             1299 ; 101  |struct Bitfield {
                             1300 ; 102  |    unsigned int B0  :1;
                             1301 ; 103  |    unsigned int B1  :1;
                             1302 ; 104  |    unsigned int B2  :1;
                             1303 ; 105  |    unsigned int B3  :1;
                             1304 ; 106  |    unsigned int B4  :1;
                             1305 ; 107  |    unsigned int B5  :1;
                             1306 ; 108  |    unsigned int B6  :1;
                             1307 ; 109  |    unsigned int B7  :1;
                             1308 ; 110  |    unsigned int B8  :1;
                             1309 ; 111  |    unsigned int B9  :1;
                             1310 ; 112  |    unsigned int B10 :1;
                             1311 ; 113  |    unsigned int B11 :1;
                             1312 ; 114  |    unsigned int B12 :1;
                             1313 ; 115  |    unsigned int B13 :1;
                             1314 ; 116  |    unsigned int B14 :1;
                             1315 ; 117  |    unsigned int B15 :1;
                             1316 ; 118  |    unsigned int B16 :1;
                             1317 ; 119  |    unsigned int B17 :1;
                             1318 ; 120  |    unsigned int B18 :1;
                             1319 ; 121  |    unsigned int B19 :1;
                             1320 ; 122  |    unsigned int B20 :1;
                             1321 ; 123  |    unsigned int B21 :1;
                             1322 ; 124  |    unsigned int B22 :1;
                             1323 ; 125  |    unsigned int B23 :1;
                             1324 ; 126  |};
                             1325 ; 127  |
                             1326 ; 128  |union BitInt {
                             1327 ; 129  |        struct Bitfield B;
                             1328 ; 130  |        int        I;
                             1329 ; 131  |};
                             1330 ; 132  |
                             1331 ; 133  |#define MAX_MSG_LENGTH 10
                             1332 ; 134  |struct CMessage
                             1333 ; 135  |{
                             1334 ; 136  |        unsigned int m_uLength;
                             1335 ; 137  |        unsigned int m_uMsg[MAX_MSG_LENGTH];
                             1336 ; 138  |};
                             1337 ; 139  |
                             1338 ; 140  |typedef struct {
                             1339 ; 141  |    WORD m_wLength;
                             1340 ; 142  |    WORD m_wMessage;
                             1341 ; 143  |    WORD m_wParams[MAX_MSG_LENGTH];
                             1342 ; 144  |} Message;
                             1343 ; 145  |
                             1344 ; 146  |struct MessageQueueDescriptor
                             1345 ; 147  |{
                             1346 ; 148  |        int *m_pBase;
                             1347 ; 149  |        int m_iModulo;
                             1348 ; 150  |        int m_iSize;
                             1349 ; 151  |        int *m_pHead;
                             1350 ; 152  |        int *m_pTail;
                             1351 ; 153  |};
                             1352 ; 154  |
                             1353 ; 155  |struct ModuleEntry
                             1354 ; 156  |{
                             1355 ; 157  |    int m_iSignaledEventMask;
                             1356 ; 158  |    int m_iWaitEventMask;
                             1357 ; 159  |    int m_iResourceOfCode;
                             1358 ; 160  |    struct MessageQueueDescriptor *m_pMessageQueue;
                             1359 ; 161  |    int _asmfunc (*m_pProcessEntryPoint)(union WaitMask Signals,struct MessageQueueDescriptor *);
                             1360 ; 162  |    int _asmfunc (*m_pInitFunction)(struct MessageQueueDescriptor *);
                             1361 ; 163  |    int m_uTimeOutHigh;
                             1362 ; 164  |    int m_uTimeOutLow;
                             1363 ; 165  |    int _asmfunc (*m_pBackgroundFunction)(struct MessageQueueDescriptor *);
                             1364 ; 166  |};
                             1365 ; 167  |
                             1366 ; 168  |union WaitMask{
                             1367 ; 169  |    struct B{
                             1368 ; 170  |        unsigned int m_bNone     :1;
                             1369 ; 171  |        unsigned int m_bMessage  :1;
                             1370 ; 172  |        unsigned int m_bTimer    :1;
                             1371 ; 173  |        unsigned int m_bButton   :1;
                             1372 ; 174  |    } B;
                             1373 ; 175  |    int I;
                             1374 ; 176  |} ;
                             1375 ; 177  |
                             1376 ; 178  |
                             1377 ; 179  |struct Button {
                             1378 ; 180  |        WORD wButtonEvent;
                             1379 ; 181  |        WORD wUnused[MAX_MSG_LENGTH];   
                             1380 ; 182  |};
                             1381 ; 183  |
                             1382 ; 184  |struct Message {
                             1383 ; 185  |        WORD wMsgLength;
                             1384 ; 186  |        WORD wMsgCommand;
                             1385 ; 187  |        WORD wMsgParms[MAX_MSG_LENGTH-1];
                             1386 ; 188  |};
                             1387 ; 189  |
                             1388 ; 190  |union EventTypes {
                             1389 ; 191  |        struct CMessage msg;
                             1390 ; 192  |        struct Button Button ;
                             1391 ; 193  |        struct Message Message;
                             1392 ; 194  |};
                             1393 ; 195  |
                             1394 ; 196  |// next 2 used to get updater build to return correct protocol ver in scsi response.
                             1395 ; 197  |#define BUILD_TYPE_UPDATER  0x100
                             1396 ; 198  |#define BUILD_TYPE_HOSTLINK 0x101
                             1397 ; 199  |#define BUILD_TYPE_PLAYER   0x102
                             1398 ; 200  |
                             1399 ; 201  |// Resets part if RETAIL build. DEBUG build executes debug instruction to halt.
                             1400 ; 202  |#define SystemHalt() __asm(" include 'sysmacro.asm' \n error") 
                             1401 ; 203  |#define assert(x)    if(!(x)) __asm(" include 'sysmacro.asm' \n error")
                             1402 ; 204  |
                             1403 ; 205  |#if DEBUG
                             1404 ; 206  |// For DEBUG builds, DebugBuildAssert(condition) halts if condition evaluates to FALSE. 
                             1405 ; 207  |#define DebugBuildAssert(x)    if(!(x)) __asm(" debug ")
                             1406 ; 208  |#else 
                             1407 ; 209  |// For RETAIL builds, DebugBuildAssert(condition) does nothing & execution continues rather than halt or reset. 
                             1408 ; 210  |#define DebugBuildAssert(x)    
                             1409 ; 211  |#endif
                             1410 ; 212  |
                             1411 ; 213  |// Do this in your C files to make a reminder that's displayed during the build.
                             1412 ; 214  |//  #pragma asm
                             1413 ; 215  |//  WARN 'Note to builder: reminder to do this after verifying that'
                             1414 ; 216  |//  #pragma endasm
                             1415 ; 217  |
                             1416 ; 218  |
                             1417 ; 219  |#ifdef COLOR_262K
                             1418 ; 220  |#define RGB(r,g,b)    ((0x0000FC & (r)) << 10) | ((0x0000FC & (g)) << 4) | ((0x0000FC & (b)) >> 2)    //262k
                             1419 ; 221  |#elif defined(COLOR_65K)
                             1420 ; 222  |#define RGB(r,g,b)    ((0x0000F8 & (r)) << 8) | ((0x0000FC & (g)) << 3) | ((0x0000F8 & (b)) >> 3)  //65k
                             1421 ; 223  |#else
                             1422 ; 224  |#define RGB(r,g,b)       ((0x0000F0 & (r)) << 4) | (0x0000F0 & (g)) | ((0x0000F0 & (b)) >> 4)
                             1423 ; 225  |#endif
                             1424 ; 226  |    
                             1425 ; 227  |#endif // #ifndef _TYPES_H
                             1426 
                             1428 
                             1429 ; 12   |
                             1430 ; 13   |#define RSRC_TYPE_STRING                1
                             1431 ; 14   |#define RSRC_TYPE_DATA                  2
                             1432 ; 15   |#define RSRC_TYPE_BITMAP                3
                             1433 ; 16   |#define RSRC_TYPE_NESTED_RESOURCE       9
                             1434 ; 17   |
                             1435 ; 18   |#define MAX_NESTED_RSC      10           // Included Root Resource
                             1436 ; 19   |#define FREE_RSC_HANDLE     0xffffff    // Code for free handle
                             1437 ; 20   |
                             1438 ; 21   |#define RS_ROOT_HANDLE                      0           // Pass this handle to open
                             1439 ; 22   |                                                        // from the root.
                             1440 ; 23   |
                             1441 ; 24   |#define RSC_MAX_HANDLE_REACHED              0x800001    // No more Nested Handles free
                             1442 ; 25   |                                                        // Maximum allocated nested resource handle reached
                             1443 ; 26   |                                                        // To correct error increase the number of MAX_NESTED_RSC
                             1444 ; 27   |#define RSC_INVALID_NESTED_HANDLE           0x800002    // The Nested Resource Handle is Invalid
                             1445 ; 28   |                                                        // Handle >= MAX_NESTED_RSC 
                             1446 ; 29   |#define RSC_INVALID_NESTED_NOT_ITIALIZED    0x800003    // The Nested Resource Handle is not initialized
                             1447 ; 30   |                                                        // element RscNumber of Struct_Handle_Nested_Rsc 
                             1448 ; 31   |                                                        // is FREE_RSC_HANDLE in 
                             1449 ; 32   |#define RSC_INVALID_RSC                     0x800004    // Resource is invalid. Resource Header does not
                             1450 ; 33   |#define RSC_INVALID_MEM_SPACE               0x800005    // Memory Space for resource is invalid. Valid spaces are X, Y or P.
                             1451 ; 34   |#define RSC_ERROR_READING_RSC               0x800006
                             1452 ; 35   |
                             1453 ; 36   |#define TARGET_MEM_X                        0x800000
                             1454 ; 37   |#define TARGET_MEM_Y                        0x400000
                             1455 ; 38   |#define TARGET_MEM_L                        0x200000
                             1456 ; 39   |#define TARGET_MEM_P                        0x100000
                             1457 ; 40   |
                             1458 ; 41   |typedef struct {
                             1459 ; 42   |    WORD    wRscNumber;             // Nested resource number
                             1460 ; 43   |                                    // 0x00 = Root Resource
                             1461 ; 44   |                                    // 0xffff = Free Handle
                             1462 ; 45   |    WORD    wStartPosition;         // Start position data section (in bytes)
                             1463 ; 46   |    WORD    wCurrentPosition;       // Current position (in bytes)
                             1464 ; 47   |} Struct_Handle_Nested_Rsc, * pStruct_Handle_Nested_Rsc;
                             1465 ; 48   |
                             1466 ; 49   |RETCODE _reentrant SysOpenResource(WORD wRscNum, BYTE btHandleNestedParentRsc);
                             1467 ; 50   |RETCODE _reentrant SysCloseResource(BYTE btHandleNestedRsc);
                             1468 ; 51   |RETCODE _reentrant SysLoadResource(WORD wRscNum, BYTE btHandleNestedRsc, WORD wRscType,
                             1469 ; 52   |                        WORD *pwTargetBuffer, WORD wTargetSpace, WORD wMaxSize);
                             1470 ; 53   |RETCODE _reentrant SysResourceFileRead(BYTE btHandleNestedRsc, WORD wNumBytes, 
                             1471 ; 54   |                            WORD wTargetSpace, WORD *pwTargetBuffer);
                             1472 ; 55   |RETCODE _reentrant SysResourceFileSeek(BYTE btHandleNestedRsc, WORD wNumWords);                        
                             1473 ; 56   |WORD _reentrant SysResourceFileTell(BYTE btHandleNestedRsc);
                             1474 ; 57   |void _reentrant SysSetResourceTag(WORD wTag);
                             1475 ; 58   |                   
                             1476 ; 59   |extern WORD wResourceTag;
                             1477 ; 60   |#define SysGetResourceTag(void) (wResourceTag)
                             1478 ; 61   |
                             1479 ; 62   |extern void EnterNonReentrantSection(void);
                             1480 ; 63   |extern void LeaveNonReentrantSection(void);
                             1481 ; 64   |
                             1482 ; 65   |#endif
                             1483 
                             1485 
                             1486 ; 5    |
                             1487 ; 6    |
                             1488 ; 7    |#ifdef STMP_BUILD_PLAYER
                             1489 ; 8    |#include "sysmem.h"
                             1490 ; 9    |#include "sysequ.h"
                             1491 ; 10   |#else
                             1492 ; 11   |#include "kernel.h"
                             1493 
                             1495 
                             1496 ; 1    |///////////////////////////////////////////////////////////////////////////////
                             1497 ; 2    |///
                             1498 ; 3    |/// Filename: kernel.h
                             1499 ; 4    |/// Description: 
                             1500 ; 5    |///
                             1501 ; 6    |///
                             1502 ; 7    |/// Copyright (c) SigmaTel, Inc. Unpublished
                             1503 ; 8    |///
                             1504 ; 9    |/// SigmaTel, Inc.
                             1505 ; 10   |/// Proprietary  Confidential
                             1506 ; 11   |///
                             1507 ; 12   |/// This source code and the algorithms implemented therein constitute
                             1508 ; 13   |/// confidential information and may comprise trade secrets of SigmaTel, Inc.
                             1509 ; 14   |/// or its associates, and any use thereof is subject to the terms and
                             1510 ; 15   |/// conditions of the Confidential Disclosure Agreement pursuant to which this
                             1511 ; 16   |/// source code was originally received.
                             1512 ; 17   |///
                             1513 ; 18   |///////////////////////////////////////////////////////////////////////////////
                             1514 ; 19   |#ifndef __KERNEL_H
                             1515 ; 20   |#define __KERNEL_H
                             1516 ; 21   |
                             1517 ; 22   |
                             1518 ; 23   |#include "types.h"
                             1519 
                             1521 
                             1522 ; 1    |////////////////////////////////////////////////////////////////////////////////
                             1523 ; 2    |// Copyright(C) SigmaTel, Inc. 2000-2004
                             1524 ; 3    |//
                             1525 ; 4    |// Filename: types.h
                             1526 ; 5    |// Description: Standard data types
                             1527 ; 6    |////////////////////////////////////////////////////////////////////////////////
                             1528 ; 7    |
                             1529 ; 8    |#ifndef _TYPES_H
TASKING DSP2410 assembler v1.5r1 Build 138 SN 00100122
                                                                                                                                                                                                                                                       Page   7

M:ADDR CODE           CYCLES LINE SOURCELINE
                             1530 ; 9    |#define _TYPES_H
                             1531 ; 10   |
                             1532 ; 11   |// TODO:  move this outta here!
                             1533 ; 12   |#if !defined(NOERROR)
                             1534 ; 13   |#define NOERROR 0
                             1535 ; 14   |#define SUCCESS 0
                             1536 ; 15   |#endif 
                             1537 ; 16   |#if !defined(SUCCESS)
                             1538 ; 17   |#define SUCCESS  0
                             1539 ; 18   |#endif
                             1540 ; 19   |#if !defined(ERROR)
                             1541 ; 20   |#define ERROR   -1
                             1542 ; 21   |#endif
                             1543 ; 22   |#if !defined(FALSE)
                             1544 ; 23   |#define FALSE 0
                             1545 ; 24   |#endif
                             1546 ; 25   |#if !defined(TRUE)
                             1547 ; 26   |#define TRUE  1
                             1548 ; 27   |#endif
                             1549 ; 28   |
                             1550 ; 29   |#if !defined(NULL)
                             1551 ; 30   |#define NULL 0
                             1552 ; 31   |#endif
                             1553 ; 32   |
                             1554 ; 33   |#define MAX_INT     0x7FFFFF
                             1555 ; 34   |#define MAX_LONG    0x7FFFFFffffff
                             1556 ; 35   |        // max positive unsigned long value: -1 == 0xFFFFFFffffff
                             1557 ; 36   |#define MAX_ULONG   (-1) 
                             1558 ; 37   |
                             1559 ; 38   |#define WORD_SIZE   24              // word size in bits
                             1560 ; 39   |#define BYTES_PER_WORD 3            // 8 bit bytes
                             1561 ; 40   |
                             1562 ; 41   |
                             1563 ; 42   |#define BYTE    unsigned char       // btVarName
                             1564 ; 43   |#define CHAR    signed char         // cVarName
                             1565 ; 44   |#define USHORT  unsigned short      // usVarName
                             1566 ; 45   |#define SHORT   unsigned short      // sVarName
                             1567 ; 46   |#define WORD    unsigned int        // wVarName
                             1568 ; 47   |#define INT     signed int          // iVarName
                             1569 ; 48   |#define DWORD   unsigned long       // dwVarName
                             1570 ; 49   |#define LONG    signed long         // lVarName
                             1571 ; 50   |#define BOOL    unsigned int        // bVarName
                             1572 ; 51   |#define FRACT   _fract              // frVarName
                             1573 ; 52   |#define LFRACT  long _fract         // lfrVarName
                             1574 ; 53   |#define CIRC    _circ               // cp<type prefix>VarName (see below)
                             1575 ; 54   |#define FLOAT   float               // fVarName
                             1576 ; 55   |#define DBL     double              // dVarName
                             1577 ; 56   |#define ENUM    enum                // eVarName
                             1578 ; 57   |#define CMX     _complex            // cmxVarName
                             1579 ; 58   |typedef WORD UCS3;                   // 
                             1580 ; 59   |
                             1581 ; 60   |#define UINT16  unsigned short
                             1582 ; 61   |#define UINT8   unsigned char   
                             1583 ; 62   |#define UINT32  unsigned long
                             1584 ; 63   |#define UINT64  unsigned long   // need to figure out how to do 64 bit values.  Or port exisiting code to only use 48 bit
                             1585 ; 64   |#define INT64   unsigned long   // need to figure out how to do 64 bit values.  Or port exisiting code to only use 48 bit
                             1586 ; 65   |#define WCHAR   UINT16
                             1587 ; 66   |
                             1588 ; 67   |//UINT128 is 16 bytes or 6 words
                             1589 ; 68   |typedef struct UINT128_3500 {   
                             1590 ; 69   |    int val[6];     
                             1591 ; 70   |} UINT128_3500;
                             1592 ; 71   |
                             1593 ; 72   |#define UINT128   UINT128_3500
                             1594 ; 73   |
                             1595 ; 74   |// Little endian word packed byte strings:   
                             1596 ; 75   |//      _packed BYTE bTextVarName[]="a string";  bText is a packed byte string prefix
                             1597 ; 76   |// Convert to big endian words by reordering bytes from high to low using swizzle.
                             1598 ; 77   |// Little endian word packed byte strings:   
                             1599 ; 78   |//      _packed BYTE bTextVarName[]="a string";  bText is a packed byte string prefix
                             1600 ; 79   |// Convert to big endian words by reordering bytes from high to low using swizzle.
                             1601 ; 80   |
                             1602 ; 81   |// Declare Memory Spaces To Use When Coding
                             1603 ; 82   |// A. Sector Buffers
                             1604 ; 83   |#define SECTOR_BUFFER_MEM_X _X
                             1605 ; 84   |#define SECTOR_BUFFER_MEM_Y _Y
                             1606 ; 85   |#define SECTOR_BUFFER_MEM SECTOR_BUFFER_MEM_X
                             1607 ; 86   |typedef WORD SECTOR_BUFFER_MEM SECTOR_BUFFER;
                             1608 ; 87   |typedef SECTOR_BUFFER * P_SECTOR_BUFFER;
                             1609 ; 88   |// B. Media DDI Memory
                             1610 ; 89   |#define MEDIA_DDI_MEM _Y
                             1611 ; 90   |
                             1612 ; 91   |
                             1613 ; 92   |
                             1614 ; 93   |// Pointers to linear structures are labeled as: p<type prefix>VarName
                             1615 ; 94   |// Examples of circular pointers:
                             1616 ; 95   |//    INT CIRC cpiVarName
                             1617 ; 96   |//    DWORD CIRC cpdwVarName
                             1618 ; 97   |
                             1619 ; 98   |#define RETCODE INT                 // rcVarName
                             1620 ; 99   |
                             1621 ; 100  |// generic bitfield structure
                             1622 ; 101  |struct Bitfield {
                             1623 ; 102  |    unsigned int B0  :1;
                             1624 ; 103  |    unsigned int B1  :1;
                             1625 ; 104  |    unsigned int B2  :1;
                             1626 ; 105  |    unsigned int B3  :1;
                             1627 ; 106  |    unsigned int B4  :1;
                             1628 ; 107  |    unsigned int B5  :1;
                             1629 ; 108  |    unsigned int B6  :1;
                             1630 ; 109  |    unsigned int B7  :1;
                             1631 ; 110  |    unsigned int B8  :1;
                             1632 ; 111  |    unsigned int B9  :1;
                             1633 ; 112  |    unsigned int B10 :1;
                             1634 ; 113  |    unsigned int B11 :1;
                             1635 ; 114  |    unsigned int B12 :1;
                             1636 ; 115  |    unsigned int B13 :1;
                             1637 ; 116  |    unsigned int B14 :1;
                             1638 ; 117  |    unsigned int B15 :1;
                             1639 ; 118  |    unsigned int B16 :1;
                             1640 ; 119  |    unsigned int B17 :1;
                             1641 ; 120  |    unsigned int B18 :1;
                             1642 ; 121  |    unsigned int B19 :1;
                             1643 ; 122  |    unsigned int B20 :1;
                             1644 ; 123  |    unsigned int B21 :1;
                             1645 ; 124  |    unsigned int B22 :1;
                             1646 ; 125  |    unsigned int B23 :1;
                             1647 ; 126  |};
                             1648 ; 127  |
                             1649 ; 128  |union BitInt {
                             1650 ; 129  |        struct Bitfield B;
                             1651 ; 130  |        int        I;
                             1652 ; 131  |};
                             1653 ; 132  |
                             1654 ; 133  |#define MAX_MSG_LENGTH 10
                             1655 ; 134  |struct CMessage
                             1656 ; 135  |{
                             1657 ; 136  |        unsigned int m_uLength;
                             1658 ; 137  |        unsigned int m_uMsg[MAX_MSG_LENGTH];
                             1659 ; 138  |};
                             1660 ; 139  |
                             1661 ; 140  |typedef struct {
                             1662 ; 141  |    WORD m_wLength;
                             1663 ; 142  |    WORD m_wMessage;
                             1664 ; 143  |    WORD m_wParams[MAX_MSG_LENGTH];
                             1665 ; 144  |} Message;
                             1666 ; 145  |
                             1667 ; 146  |struct MessageQueueDescriptor
                             1668 ; 147  |{
                             1669 ; 148  |        int *m_pBase;
                             1670 ; 149  |        int m_iModulo;
                             1671 ; 150  |        int m_iSize;
                             1672 ; 151  |        int *m_pHead;
                             1673 ; 152  |        int *m_pTail;
                             1674 ; 153  |};
                             1675 ; 154  |
                             1676 ; 155  |struct ModuleEntry
                             1677 ; 156  |{
                             1678 ; 157  |    int m_iSignaledEventMask;
                             1679 ; 158  |    int m_iWaitEventMask;
                             1680 ; 159  |    int m_iResourceOfCode;
                             1681 ; 160  |    struct MessageQueueDescriptor *m_pMessageQueue;
                             1682 ; 161  |    int _asmfunc (*m_pProcessEntryPoint)(union WaitMask Signals,struct MessageQueueDescriptor *);
                             1683 ; 162  |    int _asmfunc (*m_pInitFunction)(struct MessageQueueDescriptor *);
                             1684 ; 163  |    int m_uTimeOutHigh;
                             1685 ; 164  |    int m_uTimeOutLow;
                             1686 ; 165  |    int _asmfunc (*m_pBackgroundFunction)(struct MessageQueueDescriptor *);
                             1687 ; 166  |};
                             1688 ; 167  |
                             1689 ; 168  |union WaitMask{
                             1690 ; 169  |    struct B{
                             1691 ; 170  |        unsigned int m_bNone     :1;
                             1692 ; 171  |        unsigned int m_bMessage  :1;
                             1693 ; 172  |        unsigned int m_bTimer    :1;
                             1694 ; 173  |        unsigned int m_bButton   :1;
                             1695 ; 174  |    } B;
                             1696 ; 175  |    int I;
                             1697 ; 176  |} ;
                             1698 ; 177  |
                             1699 ; 178  |
                             1700 ; 179  |struct Button {
                             1701 ; 180  |        WORD wButtonEvent;
                             1702 ; 181  |        WORD wUnused[MAX_MSG_LENGTH];   
                             1703 ; 182  |};
                             1704 ; 183  |
                             1705 ; 184  |struct Message {
                             1706 ; 185  |        WORD wMsgLength;
                             1707 ; 186  |        WORD wMsgCommand;
                             1708 ; 187  |        WORD wMsgParms[MAX_MSG_LENGTH-1];
                             1709 ; 188  |};
                             1710 ; 189  |
                             1711 ; 190  |union EventTypes {
                             1712 ; 191  |        struct CMessage msg;
                             1713 ; 192  |        struct Button Button ;
                             1714 ; 193  |        struct Message Message;
                             1715 ; 194  |};
                             1716 ; 195  |
                             1717 ; 196  |// next 2 used to get updater build to return correct protocol ver in scsi response.
                             1718 ; 197  |#define BUILD_TYPE_UPDATER  0x100
                             1719 ; 198  |#define BUILD_TYPE_HOSTLINK 0x101
                             1720 ; 199  |#define BUILD_TYPE_PLAYER   0x102
                             1721 ; 200  |
                             1722 ; 201  |// Resets part if RETAIL build. DEBUG build executes debug instruction to halt.
                             1723 ; 202  |#define SystemHalt() __asm(" include 'sysmacro.asm' \n error") 
                             1724 ; 203  |#define assert(x)    if(!(x)) __asm(" include 'sysmacro.asm' \n error")
                             1725 ; 204  |
                             1726 ; 205  |#if DEBUG
                             1727 ; 206  |// For DEBUG builds, DebugBuildAssert(condition) halts if condition evaluates to FALSE. 
                             1728 ; 207  |#define DebugBuildAssert(x)    if(!(x)) __asm(" debug ")
                             1729 ; 208  |#else 
                             1730 ; 209  |// For RETAIL builds, DebugBuildAssert(condition) does nothing & execution continues rather than halt or reset. 
                             1731 ; 210  |#define DebugBuildAssert(x)    
                             1732 ; 211  |#endif
                             1733 ; 212  |
                             1734 ; 213  |// Do this in your C files to make a reminder that's displayed during the build.
                             1735 ; 214  |//  #pragma asm
                             1736 ; 215  |//  WARN 'Note to builder: reminder to do this after verifying that'
                             1737 ; 216  |//  #pragma endasm
                             1738 ; 217  |
                             1739 ; 218  |
                             1740 ; 219  |#ifdef COLOR_262K
                             1741 ; 220  |#define RGB(r,g,b)    ((0x0000FC & (r)) << 10) | ((0x0000FC & (g)) << 4) | ((0x0000FC & (b)) >> 2)    //262k
                             1742 ; 221  |#elif defined(COLOR_65K)
                             1743 ; 222  |#define RGB(r,g,b)    ((0x0000F8 & (r)) << 8) | ((0x0000FC & (g)) << 3) | ((0x0000F8 & (b)) >> 3)  //65k
                             1744 ; 223  |#else
                             1745 ; 224  |#define RGB(r,g,b)       ((0x0000F0 & (r)) << 4) | (0x0000F0 & (g)) | ((0x0000F0 & (b)) >> 4)
                             1746 ; 225  |#endif
                             1747 ; 226  |    
                             1748 ; 227  |#endif // #ifndef _TYPES_H
                             1749 
                             1751 
                             1752 ; 24   |#include "gettime.h"
                             1753 
                             1755 
                             1756 ; 1    |#ifndef __TIME_H
                             1757 ; 2    |#define __TIME_H
                             1758 ; 3    |
                             1759 ; 4    |_callee_save LONG GetTime(void);
                             1760 ; 5    |
                             1761 ; 6    |#endif
                             1762 
                             1764 
                             1765 ; 25   |#include "sysirq.h"
                             1766 
                             1768 
                             1769 ; 1    |////////////////////////////////////////////////////////////////////////////////
                             1770 ; 2    |// Copyright(C) SigmaTel, Inc. 2000-2001
                             1771 ; 3    |//
                             1772 ; 4    |// Filename: sysirq.h
                             1773 ; 5    |// Description: 
                             1774 ; 6    |////////////////////////////////////////////////////////////////////////////////
                             1775 ; 7    |
                             1776 ; 8    |#ifndef _SYSIRQ_H
                             1777 ; 9    |#define _SYSIRQ_H
                             1778 ; 10   |
                             1779 ; 11   |///////////////////////////////////////////////////////////////////////////////
                             1780 ; 12   |// Defs
                             1781 ; 13   |///////////////////////////////////////////////////////////////////////////////
                             1782 ; 14   |
                             1783 ; 15   |#define     INTERRUPTS_UNMASK_ALL   0x000000
                             1784 ; 16   |
TASKING DSP2410 assembler v1.5r1 Build 138 SN 00100122
                                                                                                                                                                                                                                                       Page   8

M:ADDR CODE           CYCLES LINE SOURCELINE
                             1785 ; 17   |///////////////////////////////////////////////////////////////////////////////
                             1786 ; 18   |// Structure definitions
                             1787 ; 19   |///////////////////////////////////////////////////////////////////////////////
                             1788 ; 20   |
                             1789 ; 21   |///////////////////////////////////////////////////////////////////////////////
                             1790 ; 22   |// Prototypes
                             1791 ; 23   |///////////////////////////////////////////////////////////////////////////////
                             1792 ; 24   |
                             1793 ; 25   |WORD _reentrant SysMaskAllInterrupts(void);
                             1794 ; 26   |void _reentrant SysUnMaskAllInterrupts(WORD wLevel);
                             1795 ; 27   |WORD _reentrant SysGetIrqLevel(void);
                             1796 ; 28   |RETCODE _reentrant SysSetIrqLevel(WORD wIrqLevel);
                             1797 ; 29   |
                             1798 ; 30   |#endif // #ifndef _SYSIRQ_H
                             1799 
                             1801 
                             1802 ; 26   |#include "icoll.h"
                             1803 
                             1805 
                             1806 ; 1    |////////////////////////////////////////////////////////////////////////////////
                             1807 ; 2    |// Copyright(C) SigmaTel, Inc. 2002
                             1808 ; 3    |//
                             1809 ; 4    |// Filename: icoll.h
                             1810 ; 5    |// Description: 
                             1811 ; 6    |////////////////////////////////////////////////////////////////////////////////
                             1812 ; 7    |
                             1813 ; 8    |#ifndef _ICOLL_H
                             1814 ; 9    |#define _ICOLL_H
                             1815 ; 10   |
                             1816 ; 11   |///////////////////////////////////////////////////////////////////////////////
                             1817 ; 12   |// Defs
                             1818 ; 13   |///////////////////////////////////////////////////////////////////////////////
                             1819 ; 14   |                                                                                          
                             1820 ; 15   |#define ICOLL_SOURCE_DAC_REFILL                                 (DWORD)0             
                             1821 ; 16   |#define ICOLL_SOURCE_DAC_UNDERFLOW                              (DWORD)1             
                             1822 ; 17   |#define ICOLL_SOURCE_ADC_REFILL                                 (DWORD)2             
                             1823 ; 18   |#define ICOLL_SOURCE_ADC_OVERFLOW                               (DWORD)3             
                             1824 ; 19   |#define ICOLL_SOURCE_FLASH_DONE                                 (DWORD)4              
                             1825 ; 20   |#define ICOLL_SOURCE_COMPACTFLASH_CARD_IRQ                      (DWORD)5              
                             1826 ; 21   |#define ICOLL_SOURCE_SMARTMEDIA_TIMEOUT                         (DWORD)6              
                             1827 ; 22   |#define ICOLL_SOURCE_SMARTMEDIA_INTERFACE_INVALID_PROGRAMMING   (DWORD)7              
                             1828 ; 23   |#define ICOLL_SOURCE_COMPACTFLASH_NO_CARD                       (DWORD)8               
                             1829 ; 24   |#define ICOLL_SOURCE_COMPACTFLASH_STATUS_CHANGE                 (DWORD)9               
                             1830 ; 25   |#define ICOLL_SOURCE_GPIO_0                                     (DWORD)10               
                             1831 ; 26   |#define ICOLL_SOURCE_GPIO_1                                     (DWORD)11               
                             1832 ; 27   |#define ICOLL_SOURCE_GPIO_2                                     (DWORD)12                
                             1833 ; 28   |#define ICOLL_SOURCE_TIMER_0                                    (DWORD)13                
                             1834 ; 29   |#define ICOLL_SOURCE_TIMER_1                                    (DWORD)14                
                             1835 ; 30   |#define ICOLL_SOURCE_TIMER_2                                    (DWORD)15                
                             1836 ; 31   |#define ICOLL_SOURCE_TIMER_3                                    (DWORD)16                 
                             1837 ; 32   |#define ICOLL_SOURCE_GPIO_3                                     (DWORD)17                 
                             1838 ; 33   |#define ICOLL_SOURCE_SDRAM                                      (DWORD)18                 
                             1839 ; 34   |#define ICOLL_SOURCE_CDI                                        (DWORD)19                 
                             1840 ; 35   |
                             1841 ; 36   |#if (defined(DEVICE_3410) || defined(DEVICE_3310))
                             1842 ; 37   |
                             1843 ; 38   |#define ICOLL_SOURCE_USB_SOF                                    (DWORD)20                  
                             1844 ; 39   |#define ICOLL_SOURCE_USB_SET_INTERFACE_REQUEST                  (DWORD)21                  
                             1845 ; 40   |#define ICOLL_SOURCE_USB_HOST_RESET                             (DWORD)22                  
                             1846 ; 41   |#define ICOLL_SOURCE_USB_ENDPOINT_START                         (DWORD)23
                             1847 ; 42   |#define ICOLL_SOURCE_USB_ENDPOINT_0                             (DWORD)23                  
                             1848 ; 43   |#define ICOLL_SOURCE_USB_ENDPOINT_1                             (DWORD)24                  
                             1849 ; 44   |#define ICOLL_SOURCE_USB_ENDPOINT_2                             (DWORD)25                  
                             1850 ; 45   |#define ICOLL_SOURCE_USB_ENDPOINT_3                             (DWORD)26                  
                             1851 ; 46   |#define ICOLL_SOURCE_USB_ENDPOINT_4                             (DWORD)27                  
                             1852 ; 47   |#define ICOLL_SOURCE_USB_ENDPOINT_5                             (DWORD)28                    
                             1853 ; 48   |#define ICOLL_SOURCE_USB_ENDPOINT_6                             (DWORD)29                    
                             1854 ; 49   |#define ICOLL_SOURCE_USB_ENDPOINT_7                             (DWORD)30                    
                             1855 ; 50   |
                             1856 ; 51   |#else
                             1857 ; 52   |
                             1858 ; 53   |#define ICOLL_SOURCE_VDD_5V_CONNECTED                           (DWORD)20                  
                             1859 ; 54   |#define ICOLL_SOURCE_USB_CONTROLLER                             (DWORD)21                  
                             1860 ; 55   |#define ICOLL_SOURCE_USB_WAKEUP                                 (DWORD)22                  
                             1861 ; 56   |#define ICOLL_SOURCE_VDD_5V_DISCONNECTED                        (DWORD)23
                             1862 ; 57   |#define ICOLL_SOURCE_ESPI                                       (DWORD)24                  
                             1863 ; 58   |#define ICOLL_SOURCE_FILCO                                      (DWORD)25                  
                             1864 ; 59   |#define ICOLL_SOURCE_LRADC1                                     (DWORD)26                  
                             1865 ; 60   |#define ICOLL_SOURCE_RTC_ALARM                                  (DWORD)27                  
                             1866 ; 61   |#define ICOLL_SOURCE_LRADC2                                     (DWORD)28                  
                             1867 ; 62   |#define ICOLL_SOURCE_FLASH_ECC                                  (DWORD)29                    
                             1868 ; 63   |
                             1869 ; 64   |#endif
                             1870 ; 65   |
                             1871 ; 66   |#define ICOLL_SOURCE_CDSYNC                                     (DWORD)31                    
                             1872 ; 67   |#define ICOLL_SOURCE_CDSYNC_EXCEPTION                           (DWORD)32                     
                             1873 ; 68   |#define ICOLL_SOURCE_REED_SOLOMON                               (DWORD)33
                             1874 ; 69   |#define ICOLL_END_OF_TRUE_SOURCES                                ICOLL_SOURCE_REED_SOLOMON
                             1875 ; 70   |// The rest of these "sources" are not really ICOLL sources.  They are not
                             1876 ; 71   |//  routed through the ICOLL but are included here to make interrupt abstraction
                             1877 ; 72   |//  as simple as possible.  The ICOLL functions special-case these.
                             1878 ; 73   |#define ICOLL_SOURCE_I2C_RX_READY                               (DWORD)34
                             1879 ; 74   |#define ICOLL_SOURCE_I2C_RX_OVERFLOW                            (DWORD)35
                             1880 ; 75   |#define ICOLL_SOURCE_I2C_TX_EMPTY                               (DWORD)36
                             1881 ; 76   |#define ICOLL_SOURCE_I2C_TX_UNDERFLOW                           (DWORD)37
                             1882 ; 77   |#define ICOLL_SOURCE_SPI_COMPLETE                               (DWORD)38
                             1883 ; 78   |#define ICOLL_SOURCE_I2S_RX_OVERFLOW                            (DWORD)39
                             1884 ; 79   |#define ICOLL_SOURCE_I2S_TX_UNDERFLOW                           (DWORD)40
                             1885 ; 80   |#define ICOLL_SOURCE_I2S_RX_READY                               (DWORD)41
                             1886 ; 81   |#define ICOLL_SOURCE_I2S_TX_EMPTY                               (DWORD)42
                             1887 ; 82   |#define ICOLL_SOURCE_HARDWARE_RESET                             (DWORD)43
                             1888 ; 83   |#define ICOLL_SOURCE_STACK_ERROR                                (DWORD)44
                             1889 ; 84   |#define ICOLL_SOURCE_TRACE                                      (DWORD)45
                             1890 ; 85   |#define ICOLL_SOURCE_SWI                                        (DWORD)46
                             1891 ; 86   |#define ICOLL_SOURCE_IRQA                                       (DWORD)47
                             1892 ; 87   |#define ICOLL_SOURCE_BROWNOUT                                   (DWORD)48
                             1893 ; 88   |#define ICOLL_SOURCE_ILLEGAL_INSTRUCTION                        (DWORD)49
                             1894 ; 89   |#define ICOLL_SOURCE_END                                        ICOLL_SOURCE_ILLEGAL_INSTRUCTION
                             1895 ; 90   |#define ICOLL_NUM_SOURCES                                       ICOLL_SOURCE_END+1
                             1896 ; 91   |
                             1897 ; 92   |#define ICOLL_ICLENABLE_REG_0_LAST_SRC                          (DWORD)23
                             1898 ; 93   |
                             1899 ; 94   |#define ICOLL_PRIORITY_000              0x000000
                             1900 ; 95   |#define ICOLL_PRIORITY_001              0x000001
                             1901 ; 96   |#define ICOLL_PRIORITY_010              0x000002
                             1902 ; 97   |#define ICOLL_PRIORITY_011              0x000003
                             1903 ; 98   |#define ICOLL_PRIORITY_100              0x000004
                             1904 ; 99   |#define ICOLL_PRIORITY_101              0x000005
                             1905 ; 100  |#define ICOLL_PRIORITY_110              0x000006
                             1906 ; 101  |#define ICOLL_PRIORITY_111              0x000007
                             1907 ; 102  |
                             1908 ; 103  |#define ICOLL_STEERING_IVL1             0x000000
                             1909 ; 104  |#define ICOLL_STEERING_IVL2             0x000001
                             1910 ; 105  |#define ICOLL_STEERING_IVL3             0x000002
                             1911 ; 106  |#define ICOLL_STEERING_IVL6             0x000003
                             1912 ; 107  |
                             1913 ; 108  |///////////////////////////////////////////////////////////////////////////////
                             1914 ; 109  |// ERRORS
                             1915 ; 110  |///////////////////////////////////////////////////////////////////////////////
                             1916 ; 111  |                                                                                          
                             1917 ; 112  |#define ICOLL_ERROR_INVALID_SOURCE              (RETCODE)0x000001
                             1918 ; 113  |
                             1919 ; 114  |///////////////////////////////////////////////////////////////////////////////
                             1920 ; 115  |// Structure definitions
                             1921 ; 116  |///////////////////////////////////////////////////////////////////////////////
                             1922 ; 117  |
                             1923 ; 118  |typedef void (*ISR_VECTOR)(void);
                             1924 ; 119  |
                             1925 ; 120  |typedef struct
                             1926 ; 121  |{
                             1927 ; 122  |    WORD wSource;
                             1928 ; 123  |    WORD wPriority;
                             1929 ; 124  |    WORD wSteering;
                             1930 ; 125  |} ICOLL_ELEMENT;
                             1931 ; 126  |
                             1932 ; 127  |///////////////////////////////////////////////////////////////////////////////
                             1933 ; 128  |// Prototypes
                             1934 ; 129  |///////////////////////////////////////////////////////////////////////////////
                             1935 ; 130  |
                             1936 ; 131  |void _reentrant IcollShutDown(void);
                             1937 ; 132  |RETCODE _reentrant IcollEnable(DWORD dwSource);
                             1938 ; 133  |RETCODE _reentrant IcollDisable(DWORD dwSource);
                             1939 ; 134  |BOOL _reentrant IcollGetStatus(DWORD dwSource);
                             1940 ; 135  |RETCODE _reentrant IcollSetPriority(DWORD dwSource, WORD wPriority);
                             1941 ; 136  |RETCODE _reentrant IcollSetSteering(DWORD dwSource, WORD wSteering);
                             1942 
                             1947 
                             1948 ; 137  |RETCODE _reentrant IcollInstallIsrVector(ISR_VECTOR pISR, WORD wSource);
                             1949 ; 138  |void _asmfunc IcollResetVectorTable(void);
                             1950 ; 139  |#endif // #ifndef _ICOLL_H
                             1951 
                             1953 
                             1954 ; 27   |
                             1955 ; 28   |#ifndef SYS_MAX_MSG_PARAMS
                             1956 ; 29   |#define SYS_MAX_MSG_PARAMS 10
                             1957 ; 30   |#endif
                             1958 ; 31   |
                             1959 ; 32   |#ifndef MAX_REGIONS
                             1960 ; 33   |#define MAX_REGIONS 5
                             1961 ; 34   |#endif 
                             1962 ; 35   |
                             1963 ; 36   |#define TIMEOUT_IMMEDIATE 0
                             1964 ; 37   |
                             1965 ; 38   |struct TaskEntryStruct;
                             1966 ; 39   |
                             1967 ; 40   |union SyncObjectStruct;
                             1968 ; 41   |
                             1969 ; 42   |
                             1970 ; 43   |// JCP - Already defined in types.h
                             1971 ; 44   |
                             1972 ; 45   |//typedef struct {
                             1973 ; 46   |//    WORD m_wLength;
                             1974 ; 47   |//    WORD m_wMessage;
                             1975 ; 48   |//    WORD m_wParams[SYS_MAX_MSG_PARAMS];
                             1976 ; 49   |//} Message;
                             1977 ; 50   |
                             1978 ; 51   |typedef struct {
                             1979 ; 52   |    _circ WORD    *m_pHead;
                             1980 ; 53   |    _circ WORD    *m_pTail;
                             1981 ; 54   |} CircularBufferDescriptor;
                             1982 ; 55   |
                             1983 ; 56   |typedef struct MemoryRegionStruct {
                             1984 ; 57   |    WORD m_wResourceLoaded;
                             1985 ; 58   |    _P INT *m_StartAddress;
                             1986 ; 59   |    _P INT *m_EndAddress;
                             1987 ; 60   |} MemoryRegion;
                             1988 
                             1995 
                             1996 ; 61   |
                             1997 ; 62   |
                             1998 ; 63   |typedef struct TaskEntryStruct{
                             1999 ; 64   |    CircularBufferDescriptor *m_pMessageQueue;
                             2000 ; 65   |    void   *m_pWaitingOnPtr;                                //points to either an object or a queue we're waiting on.
                             2001 ; 66   |    WORD    m_wWaitingOnWord;
                             2002 ; 67   |    WORD    m_wState;                                       //The state is used to indicate what the task is waiting on.
                             2003 ; 68   |    WORD   *m_pStackPointer;
                             2004 ; 69   |    WORD    m_wTaskID;                                      //The kernel does not use this for any purpose.   This is set by the developer
                             2005 ; 70   |                                                            //  and returned by SysGetTaskID() for use by functions that are required to 
                             2006 ; 71   |                                                            //  be task aware.
                             2007 ; 72   |    long    m_lTimeout;                                     //This is in absolute time (can compare directly to the current system time
                             2008 ; 73   |    WORD    m_wRegionResources[MAX_REGIONS];                //a snapshot of the requirements of the task in terms of which resources are loaded
                             2009 ; 74   |    WORD    m_wPriority;                                    
                             2010 ; 75   |    WORD   *m_pInitialStackPointer;                         //only used at init time
                             2011 ; 76   |    WORD    m_wStackSize;
                             2012 ; 77   |    _reentrant void   (*m_pEntryPoint)(void);               //only used at init time
                             2013 ; 78   |} TaskEntry;
                             2014 
                             2039 
                             2040 ; 79   |
                             2041 ; 80   |typedef union SyncObjectStruct {
                             2042 ; 81   |    TaskEntry   *m_pOwner;
                             2043 ; 82   |    struct
                             2044 ; 83   |    {
                             2045 ; 84   |    int          m_iOwner :16;
                             2046 ; 85   |    int          m_iCount : 8;
                             2047 ; 86   |    } counter;
                             2048 ; 87   |} SyncObject;
                             2049 ; 88   |
                             2050 ; 89   |typedef WORD SignalGroup;
                             2051 ; 90   |
                             2052 ; 91   |
                             2053 ; 92   |typedef struct {
                             2054 ; 93   |    WORD    m_wMessageType;
                             2055 ; 94   |    CircularBufferDescriptor    *m_pDestination;
                             2056 ; 95   |}  RoutingEntry;
                             2057 
                             2062 
                             2063 ; 96   |
                             2064 ; 97   |extern RoutingEntry g_RoutingTable[];
                             2065 ; 98   |extern TaskEntry *g_TaskList[];
                             2066 
                             2074 
                             2075 ; 99   |extern MemoryRegion *g_RegionTable[];
                             2076 ; 100  |
                             2077 ; 101  |//Time Releated Functions
                             2078 ; 102  |_reentrant WORD SysWait(INT wTimeout);
                             2079 ; 103  |
                             2080 ; 104  |//Task Related Functions
                             2081 ; 105  |_reentrant WORD SysGetTaskID(void);
                             2082 ; 106  |
                             2083 ; 107  |//Message related functions
TASKING DSP2410 assembler v1.5r1 Build 138 SN 00100122
                                                                                                                                                                                                                                                       Page   9

M:ADDR CODE           CYCLES LINE SOURCELINE
                             2084 ; 108  |_asmfunc WORD SysWaitOnMessage(INT wTimeout, Message *pMsg);
                             2085 
                             2092 
                             2093 ; 109  |_asmfunc WORD SysPeekMessage(CircularBufferDescriptor *pQueue, Message *pMsg);
                             2094 ; 110  |_reentrant WORD SysPostMessage(WORD wLength, ...);
                             2095 ; 111  |_reentrant WORD SysPostMessageWait(INT wTimeout, WORD wLength, ...);
                             2096 ; 112  |
                             2097 ; 113  |//maybe this is too much functionality?
                             2098 ; 114  |_asmfunc WORD SysWaitOnBoth(WORD wTimeout, SyncObject *pObject, Message *pMsg);
                             2099 
                             2111 
                             2112 ; 115  |
                             2113 ; 116  |//SyncObject Related functions
                             2114 ; 117  |_asmfunc WORD SysWaitOnObject(INT wTimeout, SyncObject *pObject);
                             2115 ; 118  |_asmfunc WORD SysAssignObject(SyncObject *pObject, TaskEntry *pTaskID);
                             2116 ; 119  |_reentrant void SysReleaseObject(SyncObject *pObject);
                             2117 ; 120  |_reentrant void ISRReleaseObject(SyncObject *pObject);
                             2118 ; 121  |
                             2119 ; 122  |//Queue Related Functions
                             2120 ; 123  |_asmfunc WORD SysWaitOnQueue(INT wTimeout,CircularBufferDescriptor *pQueue, INT wSizeToBeFree);
                             2121 ; 124  |
                             2122 ; 125  |//Event Related Functions
                             2123 ; 126  |_asmfunc WORD SysWaitOnSignal(INT wTimeout, void * pSignalGroup, int iSignal);
                             2124 
                             2126 
                             2127 ; 127  |_asmfunc void SysSignal(SignalGroup *pSignalGroup, int iSignal);
                             2128 ; 128  |
                             2129 ; 129  |//ISR function
                             2130 ; 130  |
                             2131 ; 131  |//SysCallFunctions
                             2132 ; 132  |int _asmfunc exSysCallFunction_v(void);
                             2133 ; 133  |int _asmfunc exSysCallFunction_i(int);
                             2134 ; 134  |int _asmfunc exSysCallFunction_ii(int, int);
                             2135 ; 135  |int _asmfunc exSysCallFunction_iii(int, int, int);
                             2136 ; 136  |int _asmfunc SysCallFunction(WORD * RESOURCE,int _reentrant (int,int,int*),  int, int, int *);
                             2137 ; 137  |#define SysCallFunction(rsrc,func,a,b,p) SysCallFunction((void*)rsrc,(func),(a),(b),(p))
                             2138 ; 138  |
                             2139 ; 139  |void _asmfunc v_SysCallFunction_v(WORD * RESOURCE,void _reentrant (void));
                             2140 ; 140  |#define v_SysCallFunction_v(rsrc,func) v_SysCallFunction_v((void*)rsrc,(func))
                             2141 ; 141  |
                             2142 ; 142  |void _asmfunc SysCallFunction_i(WORD * RESOURCE,void _reentrant (int),int);
                             2143 ; 143  |#define SysCallFunction_i(rsrc,func,a,b,p) SysCallFunction_i((void*)rsrc,(func),(a),(b),(p))
                             2144 ; 144  |
                             2145 ; 145  |int _asmfunc SysCallFunction_L(void* RESOURCE,int _reentrant (long,long,int*),  long, long, int *);
                             2146 ; 146  |
                             2147 ; 147  |int _asmfunc i_SysCallFunction_i(WORD * RESOURCE,int _reentrant (int), int);
                             2148 ; 148  |
                             2149 ; 149  |int _asmfunc i_SysCallFunction_iipp(WORD * RESOURCE,int _reentrant (int,int,int*,int*),  int, int, int *, int *);
                             2150 ; 150  |
                             2151 ; 151  |int _asmfunc i_SysCallFunction_iiip(WORD * RESOURCE,int _reentrant (int,int,int,int*),  int, int, int, int *);
                             2152 ; 152  |
                             2153 ; 153  |int _asmfunc fSysCallFunction(WORD * RESOURCE,int _reentrant (int,int,int*),  int, int, int *);
                             2154 ; 154  |
                             2155 ; 155  |
                             2156 ; 156  |//These values are return values, and also values that are set in the TaskEntry.m_wState to indicate what the task
                             2157 ; 157  |//is waiting on.
                             2158 ; 158  |#define EVENT_TIMEOUT   0
                             2159 ; 159  |#define EVENT_MESSAGE   1
                             2160 ; 160  |#define EVENT_OBJECT    2
                             2161 ; 161  |#define EVENT_QUEUE     4
                             2162 ; 162  |#define EVENT_SIGNAL    5
                             2163 ; 163  |#define EVENT_RELEASING_OBJECT2 6
                             2164 ; 164  |#define EVENT_RELEASING_OBJECT1 7
                             2165 ; 165  |
                             2166 ; 166  |
                             2167 ; 167  |//this is the owner that a SyncObject should be assigned to if a task it going to wait on a completion of the interrupt. 
                             2168 ; 168  |#define ISR_OWNER  ((TaskEntry*)(0xffff))
                             2169 ; 169  |#define KERNEL_OWNER  ((TaskEntry*)(0))
                             2170 ; 170  |
                             2171 ; 171  |
                             2172 ; 172  |#ifdef INSTRUMENT_ENABLE
                             2173 ; 173  |#include <regsgpio.h>
                             2174 ; 174  |
                             2175 ; 175  |//
                             2176 ; 176  |// Define the bit positions in the GPIO registers used for signalling.
                             2177 ; 177  |//
                             2178 ; 178  |#define GPIO_24     B0
                             2179 ; 179  |#define GPIO_36     B12
                             2180 ; 180  |#define GPIO_37     B13
                             2181 ; 181  |#define GPIO_38     B14
                             2182 ; 182  |#define GPIO_39     B15
                             2183 ; 183  |#define GPIO_42     B18
                             2184 ; 184  |#define GPIO_46     B22
                             2185 ; 185  |#define GPIO_47     B23
                             2186 ; 186  |
                             2187 ; 187  |//=============================================================================
                             2188 ; 188  |// SysSignalEvent
                             2189 ; 189  |//-----------------------------------------------------------------------------
                             2190 ; 190  |//! This macro allows code to set a gpio event that can be measured outside the
                             2191 ; 191  |//! part.
                             2192 ; 192  |//! \param wGPIONumber 
                             2193 ; 193  |//!     This should be one of the Macros defined above, and indicates which 
                             2194 ; 194  |//!     GPIO will be set.
                             2195 ; 195  |//!
                             2196 ; 196  |//! \return
                             2197 ; 197  |//!     None. 
                             2198 ; 198  |//!
                             2199 ; 199  |//=============================================================================
                             2200 ; 200  |#define SysSignalEvent(wGPIONumber)         \ 
                             2201 ; 201  |{                                           \ 
                             2202 ; 202  |    HW_GP1DOR.B.##wGPIONumber = 1;          \ 
                             2203 ; 203  |}
                             2204 ; 204  |
                             2205 ; 205  |//=============================================================================
                             2206 ; 206  |// SysClearEvent
                             2207 ; 207  |//-----------------------------------------------------------------------------
                             2208 ; 208  |//! This macro allows code to clear a gpio event that can be measured outside 
                             2209 ; 209  |//! the part.
                             2210 ; 210  |//! \param wGPIONumber 
                             2211 ; 211  |//!     This should be one of the Macros defined above, and indicates which 
                             2212 ; 212  |//!     GPIO will be set.
                             2213 ; 213  |//!
                             2214 ; 214  |//! \return
                             2215 ; 215  |//!     None. 
                             2216 ; 216  |//!
                             2217 ; 217  |//=============================================================================
                             2218 ; 218  |#define SysClearEvent(wGPIONumber)          \ 
                             2219 ; 219  |{                                           \ 
                             2220 ; 220  |    HW_GP1DOR.B.##wGPIONumber = 0;          \ 
                             2221 ; 221  |}
                             2222 ; 222  |
                             2223 ; 223  |//=============================================================================
                             2224 ; 224  |// SysEnableEvent
                             2225 ; 225  |//-----------------------------------------------------------------------------
                             2226 ; 226  |//! This macro must be called by code before using the SysSetEvent or 
                             2227 ; 227  |//! SysClearEvent so that the GPIOs are set up correctly.
                             2228 ; 228  |//!
                             2229 ; 229  |//! \param wGPIONumber 
                             2230 ; 230  |//!     This should be one of the Macros defined above, and indicates which 
                             2231 ; 231  |//!     GPIO will be set.
                             2232 ; 232  |//!
                             2233 ; 233  |//! \return
                             2234 ; 234  |//!     None. 
                             2235 ; 235  |//!
                             2236 ; 236  |//=============================================================================
                             2237 ; 237  |#define SysEnableEvent(wGPIONumber)         \ 
                             2238 ; 238  |{                                           \ 
                             2239 ; 239  |    HW_GP1DOER.B.##wGPIONumber=1;           \ 
                             2240 ; 240  |    HW_GP1DOR.B.##wGPIONumber=0;            \ 
                             2241 ; 241  |    HW_GP1ENR.B.##wGPIONumber=1;            \ 
                             2242 ; 242  |    HW_GP1PWR.B.##wGPIONumber=1;            \ 
                             2243 ; 243  |}
                             2244 ; 244  |#else // INSTRUMENT_ENABLE
                             2245 ; 245  |#define SysSignalEvent(wGPIONumber)
                             2246 ; 246  |#define SysClearEvent(wGPIONumber)
                             2247 ; 247  |#define SysEnableEvent(wGPIONumber)
                             2248 ; 248  |#endif // INSTRUMENT_ENABLE
                             2249 ; 249  |    
                             2250 ; 250  |#endif
                             2251 
                             2253 
                             2254 ; 12   |#include "system.h"
                             2255 
                             2257 
                             2258 ; 1    |#ifndef __SYSTEM_H
                             2259 ; 2    |#define __SYSTEM_H
                             2260 ; 3    |
                             2261 ; 4    |#include "project.h"
                             2262 
                             2264 
                             2265 ; 1    |/////////////////////////////////////////////////////////////////////////////////
                             2266 ; 2    |//  Copyright(C) SigmaTel, Inc. 2000-2004
                             2267 ; 3    |//  Filename: project.inc
                             2268 ; 4    |//  Description: 
                             2269 ; 5    |/////////////////////////////////////////////////////////////////////////////////
                             2270 ; 6    |
                             2271 ; 7    |#if (!defined(_PROJECT_INC))
                             2272 ; 8    |#define _PROJECT_INC 1
                             2273 ; 9    |
                             2274 ; 10   |#if defined(STMP_BUILD_PLAYER)
                             2275 ; 11   |#include "hwequ.h"
                             2276 ; 12   |#else 
                             2277 ; 13   |//include "regscodec.inc"
                             2278 ; 14   |#endif
                             2279 ; 15   |
                             2280 ; 16   |//////////////////////////////////////////////////////////////////////////////////
                             2281 ; 17   |// Uncomment next define to allow player boot if you have stfm1000 macro enabled (defaults ON) & 
                             2282 ; 18   |// your board crystal is not able to output nominal voltage range. Used in player main.asm. STMP00012148
                             2283 ; 19   |// Defining this will result in lower battery life (price of using a lower quality crystal). 
                             2284 ; 20   |// Those that want to save battery life and have good crystals that meet our HW team's specs can 
                             2285 ; 21   |// comment out this line to reduce crystal bias current and so battery current in player mode.  
                             2286 ; 22   |#define SUPPORT_MARGINAL_XTALS 1
                             2287 ; 23   |
                             2288 ; 24   |/////////////////////////////////////////////////////////////////////////////////
                             2289 ; 25   |// BOOT SPEED CONFIG & ASSOCIATED BATTERY VOLTAGE CHECK ENABLE
                             2290 ; 26   |/////////////////////////////////////////////////////////////////////////////////
                             2291 ; 27   |// Users can enable one of ATTEMPT_FAST_BOOT or FASTEST boot or neither project define below by defining
                             2292 ; 28   |// values as 0 or 1, else it defaults to the boot speed used in previous SDKs.
                             2293 ; 29   |#define ATTEMPT_FAST_BOOT 1
                             2294 ; 30   |#define ATTEMPT_FASTEST_BOOT 0   
                             2295 ; 31   |// Changing this define to 0 removes Vbat threshholding & unconditionally gives fast boot config above- 
                             2296 ; 32   |// disabling this check is suggested for profiling if you want to try to tweak down threshholds by maybe 50mV.
                             2297 ; 33   |// Also the tests should clear the fast boot config defines to link & boot at normal speed.
                             2298 ; 34   |#define SPEED_BOOT_BATTERY_CHECK 1
                             2299 ; 35   |
                             2300 ; 36   |/////////////////////////////////////////////////////////////////////////////////
                             2301 ; 37   |// MEDIA DEFINITIONS
                             2302 ; 38   |/////////////////////////////////////////////////////////////////////////////////
                             2303 ; 39   |
                             2304 ; 40   |/////////////////////////////////////////////////////////////////////////////////
                             2305 ; 41   |// MNAND - Number of chips forming the internal physical device (i.e. # of NANDs)
                             2306 ; 42   |#if defined(NAND1)
                             2307 ; 43   |#define SM_INTERNAL_CHIPS 1
                             2308 ; 44   |#else 
                             2309 ; 45   |#if defined(NAND2)
                             2310 ; 46   |#define SM_INTERNAL_CHIPS 2
                             2311 ; 47   |#else 
                             2312 ; 48   |#if defined(NAND3)
                             2313 ; 49   |#define SM_INTERNAL_CHIPS 3
                             2314 ; 50   |#else 
                             2315 ; 51   |#if defined(NAND4)
                             2316 ; 52   |#define SM_INTERNAL_CHIPS 4
                             2317 ; 53   |#else 
                             2318 ; 54   |#define SM_INTERNAL_CHIPS 1
                             2319 ; 55   |#endif
                             2320 ; 56   |#endif
                             2321 ; 57   |#endif
                             2322 ; 58   |#endif
                             2323 ; 59   |
                             2324 ; 60   |/////////////////////////////////////////////////////////////////////////////////
                             2325 ; 61   |// If SMARTMEDIA_DETECT_ACTIVE_HIGH is defined:
                             2326 ; 62   |//   SmartMedia will be detected as inserted if the GPIO pin reads 1 and removed if it reads 0.  
                             2327 ; 63   |// If SMARTMEDIA_DETECT_ACTIVE_HIGH is not defined ** comment out next line **
                             2328 ; 64   |//   SmartMedia will be detected as inserted if the GPIO pin reads 0 and removed if it reads 1.
                             2329 ; 65   |//*** comment out if active high ****
                             2330 ; 66   |//SMARTMEDIA_DETECT_ACTIVE_HIGH  equ     1
                             2331 ; 67   |
                             2332 ; 68   |#if defined(SMEDIA)
                             2333 ; 69   |#define NUM_REMOVABLE_MEDIA 1
                             2334 ; 70   |#define NUM_SM_EXTERNAL 1
                             2335 ; 71   |#define MMC_MAX_PHYSICAL_DEVICES 0
                             2336 ; 72   |#define SM_MAX_LOGICAL_DEVICES 2
                             2337 ; 73   |#else 
                             2338 ; 74   |#if defined(MMC)
                             2339 ; 75   |#define NUM_REMOVABLE_MEDIA 1
                             2340 ; 76   |#define NUM_SM_EXTERNAL 0
                             2341 ; 77   |#define MMC_MAX_PHYSICAL_DEVICES 1
                             2342 ; 78   |#define SM_MAX_LOGICAL_DEVICES 1
                             2343 ; 79   |#else 
                             2344 ; 80   |#define NUM_REMOVABLE_MEDIA 0
                             2345 ; 81   |#define NUM_SM_EXTERNAL 0
                             2346 ; 82   |#define MMC_MAX_PHYSICAL_DEVICES 0
                             2347 ; 83   |#define SM_MAX_LOGICAL_DEVICES 1
                             2348 ; 84   |#endif
                             2349 ; 85   |#endif
                             2350 ; 86   |
                             2351 ; 87   |/////////////////////////////////////////////////////////////////////////////////
                             2352 ; 88   |// Mass Storage Class definitions
                             2353 ; 89   |/////////////////////////////////////////////////////////////////////////////////
                             2354 ; 90   |// Set to 0 if Composite Device build is desired.    
                             2355 ; 91   |#define MULTI_LUN_BUILD 1   
TASKING DSP2410 assembler v1.5r1 Build 138 SN 00100122
                                                                                                                                                                                                                                                       Page  10

M:ADDR CODE           CYCLES LINE SOURCELINE
                             2356 ; 92   |
                             2357 ; 93   |////////////////////////////////////////////////////////////////////////////////
                             2358 ; 94   |//  SCSI
                             2359 ; 95   |#if (MULTI_LUN_BUILD==0)
                             2360 ; 96   |  #if (NUM_REMOVABLE_MEDIA == 1)
                             2361 ; 97   |    #define SCSI_NUM_TARGETS                        2
                             2362 ; 98   |    #define SCSI_DEVICE_NUM_LUNS_DEV_0              1
                             2363 ; 99   |    #define SCSI_DEVICE_NUM_LUNS_DEV_1              1
                             2364 ; 100  |  #else
                             2365 ; 101  |    #define SCSI_NUM_TARGETS                        1
                             2366 ; 102  |    #define SCSI_DEVICE_NUM_LUNS_DEV_0              1
                             2367 ; 103  |  #endif
                             2368 ; 104  |#else
                             2369 ; 105  |    #define SCSI_NUM_TARGETS                        1
                             2370 ; 106  |  #if (NUM_REMOVABLE_MEDIA == 1)
                             2371 ; 107  |    #define SCSI_DEVICE_NUM_LUNS_DEV_0              2
                             2372 ; 108  |  #else
                             2373 ; 109  |    #define SCSI_DEVICE_NUM_LUNS_DEV_0              1  
                             2374 ; 110  |  #endif
                             2375 ; 111  |#endif
                             2376 ; 112  |
                             2377 ; 113  |
                             2378 ; 114  |#define USBMSC_NUM_DEVICES                      SCSI_NUM_TARGETS
                             2379 ; 115  |
                             2380 ; 116  |
                             2381 ; 117  |////////////////////////////////////////////////////////////////////////////////
                             2382 ; 118  |// Define number of logical medias and drives for three builds (MTP, USBMSC, and Player)
                             2383 ; 119  |////////////////////////////////////////////////////////////////////////////////
                             2384 ; 120  |#ifdef MMC
                             2385 ; 121  |#ifdef MTP_BUILD
                             2386 ; 122  |// --------------------
                             2387 ; 123  |// MTP and MMC
                             2388 ; 124  |// --------------------
                             2389 ; 125  |#define NUM_LOGICAL_MEDIA       2
                             2390 ; 126  |#define NUM_LOGICAL_DRIVES      8
                             2391 ; 127  |#else  // ifndef MTP_BUILD
                             2392 ; 128  |#ifdef STMP_BUILD_PLAYER
                             2393 ; 129  |// --------------------
                             2394 ; 130  |// Player and MMC
                             2395 ; 131  |// --------------------
                             2396 ; 132  |#else
                             2397 ; 133  |// --------------------
                             2398 ; 134  |// USBMSC and MMC
                             2399 ; 135  |// --------------------
                             2400 ; 136  |#define NUM_LOGICAL_MEDIA       3
                             2401 ; 137  |#define NUM_LOGICAL_DRIVES      8
                             2402 ; 138  |#endif // ifdef STMP_BUILD_PLAYER
                             2403 ; 139  |#endif // ifdef MTP_BUILD
                             2404 ; 140  |#else  // ifndef MMC
                             2405 ; 141  |#ifdef MTP_BUILD
                             2406 ; 142  |// --------------------
                             2407 ; 143  |// MTP and NAND only
                             2408 ; 144  |// --------------------
                             2409 ; 145  |#define NUM_LOGICAL_MEDIA       1
                             2410 ; 146  |#define NUM_LOGICAL_DRIVES      7
                             2411 ; 147  |#else  // ifndef MTP_BUILD
                             2412 ; 148  |#ifdef STMP_BUILD_PLAYER
                             2413 ; 149  |// --------------------
                             2414 ; 150  |// Player and NAND only
                             2415 ; 151  |// --------------------
                             2416 ; 152  |#else
                             2417 ; 153  |// --------------------
                             2418 ; 154  |// USBMSC and NAND only
                             2419 ; 155  |// --------------------
                             2420 ; 156  |#define NUM_LOGICAL_MEDIA       2
                             2421 ; 157  |#define NUM_LOGICAL_DRIVES      7
                             2422 ; 158  |#endif // ifdef STMP_BUILD_PLAYER
                             2423 ; 159  |#endif // ifdef MTP_BUILD
                             2424 ; 160  |#endif // ifdef MMC 
                             2425 ; 161  |
                             2426 ; 162  |// If we are in an MTP build then we don't use as many transfers buffers.
                             2427 ; 163  |#if (defined(MTP_BUILD))
                             2428 ; 164  |#define MAX_USB_TRANSFERS_QUEUED 16
                             2429 ; 165  |
                             2430 ; 166  |////!
                             2431 ; 167  |////! This varible holds the watchdog count for the store flush.
                             2432 ; 168  |////!
                             2433 ; 169  |///
                             2434 ; 170  |#include <types.h>
                             2435 ; 171  |extern volatile INT g_StoreWatchDogCount;
                             2436 ; 172  |extern const INT g_StoreWatchDogTimeout;
                             2437 ; 173  |#endif
                             2438 ; 174  |
                             2439 ; 175  |////////////////////////////////////////////////////////////////////////////////
                             2440 ; 176  |// These are needed here for Mass Storage Class
                             2441 ; 177  |// Needs to be cleaned up
                             2442 ; 178  |////////////////////////////////////////////////////////////////////////////////
                             2443 ; 179  |#if (!defined(STMP_BUILD_PLAYER))
                             2444 ; 180  |#define SCRATCH_USER_Y_SIZE 512
                             2445 ; 181  |#define SCRATCH_USER_X_SIZE 512
                             2446 ; 182  |
                             2447 ; 183  |#define BROWNOUT_LEVEL1_DETECTED                0x000001
                             2448 ; 184  |
                             2449 ; 185  |#endif
                             2450 ; 186  |
                             2451 ; 187  |
                             2452 ; 188  |/////////////////////////////////////////////////////////////////////////////////
                             2453 ; 189  |// SmartMedia/NAND defs
                             2454 ; 190  |#define SM_MAX_PHYSICAL_DEVICES SM_INTERNAL_CHIPS+NUM_SM_EXTERNAL
                             2455 ; 191  |#define SM_REMOVABLE_DEVICE_NUM SM_INTERNAL_CHIPS
                             2456 ; 192  |
                             2457 ; 193  |/////////////////////////////////////////////////////////////////////////////////
                             2458 ; 194  |// Sysloadresources defs
                             2459 ; 195  |#define SM_MAX_RESOURCE_DEVICES SM_INTERNAL_CHIPS+NUM_SM_EXTERNAL
                             2460 ; 196  |
                             2461 ; 197  |/////////////////////////////////////////////////////////////////////////////////
                             2462 ; 198  |// MMC defs
                             2463 ; 199  |#define MMC_MAX_PARTITIONS 1
                             2464 ; 200  |#define MMC_MAX_LOGICAL_DEVICES MMC_MAX_PHYSICAL_DEVICES*MMC_MAX_PARTITIONS
                             2465 ; 201  |
                             2466 ; 202  |/////////////////////////////////////////////////////////////////////////////////
                             2467 ; 203  |// SPI defs
                             2468 ; 204  |#define SPI_MAX_DEVICES MMC_MAX_PHYSICAL_DEVICES
                             2469 ; 205  |
                             2470 ; 206  |/////////////////////////////////////////////////////////////////////////////////
                             2471 ; 207  |// Global media defs
                             2472 ; 208  |#define MAX_PHYSICAL_DEVICES SM_MAX_PHYSICAL_DEVICES+MMC_MAX_PHYSICAL_DEVICES
                             2473 ; 209  |#define MAX_LOGICAL_DEVICES SM_MAX_LOGICAL_DEVICES+MMC_MAX_LOGICAL_DEVICES
                             2474 ; 210  |
                             2475 ; 211  |/////////////////////////////////////////////////////////////////////////////////
                             2476 ; 212  |// DO NOT CHANGE THESE!!!
                             2477 ; 213  |#define SM_MAX_PARTITIONS 4
                             2478 ; 214  |#define MAX_HANDLES 2
                             2479 ; 215  |/////////////////////////////////////////////////////////////////////////////////
                             2480 ; 216  |
                             2481 ; 217  |
                             2482 ; 218  |/////////////////////////////////////////////////////////////////////////////////
                             2483 ; 219  |// Battery LRADC Values 
                             2484 ; 220  |/////////////////////////////////////////////////////////////////////////////////
                             2485 ; 221  |// brownout trip point in mV (moved by RS)
                             2486 ; 222  |// BATT_SAFETY_MARGIN:  percentage value used by:
                             2487 ; 223  |//   * SysSaveSettings to determine if enough power is left to attempt a settings save. 
                             2488 ; 224  |//   * Recorder to conditionally prevent the start or continuation of 
                             2489 ; 225  |//     audio recording to media.
                             2490 ; 226  |#define BATT_SAFETY_MARGIN 10
                             2491 ; 227  |
                             2492 ; 228  |//; player resource drive refresh allowed only when battery usable % is above this value. 
                             2493 ; 229  |//; 50% of usable range [0.9V to 1.5V] is around 1.2V This is the safe target alkaline voltage to do a refresh.
                             2494 ; 230  |//; LIION will also require 50% which will work but that could be changed in the future. 
                             2495 ; 231  |//RESOURCE_REFRESH_MIN_BATT_PCT equ 50
                             2496 ; 232  |
                             2497 ; 233  |// stmp00005071 adds these for mp3 encode stability at low battery per battery type & mmc presence.
                             2498 ; 234  |
                             2499 ; 235  |//// Vbat threshholds empirically tuned by profiling max bat current for 3 HW cases: 
                             2500 ; 236  |//// 1 GigaByte MMC, NAND flash only, & LiIon Buck mode. See voicemenu pre-encode Vbat check.
                             2501 ; 237  |#if (!defined(CLCD))
                             2502 ; 238  |#define MP3_ENC_MMC_MIN_V_BAT_MV 1100
                             2503 ; 239  |#define MP3_ENC_NANDONLY_MIN_V_BAT_MV 1000
                             2504 ; 240  |#else 
                             2505 ; 241  |#define MP3_ENC_MMC_MIN_V_BAT_MV 1250
                             2506 ; 242  |#define MP3_ENC_NANDONLY_MIN_V_BAT_MV 1150
                             2507 ; 243  |#endif
                             2508 ; 244  |#define MP3_ENC_BUCKMODE_MIN_V_BAT_MV 3300
                             2509 ; 245  |
                             2510 ; 246  |// These Vbat use-range-percentages are derived to correspond with target battery 
                             2511 ; 247  |// voltages of 1.10V for MMC, 1.0V for nand only (alkaline or nimh), and 3.3V for any LiIon.
                             2512 ; 248  |// See mp3 encoder overlay.
                             2513 ; 249  |#define MP3_ENC_MMC_MIN_V_BAT_RANGE_PCT 33
                             2514 ; 250  |#define MP3_ENC_NANDONLY_MIN_V_BAT_RANGE_PCT 17
                             2515 ; 251  |#define MP3_ENC_BUCKMODE_MIN_V_BAT_RANGE_PCT 25
                             2516 ; 252  |
                             2517 ; 253  |/////////////////////////////////////////////////////////////////////////////////
                             2518 ; 254  |// Voice recording filenames
                             2519 ; 255  |// number of digits in filename Vxxx.wav
                             2520 ; 256  |/////////////////////////////////////////////////////////////////////////////////
                             2521 ; 257  |#define DIGITS_IN_VOICE_FILENAME 3   
                             2522 ; 258  |
                             2523 ; 259  |/////////////////////////////////////////////////////////////////////////////////
                             2524 ; 260  |// Mic Bias: Set this enable to 1 to internally generate mic bias voltage. 
                             2525 ; 261  |// Also below, must configure internal resistor value and pin to use for DC bias. 
                             2526 ; 262  |// Can set to 0 to disable internally generated mic bias voltage at pin lradc1/2.
                             2527 ; 263  |#if defined(DEVICE_3500)
                             2528 ; 264  |#define ENABLE_INTERNALLY_GENERATED_MICBIAS 1 
                             2529 ; 265  |// MIC BIAS circuit source selection: use Low Resolution ADC pin 2 or 1 to bias mic. 
                             2530 ; 266  |// Per your layout: select LRADC 2 or 1 below 
                             2531 ; 267  |//   (pin LRADC 2 for 35xx cpu card revB, LRADC 1 for 35xx cpu card revC, ref schematics, & demo player)
                             2532 ; 268  |#define LRADC_NUM_FOR_MIC_BIAS 1 
                             2533 ; 269  |// Sets internal mic bias R to value 2, 4, or 8 (in kOhms).
                             2534 ; 270  |#define MICBIAS_CONFIGURED_RESISTOR_KOHMS 8
                             2535 ; 271  |
                             2536 ; 272  |// Allows mic bias to settle before sampling. This delay currently unused. For rec btn when bias not yet ready.
                             2537 ; 273  |#define REC_BTN_INTERNAL_MIC_BIAS_SETTLING_DELAY_MS 400 
                             2538 ; 274  |// Option always keeps bias enabled after mainmenu init. This allows for start pop prevention if you use rec button from outside voice menu.
                             2539 ; 275  |// This selection costs 1 mWatt but gains the desired low record button to sampling latency in the record-from-music-menu use-case.
                             2540 ; 276  |#define KEEP_MIC_BIAS_ENABLED 0
                             2541 ; 277  |
                             2542 ; 278  |#else 
                             2543 ; 279  |// STMP3410
                             2544 ; 280  |#define ENABLE_INTERNALLY_GENERATED_MICBIAS 0
                             2545 ; 281  |#define LRADC_NUM_FOR_MIC_BIAS 1 
                             2546 ; 282  |#define MICBIAS_CONFIGURED_RESISTOR_KOHMS 2
                             2547 ; 283  |#endif
                             2548 ; 284  |
                             2549 ; 285  |/////////////////////////////////////////////////////////////////////////////////
                             2550 ; 286  |// Number of available soft timers
                             2551 ; 287  |/////////////////////////////////////////////////////////////////////////////////
                             2552 ; 288  |#if defined(SYNC_LYRICS)
                             2553 ; 289  |#define SOFT_TIMERS 10
                             2554 ; 290  |#else 
                             2555 ; 291  |#if defined(JPEG_DECODER)
                             2556 ; 292  |#define SOFT_TIMERS 10
                             2557 ; 293  |#else 
                             2558 ; 294  |#define SOFT_TIMERS 9
                             2559 ; 295  |#endif
                             2560 ; 296  |#endif
                             2561 ; 297  |
                             2562 ; 298  |/////////////////////////////////////////////////////////////////////////////////
                             2563 ; 299  |//  sizes
                             2564 ; 300  |/////////////////////////////////////////////////////////////////////////////////
                             2565 ; 301  |#if defined(MMC)
                             2566 ; 302  |#if defined(USE_PLAYLIST5)
                             2567 ; 303  |#define MENU_STACK_SIZE 1500
                             2568 ; 304  |#else 
                             2569 ; 305  |#define MENU_STACK_SIZE 1250
                             2570 ; 306  |#endif //if @def('USE_PLAYLIST5')
                             2571 ; 307  |#else 
                             2572 ; 308  |#if defined(USE_PLAYLIST5)
                             2573 ; 309  |#define MENU_STACK_SIZE 1500
                             2574 ; 310  |#else 
                             2575 ; 311  |#define MENU_STACK_SIZE 1250
                             2576 ; 312  |#endif //if @def('USE_PLAYLIST5')
                             2577 ; 313  |#endif //if @def('MMC')
                             2578 ; 314  |
                             2579 ; 315  |// NOTE: SDK2.6 USED 550 FOR NEXT LINE, BUT SDK3.0BETA USED 750. Should it be ifdef MTP 750 else 550 for other builds? TOVERIFY. MYALLOC
                             2580 ; 316  |// 
                             2581 ; 317  |#define STACK_L1_SIZE 750
                             2582 ; 318  |#define STACK_L2_SIZE 100
                             2583 ; 319  |#define STACK_L3_SIZE 160
                             2584 ; 320  |
                             2585 ; 321  |// If we are in MTP mode the overlay task stack can shrink.
                             2586 ; 322  |// TODO shrink this stack for MTP, I will leave it at 500 until we verify that it 
                             2587 ; 323  |// is ok with switching code.
                             2588 ; 324  |#if defined(MTP_BUILD)
                             2589 ; 325  |#define OVERLAY_MANAGER_STACK_SIZE 300
                             2590 ; 326  |#endif
                             2591 ; 327  |
                             2592 ; 328  |/////////////////////////////////////////////////////////////////////////////////
                             2593 ; 329  |// maximum number of nested funclets 
                             2594 ; 330  |/////////////////////////////////////////////////////////////////////////////////
                             2595 ; 331  |#define MAX_NESTED_FUNCLET 6 
                             2596 ; 332  |
                             2597 ; 333  |/////////////////////////////////////////////////////////////////////////////////
                             2598 ; 334  |//    LCD DEFINITIONS
                             2599 ; 335  |/////////////////////////////////////////////////////////////////////////////////
                             2600 ; 336  |
                             2601 ; 337  |#define SPACE_CHAR 0x000020          
                             2602 ; 338  |#define ZERO_CHAR 0x000030
                             2603 ; 339  |#define COLON_CHAR 0x00003A
                             2604 ; 340  |#define PERIOD_CHAR 0x00002E
                             2605 ; 341  |
                             2606 ; 342  |#if (defined(S6B33B0A_LCD))
TASKING DSP2410 assembler v1.5r1 Build 138 SN 00100122
                                                                                                                                                                                                                                                       Page  11

M:ADDR CODE           CYCLES LINE SOURCELINE
                             2607 ; 343  |#define LCD_X_SIZE 128
                             2608 ; 344  |#define LCD_Y_SIZE 159
                             2609 ; 345  |#endif
                             2610 ; 346  |
                             2611 ; 347  |#if (defined(SED15XX_LCD))
                             2612 ; 348  |#define LCD_X_SIZE 128
                             2613 ; 349  |#define LCD_Y_SIZE 64
                             2614 ; 350  |#endif
                             2615 ; 351  |
                             2616 ; 352  |
                             2617 ; 353  |//////////////////////////////////////////////////////////////////////////////////
                             2618 ; 354  |//   Details on Customizing Contrast
                             2619 ; 355  |/////////////////////////////////////////////////////////////////////////////////
                             2620 ; 356  |//   Max supported LCD range is 0 - 3F; however due to hardware/voltage differences
                             2621 ; 357  |//   the range of visibility is usually smaller than this.  It is important to 
                             2622 ; 358  |//   calibrate the visible range, because the contrast setting is saved.
                             2623 ; 359  |//   If the user shuts off the player while lcd is not visible, the player is useless
                             2624 ; 360  |//   unless the ezact sequence is remembered.
                             2625 ; 361  |//   To find out what range your player supports: 
                             2626 ; 362  |//   change these equs to full range or comment out (full range is default)
                             2627 ; 363  |//;;;;;;
                             2628 ; 364  |// uncomment the line below to build code that will provide raw contrast value
                             2629 ; 365  |// recommended calibration using player -- uncomment 
                             2630 ; 366  |//;;;;;;
                             2631 ; 367  |//CONTRAST_CALIBRATION    equ  1
                             2632 ; 368  |////////////////////////////
                             2633 ; 369  |#if (defined(DEMO_HW))
                             2634 ; 370  |// this is the setting for ET301 demos; Next 2 line have not been updated for new Shingyi LCD (June6'05)
                             2635 ; 371  |#define LCD_MAX_CONTRAST 0x32 
                             2636 ; 372  |#define LCD_MIN_CONTRAST 0x1E
                             2637 ; 373  |#else 
                             2638 ; 374  |
                             2639 ; 375  |#if (defined(S6B33B0A_LCD))
                             2640 ; 376  |#define LCD_MAX_CONTRAST 210
                             2641 ; 377  |#define LCD_MIN_CONTRAST 160    
                             2642 ; 378  |#endif
                             2643 ; 379  |
                             2644 ; 380  |#if (defined(SED15XX_LCD))
                             2645 ; 381  |// Next 3 line comment was for OLD shingyi LCD: (default LCD before sdk2.6)
                             2646 ; 382  |// Engineering board regs support range [17-37].
                             2647 ; 383  |//   Engineering board DC/DC support range [24-46]. 
                             2648 ; 384  |//   One default contrast range [24-42] works for both.
                             2649 ; 385  |// The 3 sets of contrast ranges below are updated for SDK2.6 to support either 
                             2650 ; 386  |// new or old ShingYih LCDs. "File" refers to \resource\shingyih\system_lcd_init_seq.src
                             2651 ; 387  |// 3/10/05 - Use one of the 2 next contrast ranges depending on which
                             2652 ; 388  |// ShingYih LCD you have.  See \resources\shingyi\readme.txt 
                             2653 ; 389  |// Optimal for NEW LCD with NEW file (SDK2.6 default)  
                             2654 ; 390  |// G098064-41 LCD module (present on engr board revH LCD card)
                             2655 ; 391  |
                             2656 ; 392  |#if (defined(NEWSHINGYIH))
                             2657 ; 393  |#define LCD_MAX_CONTRAST 250
                             2658 ; 394  |#define LCD_MIN_CONTRAST 0
                             2659 ; 395  |#else 
                             2660 ; 396  |//-----
                             2661 ; 397  |// Near optimal for OLD LCD with NEW file. 
                             2662 ; 398  |// NOT optimal for the new lcd but pretty good. So u may use this if u want 1 build for both LCDs.
                             2663 ; 399  |#define LCD_MAX_CONTRAST 250
                             2664 ; 400  |#define LCD_MIN_CONTRAST 0
                             2665 ; 401  |
                             2666 ; 402  |//=====
                             2667 ; 403  |// Optimal for OLD ShingYih LCD with OLD file (as sdk2.521)
                             2668 ; 404  |// Suggest going with default new init file & values above for your LCD instead of this historic ver.
                             2669 ; 405  |//LCD_MAX_CONTRAST equ 42
                             2670 ; 406  |//LCD_MIN_CONTRAST equ 24 
                             2671 ; 407  |
                             2672 ; 408  |#endif
                             2673 ; 409  |#endif
                             2674 ; 410  |
                             2675 ; 411  |#endif
                             2676 ; 412  |
                             2677 ; 413  |//////////////////////////////////////////////////////////////////////////////////
                             2678 ; 414  |// The default value of the lcd contrast in % of range
                             2679 ; 415  |//   the default value is used when no settings.dat is available
                             2680 ; 416  |//////////////////////////////////////////////////////////////////////////////////
                             2681 ; 417  |
                             2682 ; 418  |#if (defined(S6B33B0A_LCD))
                             2683 ; 419  |// 60% of range is default value
                             2684 ; 420  |#define DEFAULT_CONTRAST 50 
                             2685 ; 421  |#endif
                             2686 ; 422  |
                             2687 ; 423  |#if (defined(SED15XX_LCD))
                             2688 ; 424  |// % of range is default value (was 60%)
                             2689 ; 425  |#define DEFAULT_CONTRAST 50 
                             2690 ; 426  |#endif
                             2691 ; 427  |
                             2692 ; 428  |
                             2693 ; 429  |// percentage change per increment/decrement message (LCD_DEC_CONTRAST/LCD_INC_CONTRAST)
                             2694 ; 430  |// make lower when doing calibration
                             2695 ; 431  |#define LCD_STEPSIZE_CONTRAST 10  
                             2696 ; 432  |
                             2697 ; 433  |
                             2698 ; 434  |/////////////////////////////////////////////////////////////////////////////////
                             2699 ; 435  |// For FFWD and RWND
                             2700 ; 436  |/////////////////////////////////////////////////////////////////////////////////
                             2701 ; 437  |#define SECONDS_TO_SKIP 1
                             2702 ; 438  |#define SECONDS_TO_SKIP1 3
                             2703 ; 439  |#define SECONDS_TO_SKIP2 6
                             2704 ; 440  |// number of seconds to cause reset to begin of song for PREV push
                             2705 ; 441  |#define PREV_SONG_THRESHOLD 5  
                             2706 ; 442  |// number of 300 mSec periods before the numbers of seconds to skip increases
                             2707 ; 443  |#define FIRST_TIME_BOUNDARY 15 
                             2708 ; 444  |// number of 300 mSec periods before the numbers of seconds to skip increases
                             2709 ; 445  |#define SECOND_TIME_BOUNDARY 30 
                             2710 ; 446  |
                             2711 ; 447  |// For audible FFW/RWD
                             2712 ; 448  |#define SECONDS_TO_SKIP_FOR_3X_RATE 1
                             2713 ; 449  |#define SECONDS_TO_SKIP_FOR_60X_RATE 18
                             2714 ; 450  |#define SECONDS_TO_SKIP_FOR_600X_RATE 180
                             2715 ; 451  |#define SECONDS_TO_SKIP_FOR_1800X_RATE 540
                             2716 ; 452  |// number of 300 mSec periods before the numbers of seconds to skip increases
                             2717 ; 453  |#define LEVEL1_BOUNDARY 17 
                             2718 ; 454  |// number of 300 mSec periods before the numbers of seconds to skip increases
                             2719 ; 455  |#define LEVEL2_BOUNDARY 33 
                             2720 ; 456  |// number of 300 mSec periods before the numbers of seconds to skip increases
                             2721 ; 457  |#define LEVEL3_BOUNDARY 50 
                             2722 ; 458  |// Stmp00010296 Ticket #71685:  for song shorter than the min. skip size
                             2723 ; 459  |// if song_time < skip_size, bCurrentSongShort=>TRUE (ignore FWD/RWD commands)
                             2724 ; 460  |// Short Song Time, songs too short to play.
                             2725 ; 461  |#define SHORT_SONG_TIME SECONDS_TO_SKIP         
                             2726 ; 462  |
                             2727 ; 463  |/////////////////////////////////////////////////////////////////////////////////
                             2728 ; 464  |// MP3 Sync Values
                             2729 ; 465  |/////////////////////////////////////////////////////////////////////////////////
                             2730 ; 466  |// # bytes to look for sync before marking it bad
                             2731 ; 467  |#define MP3_SYNC_THRESHOLD 70000 
                             2732 ; 468  |// # bytes to look for sync before slowing decoder isr frequency (to let menus run)
                             2733 ; 469  |#define MP3_SYNC_THRESHOLD1 10000 
                             2734 ; 470  |// once we have sync'd, the isr should be called this frequently
                             2735 ; 471  |#define MP3_DECODERISR_FAST 7500  
                             2736 ; 472  |// if decoder is having difficulty syncing, switch isr to be called less frequently
                             2737 ; 473  |#define MP3_DECODERISR_SLOW 50000 
                             2738 ; 474  |
                             2739 ; 475  |
                             2740 ; 476  |/////////////////////////////////////////////////////////////////////////////////
                             2741 ; 477  |//// Multi-Stage Volume Control Definitions
                             2742 ; 478  |/////////////////////////////////////////////////////////////////////////////////
                             2743 ; 479  |//// Use Multi-Stage Volume
                             2744 ; 480  |#define MULTI_STAGE_VOLUME 0x1                  
                             2745 ; 481  |
                             2746 ; 482  |//// Master Volume definitions
                             2747 ; 483  |#define MIX_MSTR_MAX_VOL 0x0
                             2748 ; 484  |#define NUM_MSTR_ATT_STEPS (0x1F-MIX_MSTR_MAX_VOL)
                             2749 ; 485  |
                             2750 ; 486  |//// DAC-Mode definitions
                             2751 ; 487  |//// Adjusts 0dB point
                             2752 ; 488  |#define MIX_DAC_NOM_VOL 0x6                  
                             2753 ; 489  |#define MIX_DAC_MIN_VOL 0x1F
                             2754 ; 490  |// For minimum clipping: Set MIX_DAC_MAX_VOL below to match MIX_DAC_NOM_VOL value 2 lines above.
                             2755 ; 491  |// For additional gain (with possible clipping): Set MIX_DAC_MAX_VOL in range below. 
                             2756 ; 492  |//                                               Each integer below MIX_DAC_NOM_VOL provides 1.5 dB gain on Stmp34x0; 
                             2757 ; 493  |//                                               Max gain possible: 8 step diff would provide +12dB gain.   
                             2758 ; 494  |// range: [0 to MIX_DAC_NOM_VOL] (0 for loudest volume)
                             2759 ; 495  |#define MIX_DAC_MAX_VOL 0x0  
                             2760 ; 496  |
                             2761 ; 497  |#define NUM_DAC_ATT_STEPS (MIX_DAC_MIN_VOL-MIX_DAC_NOM_VOL+1)
                             2762 ; 498  |#define NUM_DAC_GAIN_STEPS (MIX_DAC_NOM_VOL-MIX_DAC_MAX_VOL)
                             2763 ; 499  |#define NUM_DAC_MODE_VOL_STEPS (NUM_DAC_ATT_STEPS+NUM_MSTR_ATT_STEPS+NUM_DAC_GAIN_STEPS+1)
                             2764 ; 500  |
                             2765 ; 501  |//// If there is no stored volume, set to 50% of DAC-Mode max; change if DAC Mode is not the default
                             2766 ; 502  |//// STMP35xx has 2dB attenuation per step so default needs a few more steps above midpoint.
                             2767 ; 503  |#define DEFAULT_VOLUME ((NUM_DAC_MODE_VOL_STEPS/2)+6)         
                             2768 ; 504  |
                             2769 ; 505  |//// Set maximum restored volume to 75% of DAC-Mode max; change if DAC Mode is not the default
                             2770 ; 506  |#define MAX_RESTORED_VOLUME ((3*NUM_DAC_MODE_VOL_STEPS)/4)   
                             2771 ; 507  |
                             2772 ; 508  |
                             2773 ; 509  |//// Line In definitions (used for Line-In 1)
                             2774 ; 510  |//// 0dB point of the Line In
                             2775 ; 511  |#define MIX_LINE_NOM_VOL 0x8                  
                             2776 ; 512  |//// Minimum volume of Line In
                             2777 ; 513  |#define MIX_LINE_MIN_VOL 0x1F                 
                             2778 ; 514  |//// Maximum volume of Line In (can adjust extra gain)
                             2779 ; 515  |#define MIX_LINE_MAX_VOL 0x6                  
                             2780 ; 516  |#define NUM_LINE_ATT_STEPS (MIX_LINE_MIN_VOL-MIX_LINE_NOM_VOL+1)
                             2781 ; 517  |#define NUM_LINE_GAIN_STEPS (MIX_LINE_NOM_VOL-MIX_LINE_MAX_VOL)
                             2782 ; 518  |#define NUM_LINE_MODE_VOL_STEPS (NUM_LINE_ATT_STEPS+NUM_MSTR_ATT_STEPS+NUM_LINE_GAIN_STEPS+1)
                             2783 ; 519  |
                             2784 ; 520  |//// Line In definitions (used for FM tuner with 144 pin package)
                             2785 ; 521  |//// 0dB point of the Line In
                             2786 ; 522  |#define MIX_FM_NOM_VOL 0x8                  
                             2787 ; 523  |//// Minimum volume of Line In
                             2788 ; 524  |#define MIX_FM_MIN_VOL 0x1F                 
                             2789 ; 525  |//// Maximum volume of Line In (can adjust extra gain)
                             2790 ; 526  |#define MIX_FM_MAX_VOL 0x6                  
                             2791 ; 527  |#define NUM_FM_ATT_STEPS (MIX_FM_MIN_VOL-MIX_FM_NOM_VOL+1)
                             2792 ; 528  |#define NUM_FM_GAIN_STEPS (MIX_FM_NOM_VOL-MIX_FM_MAX_VOL)
                             2793 ; 529  |#define NUM_FM_MODE_VOL_STEPS (NUM_FM_ATT_STEPS+NUM_MSTR_ATT_STEPS+NUM_FM_GAIN_STEPS+1)
                             2794 ; 530  |
                             2795 ; 531  |/////////////////////////////////////////////////////////////////////////////////
                             2796 ; 532  |//// When enabled (1), periodically checks for one of several FM state machine invalid deadlock states & recovers. 
                             2797 ; 533  |//// Define as 0 to disable FM-deadlock-state checking and recovery.
                             2798 ; 534  |#define FM_WATCHDOG_ENABLE 1
                             2799 ; 535  |
                             2800 ; 536  |#if !defined(STMP_BUILD_PLAYER)
                             2801 ; 537  |////
                             2802 ; 538  |////! This varible holds the lcd display state for the mtp project.
                             2803 ; 539  |////
                             2804 ; 540  |///
                             2805 ; 541  |#include <types.h>
                             2806 ; 542  |extern volatile WORD g_wActivityState;
                             2807 ; 543  |#endif // if !@def('STMP_BUILD_PLAYER')
                             2808 ; 544  |
                             2809 ; 545  |void _reentrant Init5VSense(void);
                             2810 ; 546  |void _reentrant ServiceDCDC(void);
                             2811 ; 547  |
                             2812 ; 548  |////////////////////////////////////////////////////////////////////////////
                             2813 ; 549  |//// JPEG Thumbnail Mode Setting
                             2814 ; 550  |//// number of column in thumbnail mode
                             2815 ; 551  |#define THUMBNAIL_X 2           
                             2816 ; 552  |//// number of row in  thumbnail mode
                             2817 ; 553  |#define THUMBNAIL_Y 2           
                             2818 ; 554  |//// thumbnail boundary offset x
                             2819 ; 555  |#define THUMBNAIL_X_OFFSET 4            
                             2820 ; 556  |//// thumbnail boundary offset y
                             2821 ; 557  |#define THUMBNAIL_Y_OFFSET 4            
                             2822 ; 558  |
                             2823 ; 559  |#endif // if (!@def(_PROJECT_INC))
                             2824 ; 560  |
                             2825 
                             2827 
                             2828 ; 5    |
                             2829 ; 6    |//This H file includes common definitions and references that are used throughout the different projects.
                             2830 ; 7    |
                             2831 ; 8    |#ifndef SCRATCH_USER_Y_SIZE
                             2832 ; 9    |#define SCRATCH_USER_Y_SIZE 512
                             2833 ; 10   |#endif
                             2834 ; 11   |
                             2835 ; 12   |#ifndef SCRATCH_USER_X_SIZE
                             2836 ; 13   |#define SCRATCH_USER_X_SIZE 512
                             2837 ; 14   |#endif
                             2838 ; 15   |
                             2839 ; 16   |extern SyncObject g_Sync_UserScratchY;
                             2840 ; 17   |extern _Y WORD g_wUserScratchY[SCRATCH_USER_Y_SIZE];
                             2841 ; 18   |
                             2842 ; 19   |extern SyncObject g_Sync_UserScratchX;
                             2843 ; 20   |extern _X WORD g_wUserScratchX[SCRATCH_USER_X_SIZE];
                             2844 ; 21   |
                             2845 ; 22   |#endif
                             2846 
                             2848 
                             2849 ; 13   |#endif
                             2850 ; 14   |
                             2851 ; 15   |#pragma optimize 1
                             2853 ; 16   |
                             2854 ; 17   |#include "displaydrv.h"
                             2855 
                             2857 
                             2858 ; 1    |///////////////////////////////////////////////////////////////////////////////
                             2859 ; 2    |///
                             2860 ; 3    |/// Filename: displaydrv.h
                             2861 ; 4    |/// Description: Prototypes for the display driver files.
TASKING DSP2410 assembler v1.5r1 Build 138 SN 00100122
                                                                                                                                                                                                                                                       Page  12

M:ADDR CODE           CYCLES LINE SOURCELINE
                             2862 ; 5    |///
                             2863 ; 6    |///
                             2864 ; 7    |/// Copyright (c) SigmaTel, Inc. Unpublished
                             2865 ; 8    |///
                             2866 ; 9    |/// SigmaTel, Inc.
                             2867 ; 10   |/// Proprietary  Confidential
                             2868 ; 11   |///
                             2869 ; 12   |/// This source code and the algorithms implemented therein constitute
                             2870 ; 13   |/// confidential information and may comprise trade secrets of SigmaTel, Inc.
                             2871 ; 14   |/// or its associates, and any use thereof is subject to the terms and
                             2872 ; 15   |/// conditions of the Confidential Disclosure Agreement pursuant to which this
                             2873 ; 16   |/// source code was originally received.
                             2874 ; 17   |///
                             2875 ; 18   |///////////////////////////////////////////////////////////////////////////////
                             2876 ; 19   |#ifndef __DISPLAY_H
                             2877 ; 20   |#define __DISPLAY_H
                             2878 ; 21   |
                             2879 ; 22   |#include "project.h"
                             2880 
                             2882 
                             2883 ; 1    |/////////////////////////////////////////////////////////////////////////////////
                             2884 ; 2    |//  Copyright(C) SigmaTel, Inc. 2000-2004
                             2885 ; 3    |//  Filename: project.inc
                             2886 ; 4    |//  Description: 
                             2887 ; 5    |/////////////////////////////////////////////////////////////////////////////////
                             2888 ; 6    |
                             2889 ; 7    |#if (!defined(_PROJECT_INC))
                             2890 ; 8    |#define _PROJECT_INC 1
                             2891 ; 9    |
                             2892 ; 10   |#if defined(STMP_BUILD_PLAYER)
                             2893 ; 11   |#include "hwequ.h"
                             2894 ; 12   |#else 
                             2895 ; 13   |//include "regscodec.inc"
                             2896 ; 14   |#endif
                             2897 ; 15   |
                             2898 ; 16   |//////////////////////////////////////////////////////////////////////////////////
                             2899 ; 17   |// Uncomment next define to allow player boot if you have stfm1000 macro enabled (defaults ON) & 
                             2900 ; 18   |// your board crystal is not able to output nominal voltage range. Used in player main.asm. STMP00012148
                             2901 ; 19   |// Defining this will result in lower battery life (price of using a lower quality crystal). 
                             2902 ; 20   |// Those that want to save battery life and have good crystals that meet our HW team's specs can 
                             2903 ; 21   |// comment out this line to reduce crystal bias current and so battery current in player mode.  
                             2904 ; 22   |#define SUPPORT_MARGINAL_XTALS 1
                             2905 ; 23   |
                             2906 ; 24   |/////////////////////////////////////////////////////////////////////////////////
                             2907 ; 25   |// BOOT SPEED CONFIG & ASSOCIATED BATTERY VOLTAGE CHECK ENABLE
                             2908 ; 26   |/////////////////////////////////////////////////////////////////////////////////
                             2909 ; 27   |// Users can enable one of ATTEMPT_FAST_BOOT or FASTEST boot or neither project define below by defining
                             2910 ; 28   |// values as 0 or 1, else it defaults to the boot speed used in previous SDKs.
                             2911 ; 29   |#define ATTEMPT_FAST_BOOT 1
                             2912 ; 30   |#define ATTEMPT_FASTEST_BOOT 0   
                             2913 ; 31   |// Changing this define to 0 removes Vbat threshholding & unconditionally gives fast boot config above- 
                             2914 ; 32   |// disabling this check is suggested for profiling if you want to try to tweak down threshholds by maybe 50mV.
                             2915 ; 33   |// Also the tests should clear the fast boot config defines to link & boot at normal speed.
                             2916 ; 34   |#define SPEED_BOOT_BATTERY_CHECK 1
                             2917 ; 35   |
                             2918 ; 36   |/////////////////////////////////////////////////////////////////////////////////
                             2919 ; 37   |// MEDIA DEFINITIONS
                             2920 ; 38   |/////////////////////////////////////////////////////////////////////////////////
                             2921 ; 39   |
                             2922 ; 40   |/////////////////////////////////////////////////////////////////////////////////
                             2923 ; 41   |// MNAND - Number of chips forming the internal physical device (i.e. # of NANDs)
                             2924 ; 42   |#if defined(NAND1)
                             2925 ; 43   |#define SM_INTERNAL_CHIPS 1
                             2926 ; 44   |#else 
                             2927 ; 45   |#if defined(NAND2)
                             2928 ; 46   |#define SM_INTERNAL_CHIPS 2
                             2929 ; 47   |#else 
                             2930 ; 48   |#if defined(NAND3)
                             2931 ; 49   |#define SM_INTERNAL_CHIPS 3
                             2932 ; 50   |#else 
                             2933 ; 51   |#if defined(NAND4)
                             2934 ; 52   |#define SM_INTERNAL_CHIPS 4
                             2935 ; 53   |#else 
                             2936 ; 54   |#define SM_INTERNAL_CHIPS 1
                             2937 ; 55   |#endif
                             2938 ; 56   |#endif
                             2939 ; 57   |#endif
                             2940 ; 58   |#endif
                             2941 ; 59   |
                             2942 ; 60   |/////////////////////////////////////////////////////////////////////////////////
                             2943 ; 61   |// If SMARTMEDIA_DETECT_ACTIVE_HIGH is defined:
                             2944 ; 62   |//   SmartMedia will be detected as inserted if the GPIO pin reads 1 and removed if it reads 0.  
                             2945 ; 63   |// If SMARTMEDIA_DETECT_ACTIVE_HIGH is not defined ** comment out next line **
                             2946 ; 64   |//   SmartMedia will be detected as inserted if the GPIO pin reads 0 and removed if it reads 1.
                             2947 ; 65   |//*** comment out if active high ****
                             2948 ; 66   |//SMARTMEDIA_DETECT_ACTIVE_HIGH  equ     1
                             2949 ; 67   |
                             2950 ; 68   |#if defined(SMEDIA)
                             2951 ; 69   |#define NUM_REMOVABLE_MEDIA 1
                             2952 ; 70   |#define NUM_SM_EXTERNAL 1
                             2953 ; 71   |#define MMC_MAX_PHYSICAL_DEVICES 0
                             2954 ; 72   |#define SM_MAX_LOGICAL_DEVICES 2
                             2955 ; 73   |#else 
                             2956 ; 74   |#if defined(MMC)
                             2957 ; 75   |#define NUM_REMOVABLE_MEDIA 1
                             2958 ; 76   |#define NUM_SM_EXTERNAL 0
                             2959 ; 77   |#define MMC_MAX_PHYSICAL_DEVICES 1
                             2960 ; 78   |#define SM_MAX_LOGICAL_DEVICES 1
                             2961 ; 79   |#else 
                             2962 ; 80   |#define NUM_REMOVABLE_MEDIA 0
                             2963 ; 81   |#define NUM_SM_EXTERNAL 0
                             2964 ; 82   |#define MMC_MAX_PHYSICAL_DEVICES 0
                             2965 ; 83   |#define SM_MAX_LOGICAL_DEVICES 1
                             2966 ; 84   |#endif
                             2967 ; 85   |#endif
                             2968 ; 86   |
                             2969 ; 87   |/////////////////////////////////////////////////////////////////////////////////
                             2970 ; 88   |// Mass Storage Class definitions
                             2971 ; 89   |/////////////////////////////////////////////////////////////////////////////////
                             2972 ; 90   |// Set to 0 if Composite Device build is desired.    
                             2973 ; 91   |#define MULTI_LUN_BUILD 1   
                             2974 ; 92   |
                             2975 ; 93   |////////////////////////////////////////////////////////////////////////////////
                             2976 ; 94   |//  SCSI
                             2977 ; 95   |#if (MULTI_LUN_BUILD==0)
                             2978 ; 96   |  #if (NUM_REMOVABLE_MEDIA == 1)
                             2979 ; 97   |    #define SCSI_NUM_TARGETS                        2
                             2980 ; 98   |    #define SCSI_DEVICE_NUM_LUNS_DEV_0              1
                             2981 ; 99   |    #define SCSI_DEVICE_NUM_LUNS_DEV_1              1
                             2982 ; 100  |  #else
                             2983 ; 101  |    #define SCSI_NUM_TARGETS                        1
                             2984 ; 102  |    #define SCSI_DEVICE_NUM_LUNS_DEV_0              1
                             2985 ; 103  |  #endif
                             2986 ; 104  |#else
                             2987 ; 105  |    #define SCSI_NUM_TARGETS                        1
                             2988 ; 106  |  #if (NUM_REMOVABLE_MEDIA == 1)
                             2989 ; 107  |    #define SCSI_DEVICE_NUM_LUNS_DEV_0              2
                             2990 ; 108  |  #else
                             2991 ; 109  |    #define SCSI_DEVICE_NUM_LUNS_DEV_0              1  
                             2992 ; 110  |  #endif
                             2993 ; 111  |#endif
                             2994 ; 112  |
                             2995 ; 113  |
                             2996 ; 114  |#define USBMSC_NUM_DEVICES                      SCSI_NUM_TARGETS
                             2997 ; 115  |
                             2998 ; 116  |
                             2999 ; 117  |////////////////////////////////////////////////////////////////////////////////
                             3000 ; 118  |// Define number of logical medias and drives for three builds (MTP, USBMSC, and Player)
                             3001 ; 119  |////////////////////////////////////////////////////////////////////////////////
                             3002 ; 120  |#ifdef MMC
                             3003 ; 121  |#ifdef MTP_BUILD
                             3004 ; 122  |// --------------------
                             3005 ; 123  |// MTP and MMC
                             3006 ; 124  |// --------------------
                             3007 ; 125  |#define NUM_LOGICAL_MEDIA       2
                             3008 ; 126  |#define NUM_LOGICAL_DRIVES      8
                             3009 ; 127  |#else  // ifndef MTP_BUILD
                             3010 ; 128  |#ifdef STMP_BUILD_PLAYER
                             3011 ; 129  |// --------------------
                             3012 ; 130  |// Player and MMC
                             3013 ; 131  |// --------------------
                             3014 ; 132  |#else
                             3015 ; 133  |// --------------------
                             3016 ; 134  |// USBMSC and MMC
                             3017 ; 135  |// --------------------
                             3018 ; 136  |#define NUM_LOGICAL_MEDIA       3
                             3019 ; 137  |#define NUM_LOGICAL_DRIVES      8
                             3020 ; 138  |#endif // ifdef STMP_BUILD_PLAYER
                             3021 ; 139  |#endif // ifdef MTP_BUILD
                             3022 ; 140  |#else  // ifndef MMC
                             3023 ; 141  |#ifdef MTP_BUILD
                             3024 ; 142  |// --------------------
                             3025 ; 143  |// MTP and NAND only
                             3026 ; 144  |// --------------------
                             3027 ; 145  |#define NUM_LOGICAL_MEDIA       1
                             3028 ; 146  |#define NUM_LOGICAL_DRIVES      7
                             3029 ; 147  |#else  // ifndef MTP_BUILD
                             3030 ; 148  |#ifdef STMP_BUILD_PLAYER
                             3031 ; 149  |// --------------------
                             3032 ; 150  |// Player and NAND only
                             3033 ; 151  |// --------------------
                             3034 ; 152  |#else
                             3035 ; 153  |// --------------------
                             3036 ; 154  |// USBMSC and NAND only
                             3037 ; 155  |// --------------------
                             3038 ; 156  |#define NUM_LOGICAL_MEDIA       2
                             3039 ; 157  |#define NUM_LOGICAL_DRIVES      7
                             3040 ; 158  |#endif // ifdef STMP_BUILD_PLAYER
                             3041 ; 159  |#endif // ifdef MTP_BUILD
                             3042 ; 160  |#endif // ifdef MMC 
                             3043 ; 161  |
                             3044 ; 162  |// If we are in an MTP build then we don't use as many transfers buffers.
                             3045 ; 163  |#if (defined(MTP_BUILD))
                             3046 ; 164  |#define MAX_USB_TRANSFERS_QUEUED 16
                             3047 ; 165  |
                             3048 ; 166  |////!
                             3049 ; 167  |////! This varible holds the watchdog count for the store flush.
                             3050 ; 168  |////!
                             3051 ; 169  |///
                             3052 ; 170  |#include <types.h>
                             3053 ; 171  |extern volatile INT g_StoreWatchDogCount;
                             3054 ; 172  |extern const INT g_StoreWatchDogTimeout;
                             3055 ; 173  |#endif
                             3056 ; 174  |
                             3057 ; 175  |////////////////////////////////////////////////////////////////////////////////
                             3058 ; 176  |// These are needed here for Mass Storage Class
                             3059 ; 177  |// Needs to be cleaned up
                             3060 ; 178  |////////////////////////////////////////////////////////////////////////////////
                             3061 ; 179  |#if (!defined(STMP_BUILD_PLAYER))
                             3062 ; 180  |#define SCRATCH_USER_Y_SIZE 512
                             3063 ; 181  |#define SCRATCH_USER_X_SIZE 512
                             3064 ; 182  |
                             3065 ; 183  |#define BROWNOUT_LEVEL1_DETECTED                0x000001
                             3066 ; 184  |
                             3067 ; 185  |#endif
                             3068 ; 186  |
                             3069 ; 187  |
                             3070 ; 188  |/////////////////////////////////////////////////////////////////////////////////
                             3071 ; 189  |// SmartMedia/NAND defs
                             3072 ; 190  |#define SM_MAX_PHYSICAL_DEVICES SM_INTERNAL_CHIPS+NUM_SM_EXTERNAL
                             3073 ; 191  |#define SM_REMOVABLE_DEVICE_NUM SM_INTERNAL_CHIPS
                             3074 ; 192  |
                             3075 ; 193  |/////////////////////////////////////////////////////////////////////////////////
                             3076 ; 194  |// Sysloadresources defs
                             3077 ; 195  |#define SM_MAX_RESOURCE_DEVICES SM_INTERNAL_CHIPS+NUM_SM_EXTERNAL
                             3078 ; 196  |
                             3079 ; 197  |/////////////////////////////////////////////////////////////////////////////////
                             3080 ; 198  |// MMC defs
                             3081 ; 199  |#define MMC_MAX_PARTITIONS 1
                             3082 ; 200  |#define MMC_MAX_LOGICAL_DEVICES MMC_MAX_PHYSICAL_DEVICES*MMC_MAX_PARTITIONS
                             3083 ; 201  |
                             3084 ; 202  |/////////////////////////////////////////////////////////////////////////////////
                             3085 ; 203  |// SPI defs
                             3086 ; 204  |#define SPI_MAX_DEVICES MMC_MAX_PHYSICAL_DEVICES
                             3087 ; 205  |
                             3088 ; 206  |/////////////////////////////////////////////////////////////////////////////////
                             3089 ; 207  |// Global media defs
                             3090 ; 208  |#define MAX_PHYSICAL_DEVICES SM_MAX_PHYSICAL_DEVICES+MMC_MAX_PHYSICAL_DEVICES
                             3091 ; 209  |#define MAX_LOGICAL_DEVICES SM_MAX_LOGICAL_DEVICES+MMC_MAX_LOGICAL_DEVICES
                             3092 ; 210  |
                             3093 ; 211  |/////////////////////////////////////////////////////////////////////////////////
                             3094 ; 212  |// DO NOT CHANGE THESE!!!
                             3095 ; 213  |#define SM_MAX_PARTITIONS 4
                             3096 ; 214  |#define MAX_HANDLES 2
                             3097 ; 215  |/////////////////////////////////////////////////////////////////////////////////
                             3098 ; 216  |
                             3099 ; 217  |
                             3100 ; 218  |/////////////////////////////////////////////////////////////////////////////////
                             3101 ; 219  |// Battery LRADC Values 
                             3102 ; 220  |/////////////////////////////////////////////////////////////////////////////////
                             3103 ; 221  |// brownout trip point in mV (moved by RS)
                             3104 ; 222  |// BATT_SAFETY_MARGIN:  percentage value used by:
                             3105 ; 223  |//   * SysSaveSettings to determine if enough power is left to attempt a settings save. 
                             3106 ; 224  |//   * Recorder to conditionally prevent the start or continuation of 
                             3107 ; 225  |//     audio recording to media.
                             3108 ; 226  |#define BATT_SAFETY_MARGIN 10
                             3109 ; 227  |
                             3110 ; 228  |//; player resource drive refresh allowed only when battery usable % is above this value. 
                             3111 ; 229  |//; 50% of usable range [0.9V to 1.5V] is around 1.2V This is the safe target alkaline voltage to do a refresh.
                             3112 ; 230  |//; LIION will also require 50% which will work but that could be changed in the future. 
                             3113 ; 231  |//RESOURCE_REFRESH_MIN_BATT_PCT equ 50
TASKING DSP2410 assembler v1.5r1 Build 138 SN 00100122
                                                                                                                                                                                                                                                       Page  13

M:ADDR CODE           CYCLES LINE SOURCELINE
                             3114 ; 232  |
                             3115 ; 233  |// stmp00005071 adds these for mp3 encode stability at low battery per battery type & mmc presence.
                             3116 ; 234  |
                             3117 ; 235  |//// Vbat threshholds empirically tuned by profiling max bat current for 3 HW cases: 
                             3118 ; 236  |//// 1 GigaByte MMC, NAND flash only, & LiIon Buck mode. See voicemenu pre-encode Vbat check.
                             3119 ; 237  |#if (!defined(CLCD))
                             3120 ; 238  |#define MP3_ENC_MMC_MIN_V_BAT_MV 1100
                             3121 ; 239  |#define MP3_ENC_NANDONLY_MIN_V_BAT_MV 1000
                             3122 ; 240  |#else 
                             3123 ; 241  |#define MP3_ENC_MMC_MIN_V_BAT_MV 1250
                             3124 ; 242  |#define MP3_ENC_NANDONLY_MIN_V_BAT_MV 1150
                             3125 ; 243  |#endif
                             3126 ; 244  |#define MP3_ENC_BUCKMODE_MIN_V_BAT_MV 3300
                             3127 ; 245  |
                             3128 ; 246  |// These Vbat use-range-percentages are derived to correspond with target battery 
                             3129 ; 247  |// voltages of 1.10V for MMC, 1.0V for nand only (alkaline or nimh), and 3.3V for any LiIon.
                             3130 ; 248  |// See mp3 encoder overlay.
                             3131 ; 249  |#define MP3_ENC_MMC_MIN_V_BAT_RANGE_PCT 33
                             3132 ; 250  |#define MP3_ENC_NANDONLY_MIN_V_BAT_RANGE_PCT 17
                             3133 ; 251  |#define MP3_ENC_BUCKMODE_MIN_V_BAT_RANGE_PCT 25
                             3134 ; 252  |
                             3135 ; 253  |/////////////////////////////////////////////////////////////////////////////////
                             3136 ; 254  |// Voice recording filenames
                             3137 ; 255  |// number of digits in filename Vxxx.wav
                             3138 ; 256  |/////////////////////////////////////////////////////////////////////////////////
                             3139 ; 257  |#define DIGITS_IN_VOICE_FILENAME 3   
                             3140 ; 258  |
                             3141 ; 259  |/////////////////////////////////////////////////////////////////////////////////
                             3142 ; 260  |// Mic Bias: Set this enable to 1 to internally generate mic bias voltage. 
                             3143 ; 261  |// Also below, must configure internal resistor value and pin to use for DC bias. 
                             3144 ; 262  |// Can set to 0 to disable internally generated mic bias voltage at pin lradc1/2.
                             3145 ; 263  |#if defined(DEVICE_3500)
                             3146 ; 264  |#define ENABLE_INTERNALLY_GENERATED_MICBIAS 1 
                             3147 ; 265  |// MIC BIAS circuit source selection: use Low Resolution ADC pin 2 or 1 to bias mic. 
                             3148 ; 266  |// Per your layout: select LRADC 2 or 1 below 
                             3149 ; 267  |//   (pin LRADC 2 for 35xx cpu card revB, LRADC 1 for 35xx cpu card revC, ref schematics, & demo player)
                             3150 ; 268  |#define LRADC_NUM_FOR_MIC_BIAS 1 
                             3151 ; 269  |// Sets internal mic bias R to value 2, 4, or 8 (in kOhms).
                             3152 ; 270  |#define MICBIAS_CONFIGURED_RESISTOR_KOHMS 8
                             3153 ; 271  |
                             3154 ; 272  |// Allows mic bias to settle before sampling. This delay currently unused. For rec btn when bias not yet ready.
                             3155 ; 273  |#define REC_BTN_INTERNAL_MIC_BIAS_SETTLING_DELAY_MS 400 
                             3156 ; 274  |// Option always keeps bias enabled after mainmenu init. This allows for start pop prevention if you use rec button from outside voice menu.
                             3157 ; 275  |// This selection costs 1 mWatt but gains the desired low record button to sampling latency in the record-from-music-menu use-case.
                             3158 ; 276  |#define KEEP_MIC_BIAS_ENABLED 0
                             3159 ; 277  |
                             3160 ; 278  |#else 
                             3161 ; 279  |// STMP3410
                             3162 ; 280  |#define ENABLE_INTERNALLY_GENERATED_MICBIAS 0
                             3163 ; 281  |#define LRADC_NUM_FOR_MIC_BIAS 1 
                             3164 ; 282  |#define MICBIAS_CONFIGURED_RESISTOR_KOHMS 2
                             3165 ; 283  |#endif
                             3166 ; 284  |
                             3167 ; 285  |/////////////////////////////////////////////////////////////////////////////////
                             3168 ; 286  |// Number of available soft timers
                             3169 ; 287  |/////////////////////////////////////////////////////////////////////////////////
                             3170 ; 288  |#if defined(SYNC_LYRICS)
                             3171 ; 289  |#define SOFT_TIMERS 10
                             3172 ; 290  |#else 
                             3173 ; 291  |#if defined(JPEG_DECODER)
                             3174 ; 292  |#define SOFT_TIMERS 10
                             3175 ; 293  |#else 
                             3176 ; 294  |#define SOFT_TIMERS 9
                             3177 ; 295  |#endif
                             3178 ; 296  |#endif
                             3179 ; 297  |
                             3180 ; 298  |/////////////////////////////////////////////////////////////////////////////////
                             3181 ; 299  |//  sizes
                             3182 ; 300  |/////////////////////////////////////////////////////////////////////////////////
                             3183 ; 301  |#if defined(MMC)
                             3184 ; 302  |#if defined(USE_PLAYLIST5)
                             3185 ; 303  |#define MENU_STACK_SIZE 1500
                             3186 ; 304  |#else 
                             3187 ; 305  |#define MENU_STACK_SIZE 1250
                             3188 ; 306  |#endif //if @def('USE_PLAYLIST5')
                             3189 ; 307  |#else 
                             3190 ; 308  |#if defined(USE_PLAYLIST5)
                             3191 ; 309  |#define MENU_STACK_SIZE 1500
                             3192 ; 310  |#else 
                             3193 ; 311  |#define MENU_STACK_SIZE 1250
                             3194 ; 312  |#endif //if @def('USE_PLAYLIST5')
                             3195 ; 313  |#endif //if @def('MMC')
                             3196 ; 314  |
                             3197 ; 315  |// NOTE: SDK2.6 USED 550 FOR NEXT LINE, BUT SDK3.0BETA USED 750. Should it be ifdef MTP 750 else 550 for other builds? TOVERIFY. MYALLOC
                             3198 ; 316  |// 
                             3199 ; 317  |#define STACK_L1_SIZE 750
                             3200 ; 318  |#define STACK_L2_SIZE 100
                             3201 ; 319  |#define STACK_L3_SIZE 160
                             3202 ; 320  |
                             3203 ; 321  |// If we are in MTP mode the overlay task stack can shrink.
                             3204 ; 322  |// TODO shrink this stack for MTP, I will leave it at 500 until we verify that it 
                             3205 ; 323  |// is ok with switching code.
                             3206 ; 324  |#if defined(MTP_BUILD)
                             3207 ; 325  |#define OVERLAY_MANAGER_STACK_SIZE 300
                             3208 ; 326  |#endif
                             3209 ; 327  |
                             3210 ; 328  |/////////////////////////////////////////////////////////////////////////////////
                             3211 ; 329  |// maximum number of nested funclets 
                             3212 ; 330  |/////////////////////////////////////////////////////////////////////////////////
                             3213 ; 331  |#define MAX_NESTED_FUNCLET 6 
                             3214 ; 332  |
                             3215 ; 333  |/////////////////////////////////////////////////////////////////////////////////
                             3216 ; 334  |//    LCD DEFINITIONS
                             3217 ; 335  |/////////////////////////////////////////////////////////////////////////////////
                             3218 ; 336  |
                             3219 ; 337  |#define SPACE_CHAR 0x000020          
                             3220 ; 338  |#define ZERO_CHAR 0x000030
                             3221 ; 339  |#define COLON_CHAR 0x00003A
                             3222 ; 340  |#define PERIOD_CHAR 0x00002E
                             3223 ; 341  |
                             3224 ; 342  |#if (defined(S6B33B0A_LCD))
                             3225 ; 343  |#define LCD_X_SIZE 128
                             3226 ; 344  |#define LCD_Y_SIZE 159
                             3227 ; 345  |#endif
                             3228 ; 346  |
                             3229 ; 347  |#if (defined(SED15XX_LCD))
                             3230 ; 348  |#define LCD_X_SIZE 128
                             3231 ; 349  |#define LCD_Y_SIZE 64
                             3232 ; 350  |#endif
                             3233 ; 351  |
                             3234 ; 352  |
                             3235 ; 353  |//////////////////////////////////////////////////////////////////////////////////
                             3236 ; 354  |//   Details on Customizing Contrast
                             3237 ; 355  |/////////////////////////////////////////////////////////////////////////////////
                             3238 ; 356  |//   Max supported LCD range is 0 - 3F; however due to hardware/voltage differences
                             3239 ; 357  |//   the range of visibility is usually smaller than this.  It is important to 
                             3240 ; 358  |//   calibrate the visible range, because the contrast setting is saved.
                             3241 ; 359  |//   If the user shuts off the player while lcd is not visible, the player is useless
                             3242 ; 360  |//   unless the ezact sequence is remembered.
                             3243 ; 361  |//   To find out what range your player supports: 
                             3244 ; 362  |//   change these equs to full range or comment out (full range is default)
                             3245 ; 363  |//;;;;;;
                             3246 ; 364  |// uncomment the line below to build code that will provide raw contrast value
                             3247 ; 365  |// recommended calibration using player -- uncomment 
                             3248 ; 366  |//;;;;;;
                             3249 ; 367  |//CONTRAST_CALIBRATION    equ  1
                             3250 ; 368  |////////////////////////////
                             3251 ; 369  |#if (defined(DEMO_HW))
                             3252 ; 370  |// this is the setting for ET301 demos; Next 2 line have not been updated for new Shingyi LCD (June6'05)
                             3253 ; 371  |#define LCD_MAX_CONTRAST 0x32 
                             3254 ; 372  |#define LCD_MIN_CONTRAST 0x1E
                             3255 ; 373  |#else 
                             3256 ; 374  |
                             3257 ; 375  |#if (defined(S6B33B0A_LCD))
                             3258 ; 376  |#define LCD_MAX_CONTRAST 210
                             3259 ; 377  |#define LCD_MIN_CONTRAST 160    
                             3260 ; 378  |#endif
                             3261 ; 379  |
                             3262 ; 380  |#if (defined(SED15XX_LCD))
                             3263 ; 381  |// Next 3 line comment was for OLD shingyi LCD: (default LCD before sdk2.6)
                             3264 ; 382  |// Engineering board regs support range [17-37].
                             3265 ; 383  |//   Engineering board DC/DC support range [24-46]. 
                             3266 ; 384  |//   One default contrast range [24-42] works for both.
                             3267 ; 385  |// The 3 sets of contrast ranges below are updated for SDK2.6 to support either 
                             3268 ; 386  |// new or old ShingYih LCDs. "File" refers to \resource\shingyih\system_lcd_init_seq.src
                             3269 ; 387  |// 3/10/05 - Use one of the 2 next contrast ranges depending on which
                             3270 ; 388  |// ShingYih LCD you have.  See \resources\shingyi\readme.txt 
                             3271 ; 389  |// Optimal for NEW LCD with NEW file (SDK2.6 default)  
                             3272 ; 390  |// G098064-41 LCD module (present on engr board revH LCD card)
                             3273 ; 391  |
                             3274 ; 392  |#if (defined(NEWSHINGYIH))
                             3275 ; 393  |#define LCD_MAX_CONTRAST 250
                             3276 ; 394  |#define LCD_MIN_CONTRAST 0
                             3277 ; 395  |#else 
                             3278 ; 396  |//-----
                             3279 ; 397  |// Near optimal for OLD LCD with NEW file. 
                             3280 ; 398  |// NOT optimal for the new lcd but pretty good. So u may use this if u want 1 build for both LCDs.
                             3281 ; 399  |#define LCD_MAX_CONTRAST 250
                             3282 ; 400  |#define LCD_MIN_CONTRAST 0
                             3283 ; 401  |
                             3284 ; 402  |//=====
                             3285 ; 403  |// Optimal for OLD ShingYih LCD with OLD file (as sdk2.521)
                             3286 ; 404  |// Suggest going with default new init file & values above for your LCD instead of this historic ver.
                             3287 ; 405  |//LCD_MAX_CONTRAST equ 42
                             3288 ; 406  |//LCD_MIN_CONTRAST equ 24 
                             3289 ; 407  |
                             3290 ; 408  |#endif
                             3291 ; 409  |#endif
                             3292 ; 410  |
                             3293 ; 411  |#endif
                             3294 ; 412  |
                             3295 ; 413  |//////////////////////////////////////////////////////////////////////////////////
                             3296 ; 414  |// The default value of the lcd contrast in % of range
                             3297 ; 415  |//   the default value is used when no settings.dat is available
                             3298 ; 416  |//////////////////////////////////////////////////////////////////////////////////
                             3299 ; 417  |
                             3300 ; 418  |#if (defined(S6B33B0A_LCD))
                             3301 ; 419  |// 60% of range is default value
                             3302 ; 420  |#define DEFAULT_CONTRAST 50 
                             3303 ; 421  |#endif
                             3304 ; 422  |
                             3305 ; 423  |#if (defined(SED15XX_LCD))
                             3306 ; 424  |// % of range is default value (was 60%)
                             3307 ; 425  |#define DEFAULT_CONTRAST 50 
                             3308 ; 426  |#endif
                             3309 ; 427  |
                             3310 ; 428  |
                             3311 ; 429  |// percentage change per increment/decrement message (LCD_DEC_CONTRAST/LCD_INC_CONTRAST)
                             3312 ; 430  |// make lower when doing calibration
                             3313 ; 431  |#define LCD_STEPSIZE_CONTRAST 10  
                             3314 ; 432  |
                             3315 ; 433  |
                             3316 ; 434  |/////////////////////////////////////////////////////////////////////////////////
                             3317 ; 435  |// For FFWD and RWND
                             3318 ; 436  |/////////////////////////////////////////////////////////////////////////////////
                             3319 ; 437  |#define SECONDS_TO_SKIP 1
                             3320 ; 438  |#define SECONDS_TO_SKIP1 3
                             3321 ; 439  |#define SECONDS_TO_SKIP2 6
                             3322 ; 440  |// number of seconds to cause reset to begin of song for PREV push
                             3323 ; 441  |#define PREV_SONG_THRESHOLD 5  
                             3324 ; 442  |// number of 300 mSec periods before the numbers of seconds to skip increases
                             3325 ; 443  |#define FIRST_TIME_BOUNDARY 15 
                             3326 ; 444  |// number of 300 mSec periods before the numbers of seconds to skip increases
                             3327 ; 445  |#define SECOND_TIME_BOUNDARY 30 
                             3328 ; 446  |
                             3329 ; 447  |// For audible FFW/RWD
                             3330 ; 448  |#define SECONDS_TO_SKIP_FOR_3X_RATE 1
                             3331 ; 449  |#define SECONDS_TO_SKIP_FOR_60X_RATE 18
                             3332 ; 450  |#define SECONDS_TO_SKIP_FOR_600X_RATE 180
                             3333 ; 451  |#define SECONDS_TO_SKIP_FOR_1800X_RATE 540
                             3334 ; 452  |// number of 300 mSec periods before the numbers of seconds to skip increases
                             3335 ; 453  |#define LEVEL1_BOUNDARY 17 
                             3336 ; 454  |// number of 300 mSec periods before the numbers of seconds to skip increases
                             3337 ; 455  |#define LEVEL2_BOUNDARY 33 
                             3338 ; 456  |// number of 300 mSec periods before the numbers of seconds to skip increases
                             3339 ; 457  |#define LEVEL3_BOUNDARY 50 
                             3340 ; 458  |// Stmp00010296 Ticket #71685:  for song shorter than the min. skip size
                             3341 ; 459  |// if song_time < skip_size, bCurrentSongShort=>TRUE (ignore FWD/RWD commands)
                             3342 ; 460  |// Short Song Time, songs too short to play.
                             3343 ; 461  |#define SHORT_SONG_TIME SECONDS_TO_SKIP         
                             3344 ; 462  |
                             3345 ; 463  |/////////////////////////////////////////////////////////////////////////////////
                             3346 ; 464  |// MP3 Sync Values
                             3347 ; 465  |/////////////////////////////////////////////////////////////////////////////////
                             3348 ; 466  |// # bytes to look for sync before marking it bad
                             3349 ; 467  |#define MP3_SYNC_THRESHOLD 70000 
                             3350 ; 468  |// # bytes to look for sync before slowing decoder isr frequency (to let menus run)
                             3351 ; 469  |#define MP3_SYNC_THRESHOLD1 10000 
                             3352 ; 470  |// once we have sync'd, the isr should be called this frequently
                             3353 ; 471  |#define MP3_DECODERISR_FAST 7500  
                             3354 ; 472  |// if decoder is having difficulty syncing, switch isr to be called less frequently
                             3355 ; 473  |#define MP3_DECODERISR_SLOW 50000 
                             3356 ; 474  |
                             3357 ; 475  |
                             3358 ; 476  |/////////////////////////////////////////////////////////////////////////////////
                             3359 ; 477  |//// Multi-Stage Volume Control Definitions
                             3360 ; 478  |/////////////////////////////////////////////////////////////////////////////////
                             3361 ; 479  |//// Use Multi-Stage Volume
                             3362 ; 480  |#define MULTI_STAGE_VOLUME 0x1                  
                             3363 ; 481  |
                             3364 ; 482  |//// Master Volume definitions
TASKING DSP2410 assembler v1.5r1 Build 138 SN 00100122
                                                                                                                                                                                                                                                       Page  14

M:ADDR CODE           CYCLES LINE SOURCELINE
                             3365 ; 483  |#define MIX_MSTR_MAX_VOL 0x0
                             3366 ; 484  |#define NUM_MSTR_ATT_STEPS (0x1F-MIX_MSTR_MAX_VOL)
                             3367 ; 485  |
                             3368 ; 486  |//// DAC-Mode definitions
                             3369 ; 487  |//// Adjusts 0dB point
                             3370 ; 488  |#define MIX_DAC_NOM_VOL 0x6                  
                             3371 ; 489  |#define MIX_DAC_MIN_VOL 0x1F
                             3372 ; 490  |// For minimum clipping: Set MIX_DAC_MAX_VOL below to match MIX_DAC_NOM_VOL value 2 lines above.
                             3373 ; 491  |// For additional gain (with possible clipping): Set MIX_DAC_MAX_VOL in range below. 
                             3374 ; 492  |//                                               Each integer below MIX_DAC_NOM_VOL provides 1.5 dB gain on Stmp34x0; 
                             3375 ; 493  |//                                               Max gain possible: 8 step diff would provide +12dB gain.   
                             3376 ; 494  |// range: [0 to MIX_DAC_NOM_VOL] (0 for loudest volume)
                             3377 ; 495  |#define MIX_DAC_MAX_VOL 0x0  
                             3378 ; 496  |
                             3379 ; 497  |#define NUM_DAC_ATT_STEPS (MIX_DAC_MIN_VOL-MIX_DAC_NOM_VOL+1)
                             3380 ; 498  |#define NUM_DAC_GAIN_STEPS (MIX_DAC_NOM_VOL-MIX_DAC_MAX_VOL)
                             3381 ; 499  |#define NUM_DAC_MODE_VOL_STEPS (NUM_DAC_ATT_STEPS+NUM_MSTR_ATT_STEPS+NUM_DAC_GAIN_STEPS+1)
                             3382 ; 500  |
                             3383 ; 501  |//// If there is no stored volume, set to 50% of DAC-Mode max; change if DAC Mode is not the default
                             3384 ; 502  |//// STMP35xx has 2dB attenuation per step so default needs a few more steps above midpoint.
                             3385 ; 503  |#define DEFAULT_VOLUME ((NUM_DAC_MODE_VOL_STEPS/2)+6)         
                             3386 ; 504  |
                             3387 ; 505  |//// Set maximum restored volume to 75% of DAC-Mode max; change if DAC Mode is not the default
                             3388 ; 506  |#define MAX_RESTORED_VOLUME ((3*NUM_DAC_MODE_VOL_STEPS)/4)   
                             3389 ; 507  |
                             3390 ; 508  |
                             3391 ; 509  |//// Line In definitions (used for Line-In 1)
                             3392 ; 510  |//// 0dB point of the Line In
                             3393 ; 511  |#define MIX_LINE_NOM_VOL 0x8                  
                             3394 ; 512  |//// Minimum volume of Line In
                             3395 ; 513  |#define MIX_LINE_MIN_VOL 0x1F                 
                             3396 ; 514  |//// Maximum volume of Line In (can adjust extra gain)
                             3397 ; 515  |#define MIX_LINE_MAX_VOL 0x6                  
                             3398 ; 516  |#define NUM_LINE_ATT_STEPS (MIX_LINE_MIN_VOL-MIX_LINE_NOM_VOL+1)
                             3399 ; 517  |#define NUM_LINE_GAIN_STEPS (MIX_LINE_NOM_VOL-MIX_LINE_MAX_VOL)
                             3400 ; 518  |#define NUM_LINE_MODE_VOL_STEPS (NUM_LINE_ATT_STEPS+NUM_MSTR_ATT_STEPS+NUM_LINE_GAIN_STEPS+1)
                             3401 ; 519  |
                             3402 ; 520  |//// Line In definitions (used for FM tuner with 144 pin package)
                             3403 ; 521  |//// 0dB point of the Line In
                             3404 ; 522  |#define MIX_FM_NOM_VOL 0x8                  
                             3405 ; 523  |//// Minimum volume of Line In
                             3406 ; 524  |#define MIX_FM_MIN_VOL 0x1F                 
                             3407 ; 525  |//// Maximum volume of Line In (can adjust extra gain)
                             3408 ; 526  |#define MIX_FM_MAX_VOL 0x6                  
                             3409 ; 527  |#define NUM_FM_ATT_STEPS (MIX_FM_MIN_VOL-MIX_FM_NOM_VOL+1)
                             3410 ; 528  |#define NUM_FM_GAIN_STEPS (MIX_FM_NOM_VOL-MIX_FM_MAX_VOL)
                             3411 ; 529  |#define NUM_FM_MODE_VOL_STEPS (NUM_FM_ATT_STEPS+NUM_MSTR_ATT_STEPS+NUM_FM_GAIN_STEPS+1)
                             3412 ; 530  |
                             3413 ; 531  |/////////////////////////////////////////////////////////////////////////////////
                             3414 ; 532  |//// When enabled (1), periodically checks for one of several FM state machine invalid deadlock states & recovers. 
                             3415 ; 533  |//// Define as 0 to disable FM-deadlock-state checking and recovery.
                             3416 ; 534  |#define FM_WATCHDOG_ENABLE 1
                             3417 ; 535  |
                             3418 ; 536  |#if !defined(STMP_BUILD_PLAYER)
                             3419 ; 537  |////
                             3420 ; 538  |////! This varible holds the lcd display state for the mtp project.
                             3421 ; 539  |////
                             3422 ; 540  |///
                             3423 ; 541  |#include <types.h>
                             3424 ; 542  |extern volatile WORD g_wActivityState;
                             3425 ; 543  |#endif // if !@def('STMP_BUILD_PLAYER')
                             3426 ; 544  |
                             3427 ; 545  |void _reentrant Init5VSense(void);
                             3428 ; 546  |void _reentrant ServiceDCDC(void);
                             3429 ; 547  |
                             3430 ; 548  |////////////////////////////////////////////////////////////////////////////
                             3431 ; 549  |//// JPEG Thumbnail Mode Setting
                             3432 ; 550  |//// number of column in thumbnail mode
                             3433 ; 551  |#define THUMBNAIL_X 2           
                             3434 ; 552  |//// number of row in  thumbnail mode
                             3435 ; 553  |#define THUMBNAIL_Y 2           
                             3436 ; 554  |//// thumbnail boundary offset x
                             3437 ; 555  |#define THUMBNAIL_X_OFFSET 4            
                             3438 ; 556  |//// thumbnail boundary offset y
                             3439 ; 557  |#define THUMBNAIL_Y_OFFSET 4            
                             3440 ; 558  |
                             3441 ; 559  |#endif // if (!@def(_PROJECT_INC))
                             3442 ; 560  |
                             3443 
                             3445 
                             3446 ; 23   |
                             3447 ; 24   |#define MAX_BITMAP_SIZE 10000
                             3448 ; 25   |
                             3449 ; 26   |//comment this out to put the frame buffer in Y
                             3450 ; 27   |
                             3451 ; 28   |#ifndef LCD_X_SIZE     
                             3452 ; 29   |#define LCD_X_SIZE          98
                             3453 ; 30   |#endif
                             3454 ; 31   |
                             3455 ; 32   |#ifndef LCD_Y_SIZE
                             3456 ; 33   |#define LCD_Y_SIZE          64
                             3457 ; 34   |#endif
                             3458 ; 35   |
                             3459 ; 36   |#define BITMAP_MEMORY_SPACE TARGET_MEM_Y
                             3460 ; 37   |
                             3461 ; 38   |typedef union
                             3462 ; 39   |{
                             3463 ; 40   |    struct
                             3464 ; 41   |    {
                             3465 ; 42   |        INT m_Resource:21;
                             3466 ; 43   |        INT m_Type :3;
                             3467 ; 44   |    } Complex;
                             3468 ; 45   |    WORD I;
                             3469 ; 46   |} COMPLEX_RESOURCE;
                             3470 ; 47   |
                             3471 ; 48   |#define RESOURCE_TYPE_SIMPLE    0
                             3472 ; 49   |#define RESOURCE_TYPE_NESTED    1
                             3473 ; 50   |#define RESOURCE_TYPE_UNICODE   2
                             3474 ; 51   |
                             3475 ; 52   |
                             3476 ; 53   |typedef struct 
                             3477 ; 54   |{
                             3478 ; 55   |    INT m_iMaskLeft;
                             3479 ; 56   |    INT m_iMaskTop;
                             3480 ; 57   |    INT m_iMaskRight;
                             3481 ; 58   |    INT m_iMaskBottom;
                             3482 ; 59   |}   MASK;
                             3483 ; 60   |
                             3484 ; 61   |typedef struct 
                             3485 ; 62   |{
                             3486 ; 63   |    INT m_iWidth;
                             3487 ; 64   |    INT m_iHeight;
                             3488 ; 65   |    WORD m_wBitmap[MAX_BITMAP_SIZE];
                             3489 ; 66   |} BITMAP;
                             3490 ; 67   |
                             3491 ; 68   |
                             3492 ; 69   |typedef struct 
                             3493 ; 70   |{
                             3494 ; 71   |    INT m_iWidth;
                             3495 ; 72   |    INT m_iHeight;
                             3496 ; 73   |} BITMAPHEADER;
                             3497 ; 74   |
                             3498 ; 75   |#define DISPLAY_NORMAL  0
                             3499 ; 76   |#define DISPLAY_INVERT  1
                             3500 ; 77   |#define DISPLAY_CLEAR   2 
                             3501 ; 78   |
                             3502 ; 79   |void _reentrant DisplayInit(void);
                             3503 ; 80   |
                             3504 ; 81   |
                             3505 ; 82   |_reentrant void DisplayHandleMessage(Message *);
                             3506 ; 83   |
                             3507 ; 84   |_reentrant void DisplayUpdateDisplay(void);
                             3508 ; 85   |
                             3509 ; 86   |_reentrant void DisplayClearRange           (INT  x,INT  y,WORD cx         ,WORD cy    );
                             3510 ; 87   |_reentrant void DisplayPrintBitmapResource  (INT  x,INT  y,WORD wResource  ,INT bInvert);
                             3511 ; 88   |_reentrant void DisplayPrintStringResource  (INT  x,INT  y,WORD wResource  ,INT bInvert);
                             3512 ; 89   |_reentrant void DisplayPrintStringAddress   (INT  x,INT  y,void *pAddress  ,INT bInvert);
                             3513 ; 90   |_reentrant void DisplaySetFont(INT);
                             3514 ; 91   |_reentrant void DisplayPrintBitmapAddress(INT x,INT y,BITMAP *pBitmap,INT bInvert);
                             3515 
                             3522 
                             3523 ; 92   |_reentrant void DisplayPrintStringAddressUnicode   (INT x,INT y,void *pAddress ,INT bInvert);
                             3524 ; 93   |_reentrant void DisplayPrintStringResourceUnicode  (INT x,INT y,WORD wResource,INT bInvert);
                             3525 ; 94   |_reentrant void DisplayPrintNumber  (INT x,INT y,INT iNumber    ,INT iDigits    ,INT iFiller    ,INT bInvert);
                             3526 ; 95   |_reentrant void DisplayPrintTime    (INT x,INT y,INT iMinutes   ,INT iSeconds                   ,INT bInvert);
                             3527 ; 96   |_reentrant void DisplayPrintLongTime(INT x,INT y,INT iHours     ,INT iMinutes   ,INT iSeconds   ,INT bInvert);
                             3528 ; 97   |_reentrant void DisplaySetFont(INT iFont);
                             3529 ; 98   |_reentrant int DisplayPrintCharUnicode   (INT  x,INT y,WORD wChar,INT bInvert);
                             3530 ; 99   |
                             3531 ; 100  |
                             3532 ; 101  |#endif
                             3533 
                             3535 
                             3536 ; 18   |#include "sal\display_sal.h"
                             3537 
                             3539 
                             3540 ; 1    |#ifndef __DISPLAY_SAL_H
                             3541 ; 2    |#define __DISPLAY_SAL_H
                             3542 ; 3    |
                             3543 ; 4    |_reentrant void SALDisplayClearRange(INT x,INT y,WORD iSourceWidth,WORD iSourceHeight);
                             3544 ; 5    |_reentrant void SALDisplayPrintBitmapAddress   (INT x,INT y,void _Y *pAddress ,INT bInvert);
                             3545 ; 6    |_reentrant void SALHandleMessage(Message  *pMsg);
                             3546 ; 7    |_reentrant void SALDisplayUpdate(void);
                             3547 ; 8    |_reentrant void SALDisplayInit(void );
                             3548 ; 9    |
                             3549 ; 10   |_reentrant INT SALDisplayGetWidth(void);
                             3550 ; 11   |_reentrant INT SALDisplayGetHeight(void);
                             3551 ; 12   |
                             3552 ; 13   |
                             3553 ; 14   |#endif
                             3554 
                             3556 
                             3557 ; 19   |#include "displaydriver.h"
                             3558 
                             3560 
                             3561 ; 1    |#ifndef _DISPLAY_DRIVER_H
                             3562 ; 2    |#define _DISPLAY_DRIVER_H
                             3563 ; 3    |
                             3564 ; 4    |//currently, framebuffer only works when located in the Y memory space.
                             3565 ; 5    |#include "types.h"
                             3566 
                             3568 
                             3569 ; 1    |////////////////////////////////////////////////////////////////////////////////
                             3570 ; 2    |// Copyright(C) SigmaTel, Inc. 2000-2004
                             3571 ; 3    |//
                             3572 ; 4    |// Filename: types.h
                             3573 ; 5    |// Description: Standard data types
                             3574 ; 6    |////////////////////////////////////////////////////////////////////////////////
                             3575 ; 7    |
                             3576 ; 8    |#ifndef _TYPES_H
                             3577 ; 9    |#define _TYPES_H
                             3578 ; 10   |
                             3579 ; 11   |// TODO:  move this outta here!
                             3580 ; 12   |#if !defined(NOERROR)
                             3581 ; 13   |#define NOERROR 0
                             3582 ; 14   |#define SUCCESS 0
                             3583 ; 15   |#endif 
                             3584 ; 16   |#if !defined(SUCCESS)
                             3585 ; 17   |#define SUCCESS  0
                             3586 ; 18   |#endif
                             3587 ; 19   |#if !defined(ERROR)
                             3588 ; 20   |#define ERROR   -1
                             3589 ; 21   |#endif
                             3590 ; 22   |#if !defined(FALSE)
                             3591 ; 23   |#define FALSE 0
                             3592 ; 24   |#endif
                             3593 ; 25   |#if !defined(TRUE)
                             3594 ; 26   |#define TRUE  1
                             3595 ; 27   |#endif
                             3596 ; 28   |
                             3597 ; 29   |#if !defined(NULL)
                             3598 ; 30   |#define NULL 0
                             3599 ; 31   |#endif
                             3600 ; 32   |
                             3601 ; 33   |#define MAX_INT     0x7FFFFF
                             3602 ; 34   |#define MAX_LONG    0x7FFFFFffffff
                             3603 ; 35   |        // max positive unsigned long value: -1 == 0xFFFFFFffffff
                             3604 ; 36   |#define MAX_ULONG   (-1) 
                             3605 ; 37   |
                             3606 ; 38   |#define WORD_SIZE   24              // word size in bits
                             3607 ; 39   |#define BYTES_PER_WORD 3            // 8 bit bytes
                             3608 ; 40   |
                             3609 ; 41   |
                             3610 ; 42   |#define BYTE    unsigned char       // btVarName
                             3611 ; 43   |#define CHAR    signed char         // cVarName
                             3612 ; 44   |#define USHORT  unsigned short      // usVarName
                             3613 ; 45   |#define SHORT   unsigned short      // sVarName
                             3614 ; 46   |#define WORD    unsigned int        // wVarName
                             3615 ; 47   |#define INT     signed int          // iVarName
                             3616 ; 48   |#define DWORD   unsigned long       // dwVarName
                             3617 ; 49   |#define LONG    signed long         // lVarName
                             3618 ; 50   |#define BOOL    unsigned int        // bVarName
                             3619 ; 51   |#define FRACT   _fract              // frVarName
                             3620 ; 52   |#define LFRACT  long _fract         // lfrVarName
                             3621 ; 53   |#define CIRC    _circ               // cp<type prefix>VarName (see below)
                             3622 ; 54   |#define FLOAT   float               // fVarName
                             3623 ; 55   |#define DBL     double              // dVarName
                             3624 ; 56   |#define ENUM    enum                // eVarName
                             3625 ; 57   |#define CMX     _complex            // cmxVarName
                             3626 ; 58   |typedef WORD UCS3;                   // 
                             3627 ; 59   |
TASKING DSP2410 assembler v1.5r1 Build 138 SN 00100122
                                                                                                                                                                                                                                                       Page  15

M:ADDR CODE           CYCLES LINE SOURCELINE
                             3628 ; 60   |#define UINT16  unsigned short
                             3629 ; 61   |#define UINT8   unsigned char   
                             3630 ; 62   |#define UINT32  unsigned long
                             3631 ; 63   |#define UINT64  unsigned long   // need to figure out how to do 64 bit values.  Or port exisiting code to only use 48 bit
                             3632 ; 64   |#define INT64   unsigned long   // need to figure out how to do 64 bit values.  Or port exisiting code to only use 48 bit
                             3633 ; 65   |#define WCHAR   UINT16
                             3634 ; 66   |
                             3635 ; 67   |//UINT128 is 16 bytes or 6 words
                             3636 ; 68   |typedef struct UINT128_3500 {   
                             3637 ; 69   |    int val[6];     
                             3638 ; 70   |} UINT128_3500;
                             3639 ; 71   |
                             3640 ; 72   |#define UINT128   UINT128_3500
                             3641 ; 73   |
                             3642 ; 74   |// Little endian word packed byte strings:   
                             3643 ; 75   |//      _packed BYTE bTextVarName[]="a string";  bText is a packed byte string prefix
                             3644 ; 76   |// Convert to big endian words by reordering bytes from high to low using swizzle.
                             3645 ; 77   |// Little endian word packed byte strings:   
                             3646 ; 78   |//      _packed BYTE bTextVarName[]="a string";  bText is a packed byte string prefix
                             3647 ; 79   |// Convert to big endian words by reordering bytes from high to low using swizzle.
                             3648 ; 80   |
                             3649 ; 81   |// Declare Memory Spaces To Use When Coding
                             3650 ; 82   |// A. Sector Buffers
                             3651 ; 83   |#define SECTOR_BUFFER_MEM_X _X
                             3652 ; 84   |#define SECTOR_BUFFER_MEM_Y _Y
                             3653 ; 85   |#define SECTOR_BUFFER_MEM SECTOR_BUFFER_MEM_X
                             3654 ; 86   |typedef WORD SECTOR_BUFFER_MEM SECTOR_BUFFER;
                             3655 ; 87   |typedef SECTOR_BUFFER * P_SECTOR_BUFFER;
                             3656 ; 88   |// B. Media DDI Memory
                             3657 ; 89   |#define MEDIA_DDI_MEM _Y
                             3658 ; 90   |
                             3659 ; 91   |
                             3660 ; 92   |
                             3661 ; 93   |// Pointers to linear structures are labeled as: p<type prefix>VarName
                             3662 ; 94   |// Examples of circular pointers:
                             3663 ; 95   |//    INT CIRC cpiVarName
                             3664 ; 96   |//    DWORD CIRC cpdwVarName
                             3665 ; 97   |
                             3666 ; 98   |#define RETCODE INT                 // rcVarName
                             3667 ; 99   |
                             3668 ; 100  |// generic bitfield structure
                             3669 ; 101  |struct Bitfield {
                             3670 ; 102  |    unsigned int B0  :1;
                             3671 ; 103  |    unsigned int B1  :1;
                             3672 ; 104  |    unsigned int B2  :1;
                             3673 ; 105  |    unsigned int B3  :1;
                             3674 ; 106  |    unsigned int B4  :1;
                             3675 ; 107  |    unsigned int B5  :1;
                             3676 ; 108  |    unsigned int B6  :1;
                             3677 ; 109  |    unsigned int B7  :1;
                             3678 ; 110  |    unsigned int B8  :1;
                             3679 ; 111  |    unsigned int B9  :1;
                             3680 ; 112  |    unsigned int B10 :1;
                             3681 ; 113  |    unsigned int B11 :1;
                             3682 ; 114  |    unsigned int B12 :1;
                             3683 ; 115  |    unsigned int B13 :1;
                             3684 ; 116  |    unsigned int B14 :1;
                             3685 ; 117  |    unsigned int B15 :1;
                             3686 ; 118  |    unsigned int B16 :1;
                             3687 ; 119  |    unsigned int B17 :1;
                             3688 ; 120  |    unsigned int B18 :1;
                             3689 ; 121  |    unsigned int B19 :1;
                             3690 ; 122  |    unsigned int B20 :1;
                             3691 ; 123  |    unsigned int B21 :1;
                             3692 ; 124  |    unsigned int B22 :1;
                             3693 ; 125  |    unsigned int B23 :1;
                             3694 ; 126  |};
                             3695 ; 127  |
                             3696 ; 128  |union BitInt {
                             3697 ; 129  |        struct Bitfield B;
                             3698 ; 130  |        int        I;
                             3699 ; 131  |};
                             3700 ; 132  |
                             3701 ; 133  |#define MAX_MSG_LENGTH 10
                             3702 ; 134  |struct CMessage
                             3703 ; 135  |{
                             3704 ; 136  |        unsigned int m_uLength;
                             3705 ; 137  |        unsigned int m_uMsg[MAX_MSG_LENGTH];
                             3706 ; 138  |};
                             3707 ; 139  |
                             3708 ; 140  |typedef struct {
                             3709 ; 141  |    WORD m_wLength;
                             3710 ; 142  |    WORD m_wMessage;
                             3711 ; 143  |    WORD m_wParams[MAX_MSG_LENGTH];
                             3712 ; 144  |} Message;
                             3713 ; 145  |
                             3714 ; 146  |struct MessageQueueDescriptor
                             3715 ; 147  |{
                             3716 ; 148  |        int *m_pBase;
                             3717 ; 149  |        int m_iModulo;
                             3718 ; 150  |        int m_iSize;
                             3719 ; 151  |        int *m_pHead;
                             3720 ; 152  |        int *m_pTail;
                             3721 ; 153  |};
                             3722 ; 154  |
                             3723 ; 155  |struct ModuleEntry
                             3724 ; 156  |{
                             3725 ; 157  |    int m_iSignaledEventMask;
                             3726 ; 158  |    int m_iWaitEventMask;
                             3727 ; 159  |    int m_iResourceOfCode;
                             3728 ; 160  |    struct MessageQueueDescriptor *m_pMessageQueue;
                             3729 ; 161  |    int _asmfunc (*m_pProcessEntryPoint)(union WaitMask Signals,struct MessageQueueDescriptor *);
                             3730 ; 162  |    int _asmfunc (*m_pInitFunction)(struct MessageQueueDescriptor *);
                             3731 ; 163  |    int m_uTimeOutHigh;
                             3732 ; 164  |    int m_uTimeOutLow;
                             3733 ; 165  |    int _asmfunc (*m_pBackgroundFunction)(struct MessageQueueDescriptor *);
                             3734 ; 166  |};
                             3735 ; 167  |
                             3736 ; 168  |union WaitMask{
                             3737 ; 169  |    struct B{
                             3738 ; 170  |        unsigned int m_bNone     :1;
                             3739 ; 171  |        unsigned int m_bMessage  :1;
                             3740 ; 172  |        unsigned int m_bTimer    :1;
                             3741 ; 173  |        unsigned int m_bButton   :1;
                             3742 ; 174  |    } B;
                             3743 ; 175  |    int I;
                             3744 ; 176  |} ;
                             3745 ; 177  |
                             3746 ; 178  |
                             3747 ; 179  |struct Button {
                             3748 ; 180  |        WORD wButtonEvent;
                             3749 ; 181  |        WORD wUnused[MAX_MSG_LENGTH];   
                             3750 ; 182  |};
                             3751 ; 183  |
                             3752 ; 184  |struct Message {
                             3753 ; 185  |        WORD wMsgLength;
                             3754 ; 186  |        WORD wMsgCommand;
                             3755 ; 187  |        WORD wMsgParms[MAX_MSG_LENGTH-1];
                             3756 ; 188  |};
                             3757 ; 189  |
                             3758 ; 190  |union EventTypes {
                             3759 ; 191  |        struct CMessage msg;
                             3760 ; 192  |        struct Button Button ;
                             3761 ; 193  |        struct Message Message;
                             3762 ; 194  |};
                             3763 ; 195  |
                             3764 ; 196  |// next 2 used to get updater build to return correct protocol ver in scsi response.
                             3765 ; 197  |#define BUILD_TYPE_UPDATER  0x100
                             3766 ; 198  |#define BUILD_TYPE_HOSTLINK 0x101
                             3767 ; 199  |#define BUILD_TYPE_PLAYER   0x102
                             3768 ; 200  |
                             3769 ; 201  |// Resets part if RETAIL build. DEBUG build executes debug instruction to halt.
                             3770 ; 202  |#define SystemHalt() __asm(" include 'sysmacro.asm' \n error") 
                             3771 ; 203  |#define assert(x)    if(!(x)) __asm(" include 'sysmacro.asm' \n error")
                             3772 ; 204  |
                             3773 ; 205  |#if DEBUG
                             3774 ; 206  |// For DEBUG builds, DebugBuildAssert(condition) halts if condition evaluates to FALSE. 
                             3775 ; 207  |#define DebugBuildAssert(x)    if(!(x)) __asm(" debug ")
                             3776 ; 208  |#else 
                             3777 ; 209  |// For RETAIL builds, DebugBuildAssert(condition) does nothing & execution continues rather than halt or reset. 
                             3778 ; 210  |#define DebugBuildAssert(x)    
                             3779 ; 211  |#endif
                             3780 ; 212  |
                             3781 ; 213  |// Do this in your C files to make a reminder that's displayed during the build.
                             3782 ; 214  |//  #pragma asm
                             3783 ; 215  |//  WARN 'Note to builder: reminder to do this after verifying that'
                             3784 ; 216  |//  #pragma endasm
                             3785 ; 217  |
                             3786 ; 218  |
                             3787 ; 219  |#ifdef COLOR_262K
                             3788 ; 220  |#define RGB(r,g,b)    ((0x0000FC & (r)) << 10) | ((0x0000FC & (g)) << 4) | ((0x0000FC & (b)) >> 2)    //262k
                             3789 ; 221  |#elif defined(COLOR_65K)
                             3790 ; 222  |#define RGB(r,g,b)    ((0x0000F8 & (r)) << 8) | ((0x0000FC & (g)) << 3) | ((0x0000F8 & (b)) >> 3)  //65k
                             3791 ; 223  |#else
                             3792 ; 224  |#define RGB(r,g,b)       ((0x0000F0 & (r)) << 4) | (0x0000F0 & (g)) | ((0x0000F0 & (b)) >> 4)
                             3793 ; 225  |#endif
                             3794 ; 226  |    
                             3795 ; 227  |#endif // #ifndef _TYPES_H
                             3796 
                             3798 
                             3799 ; 6    |
                             3800 ; 7    |_reentrant void HALDisplayInit(void);
                             3801 ; 8    |_reentrant void HALDisplaySendCommand(WORD wCommand);
                             3802 ; 9    |_reentrant void HALDisplaySendData(WORD wPage, WORD wColumn, WORD wCount, WORD wByteIndex,WORD* pBuffer, WORD wDisplayOperation);
                             3803 ; 10   |_reentrant void HALDisplaySetContrast(INT iContrast);
                             3804 ; 11   |_reentrant void HALDisplayDecContrast(void);
                             3805 ; 12   |_reentrant void HALDisplayIncContrast(void);
                             3806 ; 13   |_reentrant void HALHandleMessage(Message *pMsg);
                             3807 ; 14   |
                             3808 ; 15   |
                             3809 ; 16   |
                             3810 ; 17   |
                             3811 ; 18   |#endif
                             3812 
                             3814 
                             3815 ; 20   |#include "unicode.h"
                             3816 
                             3818 
                             3819 ; 1    |#ifndef UNICODE_H
                             3820 ; 2    |#define UNICODE_H
                             3821 ; 3    |
                             3822 ; 4    |//#include "displaydrv.h"
                             3823 ; 5    |
                             3824 ; 6    |// Exported functions
                             3825 ; 7    |_reentrant BITMAP *  GetUnicodeCharacterBitmap(WORD c) ;
                             3826 ; 8    |
                             3827 ; 9    |void _reentrant CLcdPrintStringAddress(WORD x, WORD y, WORD *string, WORD bInverted);
                             3828 ; 10   |#ifndef USBMSC_BUILD
                             3829 ; 11   |void _reentrant LCDSetFont(WORD fontNum);
                             3830 ; 12   |#else
                             3831 ; 13   |void LCDSetFont(WORD fontNum);
                             3832 ; 14   |#endif
                             3833 ; 15   |
                             3834 ; 16   |#endif
                             3835 
                             3837 
                             3838 ; 21   |#include "dbcs.h"
                             3839 
                             3841 
                             3842 ; 1    |#ifndef DBCS_H
                             3843 ; 2    |#define DBCS_H
                             3844 ; 3    |
                             3845 ; 4    |
                             3846 ; 5    |_reentrant void DBCSToUnicode(_packed unsigned char *pDBCS, WORD *pUnicode,INT iLength);
                             3847 ; 6    |_reentrant void DBCSToUnicodeDstXSrcY(_packed unsigned char *pDBCS, WORD _X * _X pUnicode, INT iLength);
                             3848 ; 7    |
                             3849 ; 8    |#endif
                             3850 
                             3852 
                             3853 ; 22   |
                             3854 ; 23   |#define MAX_MASKS 5
                             3855 ; 24   |#define MAX_DIGITS 10
                             3856 ; 25   |
                             3857 ; 26   |INT g_iMaskLeft;
                             3858 ; 27   |INT g_iMaskRight;
                             3859 ; 28   |INT g_iMaskTop;
                             3860 ; 29   |INT g_iMaskBottom;
                             3861 ; 30   |
                             3862 ; 31   |_reentrant void PushMask(INT left, INT top, INT right, INT bottom);
                             3863 ; 32   |_reentrant void PopMask(void);
                             3864 
                             3871 
                             3872 ; 33   |
                             3873 ; 34   |
                             3874 ; 35   |
                             3875 ; 36   |MASK g_MaskStack[MAX_MASKS]={{0,0,LCD_X_SIZE,LCD_Y_SIZE}};
                             3876 
                             3877 
Y:0000                       3878         org     y,".ydatadisplaydrv",init:
                             3879 Fg_MaskStack:
Y:0000 000000 000000         3880         dc      $000000,$000000,$000080,$000040,$000000,$000000,$000000,$000000
       000080 000040              
       000000 000000              
       000000 000000              
Y:0008 000000 000000         3881         dc      $000000,$000000,$000000,$000000,$000000,$000000,$000000,$000000
       000000 000000              
       000000 000000              
       000000 000000              
Y:0010 000000 000000         3882         dc      $000000,$000000,$000000,$000000
       000000 000000              
                             3886 
TASKING DSP2410 assembler v1.5r1 Build 138 SN 00100122
                                                                                                                                                                                                                                                       Page  16

M:ADDR CODE           CYCLES LINE SOURCELINE
                             3887 ; 37   |g_iMaskStack=0;
                             3888 
                             3889 Fg_iMaskStack:
Y:0014 000000                3890         dc      $000000
                             3893 
                             3894 ; 38   |MASK *g_pMaskStack = g_MaskStack;
                             3895 
                             3896 Fg_pMaskStack:
Y:0015 rrrrrr                3897         dc      Fg_MaskStack
                             3902 
                             3903 ; 39   |
                             3904 ; 40   |_reentrant BITMAP *DisplayLoadBitmap(WORD iResource);
                             3905 ; 41   |
                             3906 ; 42   |
                             3907 ; 43   |_reentrant void EvaluateMask(void)
                             3908 ; 44   |{
                             3909 
P:0000                       3910         org     p,".ptextdisplaydrv":
                             3915 FEvaluateMask:
                             3921 
                             3922 ; 45   |    int i;
                             3923 ; 46   |    g_iMaskLeft = 0;
                             3924 
                             3928 
                             3929 ; 47   |    g_iMaskRight = SALDisplayGetWidth();
                             3930 
P:0000 055F7C         2    2 3916         movec   ssh,y:(r7)+
P:0001 2F0000         2    4 3926         move    #0,b
P:0002 5F7000 rrrrrr  3    7 3927         move    b,y:Fg_iMaskLeft
P:0004 0BF080 rrrrrr  6   13 3932         jsr     FSALDisplayGetWidth
                             3934 
                             3935 ; 48   |    g_iMaskTop = 0;
                             3936 
                             3940 
                             3941 ; 49   |    g_iMaskBottom = SALDisplayGetHeight();
                             3942 
P:0006 5E701B rrrrrr  3   16 3938         clr     b	                a,y:Fg_iMaskRight
P:0008 5F7000 rrrrrr  3   19 3939         move    b,y:Fg_iMaskTop
P:000A 0BF080 rrrrrr  6   25 3944         jsr     FSALDisplayGetHeight
                             3946 
                             3947 ; 50   |    for(i=0;i<g_iMaskStack;i++)
                             3948 
P:000C 65F400 rrrrrr  3   28 3952         move    #Fg_MaskStack,r5
P:000E 66F400 rrrrrr  3   31 3953         move    #Fg_MaskStack+1,r6
P:0010 270000         2   33 3950         move    #0,y1
P:0011 5E7000 rrrrrr  3   36 3945         move    a,y:Fg_iMaskBottom
P:0013 4DF000 rrrrrr  3   39 3954         move    y:Fg_iMaskStack,x1
P:0015 0AF080 rrrrrr  6   45 3955         jmp     L10
                             3956 
                             3957 ; 51   |    {
                             3958 ; 52   |        if(g_iMaskLeft < g_MaskStack[i].m_iMaskLeft)
                             3959 
P:0017 4CF000 rrrrrr  3   48 3961 L3:     move    y:Fg_iMaskLeft,x0
P:0019 0116C8         2   50 3962         mpy     y1,#22,b
P:001A 213D00         2   52 3963         move    b0,n5
P:001B 213B49         2   54 3966         tfr     x0,b	                b0,n3
P:001C 4EED00         4   58 3965         move    y:(r5+n5),y0
P:001D 20005D         2   60 3967         cmp     y0,b
P:001E 0AF0A1 rrrrrr  6   66 3968         jge     L4
                             3969 
                             3970 ; 53   |            g_iMaskLeft = g_MaskStack[i].m_iMaskLeft;
                             3971 
                             3974 
                             3975 ; 54   |        if(g_iMaskTop < g_MaskStack[i].m_iMaskTop)
                             3976 
P:0020 4E7000 rrrrrr  3   69 3973         move    y0,y:Fg_iMaskLeft
                             3978 L4:
P:0022 237E00         2   71 3979         move    n3,n6
P:0023 5FF000 rrrrrr  3   74 3978         move    y:Fg_iMaskTop,b
P:0025 4EEE00         4   78 3981         move    y:(r6+n6),y0
P:0026 20005D         2   80 3982         cmp     y0,b
P:0027 0AF0A1 rrrrrr  6   86 3983         jge     L5
                             3984 
                             3985 ; 55   |            g_iMaskTop = g_MaskStack[i].m_iMaskTop;
                             3986 
                             3989 
                             3990 ; 56   |        if(g_iMaskRight > g_MaskStack[i].m_iMaskRight)
                             3991 
P:0029 4E7000 rrrrrr  3   89 3988         move    y0,y:Fg_iMaskTop
                             3993 L5:
P:002B 64F400 rrrrrr  3   92 3994         move    #Fg_MaskStack+2,r4
P:002D 237C00         2   94 3995         move    n3,n4
P:002E 5FF000 rrrrrr  3   97 3993         move    y:Fg_iMaskRight,b
P:0030 4EEC00         4  101 3997         move    y:(r4+n4),y0
P:0031 20005D         2  103 3998         cmp     y0,b
P:0032 0AF0AF rrrrrr  6  109 3999         jle     L6
                             4000 
                             4001 ; 57   |            g_iMaskRight = g_MaskStack[i].m_iMaskRight;
                             4002 
                             4005 
                             4006 ; 58   |        if(g_iMaskBottom > g_MaskStack[i].m_iMaskBottom)
                             4007 
P:0034 4E7000 rrrrrr  3  112 4004         move    y0,y:Fg_iMaskRight
                             4009 L6:
P:0036 64F400 rrrrrr  3  115 4010         move    #Fg_MaskStack+3,r4
P:0038 237C00         2  117 4011         move    n3,n4
P:0039 5FF000 rrrrrr  3  120 4009         move    y:Fg_iMaskBottom,b
P:003B 4EEC00         4  124 4013         move    y:(r4+n4),y0
P:003C 20005D         2  126 4014         cmp     y0,b
P:003D 0AF0AF rrrrrr  6  132 4015         jle     L7
                             4016 
                             4017 ; 59   |            g_iMaskBottom = g_MaskStack[i].m_iMaskBottom;
                             4018 
                             4021 
                             4022 ; 60   |        if(g_iMaskBottom < g_iMaskTop)
                             4023 
P:003F 4E7000 rrrrrr  3  135 4020         move    y0,y:Fg_iMaskBottom
P:0041 5EF000 rrrrrr  3  138 4025 L7:     move    y:Fg_iMaskBottom,a
P:0043 5FF000 rrrrrr  3  141 4026         move    y:Fg_iMaskTop,b
P:0045 200005         2  143 4027         cmp     b,a
P:0046 0AF0A1 rrrrrr  6  149 4028         jge     L8
                             4029 
                             4030 ; 61   |            g_iMaskBottom = g_iMaskTop;
                             4031 
                             4034 
                             4035 ; 62   |        if(g_iMaskRight < g_iMaskLeft)
                             4036 
P:0048 5F7000 rrrrrr  3  152 4033         move    b,y:Fg_iMaskBottom
P:004A 5FF000 rrrrrr  3  155 4038 L8:     move    y:Fg_iMaskRight,b
P:004C 4CF000 rrrrrr  3  158 4039         move    y:Fg_iMaskLeft,x0
P:004E 20004D         2  160 4040         cmp     x0,b
P:004F 0AF0A1 rrrrrr  6  166 4041         jge     L9
                             4042 
                             4043 ; 63   |            g_iMaskRight = g_iMaskLeft;
                             4044 
P:0051 4C7000 rrrrrr  3  169 4046         move    x0,y:Fg_iMaskRight
                             4047 L9:
P:0053 44F479 000001  3  172 4049         tfr     y1,b	                #>1,x0
P:0055 200048         2  174 4051         add     x0,b
P:0056 21A700         2  176 4054         move    b1,y1
P:0057 20EF00         2  178 4057 L10:    move    y1,b
P:0058 20006D         2  180 4058         cmp     x1,b
P:0059 0AF0A9 rrrrrr  6  186 4059         jlt     L3
                             4060 
                             4061 ; 64   |    }
                             4062 ; 65   |}
                             4063 
P:005B 05FF7C         4  190 4065         movec   y:-(r7),ssh
P:005C 000000         2  192 4065         nop             ; (inserted)
P:005D 00000C         4  196 4069         rts
                             4072 
                             4073 ; 66   |
                             4074 ; 67   |_reentrant void PushMask(INT left, INT top, INT right, INT bottom)
                             4075 ; 68   |{
                             4076 
                             4081 FPushMask:
                             4100 
                             4101 ; 69   |    if(g_iMaskStack>MAX_MASKS-1)
                             4102 
P:005E 055F7C         2  198 4082         movec   ssh,y:(r7)+
P:005F 045FA0         2  200 4095         movec   m0,n7
P:0060 47F400 000004  3  203 4105         move    #>4,y1
P:0062 205F00         2  205 4085         move    (r7)+
P:0063 5D6F00         4  209 4097         move    b1,y:(r7+n7)
P:0064 5FF000 rrrrrr  3  212 4104         move    y:Fg_iMaskStack,b
P:0066 20007D         2  214 4106         cmp     y1,b
P:0067 0AF0AF rrrrrr  6  220 4107         jle     L11
                             4108 
                             4109 ; 70   |        SystemHalt();
                             4110 
                             4112 
                             4113 ; Start __asm() call number 1
                             4115  error
P:0069 0C000C         4  224 4115     jmp $000C ;Use vector at P:000C to shutdown & restart the STMP device. 
                             4115               ; Jmp to addr in low 12 bits is 1 word smaller than jsr. (changed apr 6 '05)
                             4116 ; End   __asm() call number 1
                             4117 
                             4118 ; 71   |    g_iMaskStack++;
                             4119 
                             4121 L11:
                             4125 
                             4126 ; 72   |    g_pMaskStack->m_iMaskLeft  = left;
                             4127 
                             4132 
                             4133 ; 73   |    g_pMaskStack->m_iMaskTop   = top;
                             4134 
                             4142 
                             4143 ; 74   |    g_pMaskStack->m_iMaskRight = right;
                             4144 
                             4149 
                             4150 ; 75   |    g_pMaskStack->m_iMaskBottom= bottom;
                             4151 
                             4156 
                             4157 ; 76   |    g_pMaskStack++;
                             4158 
                             4164 
                             4165 ; 77   |    EvaluateMask();
                             4166 ; 78   |}
                             4167 
P:006A 045FA0         2  226 4136         movec   m0,n7
P:006B 5FF000 rrrrrr  3  229 4121         move    y:Fg_iMaskStack,b
P:006D 45F400 000001  3  232 4122         move    #>1,x1
P:006F 3E0268         2  234 4123         add     x1,b	                #2,n6
P:0070 5D7000 rrrrrr  3  237 4124         move    b1,y:Fg_iMaskStack
P:0072 6EF000 rrrrrr  3  240 4129         move    y:Fg_pMaskStack,r6
P:0074 000000         2  242 4129         nop             ; (inserted)
P:0075 5C5E00         2  244 4131         move    a1,y:(r6)+
P:0076 5FEF00         4  248 4138         move    y:(r7+n7),b
P:0077 205700         2  250 4169         move    (r7)-
P:0078 5F5600         2  252 4139         move    b,y:(r6)-
P:0079 4C6E00         4  256 4148         move    x0,y:(r6+n6)
P:007A 3E0300         2  258 4153         move    #3,n6
P:007B 000000         2  260 4153         nop             ; (inserted)
P:007C 4E6E00         4  264 4155         move    y0,y:(r6+n6)
P:007D 3E0400         2  266 4160         move    #4,n6
P:007E 000000         2  268 4160         nop             ; (inserted)
P:007F 204E00         2  270 4162         move    (r6)+n6
P:0080 6E7000 rrrrrr  3  273 4163         move    r6,y:Fg_pMaskStack
P:0082 0BF080 rrrrrr  6  279 4171         jsr     FEvaluateMask
P:0084 05FF7C         4  283 4178         movec   y:-(r7),ssh
P:0085 000000         2  285 4178         nop             ; (inserted)
P:0086 00000C         4  289 4182         rts
                             4184 
                             4185 ; 79   |
                             4186 ; 80   |_reentrant void PopMask(void)
                             4187 ; 81   |{
                             4188 
                             4193 FPopMask:
                             4197 
                             4198 ; 82   |    if(!g_iMaskStack)
                             4199 
P:0087 055F7C         2  291 4194         movec   ssh,y:(r7)+
P:0088 5FF000 rrrrrr  3  294 4201         move    y:Fg_iMaskStack,b
P:008A 20000B         2  296 4202         tst     b
P:008B 0AF0A2 rrrrrr  6  302 4203         jne     L12
                             4204 
                             4205 ; 83   |        SystemHalt();
                             4206 
                             4208 
                             4209 ; Start __asm() call number 2
                             4211  error
P:008D 0C000C         4  306 4211     jmp $000C ;Use vector at P:000C to shutdown & restart the STMP device. 
                             4211               ; Jmp to addr in low 12 bits is 1 word smaller than jsr. (changed apr 6 '05)
                             4212 ; End   __asm() call number 2
                             4213 
                             4214 ; 84   |    g_iMaskStack--;
                             4215 
                             4217 L12:
                             4221 
                             4222 ; 85   |    g_pMaskStack--;
                             4223 
                             4230 
                             4231 ; 86   |    EvaluateMask();
                             4232 
P:008E 5FF000 rrrrrr  3  309 4217         move    y:Fg_iMaskStack,b
P:0090 44F400 000001  3  312 4218         move    #>1,x0
TASKING DSP2410 assembler v1.5r1 Build 138 SN 00100122
                                                                                                                                                                                                                                                       Page  17

M:ADDR CODE           CYCLES LINE SOURCELINE
P:0092 3D044C         2  314 4219         sub     x0,b	                #4,n5
P:0093 5D7000 rrrrrr  3  317 4220         move    b1,y:Fg_iMaskStack
P:0095 6DF000 rrrrrr  3  320 4225         move    y:Fg_pMaskStack,r5
P:0097 000000         2  322 4225         nop             ; (inserted)
P:0098 204500         2  324 4228         move    (r5)-n5
P:0099 6D7000 rrrrrr  3  327 4229         move    r5,y:Fg_pMaskStack
P:009B 0BF080 rrrrrr  6  333 4234         jsr     FEvaluateMask
                             4235 
                             4236 ; 87   |}
                             4237 
P:009D 05FF7C         4  337 4239         movec   y:-(r7),ssh
P:009E 000000         2  339 4239         nop             ; (inserted)
P:009F 00000C         4  343 4243         rts
                             4245 
                             4246 ; 88   |
                             4247 ; 89   |_reentrant void DisplayUpdateDisplay(void)
                             4248 ; 90   |{
                             4249 
                             4254 FDisplayUpdateDisplay:
                             4258 
                             4259 ; 91   |    SALDisplayUpdate();
                             4260 
P:00A0 055F7C         2  345 4255         movec   ssh,y:(r7)+
P:00A1 0BF080 rrrrrr  6  351 4262         jsr     FSALDisplayUpdate
                             4263 
                             4264 ; 92   |}
                             4265 
P:00A3 05FF7C         4  355 4267         movec   y:-(r7),ssh
P:00A4 000000         2  357 4267         nop             ; (inserted)
P:00A5 00000C         4  361 4271         rts
                             4273 
                             4274 ; 93   |
                             4275 ; 94   |_reentrant void DisplayClearRange           (INT  x,INT  y,WORD cx         ,WORD cy    )
                             4276 ; 95   |{
                             4277 
                             4282 FDisplayClearRange:
                             4294 
                             4295 ; 96   |    SALDisplayClearRange(x,y,cx,cy);
                             4296 
P:00A6 055F7C         2  363 4283         movec   ssh,y:(r7)+
P:00A7 0BF080 rrrrrr  6  369 4298         jsr     FSALDisplayClearRange
                             4303 
                             4304 ; 97   |}
                             4305 
P:00A9 05FF7C         4  373 4307         movec   y:-(r7),ssh
P:00AA 000000         2  375 4307         nop             ; (inserted)
P:00AB 00000C         4  379 4311         rts
                             4313 
                             4314 ; 98   |
                             4315 ; 99   |_reentrant void DisplaySetFont(INT iFont)
                             4316 ; 100  |{
                             4317 
                             4322 FDisplaySetFont:
                             4329 
                             4330 ; 101  |    LCDSetFont(iFont);
                             4331 
P:00AC 055F7C         2  381 4323         movec   ssh,y:(r7)+
P:00AD 0BF080 rrrrrr  6  387 4333         jsr     FLCDSetFont
                             4334 
                             4335 ; 102  |}
                             4336 
P:00AF 05FF7C         4  391 4338         movec   y:-(r7),ssh
P:00B0 000000         2  393 4338         nop             ; (inserted)
P:00B1 00000C         4  397 4342         rts
                             4344 
                             4345 ; 103  |
                             4346 ; 104  |_reentrant void DisplayPrintBitmapAddress(INT x,INT y,BITMAP *pBitmap,INT bInvert)
                             4347 ; 105  |{
                             4348 
                             4355 FDisplayPrintBitmapAddress:
                             4367 
                             4368 ; 106  |    SALDisplayPrintBitmapAddress(x,y,(void *)pBitmap,bInvert);
                             4369 
P:00B2 055F7C         2  399 4356         movec   ssh,y:(r7)+
P:00B3 0BF080 rrrrrr  6  405 4371         jsr     FSALDisplayPrintBitmapAddress
                             4376 
                             4377 ; 107  |}
                             4378 
P:00B5 05FF7C         4  409 4380         movec   y:-(r7),ssh
P:00B6 000000         2  411 4380         nop             ; (inserted)
P:00B7 00000C         4  415 4384         rts
                             4386 
                             4387 ; 108  |
                             4388 ; 109  |_reentrant void DisplayPrintBitmapResource  (INT x,INT y,WORD iResource  ,INT bInvert)
                             4389 ; 110  |{
                             4390 
                             4395 FDisplayPrintBitmapResource:
                             4413 
                             4414 ; 111  |    BITMAP  *pBitmap = NULL;
                             4415 
                             4432 
                             4433 ; 112  |    pBitmap = DisplayLoadBitmap(iResource);
                             4434 
P:00B8 055F7C         2  417 4396         movec   ssh,y:(r7)+
P:00B9 3F0300         2  419 4399         move    #3,n7
P:00BA 000000         2  421 4399         nop             ; (inserted)
P:00BB 204F00         2  423 4401         move    (r7)+n7
P:00BC 045FA0         2  425 4417         movec   m0,n7
P:00BD 000000         2  427 4417         nop             ; (inserted)
P:00BE 4E6F00         4  431 4419         move    y0,y:(r7+n7)
P:00BF 77F400 FFFFFE  3  434 4422         move    #-2,n7
P:00C1 000000         2  436 4422         nop             ; (inserted)
P:00C2 5D6F00         4  440 4424         move    b1,y:(r7+n7)
P:00C3 77F400 FFFFFD  3  443 4427         move    #-3,n7
P:00C5 000000         2  445 4427         nop             ; (inserted)
P:00C6 5C6F41         4  449 4436         tfr     x0,a	                a1,y:(r7+n7)
P:00C7 0BF080 rrrrrr  6  455 4437         jsr     FDisplayLoadBitmap
                             4442 
                             4443 ; 113  |    if(pBitmap)
                             4444 
P:00C9 220E00         2  457 4446         move    r0,a
P:00CA 200003         2  459 4447         tst     a
P:00CB 0AF0AA rrrrrr  6  465 4448         jeq     L14
                             4449 
                             4450 ; 114  |        SALDisplayPrintBitmapAddress(x,y,(void *)pBitmap,bInvert);
                             4451 
P:00CD 045FA0         2  467 4453         movec   m0,n7
P:00CE 000000         2  469 4453         nop             ; (inserted)
P:00CF 4CEF00         4  473 4455         move    y:(r7+n7),x0
P:00D0 77F400 FFFFFE  3  476 4456         move    #-2,n7
P:00D2 000000         2  478 4456         nop             ; (inserted)
P:00D3 5FEF00         4  482 4458         move    y:(r7+n7),b
P:00D4 77F400 FFFFFD  3  485 4459         move    #-3,n7
P:00D6 000000         2  487 4459         nop             ; (inserted)
P:00D7 5EEF00         4  491 4461         move    y:(r7+n7),a
P:00D8 0BF080 rrrrrr  6  497 4462         jsr     FSALDisplayPrintBitmapAddress
                             4473 L14:
                             4474 
                             4475 ; 115  |}
                             4476 
P:00DA 77F400 FFFFFC  3  500 4478         move    #-4,n7
P:00DC 000000         2  502 4478         nop             ; (inserted)
P:00DD 05EF7C         4  506 4480         movec   y:(r7+n7),ssh
P:00DE 204F00         2  508 4482         move    (r7)+n7
P:00DF 00000C         4  512 4484         rts
                             4486 
                             4487 ; 116  |
                             4488 ; 117  |_reentrant BITMAP *DisplayLoadBitmap(WORD wResource)
                             4489 ; 118  |{
                             4490 
                             4504 FDisplayLoadBitmap:
                             4521 
                             4522 ; 119  |    INT iSize;
                             4523 ; 120  |    BITMAP *pBITMAP;
                             4524 ; 121  |    COMPLEX_RESOURCE Resource;
                             4525 ; 122  |    BYTE btRscHandle;
                             4526 ; 123  |    Resource.I = wResource;
                             4527 
                             4532 
                             4533 ; 124  |
                             4534 ; 125  |    pBITMAP = (BITMAP *)&g_wUserScratchY;
                             4535 
                             4542 
                             4543 ; 126  |    iSize = SCRATCH_USER_Y_SIZE*3;
                             4544 ; 127  |
                             4545 ; 128  |    switch(Resource.Complex.m_Type)
                             4546 
P:00E0 055F7C         2  514 4505         movec   ssh,y:(r7)+
P:00E1 3F0300         2  516 4508         move    #3,n7
P:00E2 63F400 rrrrrr  3  519 4537         move    #Fg_wUserScratchY,r3
P:00E4 204F00         2  521 4510         move    (r7)+n7
P:00E5 77F400 FFFFFD  3  524 4529         move    #-3,n7
P:00E7 000000         2  526 4529         nop             ; (inserted)
P:00E8 5C6F00         4  530 4531         move    a1,y:(r7+n7)
P:00E9 77F400 FFFFFE  3  533 4538         move    #-2,n7
P:00EB 000000         2  535 4538         nop             ; (inserted)
P:00EC 6B6F00         4  539 4540         move    r3,y:(r7+n7)
P:00ED 77F400 FFFFFD  3  542 4548         move    #-3,n7
P:00EF 000000         2  544 4548         nop             ; (inserted)
P:00F0 4EEF00         4  548 4550         move    y:(r7+n7),y0
P:00F1 0115E8         2  550 4551         mpy     y0,#21,b
P:00F2 21AF00         2  552 4552         move    b1,b
P:00F3 46F400 000002  3  555 4553         move    #>2,y0
P:00F5 46F45D 000001  3  558 4554         cmp     y0,b    #>1,y0
P:00F7 0AF0AA rrrrrr  6  564 4555         jeq     L22
P:00F9 20005D         2  566 4556         cmp     y0,b
P:00FA 0AF0AA rrrrrr  6  572 4557         jeq     L23
P:00FC 20000B         2  574 4558         tst     b
P:00FD 0AF0A2 rrrrrr  6  580 4559         jne     L26
                             4560 
                             4561 ; 129  |    {
                             4562 ; 130  |    case RESOURCE_TYPE_SIMPLE:
                             4563 ; 131  |        SysLoadResource(wResource, RS_ROOT_HANDLE, RSRC_TYPE_BITMAP, (WORD*)pBITMAP, BITMAP_MEMORY_SPACE, iSize);
                             4564 
P:00FF 77F400 FFFFFE  3  583 4566         move    #-2,n7
P:0101 26401B         2  585 4570         clr     b	                #<$40,y0
P:0102 68EF00         4  589 4568         move    y:(r7+n7),r0
P:0103 45F400 000600  3  592 4572         move    #$600,x1
P:0105 44F400 000003  3  595 4569         move    #>3,x0
P:0107 0BF080 rrrrrr  6  601 4573         jsr     FSysLoadResource
                             4575 
                             4576 ; 132  |        break;
                             4577 
P:0109 0AF080 rrrrrr  6  607 4579         jmp     L26
                             4580 
                             4581 ; 133  |    case RESOURCE_TYPE_UNICODE:
                             4582 ; 134  |        pBITMAP = GetUnicodeCharacterBitmap(Resource.Complex.m_Resource);
                             4583 
P:010B 4DEF00         4  611 4585 L22:    move    y:(r7+n7),x1
P:010C 0115F0         2  613 4586         mpy     x1,#21,a
P:010D 210500         2  615 4587         move    a0,x1
P:010E 0103F0         2  617 4588         mpy     x1,#3,a
P:010F 218E00         2  619 4589         move    a1,a
P:0110 0BF080 rrrrrr  6  625 4590         jsr     FGetUnicodeCharacterBitmap
                             4594 
                             4595 ; 135  |        break;
                             4596 
P:0112 77F400 FFFFFE  3  628 4591         move    #-2,n7
P:0114 000000         2  630 4591         nop             ; (inserted)
P:0115 686F00         4  634 4593         move    r0,y:(r7+n7)
P:0116 0AF080 rrrrrr  6  640 4598         jmp     L26
                             4599 
                             4600 ; 136  |    case RESOURCE_TYPE_NESTED:
                             4601 ; 137  |        btRscHandle = (BYTE) SysOpenResource(Resource.Complex.m_Resource&0x03f, RS_ROOT_HANDLE);                
                             4602 
                             4604 L23:
P:0118 44F400 00003F  3  643 4608         move    #>$3F,x0
P:011A 4FEF00         4  647 4604         move    y:(r7+n7),y1
P:011B 0115C8         2  649 4605         mpy     y1,#21,b
P:011C 212700         2  651 4606         move    b0,y1
P:011D 0103C8         2  653 4607         mpy     y1,#3,b
P:011E 20004E         2  655 4609         and     x0,b
P:011F 21AE1B         2  657 4611         clr     b	                b1,a
P:0120 0BF080 rrrrrr  6  663 4612         jsr     FSysOpenResource
                             4615 
                             4616 ; 138  |        SysLoadResource(Resource.Complex.m_Resource>>10, btRscHandle, RSRC_TYPE_BITMAP,(WORD *)pBITMAP,BITMAP_MEMORY_SPACE, iSize);
                             4617 
P:0122 77F409 FFFFFD  3  666 4613         tfr     a,b	                #-3,n7
P:0124 45F400 000600  3  669 4640         move    #$600,x1
P:0126 44F400 000003  3  672 4638         move    #>3,x0
P:0128 4EEF00         4  676 4621         move    y:(r7+n7),y0
P:0129 77F400 FFFFFE  3  679 4628         move    #-2,n7
P:012B 0115E0         2  681 4622         mpy     y0,#21,a
P:012C 68EF00         4  685 4630         move    y:(r7+n7),r0
P:012D 045FA0         2  687 4631         movec   m0,n7
P:012E 210600         2  689 4623         move    a0,y0
P:012F 5D6F00         4  693 4633         move    b1,y:(r7+n7)
P:0130 0103E0         2  695 4624         mpy     y0,#3,a
P:0131 218600         2  697 4625         move    a1,y0
P:0132 010AE0         2  699 4626         mpy     y0,#10,a
P:0133 264000         2  701 4639         move    #<$40,y0
P:0134 218E00         2  703 4627         move    a1,a
P:0135 0BF080 rrrrrr  6  709 4641         jsr     FSysLoadResource
                             4644 
                             4645 ; 139  |        SysCloseResource(btRscHandle);
                             4646 
TASKING DSP2410 assembler v1.5r1 Build 138 SN 00100122
                                                                                                                                                                                                                                                       Page  18

M:ADDR CODE           CYCLES LINE SOURCELINE
P:0137 045FA0         2  711 4648         movec   m0,n7
P:0138 000000         2  713 4648         nop             ; (inserted)
P:0139 5EEF00         4  717 4650         move    y:(r7+n7),a
P:013A 0BF080 rrrrrr  6  723 4651         jsr     FSysCloseResource
                             4655 
                             4656 ; 140  |        break;
                             4657 ; 141  |    }
                             4658 ; 142  |    return pBITMAP;
                             4659 
                             4661 L26:
                             4666 
                             4667 ; 143  |}
                             4668 
P:013C 77F400 FFFFFE  3  726 4661         move    #-2,n7
P:013E 000000         2  728 4661         nop             ; (inserted)
P:013F 68EF00         4  732 4663         move    y:(r7+n7),r0
P:0140 77F400 FFFFFC  3  735 4670         move    #-4,n7
P:0142 000000         2  737 4670         nop             ; (inserted)
P:0143 05EF7C         4  741 4672         movec   y:(r7+n7),ssh
P:0144 204F00         2  743 4674         move    (r7)+n7
P:0145 00000C         4  747 4676         rts
                             4679 
                             4680 ; 144  |
                             4681 ; 145  |
                             4682 ; 146  |_reentrant void DisplayPrintStringResource  (INT x,INT y,WORD wResource,INT bInvert)
                             4683 ; 147  |{
                             4684 
                             4689 FDisplayPrintStringResource:
                             4713 
                             4714 ; 148  |    BYTE btRscHandle;
                             4715 ; 149  |    INT iSize = SCRATCH_USER_Y_SIZE*3;
                             4716 ; 150  |    WORD wStringResourceMemorySpace = TARGET_MEM_Y;
                             4717 ; 151  |    WORD *pResourceString = (WORD*)&g_wUserScratchY;
                             4718 
                             4740 
                             4741 ; 152  |
                             4742 ; 153  |    COMPLEX_RESOURCE Resource;
                             4743 ; 154  |    Resource.I = wResource;
                             4744 
                             4753 
                             4754 ; 155  |
                             4755 ; 156  |    switch(Resource.Complex.m_Type)
                             4756 
P:0146 055F7C         2  749 4690         movec   ssh,y:(r7)+
P:0147 3F0600         2  751 4693         move    #6,n7
P:0148 76F400 rrrrrr  3  754 4735         move    #Fg_wUserScratchY,n6
P:014A 204F00         2  756 4695         move    (r7)+n7
P:014B 77F400 FFFFFD  3  759 4720         move    #-3,n7
P:014D 000000         2  761 4720         nop             ; (inserted)
P:014E 4E6F00         4  765 4722         move    y0,y:(r7+n7)
P:014F 77F400 FFFFFC  3  768 4725         move    #-4,n7
P:0151 000000         2  770 4725         nop             ; (inserted)
P:0152 5D6F00         4  774 4727         move    b1,y:(r7+n7)
P:0153 77F400 FFFFFB  3  777 4730         move    #-5,n7
P:0155 000000         2  779 4730         nop             ; (inserted)
P:0156 5C6F41         4  783 4746         tfr     x0,a	                a1,y:(r7+n7)
P:0157 77F400 FFFFFE  3  786 4736         move    #-2,n7
P:0159 218600         2  788 4758         move    a1,y0
P:015A 7E6F00         4  792 4738         move    n6,y:(r7+n7)
P:015B 0115E8         2  794 4759         mpy     y0,#21,b
P:015C 21AF00         2  796 4760         move    b1,b
P:015D 46F400 000001  3  799 4761         move    #>1,y0
P:015F 77F45D FFFFFA  3  802 4762         cmp     y0,b	                #-6,n7
P:0161 000000         2  804 4762         nop             ; (inserted)
P:0162 5C6F00         4  808 4750         move    a1,y:(r7+n7)
P:0163 0AF0AA rrrrrr  6  814 4763         jeq     L32
P:0165 20000B         2  816 4764         tst     b
P:0166 0AF0A2 rrrrrr  6  822 4765         jne     L34
                             4766 
                             4767 ; 157  |    {
                             4768 ; 158  |    case RESOURCE_TYPE_SIMPLE:
                             4769 ; 159  |        SysLoadResource(wResource, RS_ROOT_HANDLE, RSRC_TYPE_STRING,pResourceString, wStringResourceMemorySpace , iSize);
                             4770 
P:0168 77F400 FFFFFE  3  825 4772         move    #-2,n7
P:016A 20C41B         2  827 4778         clr     b	                y0,x0
P:016B 68EF00         4  831 4774         move    y:(r7+n7),r0
P:016C 45F400 000600  3  834 4780         move    #$600,x1
P:016E 264000         2  836 4779         move    #<$40,y0
P:016F 0BF080 rrrrrr  6  842 4781         jsr     FSysLoadResource
                             4785 
                             4786 ; 160  |        break;
                             4787 
P:0171 0AF080 rrrrrr  6  848 4789         jmp     L34
                             4790 
                             4791 ; 161  |    case RESOURCE_TYPE_NESTED:
                             4792 ; 162  |        btRscHandle = (BYTE) SysOpenResource(Resource.Complex.m_Resource&0x03f, RS_ROOT_HANDLE);                
                             4793 
P:0173 218700         2  850 4795 L32:    move    a1,y1
P:0174 44F400 00003F  3  853 4799         move    #>$3F,x0
P:0176 0115C8         2  855 4796         mpy     y1,#21,b
P:0177 212700         2  857 4797         move    b0,y1
P:0178 0103C8         2  859 4798         mpy     y1,#3,b
P:0179 20004E         2  861 4800         and     x0,b
P:017A 21AE1B         2  863 4802         clr     b	                b1,a
P:017B 0BF080 rrrrrr  6  869 4803         jsr     FSysOpenResource
                             4806 
                             4807 ; 163  |        SysLoadResource(Resource.Complex.m_Resource>>10, btRscHandle, RSRC_TYPE_STRING,pResourceString, wStringResourceMemorySpace , iSize);
                             4808 
P:017D 77F409 FFFFFA  3  872 4804         tfr     a,b	                #-6,n7
P:017F 45F400 000600  3  875 4833         move    #$600,x1
P:0181 44F400 000001  3  878 4831         move    #>1,x0
P:0183 4EEF00         4  882 4812         move    y:(r7+n7),y0
P:0184 77F400 FFFFFE  3  885 4819         move    #-2,n7
P:0186 0115E0         2  887 4813         mpy     y0,#21,a
P:0187 68EF00         4  891 4821         move    y:(r7+n7),r0
P:0188 045FA0         2  893 4824         movec   m0,n7
P:0189 210600         2  895 4814         move    a0,y0
P:018A 5D6F00         4  899 4826         move    b1,y:(r7+n7)
P:018B 0103E0         2  901 4815         mpy     y0,#3,a
P:018C 218600         2  903 4816         move    a1,y0
P:018D 010AE0         2  905 4817         mpy     y0,#10,a
P:018E 264000         2  907 4832         move    #<$40,y0
P:018F 218E00         2  909 4818         move    a1,a
P:0190 0BF080 rrrrrr  6  915 4834         jsr     FSysLoadResource
                             4839 
                             4840 ; 164  |        SysCloseResource(btRscHandle);
                             4841 
P:0192 045FA0         2  917 4843         movec   m0,n7
P:0193 000000         2  919 4843         nop             ; (inserted)
P:0194 5EEF00         4  923 4845         move    y:(r7+n7),a
P:0195 0BF080 rrrrrr  6  929 4846         jsr     FSysCloseResource
                             4850 
                             4851 ; 165  |        break;
                             4852 ; 166  |    }
                             4853 ; 167  |    DisplayPrintStringAddress(x,y,pResourceString,bInvert);
                             4854 
                             4856 L34:
P:0197 77F400 FFFFFE  3  932 4856         move    #-2,n7
P:0199 000000         2  934 4856         nop             ; (inserted)
P:019A 68EF00         4  938 4858         move    y:(r7+n7),r0
P:019B 77F400 FFFFFD  3  941 4862         move    #-3,n7
P:019D 000000         2  943 4862         nop             ; (inserted)
P:019E 4CEF00         4  947 4864         move    y:(r7+n7),x0
P:019F 77F400 FFFFFC  3  950 4865         move    #-4,n7
P:01A1 000000         2  952 4865         nop             ; (inserted)
P:01A2 5FEF00         4  956 4867         move    y:(r7+n7),b
P:01A3 77F400 FFFFFB  3  959 4868         move    #-5,n7
P:01A5 000000         2  961 4868         nop             ; (inserted)
P:01A6 5EEF00         4  965 4870         move    y:(r7+n7),a
P:01A7 0BF080 rrrrrr  6  971 4871         jsr     FDisplayPrintStringAddress
                             4881 
                             4882 ; 168  |}
                             4883 
P:01A9 77F400 FFFFF9  3  974 4885         move    #-7,n7
P:01AB 000000         2  976 4885         nop             ; (inserted)
P:01AC 05EF7C         4  980 4887         movec   y:(r7+n7),ssh
P:01AD 204F00         2  982 4889         move    (r7)+n7
P:01AE 00000C         4  986 4891         rts
                             4893 
                             4894 ; 169  |
                             4895 ; 170  |
                             4896 ; 171  |_reentrant void DisplayPrintStringResourceUnicode  (INT x,INT y,WORD wResource,INT bInvert)
                             4897 ; 172  |{
                             4898 
                             4903 FDisplayPrintStringResourceUnicode:
                             4925 
                             4926 ; 173  |    INT iSize = SCRATCH_USER_Y_SIZE*3;
                             4927 ; 174  |    WORD wStringResourceMemorySpace = TARGET_MEM_Y;
                             4928 ; 175  |    WORD *pResourceString = ((WORD*)&g_wUserScratchY)+50;//give it some space to avoid where the bitmap will be loaded
                             4929 
                             4951 
                             4952 ; 176  |    COMPLEX_RESOURCE Resource;
                             4953 ; 177  |    BYTE btRscHandle;
                             4954 ; 178  |
                             4955 ; 179  |    Resource.I = wResource;
                             4956 
                             4967 
                             4968 ; 180  |
                             4969 ; 181  |    switch(Resource.Complex.m_Type)
                             4970 
P:01AF 055F7C         2  988 4904         movec   ssh,y:(r7)+
P:01B0 3F0600         2  990 4907         move    #6,n7
P:01B1 66F400 rrrrrr  3  993 4946         move    #Fg_wUserScratchY+50,r6
P:01B3 204F00         2  995 4909         move    (r7)+n7
P:01B4 77F400 FFFFFD  3  998 4931         move    #-3,n7
P:01B6 000000         2 1000 4931         nop             ; (inserted)
P:01B7 4E6F00         4 1004 4933         move    y0,y:(r7+n7)
P:01B8 77F400 FFFFFC  3 1007 4936         move    #-4,n7
P:01BA 000000         2 1009 4936         nop             ; (inserted)
P:01BB 5D6F00         4 1013 4938         move    b1,y:(r7+n7)
P:01BC 77F400 FFFFFB  3 1016 4941         move    #-5,n7
P:01BE 000000         2 1018 4941         nop             ; (inserted)
P:01BF 5C6F41         4 1022 4958         tfr     x0,a	                a1,y:(r7+n7)
P:01C0 77F400 FFFFFE  3 1025 4947         move    #-2,n7
P:01C2 218600         2 1027 4972         move    a1,y0
P:01C3 6E6F00         4 1031 4949         move    r6,y:(r7+n7)
P:01C4 0115E8         2 1033 4973         mpy     y0,#21,b
P:01C5 21AF00         2 1035 4974         move    b1,b
P:01C6 46F400 000001  3 1038 4975         move    #>1,y0
P:01C8 77F45D FFFFFA  3 1041 4976         cmp     y0,b	                #-6,n7
P:01CA 000000         2 1043 4976         nop             ; (inserted)
P:01CB 5C6F00         4 1047 4964         move    a1,y:(r7+n7)
P:01CC 0AF0AA rrrrrr  6 1053 4977         jeq     L40
P:01CE 20000B         2 1055 4978         tst     b
P:01CF 0AF0A2 rrrrrr  6 1061 4979         jne     L42
                             4980 
                             4981 ; 182  |    {
                             4982 ; 183  |    case RESOURCE_TYPE_SIMPLE:
                             4983 ; 184  |        SysLoadResource(wResource, RS_ROOT_HANDLE, RSRC_TYPE_STRING,pResourceString, wStringResourceMemorySpace , iSize);
                             4984 
P:01D1 77F400 FFFFFE  3 1064 4986         move    #-2,n7
P:01D3 20C41B         2 1066 4991         clr     b	                y0,x0
P:01D4 68EF00         4 1070 4988         move    y:(r7+n7),r0
P:01D5 45F400 000600  3 1073 4994         move    #$600,x1
P:01D7 264000         2 1075 4993         move    #<$40,y0
P:01D8 0BF080 rrrrrr  6 1081 4995         jsr     FSysLoadResource
                             4999 
                             5000 ; 185  |        break;
                             5001 
P:01DA 0AF080 rrrrrr  6 1087 5003         jmp     L42
                             5004 
                             5005 ; 186  |    case RESOURCE_TYPE_NESTED:
                             5006 ; 187  |        btRscHandle = (BYTE) SysOpenResource(Resource.Complex.m_Resource&0x03f, RS_ROOT_HANDLE);                
                             5007 
P:01DC 218700         2 1089 5009 L40:    move    a1,y1
P:01DD 44F400 00003F  3 1092 5013         move    #>$3F,x0
P:01DF 0115C8         2 1094 5010         mpy     y1,#21,b
P:01E0 212700         2 1096 5011         move    b0,y1
P:01E1 0103C8         2 1098 5012         mpy     y1,#3,b
P:01E2 20004E         2 1100 5014         and     x0,b
P:01E3 21AE1B         2 1102 5016         clr     b	                b1,a
P:01E4 0BF080 rrrrrr  6 1108 5017         jsr     FSysOpenResource
                             5020 
                             5021 ; 188  |        SysLoadResource(Resource.Complex.m_Resource>>10, btRscHandle, RSRC_TYPE_STRING,pResourceString, wStringResourceMemorySpace , iSize);
                             5022 
P:01E6 77F409 FFFFFA  3 1111 5018         tfr     a,b	                #-6,n7
P:01E8 45F400 000600  3 1114 5047         move    #$600,x1
P:01EA 44F400 000001  3 1117 5045         move    #>1,x0
P:01EC 4EEF00         4 1121 5026         move    y:(r7+n7),y0
P:01ED 77F400 FFFFFE  3 1124 5033         move    #-2,n7
P:01EF 0115E0         2 1126 5027         mpy     y0,#21,a
P:01F0 68EF00         4 1130 5035         move    y:(r7+n7),r0
P:01F1 045FA0         2 1132 5038         movec   m0,n7
P:01F2 210600         2 1134 5028         move    a0,y0
P:01F3 5D6F00         4 1138 5040         move    b1,y:(r7+n7)
P:01F4 0103E0         2 1140 5029         mpy     y0,#3,a
P:01F5 218600         2 1142 5030         move    a1,y0
P:01F6 010AE0         2 1144 5031         mpy     y0,#10,a
P:01F7 264000         2 1146 5046         move    #<$40,y0
P:01F8 218E00         2 1148 5032         move    a1,a
P:01F9 0BF080 rrrrrr  6 1154 5048         jsr     FSysLoadResource
TASKING DSP2410 assembler v1.5r1 Build 138 SN 00100122
                                                                                                                                                                                                                                                       Page  19

M:ADDR CODE           CYCLES LINE SOURCELINE
                             5053 
                             5054 ; 189  |        SysCloseResource(btRscHandle);
                             5055 
P:01FB 045FA0         2 1156 5057         movec   m0,n7
P:01FC 000000         2 1158 5057         nop             ; (inserted)
P:01FD 5EEF00         4 1162 5059         move    y:(r7+n7),a
P:01FE 0BF080 rrrrrr  6 1168 5060         jsr     FSysCloseResource
                             5064 
                             5065 ; 190  |        break;
                             5066 ; 191  |    }
                             5067 ; 192  |    DisplayPrintStringAddressUnicode(x,y,pResourceString,bInvert);
                             5068 
                             5070 L42:
P:0200 77F400 FFFFFE  3 1171 5070         move    #-2,n7
P:0202 000000         2 1173 5070         nop             ; (inserted)
P:0203 68EF00         4 1177 5072         move    y:(r7+n7),r0
P:0204 77F400 FFFFFD  3 1180 5076         move    #-3,n7
P:0206 000000         2 1182 5076         nop             ; (inserted)
P:0207 4CEF00         4 1186 5078         move    y:(r7+n7),x0
P:0208 77F400 FFFFFC  3 1189 5079         move    #-4,n7
P:020A 000000         2 1191 5079         nop             ; (inserted)
P:020B 5FEF00         4 1195 5081         move    y:(r7+n7),b
P:020C 77F400 FFFFFB  3 1198 5082         move    #-5,n7
P:020E 000000         2 1200 5082         nop             ; (inserted)
P:020F 5EEF00         4 1204 5084         move    y:(r7+n7),a
P:0210 0BF080 rrrrrr  6 1210 5085         jsr     FDisplayPrintStringAddressUnicode
                             5095 
                             5096 ; 193  |}
                             5097 
P:0212 77F400 FFFFF9  3 1213 5099         move    #-7,n7
P:0214 000000         2 1215 5099         nop             ; (inserted)
P:0215 05EF7C         4 1219 5101         movec   y:(r7+n7),ssh
P:0216 204F00         2 1221 5103         move    (r7)+n7
P:0217 00000C         4 1225 5105         rts
                             5107 
                             5108 ; 194  |
                             5109 ; 195  |
                             5110 ; 196  |#ifdef FAT32TEST
                             5111 ; 197  |WORD Fat32TestString[64];
                             5112 ; 198  |#endif
                             5113 ; 199  |_reentrant void DisplayPrintStringAddress   (INT x,INT y,void *pAddress ,INT bInvert)
                             5114 ; 200  |{
                             5115 
                             5120 FDisplayPrintStringAddress:
                             5142 
                             5143 ; 201  |    INT     iLength;
                             5144 ; 202  |    INT     iSize = SCRATCH_USER_Y_SIZE;
                             5145 ; 203  |    WORD    *pUnicodeString;
                             5146 
                             5163 
                             5164 ; 204  |
                             5165 ; 205  |    iLength = packed_strlen((_packed unsigned char *)pAddress)+1;
                             5166 
P:0218 055F7C         2 1227 5121         movec   ssh,y:(r7)+
P:0219 3F0500         2 1229 5124         move    #5,n7
P:021A 000000         2 1231 5124         nop             ; (inserted)
P:021B 204F00         2 1233 5126         move    (r7)+n7
P:021C 77F400 FFFFFD  3 1236 5148         move    #-3,n7
P:021E 000000         2 1238 5148         nop             ; (inserted)
P:021F 4C6F00         4 1242 5150         move    x0,y:(r7+n7)
P:0220 77F400 FFFFFC  3 1245 5153         move    #-4,n7
P:0222 000000         2 1247 5153         nop             ; (inserted)
P:0223 5D6F00         4 1251 5155         move    b1,y:(r7+n7)
P:0224 77F400 FFFFFB  3 1254 5158         move    #-5,n7
P:0226 000000         2 1256 5158         nop             ; (inserted)
P:0227 5C6F00         4 1260 5160         move    a1,y:(r7+n7)
P:0228 77F400 FFFFFE  3 1263 5168         move    #-2,n7
P:022A 000000         2 1265 5168         nop             ; (inserted)
P:022B 686F00         4 1269 5170         move    r0,y:(r7+n7)
P:022C 0BF080 rrrrrr  6 1275 5172         jsr     packed_strlen
                             5176 
                             5177 ; 206  |#ifdef FAT32TEST
                             5178 ; 207  |    // If same -3 is used, the first two words of pUnicodeString 
                             5179 ; 208  |    // become corrupted resulting in garbage being displayed on
                             5180 ; 209  |    // screen.  This seems to only affect fat32test
                             5181 ; 210  |    pUnicodeString = Fat32TestString;
                             5182 ; 211  |#else
                             5183 ; 212  |    pUnicodeString = ((WORD*)&g_wUserScratchY)+iSize-iLength-3;
                             5184 
                             5194 
                             5195 ; 213  |#endif
                             5196 ; 214  |    //convert the string to unicode.
                             5197 ; 215  |    DBCSToUnicode((_packed unsigned char *)pAddress,pUnicodeString,iLength);
                             5198 
P:022E 045FA0         2 1277 5200         movec   m0,n7
P:022F 45F400 000001  3 1280 5173         move    #>1,x1
P:0231 64F460 rrrrrr  3 1283 5174         add     x1,a	                #Fg_wUserScratchY+512,r4
P:0233 219C00         2 1285 5186         move    a1,n4
P:0234 000000         2 1287 5186         nop             ; (inserted)
P:0235 204400         2 1289 5189         move    (r4)-n4
P:0236 3C0300         2 1291 5190         move    #3,n4
P:0237 000000         2 1293 5190         nop             ; (inserted)
P:0238 204400         2 1295 5192         move    (r4)-n4
P:0239 6C6F00         4 1299 5202         move    r4,y:(r7+n7)
P:023A 77F400 FFFFFE  3 1302 5207         move    #-2,n7
P:023C 000000         2 1304 5207         nop             ; (inserted)
P:023D 68EF00         4 1308 5209         move    y:(r7+n7),r0
P:023E 0BF080 rrrrrr  6 1314 5210         jsr     FDBCSToUnicode
                             5214 
                             5215 ; 216  |    //display the string to unicode.
                             5216 ; 217  |    DisplayPrintStringAddressUnicode(x,y,pUnicodeString,bInvert);
                             5217 
P:0240 045FA0         2 1316 5219         movec   m0,n7
P:0241 000000         2 1318 5219         nop             ; (inserted)
P:0242 68EF00         4 1322 5221         move    y:(r7+n7),r0
P:0243 77F400 FFFFFD  3 1325 5225         move    #-3,n7
P:0245 000000         2 1327 5225         nop             ; (inserted)
P:0246 4CEF00         4 1331 5227         move    y:(r7+n7),x0
P:0247 77F400 FFFFFC  3 1334 5228         move    #-4,n7
P:0249 000000         2 1336 5228         nop             ; (inserted)
P:024A 5FEF00         4 1340 5230         move    y:(r7+n7),b
P:024B 77F400 FFFFFB  3 1343 5231         move    #-5,n7
P:024D 000000         2 1345 5231         nop             ; (inserted)
P:024E 5EEF00         4 1349 5233         move    y:(r7+n7),a
P:024F 0BF080 rrrrrr  6 1355 5234         jsr     FDisplayPrintStringAddressUnicode
                             5244 
                             5245 ; 218  |
                             5246 ; 219  |
                             5247 ; 220  |}
                             5248 
P:0251 77F400 FFFFFA  3 1358 5250         move    #-6,n7
P:0253 000000         2 1360 5250         nop             ; (inserted)
P:0254 05EF7C         4 1364 5252         movec   y:(r7+n7),ssh
P:0255 204F00         2 1366 5254         move    (r7)+n7
P:0256 00000C         4 1370 5256         rts
                             5258 
                             5259 ; 221  |
                             5260 ; 222  |_reentrant int DisplayPrintCharUnicode   (INT  x,INT y,WORD wChar,INT bInvert)
                             5261 ; 223  |{
                             5262 
                             5267 FDisplayPrintCharUnicode:
                             5288 
                             5289 ; 224  |    COMPLEX_RESOURCE Resource;
                             5290 ; 225  |    BITMAP *pCharacter;
                             5291 ; 226  |    WORD wWidth = 0;
                             5292 
                             5316 
                             5317 ; 227  |
                             5318 ; 228  |    Resource.I = wChar;
                             5319 
                             5324 
                             5325 ; 229  |    Resource.Complex.m_Type = RESOURCE_TYPE_UNICODE;
                             5326 
                             5331 
                             5332 ; 230  |    pCharacter = DisplayLoadBitmap(Resource.I);
                             5333 
P:0257 055F7C         2 1372 5268         movec   ssh,y:(r7)+
P:0258 3F0600         2 1374 5271         move    #6,n7
P:0259 000000         2 1376 5271         nop             ; (inserted)
P:025A 204F00         2 1378 5273         move    (r7)+n7
P:025B 77F400 FFFFFD  3 1381 5294         move    #-3,n7
P:025D 000000         2 1383 5294         nop             ; (inserted)
P:025E 4E6F00         4 1387 5296         move    y0,y:(r7+n7)
P:025F 77F400 FFFFFC  3 1390 5299         move    #-4,n7
P:0261 000000         2 1392 5299         nop             ; (inserted)
P:0262 5D6F00         4 1396 5301         move    b1,y:(r7+n7)
P:0263 77F400 FFFFFB  3 1399 5304         move    #-5,n7
P:0265 000000         2 1401 5304         nop             ; (inserted)
P:0266 5C6F00         4 1405 5306         move    a1,y:(r7+n7)
P:0267 77F400 FFFFFE  3 1408 5311         move    #-2,n7
P:0269 2C0000         2 1410 5309         move    #0,a1
P:026A 5C6F00         4 1414 5313         move    a1,y:(r7+n7)
P:026B 77F400 FFFFFA  3 1417 5321         move    #-6,n7
P:026D 000000         2 1419 5321         nop             ; (inserted)
P:026E 4C6F00         4 1423 5323         move    x0,y:(r7+n7)
P:026F 0A6F55         6 1429 5328         bclr    #21,y:(r7+n7)
P:0270 0A6F76         6 1435 5329         bset    #22,y:(r7+n7)
P:0271 0A6F57         6 1441 5330         bclr    #23,y:(r7+n7)
P:0272 5EEF00         4 1445 5335         move    y:(r7+n7),a
P:0273 0BF080 rrrrrr  6 1451 5336         jsr     FDisplayLoadBitmap
                             5339 
                             5340 ; 231  |    if(pCharacter)
                             5341 
P:0275 220F00         2 1453 5343         move    r0,b
P:0276 20000B         2 1455 5344         tst     b
P:0277 0AF0AA rrrrrr  6 1461 5345         jeq     L43
                             5353 
                             5354 ; 232  |    {
                             5355 ; 233  |        SALDisplayPrintBitmapAddress(x,y,pCharacter,bInvert);
                             5356 
P:0279 045FA0         2 1463 5346         movec   m0,n7
P:027A 000000         2 1465 5346         nop             ; (inserted)
P:027B 686F00         4 1469 5348         move    r0,y:(r7+n7)
P:027C 77F400 FFFFFD  3 1472 5358         move    #-3,n7
P:027E 000000         2 1474 5358         nop             ; (inserted)
P:027F 4CEF00         4 1478 5360         move    y:(r7+n7),x0
P:0280 77F400 FFFFFC  3 1481 5361         move    #-4,n7
P:0282 000000         2 1483 5361         nop             ; (inserted)
P:0283 5FEF00         4 1487 5363         move    y:(r7+n7),b
P:0284 77F400 FFFFFB  3 1490 5364         move    #-5,n7
P:0286 000000         2 1492 5364         nop             ; (inserted)
P:0287 5EEF00         4 1496 5366         move    y:(r7+n7),a
P:0288 0BF080 rrrrrr  6 1502 5367         jsr     FSALDisplayPrintBitmapAddress
                             5379 
                             5380 ; 234  |        wWidth = pCharacter->m_iWidth;       
                             5381 
                             5393 
                             5394 ; 235  |    }
                             5395 ; 236  |
                             5396 ; 237  |    return wWidth;
                             5397 
P:028A 045FA0         2 1504 5383         movec   m0,n7
P:028B 000000         2 1506 5383         nop             ; (inserted)
P:028C 6EEF00         4 1510 5385         move    y:(r7+n7),r6
P:028D 77F400 FFFFFE  3 1513 5390         move    #-2,n7
P:028F 4EE600         2 1515 5387         move    y:(r6),y0
P:0290 4E6F00         4 1519 5392         move    y0,y:(r7+n7)
                             5399 L43:
                             5405 
                             5406 ; 238  |}
                             5407 
P:0291 77F400 FFFFFE  3 1522 5399         move    #-2,n7
P:0293 000000         2 1524 5399         nop             ; (inserted)
P:0294 5EEF00         4 1528 5401         move    y:(r7+n7),a
P:0295 77F400 FFFFF9  3 1531 5409         move    #-7,n7
P:0297 218E00         2 1533 5402         move    a1,a
P:0298 05EF7C         4 1537 5411         movec   y:(r7+n7),ssh
P:0299 204F00         2 1539 5413         move    (r7)+n7
P:029A 00000C         4 1543 5415         rts
                             5419 
                             5420 ; 239  |
                             5421 ; 240  |
                             5422 ; 241  |_reentrant void DisplayPrintStringAddressUnicode   (INT  x,INT y,void *pAddress ,INT bInvert)
                             5423 ; 242  |{
                             5424 
                             5429 FDisplayPrintStringAddressUnicode:
                             5449 
                             5450 ; 243  |    COMPLEX_RESOURCE Resource;
                             5451 ; 244  |    WORD *pString=pAddress;
                             5452 
                             5468 
                             5469 ; 245  |    BITMAP *pCharacter;
                             5470 ; 246  |    while(*pString)
                             5471 
P:029B 055F7C         2 1545 5430         movec   ssh,y:(r7)+
P:029C 3F0400         2 1547 5433         move    #4,n7
P:029D 221600         2 1549 5464         move    r0,r6
P:029E 204F00         2 1551 5435         move    (r7)+n7
P:029F 77F400 FFFFFE  3 1554 5454         move    #-2,n7
P:02A1 000000         2 1556 5454         nop             ; (inserted)
P:02A2 4C6F00         4 1560 5456         move    x0,y:(r7+n7)
P:02A3 77F400 FFFFFD  3 1563 5459         move    #-3,n7
P:02A5 000000         2 1565 5459         nop             ; (inserted)
P:02A6 5D6F00         4 1569 5461         move    b1,y:(r7+n7)
P:02A7 0AF080 rrrrrr  6 1575 5473         jmp     L45
                             5474 
                             5475 ; 247  |    {
                             5476 ; 248  |        x+=DisplayPrintCharUnicode(x,y,*pString++,bInvert);
                             5477 
                             5479 L44:
TASKING DSP2410 assembler v1.5r1 Build 138 SN 00100122
                                                                                                                                                                                                                                                       Page  20

M:ADDR CODE           CYCLES LINE SOURCELINE
P:02A9 045FA0         2 1577 5479         movec   m0,n7
P:02AA 000000         2 1579 5479         nop             ; (inserted)
P:02AB 6E6F00         4 1583 5481         move    r6,y:(r7+n7)
P:02AC 77F400 FFFFFC  3 1586 5485         move    #-4,n7
P:02AE 4CE600         2 1588 5482         move    y:(r6),x0
P:02AF 5C6F00         4 1592 5487         move    a1,y:(r7+n7)
P:02B0 77F400 FFFFFD  3 1595 5492         move    #-3,n7
P:02B2 000000         2 1597 5492         nop             ; (inserted)
P:02B3 5FEF00         4 1601 5494         move    y:(r7+n7),b
P:02B4 77F400 FFFFFE  3 1604 5497         move    #-2,n7
P:02B6 000000         2 1606 5497         nop             ; (inserted)
P:02B7 4EEF00         4 1610 5499         move    y:(r7+n7),y0
P:02B8 0BF080 rrrrrr  6 1616 5502         jsr     FDisplayPrintCharUnicode
                             5525 
                             5526 ; 249  |        if(x > g_iMaskRight)
                             5527 
P:02BA 77F400 FFFFFC  3 1619 5510         move    #-4,n7
P:02BC 4EF000 rrrrrr  3 1622 5529         move    y:Fg_iMaskRight,y0
P:02BE 4FEF00         4 1626 5512         move    y:(r7+n7),y1
P:02BF 045FA0         2 1628 5518         movec   m0,n7
P:02C0 200070         2 1630 5513         add     y1,a
P:02C1 6EEF55         4 1634 5530         cmp     y0,a	                y:(r7+n7),r6
P:02C2 000000         2 1636 5530         nop             ; (inserted)
P:02C3 205E00         2 1638 5522         move    (r6)+
P:02C4 0AF0A7 rrrrrr  6 1644 5531         jgt     L46
P:02C6 5FE600         2 1646 5533 L45:    move    y:(r6),b
P:02C7 2B0000         2 1648 5534         move    #0,b2
P:02C8 20000B         2 1650 5535         tst     b
P:02C9 0AF0A2 rrrrrr  6 1656 5536         jne     L44
                             5537 
                             5538 ; 250  |            break;//short cut to end print string quicker
                             5539 ; 251  |    }
                             5540 
                             5542 L46:
                             5543 
                             5544 ; 252  |}
                             5545 
P:02CB 77F400 FFFFFB  3 1659 5547         move    #-5,n7
P:02CD 000000         2 1661 5547         nop             ; (inserted)
P:02CE 05EF7C         4 1665 5549         movec   y:(r7+n7),ssh
P:02CF 204F00         2 1667 5551         move    (r7)+n7
P:02D0 00000C         4 1671 5553         rts
                             5559 
                             5560 ; 253  |
                             5561 ; 254  |void StringPrintNumber(WORD *pUnicodeString,INT iNumber, INT iDigits, INT iFiller)
                             5562 ; 255  |{
                             5563 
                             5568 FStringPrintNumber:
                             5579 
                             5580 ; 256  |    int i;
                             5581 
                             5592 
                             5593 ; 257  |    for(i=0;i<iDigits;i++)
                             5594 
P:02D1 221500         2 1673 5598         move    r0,r5
P:02D2 270000         2 1675 5596         move    #0,y1
P:02D3 045516         4 1679 5600         lua     (r5)-,r6
P:02D4 5C7000 rrrrrr  3 1682 5583         move    a1,y:ss_StringPrintNumber
P:02D6 21A500         2 1684 5586         move    b1,x1
P:02D7 46F400 000030  3 1687 5604         move    #>$30,y0
P:02D9 4C7000 rrrrrr  3 1690 5589         move    x0,y:ss_StringPrintNumber+1
P:02DB 44F400 00000A  3 1693 5603         move    #>10,x0
P:02DD 0AF080 rrrrrr  6 1699 5605         jmp     L51
                             5606 
                             5607 ; 258  |    {
                             5608 ; 259  |        if(iNumber||!i)
                             5609 
P:02DF 5FF000 rrrrrr  3 1702 5611 L47:    move    y:ss_StringPrintNumber,b
P:02E1 20000B         2 1704 5612         tst     b
P:02E2 0AF0A2 rrrrrr  6 1710 5613         jne     L48
P:02E4 20EF00         2 1712 5614         move    y1,b
P:02E5 20000B         2 1714 5615         tst     b
P:02E6 0AF0A2 rrrrrr  6 1720 5616         jne     L49
                             5617 
                             5618 ; 260  |        {
                             5619 ; 261  |            pUnicodeString[iDigits-i-1] = 0x30+ iNumber%10;
                             5620 
P:02E8 5EF000 rrrrrr  3 1723 5622 L48:    move    y:ss_StringPrintNumber,a
P:02EA 0BF080 rrrrrr  6 1729 5623         jsr     Rmod_iii
                             5630 
                             5631 ; 262  |            iNumber /= 10;
                             5632 
P:02EC 20AF50         2 1731 5624         add     y0,a	                x1,b
P:02ED 20007C         2 1733 5626         sub     y1,b
P:02EE 21BE00         2 1735 5627         move    b1,n6
P:02EF 000000         2 1737 5627         nop             ; (inserted)
P:02F0 5C6E00         4 1741 5629         move    a1,y:(r6+n6)
P:02F1 5EF000 rrrrrr  3 1744 5634         move    y:ss_StringPrintNumber,a
P:02F3 0BF080 rrrrrr  6 1750 5635         jsr     Rdiv_iii
                             5642 
                             5643 ; 263  |        }
                             5644 
P:02F5 5E7000 rrrrrr  3 1753 5638         move    a,y:ss_StringPrintNumber
P:02F7 5EF000 rrrrrr  3 1756 5641         move    y:ss_StringPrintNumber,a
P:02F9 0AF080 rrrrrr  6 1762 5646         jmp     L50
                             5647 
                             5648 ; 264  |        else
                             5649 ; 265  |        {
                             5650 ; 266  |            pUnicodeString[iDigits-i-1] = iFiller;
                             5651 
                             5653 L49:
                             5658 
                             5659 ; 267  |        }
                             5660 
P:02FB 20AF00         2 1764 5653         move    x1,b
P:02FC 20007C         2 1766 5654         sub     y1,b
P:02FD 21BE00         2 1768 5655         move    b1,n6
P:02FE 5FF000 rrrrrr  3 1771 5656         move    y:ss_StringPrintNumber+1,b
P:0300 5F6E00         4 1775 5657         move    b,y:(r6+n6)
                             5662 L50:
P:0301 57F471 000001  3 1778 5664         tfr     y1,a	                #>1,b
P:0303 200010         2 1780 5666         add     b,a
P:0304 218700         2 1782 5669         move    a1,y1
P:0305 20EF00         2 1784 5672 L51:    move    y1,b
P:0306 20006D         2 1786 5673         cmp     x1,b
P:0307 0AF0A9 rrrrrr  6 1792 5674         jlt     L47
                             5675 
                             5676 ; 268  |
                             5677 ; 269  |    }
                             5678 ; 270  |    pUnicodeString[iDigits]=0;
                             5679 
                             5684 
                             5685 ; 271  |
                             5686 ; 272  |}
                             5687 
P:0309 20BD1B         2 1794 5682         clr     b	                x1,n5
P:030A 000000         2 1796 5682         nop             ; (inserted)
P:030B 5F6D00         4 1800 5683         move    b,y:(r5+n5)
P:030C 00000C         4 1804 5689         rts
                             5695 
Y:0000                       5696         org     y,".yovldisplaydrv@StringPrintNumber",overlay:
                             5697 ss_StringPrintNumber:
Y:0000                       5698         ds      2
   |   RESERVED                   
Y:0001
                             5699 
P:030D                       5700         org     p,".ptextdisplaydrv":
                             5702 
                             5703 ; 273  |
                             5704 ; 274  |
                             5705 ; 275  |
                             5706 ; 276  |_reentrant void DisplayPrintNumber(INT  x,INT y,INT iNumber,INT iDigits, INT iFiller, INT bInvert)
                             5707 ; 277  |{
                             5708 
                             5713 FDisplayPrintNumber:
                             5734 
                             5735 ; 278  |    WORD    pUnicodeString[MAX_DIGITS];
                             5736 
                             5753 
                             5754 ; 279  |    if(iDigits < MAX_DIGITS)
                             5755 
P:030D 055F7C         2 1806 5714         movec   ssh,y:(r7)+
P:030E 3F0D00         2 1808 5717         move    #13,n7
P:030F 000000         2 1810 5717         nop             ; (inserted)
P:0310 204F00         2 1812 5719         move    (r7)+n7
P:0311 045FA0         2 1814 5738         movec   m0,n7
P:0312 000000         2 1816 5738         nop             ; (inserted)
P:0313 4F6F00         4 1820 5740         move    y1,y:(r7+n7)
P:0314 77F400 FFFFFE  3 1823 5743         move    #-2,n7
P:0316 47F400 00000A  3 1826 5758         move    #>10,y1
P:0318 5D6F59         4 1830 5757         tfr     y0,b	                b1,y:(r7+n7)
P:0319 77F47D FFFFFD  3 1833 5759         cmp     y1,b	                #-3,n7
P:031B 000000         2 1835 5759         nop             ; (inserted)
P:031C 5C6F00         4 1839 5750         move    a1,y:(r7+n7)
P:031D 0AF0A1 rrrrrr  6 1845 5762         jge     L52
                             5763 
                             5764 ; 280  |    {
                             5765 ; 281  |        StringPrintNumber(pUnicodeString, iNumber, iDigits,iFiller);
                             5766 
P:031F 77F441 FFFFF3  3 1848 5772         tfr     x0,a	                #-13,n7
P:0321 20A400         2 1850 5773         move    x1,x0
P:0322 044F1D         4 1854 5770         lua     (r7)+n7,n5
P:0323 23B000         2 1856 5771         move    n5,r0
P:0324 0BF080 rrrrrr  6 1862 5774         jsr     FStringPrintNumber
                             5782 
                             5783 ; 282  |        DisplayPrintStringAddressUnicode(x,y,pUnicodeString,bInvert);
                             5784 
P:0326 77F400 FFFFF3  3 1865 5786         move    #-13,n7
P:0328 000000         2 1867 5786         nop             ; (inserted)
P:0329 044F10         4 1871 5788         lua     (r7)+n7,r0
P:032A 045FA0         2 1873 5789         movec   m0,n7
P:032B 000000         2 1875 5789         nop             ; (inserted)
P:032C 4CEF00         4 1879 5791         move    y:(r7+n7),x0
P:032D 77F400 FFFFFE  3 1882 5792         move    #-2,n7
P:032F 000000         2 1884 5792         nop             ; (inserted)
P:0330 5FEF00         4 1888 5794         move    y:(r7+n7),b
P:0331 77F400 FFFFFD  3 1891 5795         move    #-3,n7
P:0333 000000         2 1893 5795         nop             ; (inserted)
P:0334 5EEF00         4 1897 5797         move    y:(r7+n7),a
P:0335 0BF080 rrrrrr  6 1903 5798         jsr     FDisplayPrintStringAddressUnicode
                             5808 
                             5809 ; 283  |    }
                             5810 
                             5812 L52:
                             5813 
                             5814 ; 284  |}
                             5815 
P:0337 77F400 FFFFF2  3 1906 5817         move    #-14,n7
P:0339 000000         2 1908 5817         nop             ; (inserted)
P:033A 05EF7C         4 1912 5819         movec   y:(r7+n7),ssh
P:033B 204F00         2 1914 5821         move    (r7)+n7
P:033C 00000C         4 1918 5823         rts
                             5825 
                             5826 ; 285  |
                             5827 ; 286  |#ifndef FAT32TEST
                             5828 ; 287  |_reentrant void DisplayPrintTime    (INT x,INT y,INT iMinutes   ,INT iSeconds                   ,INT bInvert)
                             5829 ; 288  |{
                             5830 
                             5835 FDisplayPrintTime:
                             5855 
                             5856 ; 289  |    WORD pUnicodeString[2+1+2+1+2];//2 for minutes, 1 for colon, 2 for seconds, 1 for terminator, and 2 for padding
                             5857 
                             5879 
                             5880 ; 290  |    StringPrintNumber(pUnicodeString+0, iMinutes, 2,'0');
                             5881 
P:033D 055F7C         2 1920 5836         movec   ssh,y:(r7)+
P:033E 3F0C00         2 1922 5839         move    #12,n7
P:033F 000000         2 1924 5839         nop             ; (inserted)
P:0340 204F00         2 1926 5841         move    (r7)+n7
P:0341 045FA0         2 1928 5859         movec   m0,n7
P:0342 000000         2 1930 5859         nop             ; (inserted)
P:0343 4D6F00         4 1934 5861         move    x1,y:(r7+n7)
P:0344 77F400 FFFFFE  3 1937 5864         move    #-2,n7
P:0346 000000         2 1939 5864         nop             ; (inserted)
P:0347 4E6F00         4 1943 5866         move    y0,y:(r7+n7)
P:0348 77F400 FFFFFD  3 1946 5869         move    #-3,n7
P:034A 46F400 000030  3 1949 5888         move    #>$30,y0
P:034C 5D6F00         4 1953 5871         move    b1,y:(r7+n7)
P:034D 77F400 FFFFFC  3 1956 5874         move    #-4,n7
P:034F 57F400 000002  3 1959 5886         move    #>2,b
P:0351 5C6F41         4 1963 5889         tfr     x0,a	                a1,y:(r7+n7)
P:0352 77F400 FFFFF4  3 1966 5883         move    #-12,n7
P:0354 20C400         2 1968 5890         move    y0,x0
P:0355 044F16         4 1972 5885         lua     (r7)+n7,r6
P:0356 22D000         2 1974 5887         move    r6,r0
P:0357 0BF080 rrrrrr  6 1980 5891         jsr     FStringPrintNumber
                             5895 
                             5896 ; 291  |    pUnicodeString[2]=':';
                             5897 
                             5903 
                             5904 ; 292  |    StringPrintNumber(pUnicodeString+3, iSeconds, 2,'0');
                             5905 
P:0359 77F400 FFFFF6  3 1983 5900         move    #-10,n7
TASKING DSP2410 assembler v1.5r1 Build 138 SN 00100122
                                                                                                                                                                                                                                                       Page  21

M:ADDR CODE           CYCLES LINE SOURCELINE
P:035B 57F400 000002  3 1986 5913         move    #>2,b
P:035D 45F400 00003A  3 1989 5899         move    #>58,x1
P:035F 44F400 000030  3 1992 5914         move    #>$30,x0
P:0361 4D6F00         4 1996 5902         move    x1,y:(r7+n7)
P:0362 77F400 FFFFF7  3 1999 5907         move    #-9,n7
P:0364 000000         2 2001 5907         nop             ; (inserted)
P:0365 044F10         4 2005 5909         lua     (r7)+n7,r0
P:0366 77F400 FFFFFE  3 2008 5910         move    #-2,n7
P:0368 000000         2 2010 5910         nop             ; (inserted)
P:0369 5EEF00         4 2014 5912         move    y:(r7+n7),a
P:036A 0BF080 rrrrrr  6 2020 5915         jsr     FStringPrintNumber
                             5919 
                             5920 ; 293  |    DisplayPrintStringAddressUnicode(x,y,pUnicodeString,bInvert);
                             5921 
P:036C 77F400 FFFFF4  3 2023 5923         move    #-12,n7
P:036E 000000         2 2025 5923         nop             ; (inserted)
P:036F 044F10         4 2029 5925         lua     (r7)+n7,r0
P:0370 045FA0         2 2031 5926         movec   m0,n7
P:0371 000000         2 2033 5926         nop             ; (inserted)
P:0372 4CEF00         4 2037 5928         move    y:(r7+n7),x0
P:0373 77F400 FFFFFD  3 2040 5929         move    #-3,n7
P:0375 000000         2 2042 5929         nop             ; (inserted)
P:0376 5FEF00         4 2046 5931         move    y:(r7+n7),b
P:0377 77F400 FFFFFC  3 2049 5932         move    #-4,n7
P:0379 000000         2 2051 5932         nop             ; (inserted)
P:037A 5EEF00         4 2055 5934         move    y:(r7+n7),a
P:037B 0BF080 rrrrrr  6 2061 5935         jsr     FDisplayPrintStringAddressUnicode
                             5945 
                             5946 ; 294  |}
                             5947 
P:037D 77F400 FFFFF3  3 2064 5949         move    #-13,n7
P:037F 000000         2 2066 5949         nop             ; (inserted)
P:0380 05EF7C         4 2070 5951         movec   y:(r7+n7),ssh
P:0381 204F00         2 2072 5953         move    (r7)+n7
P:0382 00000C         4 2076 5955         rts
                             5957 
                             5958 ; 295  |
                             5959 ; 296  |_reentrant void DisplayPrintLongTime(INT x,INT y,INT iHours     ,INT iMinutes   ,INT iSeconds   ,INT bInvert)
                             5960 ; 297  |{
                             5961 
                             5966 FDisplayPrintLongTime:
                             5988 
                             5989 ; 298  |    WORD pUnicodeString[2+1+2+1+2+1+2];//2 for minutes, 1 for colon, 2 for seconds, 1 for terminator, and 2 for padding
                             5990 
                             6017 
                             6018 ; 299  |    StringPrintNumber(pUnicodeString+0, iHours  , 2,'0');
                             6019 
P:0383 055F7C         2 2078 5967         movec   ssh,y:(r7)+
P:0384 3F1100         2 2080 5970         move    #17,n7
P:0385 283000         2 2082 6026         move    #$30,a0
P:0386 204F00         2 2084 5972         move    (r7)+n7
P:0387 045FA0         2 2086 5992         movec   m0,n7
P:0388 000000         2 2088 5992         nop             ; (inserted)
P:0389 4F6F00         4 2092 5994         move    y1,y:(r7+n7)
P:038A 77F400 FFFFFE  3 2095 5997         move    #-2,n7
P:038C 000000         2 2097 5997         nop             ; (inserted)
P:038D 4D6F00         4 2101 5999         move    x1,y:(r7+n7)
P:038E 77F400 FFFFFD  3 2104 6002         move    #-3,n7
P:0390 000000         2 2106 6002         nop             ; (inserted)
P:0391 4E6F00         4 2110 6004         move    y0,y:(r7+n7)
P:0392 77F400 FFFFFB  3 2113 6007         move    #-5,n7
P:0394 000000         2 2115 6007         nop             ; (inserted)
P:0395 5D6F00         4 2119 6009         move    b1,y:(r7+n7)
P:0396 77F400 FFFFFA  3 2122 6012         move    #-6,n7
P:0398 57F400 000002  3 2125 6024         move    #>2,b
P:039A 5C6F00         4 2129 6014         move    a1,y:(r7+n7)
P:039B 77F400 FFFFEF  3 2132 6021         move    #-17,n7
P:039D 000000         2 2134 6021         nop             ; (inserted)
P:039E 044F15         4 2138 6023         lua     (r7)+n7,r5
P:039F 77F400 FFFFFC  3 2141 6027         move    #-4,n7
P:03A1 22B000         2 2143 6025         move    r5,r0
P:03A2 4C6F00         4 2147 6029         move    x0,y:(r7+n7)
P:03A3 210400         2 2149 6032         move    a0,x0
P:03A4 5EEF00         4 2153 6033         move    y:(r7+n7),a
P:03A5 0BF080 rrrrrr  6 2159 6034         jsr     FStringPrintNumber
                             6038 
                             6039 ; 300  |    pUnicodeString[2]=':';
                             6040 
                             6046 
                             6047 ; 301  |    StringPrintNumber(pUnicodeString+3, iMinutes, 2,'0');
                             6048 
P:03A7 77F400 FFFFF1  3 2162 6043         move    #-15,n7
P:03A9 293A00         2 2164 6042         move    #58,b0
P:03AA 44F400 000030  3 2167 6054         move    #>$30,x0
P:03AC 596F00         4 2171 6045         move    b0,y:(r7+n7)
P:03AD 77F400 FFFFF2  3 2174 6050         move    #-14,n7
P:03AF 57F400 000002  3 2177 6053         move    #>2,b
P:03B1 044F10         4 2181 6052         lua     (r7)+n7,r0
P:03B2 77F400 FFFFFD  3 2184 6055         move    #-3,n7
P:03B4 000000         2 2186 6055         nop             ; (inserted)
P:03B5 5EEF00         4 2190 6057         move    y:(r7+n7),a
P:03B6 0BF080 rrrrrr  6 2196 6058         jsr     FStringPrintNumber
                             6062 
                             6063 ; 302  |    pUnicodeString[5]=':';
                             6064 
                             6070 
                             6071 ; 303  |    StringPrintNumber(pUnicodeString+6, iSeconds, 2,'0');
                             6072 
P:03B8 77F400 FFFFF4  3 2199 6067         move    #-12,n7
P:03BA 56F400 00003A  3 2202 6066         move    #>58,a
P:03BC 57F400 000002  3 2205 6080         move    #>2,b
P:03BE 44F400 000030  3 2208 6081         move    #>$30,x0
P:03C0 5C6F00         4 2212 6069         move    a1,y:(r7+n7)
P:03C1 77F400 FFFFF5  3 2215 6074         move    #-11,n7
P:03C3 000000         2 2217 6074         nop             ; (inserted)
P:03C4 044F10         4 2221 6076         lua     (r7)+n7,r0
P:03C5 77F400 FFFFFE  3 2224 6077         move    #-2,n7
P:03C7 000000         2 2226 6077         nop             ; (inserted)
P:03C8 5EEF00         4 2230 6079         move    y:(r7+n7),a
P:03C9 0BF080 rrrrrr  6 2236 6082         jsr     FStringPrintNumber
                             6086 
                             6087 ; 304  |    DisplayPrintStringAddressUnicode(x,y,pUnicodeString,bInvert);
                             6088 
P:03CB 77F400 FFFFEF  3 2239 6090         move    #-17,n7
P:03CD 000000         2 2241 6090         nop             ; (inserted)
P:03CE 044F10         4 2245 6092         lua     (r7)+n7,r0
P:03CF 045FA0         2 2247 6093         movec   m0,n7
P:03D0 000000         2 2249 6093         nop             ; (inserted)
P:03D1 4CEF00         4 2253 6095         move    y:(r7+n7),x0
P:03D2 77F400 FFFFFB  3 2256 6096         move    #-5,n7
P:03D4 000000         2 2258 6096         nop             ; (inserted)
P:03D5 5FEF00         4 2262 6098         move    y:(r7+n7),b
P:03D6 77F400 FFFFFA  3 2265 6099         move    #-6,n7
P:03D8 000000         2 2267 6099         nop             ; (inserted)
P:03D9 5EEF00         4 2271 6101         move    y:(r7+n7),a
P:03DA 0BF080 rrrrrr  6 2277 6102         jsr     FDisplayPrintStringAddressUnicode
                             6112 
                             6113 ; 305  |}
                             6114 
P:03DC 77F400 FFFFEE  3 2280 6116         move    #-18,n7
P:03DE 000000         2 2282 6116         nop             ; (inserted)
P:03DF 05EF7C         4 2286 6118         movec   y:(r7+n7),ssh
P:03E0 204F00         2 2288 6120         move    (r7)+n7
P:03E1 00000C         4 2292 6122         rts
                             6124 
                             6125 ; 306  |#endif
                             6126 ; 307  |_reentrant void DisplayHandleMessage(Message *pMsg)
                             6127 ; 308  |{
                             6128 
                             6135 FDisplayHandleMessage:
                             6141 
                             6142 ; 309  |    SALHandleMessage(pMsg);
                             6143 
P:03E2 055F7C         2 2294 6136         movec   ssh,y:(r7)+
P:03E3 0BF080 rrrrrr  6 2300 6145         jsr     FSALHandleMessage
                             6147 
                             6148 ; 310  |}
                             6149 
P:03E5 05FF7C         4 2304 6151         movec   y:-(r7),ssh
P:03E6 000000         2 2306 6151         nop             ; (inserted)
P:03E7 00000C         4 2310 6155         rts
                             6157 
                             6158 ; 311  |
                             6159 ; 312  |// tt - added for Stmp00002965/2970 - now display hour if we're over an hour of play time.
                             6160 ; 313  |_reentrant void DisplayPrint1DigitHourTime(INT x,INT y,INT iHours     ,INT iMinutes   ,INT iSeconds   ,INT bInvert)
                             6161 ; 314  |{
                             6162 
                             6167 FDisplayPrint1DigitHourTime:
                             6188 
                             6189 ; 315  |    WORD pUnicodeString[2+1+2+1+2+1+2];// 2 for hours, 1 for colon, 2 for minutes, 1 for colon, 2 for seconds, 1 for terminator, and 2 for padding
                             6190 
                             6217 
                             6218 ; 316  |    StringPrintNumber(pUnicodeString+0, iHours  , 2,'0');
                             6219 
P:03E8 055F7C         2 2312 6168         movec   ssh,y:(r7)+
P:03E9 3F1100         2 2314 6171         move    #17,n7
P:03EA 283000         2 2316 6226         move    #$30,a0
P:03EB 204F00         2 2318 6173         move    (r7)+n7
P:03EC 045FA0         2 2320 6192         movec   m0,n7
P:03ED 000000         2 2322 6192         nop             ; (inserted)
P:03EE 4F6F00         4 2326 6194         move    y1,y:(r7+n7)
P:03EF 77F400 FFFFFE  3 2329 6197         move    #-2,n7
P:03F1 000000         2 2331 6197         nop             ; (inserted)
P:03F2 4D6F00         4 2335 6199         move    x1,y:(r7+n7)
P:03F3 77F400 FFFFFD  3 2338 6202         move    #-3,n7
P:03F5 000000         2 2340 6202         nop             ; (inserted)
P:03F6 4E6F00         4 2344 6204         move    y0,y:(r7+n7)
P:03F7 77F400 FFFFFB  3 2347 6207         move    #-5,n7
P:03F9 000000         2 2349 6207         nop             ; (inserted)
P:03FA 5D6F00         4 2353 6209         move    b1,y:(r7+n7)
P:03FB 77F400 FFFFFA  3 2356 6212         move    #-6,n7
P:03FD 57F400 000002  3 2359 6224         move    #>2,b
P:03FF 5C6F00         4 2363 6214         move    a1,y:(r7+n7)
P:0400 77F400 FFFFEF  3 2366 6221         move    #-17,n7
P:0402 000000         2 2368 6221         nop             ; (inserted)
P:0403 044F15         4 2372 6223         lua     (r7)+n7,r5
P:0404 77F400 FFFFFC  3 2375 6227         move    #-4,n7
P:0406 22B000         2 2377 6225         move    r5,r0
P:0407 4C6F00         4 2381 6229         move    x0,y:(r7+n7)
P:0408 210400         2 2383 6232         move    a0,x0
P:0409 5EEF00         4 2387 6233         move    y:(r7+n7),a
P:040A 0BF080 rrrrrr  6 2393 6234         jsr     FStringPrintNumber
                             6238 
                             6239 ; 317  |    pUnicodeString[2]=':';
                             6240 
                             6246 
                             6247 ; 318  |    StringPrintNumber(pUnicodeString+3, iMinutes, 2,'0');
                             6248 
P:040C 77F400 FFFFF1  3 2396 6243         move    #-15,n7
P:040E 293A00         2 2398 6242         move    #58,b0
P:040F 44F400 000030  3 2401 6254         move    #>$30,x0
P:0411 596F00         4 2405 6245         move    b0,y:(r7+n7)
P:0412 77F400 FFFFF2  3 2408 6250         move    #-14,n7
P:0414 57F400 000002  3 2411 6253         move    #>2,b
P:0416 044F10         4 2415 6252         lua     (r7)+n7,r0
P:0417 77F400 FFFFFD  3 2418 6255         move    #-3,n7
P:0419 000000         2 2420 6255         nop             ; (inserted)
P:041A 5EEF00         4 2424 6257         move    y:(r7+n7),a
P:041B 0BF080 rrrrrr  6 2430 6258         jsr     FStringPrintNumber
                             6262 
                             6263 ; 319  |    pUnicodeString[5]=':';
                             6264 
                             6270 
                             6271 ; 320  |    StringPrintNumber(pUnicodeString+6, iSeconds, 2,'0');
                             6272 
P:041D 77F400 FFFFF4  3 2433 6267         move    #-12,n7
P:041F 56F400 00003A  3 2436 6266         move    #>58,a
P:0421 57F400 000002  3 2439 6280         move    #>2,b
P:0423 44F400 000030  3 2442 6281         move    #>$30,x0
P:0425 5C6F00         4 2446 6269         move    a1,y:(r7+n7)
P:0426 77F400 FFFFF5  3 2449 6274         move    #-11,n7
P:0428 000000         2 2451 6274         nop             ; (inserted)
P:0429 044F10         4 2455 6276         lua     (r7)+n7,r0
P:042A 77F400 FFFFFE  3 2458 6277         move    #-2,n7
P:042C 000000         2 2460 6277         nop             ; (inserted)
P:042D 5EEF00         4 2464 6279         move    y:(r7+n7),a
P:042E 0BF080 rrrrrr  6 2470 6282         jsr     FStringPrintNumber
                             6286 
                             6287 ; 321  |    DisplayPrintStringAddressUnicode(x,y,pUnicodeString,bInvert);
                             6288 
P:0430 77F400 FFFFEF  3 2473 6290         move    #-17,n7
P:0432 000000         2 2475 6290         nop             ; (inserted)
P:0433 044F10         4 2479 6292         lua     (r7)+n7,r0
P:0434 045FA0         2 2481 6293         movec   m0,n7
P:0435 000000         2 2483 6293         nop             ; (inserted)
P:0436 4CEF00         4 2487 6295         move    y:(r7+n7),x0
P:0437 77F400 FFFFFB  3 2490 6296         move    #-5,n7
P:0439 000000         2 2492 6296         nop             ; (inserted)
P:043A 5FEF00         4 2496 6298         move    y:(r7+n7),b
P:043B 77F400 FFFFFA  3 2499 6299         move    #-6,n7
P:043D 000000         2 2501 6299         nop             ; (inserted)
P:043E 5EEF00         4 2505 6301         move    y:(r7+n7),a
P:043F 0BF080 rrrrrr  6 2511 6302         jsr     FDisplayPrintStringAddressUnicode
                             6312 
                             6313 ; 322  |}
                             6314 
P:0441 77F400 FFFFEE  3 2514 6316         move    #-18,n7
P:0443 000000         2 2516 6316         nop             ; (inserted)
P:0444 05EF7C         4 2520 6318         movec   y:(r7+n7),ssh
P:0445 204F00         2 2522 6320         move    (r7)+n7
P:0446 00000C         4 2526 6322         rts
TASKING DSP2410 assembler v1.5r1 Build 138 SN 00100122
                                                                                                                                                                                                                                                       Page  22

M:ADDR CODE           CYCLES LINE SOURCELINE
                             6324 
                             6325 ; 323  |
                             6326 
                             6328 
                             6331 
Y:0000                       6332         org     y,".ybssdisplaydrv",bss:
                             6333 Fg_iMaskBottom:
Y:0000 RESERVED              6334         ds      1
Y:0000
                             6339 Fg_iMaskTop:
Y:0001 RESERVED              6340         ds      1
Y:0001
                             6355 Fg_iMaskRight:
Y:0002 RESERVED              6356         ds      1
Y:0002
                             6373 Fg_iMaskLeft:
Y:0003 RESERVED              6374         ds      1
Y:0003
                             6375 
                             6376         extern  Rdiv_iii, Rmod_iii, packed_strlen, FDBCSToUnicode
                             6377         extern  FGetUnicodeCharacterBitmap, FLCDSetFont
                             6378         extern  FSALDisplayClearRange, FSALDisplayGetHeight
                             6379         extern  FSALDisplayGetWidth, FSALDisplayPrintBitmapAddress
                             6380         extern  FSALDisplayUpdate, FSALHandleMessage, FSysCloseResource
                             6381         extern  FSysLoadResource, FSysOpenResource, y:Fg_wUserScratchY
                             6382 
                             6383         global  FDisplayClearRange, FDisplayHandleMessage
                             6384         global  FDisplayLoadBitmap, FDisplayPrint1DigitHourTime
                             6385         global  FDisplayPrintBitmapAddress, FDisplayPrintBitmapResource
                             6386         global  FDisplayPrintCharUnicode, FDisplayPrintLongTime
                             6387         global  FDisplayPrintNumber, FDisplayPrintStringAddress
                             6388         global  FDisplayPrintStringAddressUnicode
                             6389         global  FDisplayPrintStringResource
                             6390         global  FDisplayPrintStringResourceUnicode, FDisplayPrintTime
                             6391         global  FDisplaySetFont, FDisplayUpdateDisplay, FEvaluateMask
                             6392         global  FPopMask, FPushMask, FStringPrintNumber, Fg_MaskStack
                             6393         global  Fg_iMaskBottom, Fg_iMaskLeft, Fg_iMaskRight, Fg_iMaskStack
                             6394         global  Fg_iMaskTop, Fg_pMaskStack
                             6395 
                             6396         local   L3, L4, L5, L6, L7, L8, L9, L10, L11, L12, L14, L22, L23
                             6397         local   L26, L32, L34, L40, L42, L43, L44, L45, L46, L47, L48, L49
                             6398         local   L50, L51, L52, ss_StringPrintNumber
                             6399 
                             6400         calls   "DisplayClearRange", "SALDisplayClearRange"
                             6401         calls   "DisplayHandleMessage", "SALHandleMessage"
                             6402         calls   "DisplayLoadBitmap", "GetUnicodeCharacterBitmap"
                             6403         calls   "DisplayLoadBitmap", "SysCloseResource", "SysLoadResource"
                             6404         calls   "DisplayLoadBitmap", "SysOpenResource"
                             6405         calls   "DisplayPrint1DigitHourTime", "DisplayPrintStringAddressUnicode"
                             6406         calls   "DisplayPrint1DigitHourTime", "StringPrintNumber"
                             6407         calls   "DisplayPrintBitmapAddress", "SALDisplayPrintBitmapAddress"
                             6408         calls   "DisplayPrintBitmapResource", "DisplayLoadBitmap"
                             6409         calls   "DisplayPrintBitmapResource", "SALDisplayPrintBitmapAddress"
                             6410         calls   "DisplayPrintCharUnicode", "DisplayLoadBitmap"
                             6411         calls   "DisplayPrintCharUnicode", "SALDisplayPrintBitmapAddress"
                             6412         calls   "DisplayPrintLongTime", "DisplayPrintStringAddressUnicode"
                             6413         calls   "DisplayPrintLongTime", "StringPrintNumber"
                             6414         calls   "DisplayPrintNumber", "DisplayPrintStringAddressUnicode"
                             6415         calls   "DisplayPrintNumber", "StringPrintNumber"
                             6416         calls   "DisplayPrintStringAddress", "DBCSToUnicode"
                             6417         calls   "DisplayPrintStringAddress", "DisplayPrintStringAddressUnicode"
                             6418         calls   "DisplayPrintStringAddress", "packed_strlen"
                             6419         calls   "DisplayPrintStringAddressUnicode", "DisplayPrintCharUnicode"
                             6420         calls   "DisplayPrintStringResource", "DisplayPrintStringAddress"
                             6421         calls   "DisplayPrintStringResource", "SysCloseResource"
                             6422         calls   "DisplayPrintStringResource", "SysLoadResource"
                             6423         calls   "DisplayPrintStringResource", "SysOpenResource"
                             6424         calls   "DisplayPrintStringResourceUnicode", "DisplayPrintStringAddressUnicode"
                             6425         calls   "DisplayPrintStringResourceUnicode", "SysCloseResource"
                             6426         calls   "DisplayPrintStringResourceUnicode", "SysLoadResource"
                             6427         calls   "DisplayPrintStringResourceUnicode", "SysOpenResource"
                             6428         calls   "DisplayPrintTime", "DisplayPrintStringAddressUnicode"
                             6429         calls   "DisplayPrintTime", "StringPrintNumber"
                             6430         calls   "DisplaySetFont", "LCDSetFont"
                             6431         calls   "DisplayUpdateDisplay", "SALDisplayUpdate"
                             6432         calls   "EvaluateMask", "SALDisplayGetHeight", "SALDisplayGetWidth"
                             6433         calls   "PopMask", "EvaluateMask"
                             6434         calls   "PushMask", "EvaluateMask"
                             6435         calls   "StringPrintNumber", "Rdiv_iii", "Rmod_iii"
                             6436 
