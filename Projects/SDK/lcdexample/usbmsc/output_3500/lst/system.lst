TASKING DSP2410 assembler v1.5r1 Build 138 SN 00100122
                                                                                                                            Page   1
C:\STMP3XXX_SDK_FIRMWARE_320_finalfix\Projects\SDK\lcdexample\usbmsc\Make\cc87081b.src
M:ADDR CODE           CYCLES LINE SOURCELINE
                                1 ; TASKING DSP2410 C compiler v1.5r1 Build 208 SN 00100122
                                2 ; options: -OG -si -w68 -w66 -I..\output_3500\include
                                3 ;          -I..\..\..\..\..\Projects\sdk\lcdexample\usbmsc -I -I..\..
                                4 ;          -I..\..\..\..\..\inc -I..\..\..\..\..\System\Common
                                5 ;          -I..\..\..\..\..\System\Common\symbols -I
                                6 ;          -I..\..\..\..\..\Algorithms\DRM\janus\src\h
                                7 ;          -I..\..\..\..\..\devicedriver\media\ddildl
                                8 ;          -I..\..\..\..\..\devicedriver\media\ddildl\include
                                9 ;          -I..\..\..\..\..\devicedriver\media\MediaTypeMMC\DDI\include
                               10 ;          -I..\..\..\..\..\devicedriver\media\ddildl\include
                               11 ;          -I..\..\..\..\..\devicedriver\media\MediaTypeMMC\DDI\include
                               12 ;          -I..\..\..\..\..\devicedriver\media\MediaTypeMMC\DDI\Media
                               13 ;          -I..\..\..\..\..\devicedriver\media\MediaTypeMMC\HAL\include
                               14 ;          -I..\..\..\..\..\devicedriver\media\MediaTypeRAM\include
                               15 ;          -I..\..\..\..\..\devicedriver\media\MediaTypeRAM\DDI\DataDrive\include
                               16 ;          -I..\..\..\..\..\devicedriver\media\MediaTypeRAM\DDI\include
                               17 ;          -I..\..\..\..\..\devicedriver\media\MediaTypeRAM\HAL\include
                               18 ;          -I..\..\..\..\..\devicedriver\media\MediaTypeRAM\DDI\DataDrive
                               19 ;          -I..\..\..\..\..\devicedriver\media\MediaTypeRAM\include
                               20 ;          -I..\..\..\..\..\devicedriver\media\MediaTypeRAM\DDI\SystemDrive\include
                               21 ;          -I..\..\..\..\..\devicedriver\media\MediaTypeRAM\DDI\include
                               22 ;          -I..\..\..\..\..\devicedriver\media\MediaTypeRAM\HAL\include
                               23 ;          -I..\..\..\..\..\devicedriver\media\MediaTypeRAM\DDI\SystemDrive
                               24 ;          -I..\..\..\..\..\devicedriver\media\MediaTypeRAM\include
                               25 ;          -I..\..\..\..\..\devicedriver\media\MediaTypeRAM\DDI\Media\include
                               26 ;          -I..\..\..\..\..\devicedriver\media\MediaTypeRAM\DDI\include
                               27 ;          -I..\..\..\..\..\devicedriver\media\MediaTypeRAM\HAL\include
                               28 ;          -I..\..\..\..\..\devicedriver\media\MediaTypeRAM\DDI\Media
                               29 ;          -I..\..\..\..\..\devicedriver\media\MediaTypeRAM\include
                               30 ;          -I..\..\..\..\..\devicedriver\media\MediaTypeRAM\DDI\include
                               31 ;          -I..\..\..\..\..\devicedriver\media\MediaTypeRAM\HAL\include
                               32 ;          -I..\..\..\..\..\devicedriver\media\MediaTypeNAND\include
                               33 ;          -I..\..\..\..\..\devicedriver\media\MediaTypeNAND\DDI\DataDrive\include
                               34 ;          -I..\..\..\..\..\devicedriver\media\MediaTypeNAND\DDI\include
                               35 ;          -I..\..\..\..\..\devicedriver\media\MediaTypeNAND\HAL\include
                               36 ;          -I..\..\..\..\..\devicedriver\media\MediaTypeNAND\DDI\DataDrive
                               37 ;          -I..\..\..\..\..\devicedriver\media\ddildl\include -I
                               38 ;          -I..\..\..\..\..\FileSystem\Fat32\cmp\cmp_stdtype
                               39 ;          -I..\..\..\..\..\FileSystem\Fat32\cmp\cmp_debug
                               40 ;          -I..\..\..\..\..\FileSystem\Fat32\cmp\cmp_file_system
                               41 ;          -I..\..\..\..\..\DeviceDriver\Media\cmp\cmp_media_nand
                               42 ;          -I..\..\..\..\..\devicedriver\media\MediaTypeNAND\include
                               43 ;          -I..\..\..\..\..\devicedriver\media\MediaTypeNAND\DDI\Common\include
                               44 ;          -I..\..\..\..\..\devicedriver\media\MediaTypeNAND\DDI\include
                               45 ;          -I..\..\..\..\..\devicedriver\media\MediaTypeNAND\HAL\include
                               46 ;          -I..\..\..\..\..\devicedriver\media\MediaTypeNAND\DDI\Common
                               47 ;          -I..\..\..\..\..\devicedriver\media\MediaTypeNAND\include
                               48 ;          -I..\..\..\..\..\devicedriver\media\MediaTypeNAND\DDI\SystemDrive\include
                               49 ;          -I..\..\..\..\..\devicedriver\media\MediaTypeNAND\DDI\include
                               50 ;          -I..\..\..\..\..\devicedriver\media\MediaTypeNAND\HAL\include
                               51 ;          -I..\..\..\..\..\devicedriver\media\MediaTypeNAND\DDI\SystemDrive
                               52 ;          -I..\..\..\..\..\devicedriver\media\MediaTypeNAND\include
                               53 ;          -I..\..\..\..\..\devicedriver\media\MediaTypeNAND\DDI\Media\include
                               54 ;          -I..\..\..\..\..\devicedriver\media\MediaTypeNAND\DDI\include
                               55 ;          -I..\..\..\..\..\devicedriver\media\MediaTypeNAND\HAL\include
                               56 ;          -I..\..\..\..\..\devicedriver\media\MediaTypeNAND\DDI\Media
                               57 ;          -I..\..\..\..\..\devicedriver\media\include
                               58 ;          -I..\..\..\..\..\devicedriver\media\ddildl
                               59 ;          -I..\..\..\..\..\devicedriver\media\ddildl\include
                               60 ;          -I..\..\..\..\..\devicedriver\media\MediaTypeNAND\DDI\Common\include
                               61 ;          -I..\..\..\..\..\devicedriver\media\MediaTypeNAND\DDI\include
                               62 ;          -I..\..\..\..\..\DeviceDriver\Media\MediaTypeNAND\HAL
TASKING DSP2410 assembler v1.5r1 Build 138 SN 00100122
                                                                                                                            Page   2

M:ADDR CODE           CYCLES LINE SOURCELINE
                               63 ;          -I..\..\..\..\..\DeviceDriver\Media\MediaTypeNAND\HAL\include
                               64 ;          -I..\..\..\..\..\DeviceDriver\Media\include
                               65 ;          -I..\..\..\..\..\DeviceDriver\Media\PortHIL\GPFlash\include
                               66 ;          -I..\..\..\..\..\DeviceDriver\Media\PortHIL\GPFlash
                               67 ;          -I..\..\..\..\..\system\common\resourcemanager -I..\..\..\..\..\inc
                               68 ;          -I..\..\..\..\..\DeviceDriver\Media\usb\Ch9
                               69 ;          -I..\..\..\..\..\DeviceDriver\Media\scsi
                               70 ;          -I..\..\..\..\..\DeviceDriver\Media\usbmsc
                               71 ;          -I..\..\..\..\..\DeviceDriver\Media\mtp
                               72 ;          -I..\..\..\..\..\System\Common\updater
                               73 ;          -I..\..\..\..\..\libsource\sysserialnumber -DALL -DD3500 -DMMC
                               74 ;          -DLIION -DTUNER_STFM1000 -DSTFM1000_LCD=TRUE -DDCDC_POWER_TRANSFER
                               75 ;          -DBACKLIGHT -DWMAAPI_NO_DRM -DREVB_ENGR_BD -DSED15XX_LCD -DFAT16
                               76 ;          -DDEVICE_3500 -DENGR_BD -DUSBMSC_BUILD -DBATTERY_TYPE_LI_ION
                               77 ;          -DBATTERY_CHARGE -DUSE_PLAYLIST3_HOST -DASCII_ONLY -DRETAIL
                               78 ;          -DDEVICE_3500 -DMMC -Dk_opt_performance_enhancement
                               79 ;          -I..\..\..\..\..\devicedriver\display
                               80 ;          -I..\..\..\..\..\System\MsgModules\Hardware\Display -g -O2 -R -Cs
                               81 ;          -MmyL
                               82 
                               90 
                               91 ;       system.c:
                               92 ; 1    |// Filename: system.c   usbmsc version
                               93 ; 2    |#include "kernel.h"
                               94 
                               96 
                               97 ; 1    |///////////////////////////////////////////////////////////////////////////////
                               98 ; 2    |///
                               99 ; 3    |/// Filename: kernel.h
                              100 ; 4    |/// Description: 
                              101 ; 5    |///
                              102 ; 6    |///
                              103 ; 7    |/// Copyright (c) SigmaTel, Inc. Unpublished
                              104 ; 8    |///
                              105 ; 9    |/// SigmaTel, Inc.
                              106 ; 10   |/// Proprietary  Confidential
                              107 ; 11   |///
                              108 ; 12   |/// This source code and the algorithms implemented therein constitute
                              109 ; 13   |/// confidential information and may comprise trade secrets of SigmaTel, Inc.
                              110 ; 14   |/// or its associates, and any use thereof is subject to the terms and
                              111 ; 15   |/// conditions of the Confidential Disclosure Agreement pursuant to which this
                              112 ; 16   |/// source code was originally received.
                              113 ; 17   |///
                              114 ; 18   |///////////////////////////////////////////////////////////////////////////////
                              115 ; 19   |#ifndef __KERNEL_H
                              116 ; 20   |#define __KERNEL_H
                              117 ; 21   |
                              118 ; 22   |
                              119 ; 23   |#include "types.h"
                              120 
                              122 
                              123 ; 1    |////////////////////////////////////////////////////////////////////////////////
                              124 ; 2    |// Copyright(C) SigmaTel, Inc. 2000-2004
                              125 ; 3    |//
                              126 ; 4    |// Filename: types.h
                              127 ; 5    |// Description: Standard data types
                              128 ; 6    |////////////////////////////////////////////////////////////////////////////////
                              129 ; 7    |
                              130 ; 8    |#ifndef _TYPES_H
                              131 ; 9    |#define _TYPES_H
                              132 ; 10   |
                              133 ; 11   |// TODO:  move this outta here!
TASKING DSP2410 assembler v1.5r1 Build 138 SN 00100122
                                                                                                                            Page   3

M:ADDR CODE           CYCLES LINE SOURCELINE
                              134 ; 12   |#if !defined(NOERROR)
                              135 ; 13   |#define NOERROR 0
                              136 ; 14   |#define SUCCESS 0
                              137 ; 15   |#endif 
                              138 ; 16   |#if !defined(SUCCESS)
                              139 ; 17   |#define SUCCESS  0
                              140 ; 18   |#endif
                              141 ; 19   |#if !defined(ERROR)
                              142 ; 20   |#define ERROR   -1
                              143 ; 21   |#endif
                              144 ; 22   |#if !defined(FALSE)
                              145 ; 23   |#define FALSE 0
                              146 ; 24   |#endif
                              147 ; 25   |#if !defined(TRUE)
                              148 ; 26   |#define TRUE  1
                              149 ; 27   |#endif
                              150 ; 28   |
                              151 ; 29   |#if !defined(NULL)
                              152 ; 30   |#define NULL 0
                              153 ; 31   |#endif
                              154 ; 32   |
                              155 ; 33   |#define MAX_INT     0x7FFFFF
                              156 ; 34   |#define MAX_LONG    0x7FFFFFffffff
                              157 ; 35   |        // max positive unsigned long value: -1 == 0xFFFFFFffffff
                              158 ; 36   |#define MAX_ULONG   (-1) 
                              159 ; 37   |
                              160 ; 38   |#define WORD_SIZE   24              // word size in bits
                              161 ; 39   |#define BYTES_PER_WORD 3            // 8 bit bytes
                              162 ; 40   |
                              163 ; 41   |
                              164 ; 42   |#define BYTE    unsigned char       // btVarName
                              165 ; 43   |#define CHAR    signed char         // cVarName
                              166 ; 44   |#define USHORT  unsigned short      // usVarName
                              167 ; 45   |#define SHORT   unsigned short      // sVarName
                              168 ; 46   |#define WORD    unsigned int        // wVarName
                              169 ; 47   |#define INT     signed int          // iVarName
                              170 ; 48   |#define DWORD   unsigned long       // dwVarName
                              171 ; 49   |#define LONG    signed long         // lVarName
                              172 ; 50   |#define BOOL    unsigned int        // bVarName
                              173 ; 51   |#define FRACT   _fract              // frVarName
                              174 ; 52   |#define LFRACT  long _fract         // lfrVarName
                              175 ; 53   |#define CIRC    _circ               // cp<type prefix>VarName (see below)
                              176 ; 54   |#define FLOAT   float               // fVarName
                              177 ; 55   |#define DBL     double              // dVarName
                              178 ; 56   |#define ENUM    enum                // eVarName
                              179 ; 57   |#define CMX     _complex            // cmxVarName
                              180 ; 58   |typedef WORD UCS3;                   // 
                              181 ; 59   |
                              182 ; 60   |#define UINT16  unsigned short
                              183 ; 61   |#define UINT8   unsigned char   
                              184 ; 62   |#define UINT32  unsigned long
                              185 ; 63   |#define UINT64  unsigned long   // need to figure out how to do 64 bit values.  Or port ex
                                  isiting code to only use 48 bit
                              186 ; 64   |#define INT64   unsigned long   // need to figure out how to do 64 bit values.  Or port ex
                                  isiting code to only use 48 bit
                              187 ; 65   |#define WCHAR   UINT16
                              188 ; 66   |
                              189 ; 67   |//UINT128 is 16 bytes or 6 words
                              190 ; 68   |typedef struct UINT128_3500 {   
                              191 ; 69   |    int val[6];     
                              192 ; 70   |} UINT128_3500;
                              193 ; 71   |
TASKING DSP2410 assembler v1.5r1 Build 138 SN 00100122
                                                                                                                            Page   4

M:ADDR CODE           CYCLES LINE SOURCELINE
                              194 ; 72   |#define UINT128   UINT128_3500
                              195 ; 73   |
                              196 ; 74   |// Little endian word packed byte strings:   
                              197 ; 75   |//      _packed BYTE bTextVarName[]="a string";  bText is a packed byte string prefix
                              198 ; 76   |// Convert to big endian words by reordering bytes from high to low using swizzle.
                              199 ; 77   |// Little endian word packed byte strings:   
                              200 ; 78   |//      _packed BYTE bTextVarName[]="a string";  bText is a packed byte string prefix
                              201 ; 79   |// Convert to big endian words by reordering bytes from high to low using swizzle.
                              202 ; 80   |
                              203 ; 81   |// Declare Memory Spaces To Use When Coding
                              204 ; 82   |// A. Sector Buffers
                              205 ; 83   |#define SECTOR_BUFFER_MEM_X _X
                              206 ; 84   |#define SECTOR_BUFFER_MEM_Y _Y
                              207 ; 85   |#define SECTOR_BUFFER_MEM SECTOR_BUFFER_MEM_X
                              208 ; 86   |typedef WORD SECTOR_BUFFER_MEM SECTOR_BUFFER;
                              209 
                              211 
                              212 ; 87   |typedef SECTOR_BUFFER * P_SECTOR_BUFFER;
                              213 ; 88   |// B. Media DDI Memory
                              214 ; 89   |#define MEDIA_DDI_MEM _Y
                              215 ; 90   |
                              216 ; 91   |
                              217 ; 92   |
                              218 ; 93   |// Pointers to linear structures are labeled as: p<type prefix>VarName
                              219 ; 94   |// Examples of circular pointers:
                              220 ; 95   |//    INT CIRC cpiVarName
                              221 ; 96   |//    DWORD CIRC cpdwVarName
                              222 ; 97   |
                              223 ; 98   |#define RETCODE INT                 // rcVarName
                              224 ; 99   |
                              225 ; 100  |// generic bitfield structure
                              226 ; 101  |struct Bitfield {
                              227 ; 102  |    unsigned int B0  :1;
                              228 ; 103  |    unsigned int B1  :1;
                              229 ; 104  |    unsigned int B2  :1;
                              230 ; 105  |    unsigned int B3  :1;
                              231 ; 106  |    unsigned int B4  :1;
                              232 ; 107  |    unsigned int B5  :1;
                              233 ; 108  |    unsigned int B6  :1;
                              234 ; 109  |    unsigned int B7  :1;
                              235 ; 110  |    unsigned int B8  :1;
                              236 ; 111  |    unsigned int B9  :1;
                              237 ; 112  |    unsigned int B10 :1;
                              238 ; 113  |    unsigned int B11 :1;
                              239 ; 114  |    unsigned int B12 :1;
                              240 ; 115  |    unsigned int B13 :1;
                              241 ; 116  |    unsigned int B14 :1;
                              242 ; 117  |    unsigned int B15 :1;
                              243 ; 118  |    unsigned int B16 :1;
                              244 ; 119  |    unsigned int B17 :1;
                              245 ; 120  |    unsigned int B18 :1;
                              246 ; 121  |    unsigned int B19 :1;
                              247 ; 122  |    unsigned int B20 :1;
                              248 ; 123  |    unsigned int B21 :1;
                              249 ; 124  |    unsigned int B22 :1;
                              250 ; 125  |    unsigned int B23 :1;
                              251 ; 126  |};
                              252 ; 127  |
                              253 ; 128  |union BitInt {
                              254 ; 129  |        struct Bitfield B;
                              255 ; 130  |        int        I;
                              256 ; 131  |};
TASKING DSP2410 assembler v1.5r1 Build 138 SN 00100122
                                                                                                                            Page   5

M:ADDR CODE           CYCLES LINE SOURCELINE
                              257 ; 132  |
                              258 ; 133  |#define MAX_MSG_LENGTH 10
                              259 ; 134  |struct CMessage
                              260 ; 135  |{
                              261 ; 136  |        unsigned int m_uLength;
                              262 ; 137  |        unsigned int m_uMsg[MAX_MSG_LENGTH];
                              263 ; 138  |};
                              264 ; 139  |
                              265 ; 140  |typedef struct {
                              266 ; 141  |    WORD m_wLength;
                              267 ; 142  |    WORD m_wMessage;
                              268 ; 143  |    WORD m_wParams[MAX_MSG_LENGTH];
                              269 ; 144  |} Message;
                              270 ; 145  |
                              271 ; 146  |struct MessageQueueDescriptor
                              272 ; 147  |{
                              273 ; 148  |        int *m_pBase;
                              274 ; 149  |        int m_iModulo;
                              275 ; 150  |        int m_iSize;
                              276 ; 151  |        int *m_pHead;
                              277 ; 152  |        int *m_pTail;
                              278 ; 153  |};
                              279 ; 154  |
                              280 ; 155  |struct ModuleEntry
                              281 ; 156  |{
                              282 ; 157  |    int m_iSignaledEventMask;
                              283 ; 158  |    int m_iWaitEventMask;
                              284 ; 159  |    int m_iResourceOfCode;
                              285 ; 160  |    struct MessageQueueDescriptor *m_pMessageQueue;
                              286 ; 161  |    int _asmfunc (*m_pProcessEntryPoint)(union WaitMask Signals,struct MessageQueueDescrip
                                  tor *);
                              287 ; 162  |    int _asmfunc (*m_pInitFunction)(struct MessageQueueDescriptor *);
                              288 ; 163  |    int m_uTimeOutHigh;
                              289 ; 164  |    int m_uTimeOutLow;
                              290 ; 165  |    int _asmfunc (*m_pBackgroundFunction)(struct MessageQueueDescriptor *);
                              291 ; 166  |};
                              292 ; 167  |
                              293 ; 168  |union WaitMask{
                              294 ; 169  |    struct B{
                              295 ; 170  |        unsigned int m_bNone     :1;
                              296 ; 171  |        unsigned int m_bMessage  :1;
                              297 ; 172  |        unsigned int m_bTimer    :1;
                              298 ; 173  |        unsigned int m_bButton   :1;
                              299 ; 174  |    } B;
                              300 ; 175  |    int I;
                              301 ; 176  |} ;
                              302 ; 177  |
                              303 ; 178  |
                              304 ; 179  |struct Button {
                              305 ; 180  |        WORD wButtonEvent;
                              306 ; 181  |        WORD wUnused[MAX_MSG_LENGTH];   
                              307 ; 182  |};
                              308 ; 183  |
                              309 ; 184  |struct Message {
                              310 ; 185  |        WORD wMsgLength;
                              311 ; 186  |        WORD wMsgCommand;
                              312 ; 187  |        WORD wMsgParms[MAX_MSG_LENGTH-1];
                              313 ; 188  |};
                              314 ; 189  |
                              315 ; 190  |union EventTypes {
                              316 ; 191  |        struct CMessage msg;
                              317 ; 192  |        struct Button Button ;
TASKING DSP2410 assembler v1.5r1 Build 138 SN 00100122
                                                                                                                            Page   6

M:ADDR CODE           CYCLES LINE SOURCELINE
                              318 ; 193  |        struct Message Message;
                              319 ; 194  |};
                              320 ; 195  |
                              321 ; 196  |// next 2 used to get updater build to return correct protocol ver in scsi response.
                              322 ; 197  |#define BUILD_TYPE_UPDATER  0x100
                              323 ; 198  |#define BUILD_TYPE_HOSTLINK 0x101
                              324 ; 199  |#define BUILD_TYPE_PLAYER   0x102
                              325 ; 200  |
                              326 ; 201  |// Resets part if RETAIL build. DEBUG build executes debug instruction to halt.
                              327 ; 202  |#define SystemHalt() __asm(" include 'sysmacro.asm' \n error") 
                              328 ; 203  |#define assert(x)    if(!(x)) __asm(" include 'sysmacro.asm' \n error")
                              329 ; 204  |
                              330 ; 205  |#if DEBUG
                              331 ; 206  |// For DEBUG builds, DebugBuildAssert(condition) halts if condition evaluates to FALSE. 
                              332 ; 207  |#define DebugBuildAssert(x)    if(!(x)) __asm(" debug ")
                              333 ; 208  |#else 
                              334 ; 209  |// For RETAIL builds, DebugBuildAssert(condition) does nothing & execution continues rathe
                                  r than halt or reset. 
                              335 ; 210  |#define DebugBuildAssert(x)    
                              336 ; 211  |#endif
                              337 ; 212  |
                              338 ; 213  |// Do this in your C files to make a reminder that's displayed during the build.
                              339 ; 214  |//  #pragma asm
                              340 ; 215  |//  WARN 'Note to builder: reminder to do this after verifying that'
                              341 ; 216  |//  #pragma endasm
                              342 ; 217  |
                              343 ; 218  |
                              344 ; 219  |#ifdef COLOR_262K
                              345 ; 220  |#define RGB(r,g,b)    ((0x0000FC & (r)) << 10) | ((0x0000FC & (g)) << 4) | ((0x0000FC & (b
                                  )) >> 2)    //262k
                              346 ; 221  |#elif defined(COLOR_65K)
                              347 ; 222  |#define RGB(r,g,b)    ((0x0000F8 & (r)) << 8) | ((0x0000FC & (g)) << 3) | ((0x0000F8 & (b)
                                  ) >> 3)  //65k
                              348 ; 223  |#else
                              349 ; 224  |#define RGB(r,g,b)       ((0x0000F0 & (r)) << 4) | (0x0000F0 & (g)) | ((0x0000F0 & (b)) >>
                                   4)
                              350 ; 225  |#endif
                              351 ; 226  |    
                              352 ; 227  |#endif // #ifndef _TYPES_H
                              353 
                              355 
                              356 ; 24   |#include "gettime.h"
                              357 
                              359 
                              360 ; 1    |#ifndef __TIME_H
                              361 ; 2    |#define __TIME_H
                              362 ; 3    |
                              363 ; 4    |_callee_save LONG GetTime(void);
                              364 ; 5    |
                              365 ; 6    |#endif
                              366 
                              368 
                              369 ; 25   |#include "sysirq.h"
                              370 
                              372 
                              373 ; 1    |////////////////////////////////////////////////////////////////////////////////
                              374 ; 2    |// Copyright(C) SigmaTel, Inc. 2000-2001
                              375 ; 3    |//
                              376 ; 4    |// Filename: sysirq.h
                              377 ; 5    |// Description: 
                              378 ; 6    |////////////////////////////////////////////////////////////////////////////////
                              379 ; 7    |
TASKING DSP2410 assembler v1.5r1 Build 138 SN 00100122
                                                                                                                            Page   7

M:ADDR CODE           CYCLES LINE SOURCELINE
                              380 ; 8    |#ifndef _SYSIRQ_H
                              381 ; 9    |#define _SYSIRQ_H
                              382 ; 10   |
                              383 ; 11   |///////////////////////////////////////////////////////////////////////////////
                              384 ; 12   |// Defs
                              385 ; 13   |///////////////////////////////////////////////////////////////////////////////
                              386 ; 14   |
                              387 ; 15   |#define     INTERRUPTS_UNMASK_ALL   0x000000
                              388 ; 16   |
                              389 ; 17   |///////////////////////////////////////////////////////////////////////////////
                              390 ; 18   |// Structure definitions
                              391 ; 19   |///////////////////////////////////////////////////////////////////////////////
                              392 ; 20   |
                              393 ; 21   |///////////////////////////////////////////////////////////////////////////////
                              394 ; 22   |// Prototypes
                              395 ; 23   |///////////////////////////////////////////////////////////////////////////////
                              396 ; 24   |
                              397 ; 25   |WORD _reentrant SysMaskAllInterrupts(void);
                              398 ; 26   |void _reentrant SysUnMaskAllInterrupts(WORD wLevel);
                              399 ; 27   |WORD _reentrant SysGetIrqLevel(void);
                              400 ; 28   |RETCODE _reentrant SysSetIrqLevel(WORD wIrqLevel);
                              401 ; 29   |
                              402 ; 30   |#endif // #ifndef _SYSIRQ_H
                              403 
                              405 
                              406 ; 26   |#include "icoll.h"
                              407 
                              409 
                              410 ; 1    |////////////////////////////////////////////////////////////////////////////////
                              411 ; 2    |// Copyright(C) SigmaTel, Inc. 2002
                              412 ; 3    |//
                              413 ; 4    |// Filename: icoll.h
                              414 ; 5    |// Description: 
                              415 ; 6    |////////////////////////////////////////////////////////////////////////////////
                              416 ; 7    |
                              417 ; 8    |#ifndef _ICOLL_H
                              418 ; 9    |#define _ICOLL_H
                              419 ; 10   |
                              420 ; 11   |///////////////////////////////////////////////////////////////////////////////
                              421 ; 12   |// Defs
                              422 ; 13   |///////////////////////////////////////////////////////////////////////////////
                              423 ; 14   |                                                                                          
                                  
                              424 ; 15   |#define ICOLL_SOURCE_DAC_REFILL                                 (DWORD)0             
                              425 ; 16   |#define ICOLL_SOURCE_DAC_UNDERFLOW                              (DWORD)1             
                              426 ; 17   |#define ICOLL_SOURCE_ADC_REFILL                                 (DWORD)2             
                              427 ; 18   |#define ICOLL_SOURCE_ADC_OVERFLOW                               (DWORD)3             
                              428 ; 19   |#define ICOLL_SOURCE_FLASH_DONE                                 (DWORD)4              
                              429 ; 20   |#define ICOLL_SOURCE_COMPACTFLASH_CARD_IRQ                      (DWORD)5              
                              430 ; 21   |#define ICOLL_SOURCE_SMARTMEDIA_TIMEOUT                         (DWORD)6              
                              431 ; 22   |#define ICOLL_SOURCE_SMARTMEDIA_INTERFACE_INVALID_PROGRAMMING   (DWORD)7              
                              432 ; 23   |#define ICOLL_SOURCE_COMPACTFLASH_NO_CARD                       (DWORD)8               
                              433 ; 24   |#define ICOLL_SOURCE_COMPACTFLASH_STATUS_CHANGE                 (DWORD)9               
                              434 ; 25   |#define ICOLL_SOURCE_GPIO_0                                     (DWORD)10               
                              435 ; 26   |#define ICOLL_SOURCE_GPIO_1                                     (DWORD)11               
                              436 ; 27   |#define ICOLL_SOURCE_GPIO_2                                     (DWORD)12                
                              437 ; 28   |#define ICOLL_SOURCE_TIMER_0                                    (DWORD)13                
                              438 ; 29   |#define ICOLL_SOURCE_TIMER_1                                    (DWORD)14                
                              439 ; 30   |#define ICOLL_SOURCE_TIMER_2                                    (DWORD)15                
                              440 ; 31   |#define ICOLL_SOURCE_TIMER_3                                    (DWORD)16                 
                                  
TASKING DSP2410 assembler v1.5r1 Build 138 SN 00100122
                                                                                                                            Page   8

M:ADDR CODE           CYCLES LINE SOURCELINE
                              441 ; 32   |#define ICOLL_SOURCE_GPIO_3                                     (DWORD)17                 
                                  
                              442 ; 33   |#define ICOLL_SOURCE_SDRAM                                      (DWORD)18                 
                                  
                              443 ; 34   |#define ICOLL_SOURCE_CDI                                        (DWORD)19                 
                                  
                              444 ; 35   |
                              445 ; 36   |#if (defined(DEVICE_3410) || defined(DEVICE_3310))
                              446 ; 37   |
                              447 ; 38   |#define ICOLL_SOURCE_USB_SOF                                    (DWORD)20                 
                                   
                              448 ; 39   |#define ICOLL_SOURCE_USB_SET_INTERFACE_REQUEST                  (DWORD)21                 
                                   
                              449 ; 40   |#define ICOLL_SOURCE_USB_HOST_RESET                             (DWORD)22                 
                                   
                              450 ; 41   |#define ICOLL_SOURCE_USB_ENDPOINT_START                         (DWORD)23
                              451 ; 42   |#define ICOLL_SOURCE_USB_ENDPOINT_0                             (DWORD)23                 
                                   
                              452 ; 43   |#define ICOLL_SOURCE_USB_ENDPOINT_1                             (DWORD)24                 
                                   
                              453 ; 44   |#define ICOLL_SOURCE_USB_ENDPOINT_2                             (DWORD)25                 
                                   
                              454 ; 45   |#define ICOLL_SOURCE_USB_ENDPOINT_3                             (DWORD)26                 
                                   
                              455 ; 46   |#define ICOLL_SOURCE_USB_ENDPOINT_4                             (DWORD)27                 
                                   
                              456 ; 47   |#define ICOLL_SOURCE_USB_ENDPOINT_5                             (DWORD)28                 
                                     
                              457 ; 48   |#define ICOLL_SOURCE_USB_ENDPOINT_6                             (DWORD)29                 
                                     
                              458 ; 49   |#define ICOLL_SOURCE_USB_ENDPOINT_7                             (DWORD)30                 
                                     
                              459 ; 50   |
                              460 ; 51   |#else
                              461 ; 52   |
                              462 ; 53   |#define ICOLL_SOURCE_VDD_5V_CONNECTED                           (DWORD)20                 
                                   
                              463 ; 54   |#define ICOLL_SOURCE_USB_CONTROLLER                             (DWORD)21                 
                                   
                              464 ; 55   |#define ICOLL_SOURCE_USB_WAKEUP                                 (DWORD)22                 
                                   
                              465 ; 56   |#define ICOLL_SOURCE_VDD_5V_DISCONNECTED                        (DWORD)23
                              466 ; 57   |#define ICOLL_SOURCE_ESPI                                       (DWORD)24                 
                                   
                              467 ; 58   |#define ICOLL_SOURCE_FILCO                                      (DWORD)25                 
                                   
                              468 ; 59   |#define ICOLL_SOURCE_LRADC1                                     (DWORD)26                 
                                   
                              469 ; 60   |#define ICOLL_SOURCE_RTC_ALARM                                  (DWORD)27                 
                                   
                              470 ; 61   |#define ICOLL_SOURCE_LRADC2                                     (DWORD)28                 
                                   
                              471 ; 62   |#define ICOLL_SOURCE_FLASH_ECC                                  (DWORD)29                 
                                     
                              472 ; 63   |
                              473 ; 64   |#endif
                              474 ; 65   |
                              475 ; 66   |#define ICOLL_SOURCE_CDSYNC                                     (DWORD)31                 
                                     
                              476 ; 67   |#define ICOLL_SOURCE_CDSYNC_EXCEPTION                           (DWORD)32                 
                                      
                              477 ; 68   |#define ICOLL_SOURCE_REED_SOLOMON                               (DWORD)33
TASKING DSP2410 assembler v1.5r1 Build 138 SN 00100122
                                                                                                                            Page   9

M:ADDR CODE           CYCLES LINE SOURCELINE
                              478 ; 69   |#define ICOLL_END_OF_TRUE_SOURCES                                ICOLL_SOURCE_REED_SOLOMON
                                  
                              479 ; 70   |// The rest of these "sources" are not really ICOLL sources.  They are not
                              480 ; 71   |//  routed through the ICOLL but are included here to make interrupt abstraction
                              481 ; 72   |//  as simple as possible.  The ICOLL functions special-case these.
                              482 ; 73   |#define ICOLL_SOURCE_I2C_RX_READY                               (DWORD)34
                              483 ; 74   |#define ICOLL_SOURCE_I2C_RX_OVERFLOW                            (DWORD)35
                              484 ; 75   |#define ICOLL_SOURCE_I2C_TX_EMPTY                               (DWORD)36
                              485 ; 76   |#define ICOLL_SOURCE_I2C_TX_UNDERFLOW                           (DWORD)37
                              486 ; 77   |#define ICOLL_SOURCE_SPI_COMPLETE                               (DWORD)38
                              487 ; 78   |#define ICOLL_SOURCE_I2S_RX_OVERFLOW                            (DWORD)39
                              488 ; 79   |#define ICOLL_SOURCE_I2S_TX_UNDERFLOW                           (DWORD)40
                              489 ; 80   |#define ICOLL_SOURCE_I2S_RX_READY                               (DWORD)41
                              490 ; 81   |#define ICOLL_SOURCE_I2S_TX_EMPTY                               (DWORD)42
                              491 ; 82   |#define ICOLL_SOURCE_HARDWARE_RESET                             (DWORD)43
                              492 ; 83   |#define ICOLL_SOURCE_STACK_ERROR                                (DWORD)44
                              493 ; 84   |#define ICOLL_SOURCE_TRACE                                      (DWORD)45
                              494 ; 85   |#define ICOLL_SOURCE_SWI                                        (DWORD)46
                              495 ; 86   |#define ICOLL_SOURCE_IRQA                                       (DWORD)47
                              496 ; 87   |#define ICOLL_SOURCE_BROWNOUT                                   (DWORD)48
                              497 ; 88   |#define ICOLL_SOURCE_ILLEGAL_INSTRUCTION                        (DWORD)49
                              498 ; 89   |#define ICOLL_SOURCE_END                                        ICOLL_SOURCE_ILLEGAL_INSTR
                                  UCTION
                              499 ; 90   |#define ICOLL_NUM_SOURCES                                       ICOLL_SOURCE_END+1
                              500 ; 91   |
                              501 ; 92   |#define ICOLL_ICLENABLE_REG_0_LAST_SRC                          (DWORD)23
                              502 ; 93   |
                              503 ; 94   |#define ICOLL_PRIORITY_000              0x000000
                              504 ; 95   |#define ICOLL_PRIORITY_001              0x000001
                              505 ; 96   |#define ICOLL_PRIORITY_010              0x000002
                              506 ; 97   |#define ICOLL_PRIORITY_011              0x000003
                              507 ; 98   |#define ICOLL_PRIORITY_100              0x000004
                              508 ; 99   |#define ICOLL_PRIORITY_101              0x000005
                              509 ; 100  |#define ICOLL_PRIORITY_110              0x000006
                              510 ; 101  |#define ICOLL_PRIORITY_111              0x000007
                              511 ; 102  |
                              512 ; 103  |#define ICOLL_STEERING_IVL1             0x000000
                              513 ; 104  |#define ICOLL_STEERING_IVL2             0x000001
                              514 ; 105  |#define ICOLL_STEERING_IVL3             0x000002
                              515 ; 106  |#define ICOLL_STEERING_IVL6             0x000003
                              516 ; 107  |
                              517 ; 108  |///////////////////////////////////////////////////////////////////////////////
                              518 ; 109  |// ERRORS
                              519 ; 110  |///////////////////////////////////////////////////////////////////////////////
                              520 ; 111  |                                                                                          
                                  
                              521 ; 112  |#define ICOLL_ERROR_INVALID_SOURCE              (RETCODE)0x000001
                              522 ; 113  |
                              523 ; 114  |///////////////////////////////////////////////////////////////////////////////
                              524 ; 115  |// Structure definitions
                              525 ; 116  |///////////////////////////////////////////////////////////////////////////////
                              526 ; 117  |
                              527 ; 118  |typedef void (*ISR_VECTOR)(void);
                              528 ; 119  |
                              529 ; 120  |typedef struct
                              530 ; 121  |{
                              531 ; 122  |    WORD wSource;
                              532 ; 123  |    WORD wPriority;
                              533 ; 124  |    WORD wSteering;
                              534 ; 125  |} ICOLL_ELEMENT;
                              535 ; 126  |
                              536 ; 127  |///////////////////////////////////////////////////////////////////////////////
TASKING DSP2410 assembler v1.5r1 Build 138 SN 00100122
                                                                                                                            Page  10

M:ADDR CODE           CYCLES LINE SOURCELINE
                              537 ; 128  |// Prototypes
                              538 ; 129  |///////////////////////////////////////////////////////////////////////////////
                              539 ; 130  |
                              540 ; 131  |void _reentrant IcollShutDown(void);
                              541 ; 132  |RETCODE _reentrant IcollEnable(DWORD dwSource);
                              542 ; 133  |RETCODE _reentrant IcollDisable(DWORD dwSource);
                              543 ; 134  |BOOL _reentrant IcollGetStatus(DWORD dwSource);
                              544 ; 135  |RETCODE _reentrant IcollSetPriority(DWORD dwSource, WORD wPriority);
                              545 ; 136  |RETCODE _reentrant IcollSetSteering(DWORD dwSource, WORD wSteering);
                              546 
                              551 
                              552 ; 137  |RETCODE _reentrant IcollInstallIsrVector(ISR_VECTOR pISR, WORD wSource);
                              553 ; 138  |void _asmfunc IcollResetVectorTable(void);
                              554 ; 139  |#endif // #ifndef _ICOLL_H
                              555 
                              557 
                              558 ; 27   |
                              559 ; 28   |#ifndef SYS_MAX_MSG_PARAMS
                              560 ; 29   |#define SYS_MAX_MSG_PARAMS 10
                              561 ; 30   |#endif
                              562 ; 31   |
                              563 ; 32   |#ifndef MAX_REGIONS
                              564 ; 33   |#define MAX_REGIONS 5
                              565 ; 34   |#endif 
                              566 ; 35   |
                              567 ; 36   |#define TIMEOUT_IMMEDIATE 0
                              568 ; 37   |
                              569 ; 38   |struct TaskEntryStruct;
                              570 ; 39   |
                              571 ; 40   |union SyncObjectStruct;
                              572 ; 41   |
                              573 ; 42   |
                              574 ; 43   |// JCP - Already defined in types.h
                              575 ; 44   |
                              576 ; 45   |//typedef struct {
                              577 ; 46   |//    WORD m_wLength;
                              578 ; 47   |//    WORD m_wMessage;
                              579 ; 48   |//    WORD m_wParams[SYS_MAX_MSG_PARAMS];
                              580 ; 49   |//} Message;
                              581 ; 50   |
                              582 ; 51   |typedef struct {
                              583 ; 52   |    _circ WORD    *m_pHead;
                              584 ; 53   |    _circ WORD    *m_pTail;
                              585 ; 54   |} CircularBufferDescriptor;
                              586 ; 55   |
                              587 ; 56   |typedef struct MemoryRegionStruct {
                              588 ; 57   |    WORD m_wResourceLoaded;
                              589 ; 58   |    _P INT *m_StartAddress;
                              590 ; 59   |    _P INT *m_EndAddress;
                              591 ; 60   |} MemoryRegion;
                              592 
                              599 
                              600 ; 61   |
                              601 ; 62   |
                              602 ; 63   |typedef struct TaskEntryStruct{
                              603 ; 64   |    CircularBufferDescriptor *m_pMessageQueue;
                              604 ; 65   |    void   *m_pWaitingOnPtr;                                //points to either an object o
                                  r a queue we're waiting on.
                              605 ; 66   |    WORD    m_wWaitingOnWord;
                              606 ; 67   |    WORD    m_wState;                                       //The state is used to indicat
                                  e what the task is waiting on.
                              607 ; 68   |    WORD   *m_pStackPointer;
TASKING DSP2410 assembler v1.5r1 Build 138 SN 00100122
                                                                                                                            Page  11

M:ADDR CODE           CYCLES LINE SOURCELINE
                              608 ; 69   |    WORD    m_wTaskID;                                      //The kernel does not use this
                                   for any purpose.   This is set by the developer
                              609 ; 70   |                                                            //  and returned by SysGetTask
                                  ID() for use by functions that are required to 
                              610 ; 71   |                                                            //  be task aware.
                              611 ; 72   |    long    m_lTimeout;                                     //This is in absolute time (ca
                                  n compare directly to the current system time
                              612 ; 73   |    WORD    m_wRegionResources[MAX_REGIONS];                //a snapshot of the requiremen
                                  ts of the task in terms of which resources are loaded
                              613 ; 74   |    WORD    m_wPriority;                                    
                              614 ; 75   |    WORD   *m_pInitialStackPointer;                         //only used at init time
                              615 ; 76   |    WORD    m_wStackSize;
                              616 ; 77   |    _reentrant void   (*m_pEntryPoint)(void);               //only used at init time
                              617 ; 78   |} TaskEntry;
                              618 
                              643 
                              644 ; 79   |
                              645 ; 80   |typedef union SyncObjectStruct {
                              646 ; 81   |    TaskEntry   *m_pOwner;
                              647 ; 82   |    struct
                              648 ; 83   |    {
                              649 ; 84   |    int          m_iOwner :16;
                              650 ; 85   |    int          m_iCount : 8;
                              651 ; 86   |    } counter;
                              652 ; 87   |} SyncObject;
                              653 ; 88   |
                              654 ; 89   |typedef WORD SignalGroup;
                              655 ; 90   |
                              656 ; 91   |
                              657 ; 92   |typedef struct {
                              658 ; 93   |    WORD    m_wMessageType;
                              659 ; 94   |    CircularBufferDescriptor    *m_pDestination;
                              660 ; 95   |}  RoutingEntry;
                              661 
                              666 
                              667 ; 96   |
                              668 ; 97   |extern RoutingEntry g_RoutingTable[];
                              669 ; 98   |extern TaskEntry *g_TaskList[];
                              670 
                              678 
                              679 ; 99   |extern MemoryRegion *g_RegionTable[];
                              680 ; 100  |
                              681 ; 101  |//Time Releated Functions
                              682 ; 102  |_reentrant WORD SysWait(INT wTimeout);
                              683 ; 103  |
                              684 ; 104  |//Task Related Functions
                              685 ; 105  |_reentrant WORD SysGetTaskID(void);
                              686 ; 106  |
                              687 ; 107  |//Message related functions
                              688 ; 108  |_asmfunc WORD SysWaitOnMessage(INT wTimeout, Message *pMsg);
                              689 
                              696 
                              697 ; 109  |_asmfunc WORD SysPeekMessage(CircularBufferDescriptor *pQueue, Message *pMsg);
                              698 ; 110  |_reentrant WORD SysPostMessage(WORD wLength, ...);
                              699 ; 111  |_reentrant WORD SysPostMessageWait(INT wTimeout, WORD wLength, ...);
                              700 ; 112  |
                              701 ; 113  |//maybe this is too much functionality?
                              702 ; 114  |_asmfunc WORD SysWaitOnBoth(WORD wTimeout, SyncObject *pObject, Message *pMsg);
                              703 
                              715 
                              716 ; 115  |
                              717 ; 116  |//SyncObject Related functions
TASKING DSP2410 assembler v1.5r1 Build 138 SN 00100122
                                                                                                                            Page  12

M:ADDR CODE           CYCLES LINE SOURCELINE
                              718 ; 117  |_asmfunc WORD SysWaitOnObject(INT wTimeout, SyncObject *pObject);
                              719 ; 118  |_asmfunc WORD SysAssignObject(SyncObject *pObject, TaskEntry *pTaskID);
                              720 ; 119  |_reentrant void SysReleaseObject(SyncObject *pObject);
                              721 ; 120  |_reentrant void ISRReleaseObject(SyncObject *pObject);
                              722 ; 121  |
                              723 ; 122  |//Queue Related Functions
                              724 ; 123  |_asmfunc WORD SysWaitOnQueue(INT wTimeout,CircularBufferDescriptor *pQueue, INT wSizeToBeF
                                  ree);
                              725 ; 124  |
                              726 ; 125  |//Event Related Functions
                              727 ; 126  |_asmfunc WORD SysWaitOnSignal(INT wTimeout, void * pSignalGroup, int iSignal);
                              728 
                              730 
                              731 ; 127  |_asmfunc void SysSignal(SignalGroup *pSignalGroup, int iSignal);
                              732 ; 128  |
                              733 ; 129  |//ISR function
                              734 ; 130  |
                              735 ; 131  |//SysCallFunctions
                              736 ; 132  |int _asmfunc exSysCallFunction_v(void);
                              737 ; 133  |int _asmfunc exSysCallFunction_i(int);
                              738 ; 134  |int _asmfunc exSysCallFunction_ii(int, int);
                              739 ; 135  |int _asmfunc exSysCallFunction_iii(int, int, int);
                              740 ; 136  |int _asmfunc SysCallFunction(WORD * RESOURCE,int _reentrant (int,int,int*),  int, int, int
                                   *);
                              741 ; 137  |#define SysCallFunction(rsrc,func,a,b,p) SysCallFunction((void*)rsrc,(func),(a),(b),(p))
                              742 ; 138  |
                              743 ; 139  |void _asmfunc v_SysCallFunction_v(WORD * RESOURCE,void _reentrant (void));
                              744 ; 140  |#define v_SysCallFunction_v(rsrc,func) v_SysCallFunction_v((void*)rsrc,(func))
                              745 ; 141  |
                              746 ; 142  |void _asmfunc SysCallFunction_i(WORD * RESOURCE,void _reentrant (int),int);
                              747 ; 143  |#define SysCallFunction_i(rsrc,func,a,b,p) SysCallFunction_i((void*)rsrc,(func),(a),(b),(p
                                  ))
                              748 ; 144  |
                              749 ; 145  |int _asmfunc SysCallFunction_L(void* RESOURCE,int _reentrant (long,long,int*),  long, long
                                  , int *);
                              750 ; 146  |
                              751 ; 147  |int _asmfunc i_SysCallFunction_i(WORD * RESOURCE,int _reentrant (int), int);
                              752 ; 148  |
                              753 ; 149  |int _asmfunc i_SysCallFunction_iipp(WORD * RESOURCE,int _reentrant (int,int,int*,int*),  i
                                  nt, int, int *, int *);
                              754 ; 150  |
                              755 ; 151  |int _asmfunc i_SysCallFunction_iiip(WORD * RESOURCE,int _reentrant (int,int,int,int*),  in
                                  t, int, int, int *);
                              756 ; 152  |
                              757 ; 153  |int _asmfunc fSysCallFunction(WORD * RESOURCE,int _reentrant (int,int,int*),  int, int, in
                                  t *);
                              758 ; 154  |
                              759 ; 155  |
                              760 ; 156  |//These values are return values, and also values that are set in the TaskEntry.m_wState t
                                  o indicate what the task
                              761 ; 157  |//is waiting on.
                              762 ; 158  |#define EVENT_TIMEOUT   0
                              763 ; 159  |#define EVENT_MESSAGE   1
                              764 ; 160  |#define EVENT_OBJECT    2
                              765 ; 161  |#define EVENT_QUEUE     4
                              766 ; 162  |#define EVENT_SIGNAL    5
                              767 ; 163  |#define EVENT_RELEASING_OBJECT2 6
                              768 ; 164  |#define EVENT_RELEASING_OBJECT1 7
                              769 ; 165  |
                              770 ; 166  |
                              771 ; 167  |//this is the owner that a SyncObject should be assigned to if a task it going to wait on 
                                  a completion of the interrupt. 
TASKING DSP2410 assembler v1.5r1 Build 138 SN 00100122
                                                                                                                            Page  13

M:ADDR CODE           CYCLES LINE SOURCELINE
                              772 ; 168  |#define ISR_OWNER  ((TaskEntry*)(0xffff))
                              773 ; 169  |#define KERNEL_OWNER  ((TaskEntry*)(0))
                              774 ; 170  |
                              775 ; 171  |
                              776 ; 172  |#ifdef INSTRUMENT_ENABLE
                              777 ; 173  |#include <regsgpio.h>
                              778 ; 174  |
                              779 ; 175  |//
                              780 ; 176  |// Define the bit positions in the GPIO registers used for signalling.
                              781 ; 177  |//
                              782 ; 178  |#define GPIO_24     B0
                              783 ; 179  |#define GPIO_36     B12
                              784 ; 180  |#define GPIO_37     B13
                              785 ; 181  |#define GPIO_38     B14
                              786 ; 182  |#define GPIO_39     B15
                              787 ; 183  |#define GPIO_42     B18
                              788 ; 184  |#define GPIO_46     B22
                              789 ; 185  |#define GPIO_47     B23
                              790 ; 186  |
                              791 ; 187  |//=============================================================================
                              792 ; 188  |// SysSignalEvent
                              793 ; 189  |//-----------------------------------------------------------------------------
                              794 ; 190  |//! This macro allows code to set a gpio event that can be measured outside the
                              795 ; 191  |//! part.
                              796 ; 192  |//! \param wGPIONumber 
                              797 ; 193  |//!     This should be one of the Macros defined above, and indicates which 
                              798 ; 194  |//!     GPIO will be set.
                              799 ; 195  |//!
                              800 ; 196  |//! \return
                              801 ; 197  |//!     None. 
                              802 ; 198  |//!
                              803 ; 199  |//=============================================================================
                              804 ; 200  |#define SysSignalEvent(wGPIONumber)         \ 
                              805 ; 201  |{                                           \ 
                              806 ; 202  |    HW_GP1DOR.B.##wGPIONumber = 1;          \ 
                              807 ; 203  |}
                              808 ; 204  |
                              809 ; 205  |//=============================================================================
                              810 ; 206  |// SysClearEvent
                              811 ; 207  |//-----------------------------------------------------------------------------
                              812 ; 208  |//! This macro allows code to clear a gpio event that can be measured outside 
                              813 ; 209  |//! the part.
                              814 ; 210  |//! \param wGPIONumber 
                              815 ; 211  |//!     This should be one of the Macros defined above, and indicates which 
                              816 ; 212  |//!     GPIO will be set.
                              817 ; 213  |//!
                              818 ; 214  |//! \return
                              819 ; 215  |//!     None. 
                              820 ; 216  |//!
                              821 ; 217  |//=============================================================================
                              822 ; 218  |#define SysClearEvent(wGPIONumber)          \ 
                              823 ; 219  |{                                           \ 
                              824 ; 220  |    HW_GP1DOR.B.##wGPIONumber = 0;          \ 
                              825 ; 221  |}
                              826 ; 222  |
                              827 ; 223  |//=============================================================================
                              828 ; 224  |// SysEnableEvent
                              829 ; 225  |//-----------------------------------------------------------------------------
                              830 ; 226  |//! This macro must be called by code before using the SysSetEvent or 
                              831 ; 227  |//! SysClearEvent so that the GPIOs are set up correctly.
                              832 ; 228  |//!
                              833 ; 229  |//! \param wGPIONumber 
TASKING DSP2410 assembler v1.5r1 Build 138 SN 00100122
                                                                                                                            Page  14

M:ADDR CODE           CYCLES LINE SOURCELINE
                              834 ; 230  |//!     This should be one of the Macros defined above, and indicates which 
                              835 ; 231  |//!     GPIO will be set.
                              836 ; 232  |//!
                              837 ; 233  |//! \return
                              838 ; 234  |//!     None. 
                              839 ; 235  |//!
                              840 ; 236  |//=============================================================================
                              841 ; 237  |#define SysEnableEvent(wGPIONumber)         \ 
                              842 ; 238  |{                                           \ 
                              843 ; 239  |    HW_GP1DOER.B.##wGPIONumber=1;           \ 
                              844 ; 240  |    HW_GP1DOR.B.##wGPIONumber=0;            \ 
                              845 ; 241  |    HW_GP1ENR.B.##wGPIONumber=1;            \ 
                              846 ; 242  |    HW_GP1PWR.B.##wGPIONumber=1;            \ 
                              847 ; 243  |}
                              848 ; 244  |#else // INSTRUMENT_ENABLE
                              849 ; 245  |#define SysSignalEvent(wGPIONumber)
                              850 ; 246  |#define SysClearEvent(wGPIONumber)
                              851 ; 247  |#define SysEnableEvent(wGPIONumber)
                              852 ; 248  |#endif // INSTRUMENT_ENABLE
                              853 ; 249  |    
                              854 ; 250  |#endif
                              855 
                              857 
                              858 ; 3    |#include "project.h"
                              859 
                              861 
                              862 ; 1    |/////////////////////////////////////////////////////////////////////////////////
                              863 ; 2    |//  Copyright(C) SigmaTel, Inc. 2000-2004
                              864 ; 3    |//  Filename: project.inc
                              865 ; 4    |//  Description: 
                              866 ; 5    |/////////////////////////////////////////////////////////////////////////////////
                              867 ; 6    |
                              868 ; 7    |#if (!defined(_PROJECT_INC))
                              869 ; 8    |#define _PROJECT_INC 1
                              870 ; 9    |
                              871 ; 10   |#if defined(STMP_BUILD_PLAYER)
                              872 ; 11   |#include "hwequ.h"
                              873 ; 12   |#else 
                              874 ; 13   |//include "regscodec.inc"
                              875 ; 14   |#endif
                              876 ; 15   |
                              877 ; 16   |//////////////////////////////////////////////////////////////////////////////////
                              878 ; 17   |// Uncomment next define to allow player boot if you have stfm1000 macro enabled (defaults
                                   ON) & 
                              879 ; 18   |// your board crystal is not able to output nominal voltage range. Used in player main.asm
                                  . STMP00012148
                              880 ; 19   |// Defining this will result in lower battery life (price of using a lower quality crystal
                                  ). 
                              881 ; 20   |// Those that want to save battery life and have good crystals that meet our HW team's spe
                                  cs can 
                              882 ; 21   |// comment out this line to reduce crystal bias current and so battery current in player m
                                  ode.  
                              883 ; 22   |#define SUPPORT_MARGINAL_XTALS 1
                              884 ; 23   |
                              885 ; 24   |/////////////////////////////////////////////////////////////////////////////////
                              886 ; 25   |// BOOT SPEED CONFIG & ASSOCIATED BATTERY VOLTAGE CHECK ENABLE
                              887 ; 26   |/////////////////////////////////////////////////////////////////////////////////
                              888 ; 27   |// Users can enable one of ATTEMPT_FAST_BOOT or FASTEST boot or neither project define bel
                                  ow by defining
                              889 ; 28   |// values as 0 or 1, else it defaults to the boot speed used in previous SDKs.
                              890 ; 29   |#define ATTEMPT_FAST_BOOT 1
                              891 ; 30   |#define ATTEMPT_FASTEST_BOOT 0   
TASKING DSP2410 assembler v1.5r1 Build 138 SN 00100122
                                                                                                                            Page  15

M:ADDR CODE           CYCLES LINE SOURCELINE
                              892 ; 31   |// Changing this define to 0 removes Vbat threshholding & unconditionally gives fast boot 
                                  config above- 
                              893 ; 32   |// disabling this check is suggested for profiling if you want to try to tweak down thresh
                                  holds by maybe 50mV.
                              894 ; 33   |// Also the tests should clear the fast boot config defines to link & boot at normal speed
                                  .
                              895 ; 34   |#define SPEED_BOOT_BATTERY_CHECK 1
                              896 ; 35   |
                              897 ; 36   |/////////////////////////////////////////////////////////////////////////////////
                              898 ; 37   |// MEDIA DEFINITIONS
                              899 ; 38   |/////////////////////////////////////////////////////////////////////////////////
                              900 ; 39   |
                              901 ; 40   |/////////////////////////////////////////////////////////////////////////////////
                              902 ; 41   |// MNAND - Number of chips forming the internal physical device (i.e. # of NANDs)
                              903 ; 42   |#if defined(NAND1)
                              904 ; 43   |#define SM_INTERNAL_CHIPS 1
                              905 ; 44   |#else 
                              906 ; 45   |#if defined(NAND2)
                              907 ; 46   |#define SM_INTERNAL_CHIPS 2
                              908 ; 47   |#else 
                              909 ; 48   |#if defined(NAND3)
                              910 ; 49   |#define SM_INTERNAL_CHIPS 3
                              911 ; 50   |#else 
                              912 ; 51   |#if defined(NAND4)
                              913 ; 52   |#define SM_INTERNAL_CHIPS 4
                              914 ; 53   |#else 
                              915 ; 54   |#define SM_INTERNAL_CHIPS 1
                              916 ; 55   |#endif
                              917 ; 56   |#endif
                              918 ; 57   |#endif
                              919 ; 58   |#endif
                              920 ; 59   |
                              921 ; 60   |/////////////////////////////////////////////////////////////////////////////////
                              922 ; 61   |// If SMARTMEDIA_DETECT_ACTIVE_HIGH is defined:
                              923 ; 62   |//   SmartMedia will be detected as inserted if the GPIO pin reads 1 and removed if it rea
                                  ds 0.  
                              924 ; 63   |// If SMARTMEDIA_DETECT_ACTIVE_HIGH is not defined ** comment out next line **
                              925 ; 64   |//   SmartMedia will be detected as inserted if the GPIO pin reads 0 and removed if it rea
                                  ds 1.
                              926 ; 65   |//*** comment out if active high ****
                              927 ; 66   |//SMARTMEDIA_DETECT_ACTIVE_HIGH  equ     1
                              928 ; 67   |
                              929 ; 68   |#if defined(SMEDIA)
                              930 ; 69   |#define NUM_REMOVABLE_MEDIA 1
                              931 ; 70   |#define NUM_SM_EXTERNAL 1
                              932 ; 71   |#define MMC_MAX_PHYSICAL_DEVICES 0
                              933 ; 72   |#define SM_MAX_LOGICAL_DEVICES 2
                              934 ; 73   |#else 
                              935 ; 74   |#if defined(MMC)
                              936 ; 75   |#define NUM_REMOVABLE_MEDIA 1
                              937 ; 76   |#define NUM_SM_EXTERNAL 0
                              938 ; 77   |#define MMC_MAX_PHYSICAL_DEVICES 1
                              939 ; 78   |#define SM_MAX_LOGICAL_DEVICES 1
                              940 ; 79   |#else 
                              941 ; 80   |#define NUM_REMOVABLE_MEDIA 0
                              942 ; 81   |#define NUM_SM_EXTERNAL 0
                              943 ; 82   |#define MMC_MAX_PHYSICAL_DEVICES 0
                              944 ; 83   |#define SM_MAX_LOGICAL_DEVICES 1
                              945 ; 84   |#endif
                              946 ; 85   |#endif
                              947 ; 86   |
                              948 ; 87   |/////////////////////////////////////////////////////////////////////////////////
TASKING DSP2410 assembler v1.5r1 Build 138 SN 00100122
                                                                                                                            Page  16

M:ADDR CODE           CYCLES LINE SOURCELINE
                              949 ; 88   |// Mass Storage Class definitions
                              950 ; 89   |/////////////////////////////////////////////////////////////////////////////////
                              951 ; 90   |// Set to 0 if Composite Device build is desired.    
                              952 ; 91   |#define MULTI_LUN_BUILD 1   
                              953 ; 92   |
                              954 ; 93   |////////////////////////////////////////////////////////////////////////////////
                              955 ; 94   |//  SCSI
                              956 ; 95   |#if (MULTI_LUN_BUILD==0)
                              957 ; 96   |  #if (NUM_REMOVABLE_MEDIA == 1)
                              958 ; 97   |    #define SCSI_NUM_TARGETS                        2
                              959 ; 98   |    #define SCSI_DEVICE_NUM_LUNS_DEV_0              1
                              960 ; 99   |    #define SCSI_DEVICE_NUM_LUNS_DEV_1              1
                              961 ; 100  |  #else
                              962 ; 101  |    #define SCSI_NUM_TARGETS                        1
                              963 ; 102  |    #define SCSI_DEVICE_NUM_LUNS_DEV_0              1
                              964 ; 103  |  #endif
                              965 ; 104  |#else
                              966 ; 105  |    #define SCSI_NUM_TARGETS                        1
                              967 ; 106  |  #if (NUM_REMOVABLE_MEDIA == 1)
                              968 ; 107  |    #define SCSI_DEVICE_NUM_LUNS_DEV_0              2
                              969 ; 108  |  #else
                              970 ; 109  |    #define SCSI_DEVICE_NUM_LUNS_DEV_0              1  
                              971 ; 110  |  #endif
                              972 ; 111  |#endif
                              973 ; 112  |
                              974 ; 113  |
                              975 ; 114  |#define USBMSC_NUM_DEVICES                      SCSI_NUM_TARGETS
                              976 ; 115  |
                              977 ; 116  |
                              978 ; 117  |////////////////////////////////////////////////////////////////////////////////
                              979 ; 118  |// Define number of logical medias and drives for three builds (MTP, USBMSC, and Player)
                              980 ; 119  |////////////////////////////////////////////////////////////////////////////////
                              981 ; 120  |#ifdef MMC
                              982 ; 121  |#ifdef MTP_BUILD
                              983 ; 122  |// --------------------
                              984 ; 123  |// MTP and MMC
                              985 ; 124  |// --------------------
                              986 ; 125  |#define NUM_LOGICAL_MEDIA       2
                              987 ; 126  |#define NUM_LOGICAL_DRIVES      8
                              988 ; 127  |#else  // ifndef MTP_BUILD
                              989 ; 128  |#ifdef STMP_BUILD_PLAYER
                              990 ; 129  |// --------------------
                              991 ; 130  |// Player and MMC
                              992 ; 131  |// --------------------
                              993 ; 132  |#else
                              994 ; 133  |// --------------------
                              995 ; 134  |// USBMSC and MMC
                              996 ; 135  |// --------------------
                              997 ; 136  |#define NUM_LOGICAL_MEDIA       3
                              998 ; 137  |#define NUM_LOGICAL_DRIVES      8
                              999 ; 138  |#endif // ifdef STMP_BUILD_PLAYER
                             1000 ; 139  |#endif // ifdef MTP_BUILD
                             1001 ; 140  |#else  // ifndef MMC
                             1002 ; 141  |#ifdef MTP_BUILD
                             1003 ; 142  |// --------------------
                             1004 ; 143  |// MTP and NAND only
                             1005 ; 144  |// --------------------
                             1006 ; 145  |#define NUM_LOGICAL_MEDIA       1
                             1007 ; 146  |#define NUM_LOGICAL_DRIVES      7
                             1008 ; 147  |#else  // ifndef MTP_BUILD
                             1009 ; 148  |#ifdef STMP_BUILD_PLAYER
                             1010 ; 149  |// --------------------
TASKING DSP2410 assembler v1.5r1 Build 138 SN 00100122
                                                                                                                            Page  17

M:ADDR CODE           CYCLES LINE SOURCELINE
                             1011 ; 150  |// Player and NAND only
                             1012 ; 151  |// --------------------
                             1013 ; 152  |#else
                             1014 ; 153  |// --------------------
                             1015 ; 154  |// USBMSC and NAND only
                             1016 ; 155  |// --------------------
                             1017 ; 156  |#define NUM_LOGICAL_MEDIA       2
                             1018 ; 157  |#define NUM_LOGICAL_DRIVES      7
                             1019 ; 158  |#endif // ifdef STMP_BUILD_PLAYER
                             1020 ; 159  |#endif // ifdef MTP_BUILD
                             1021 ; 160  |#endif // ifdef MMC 
                             1022 ; 161  |
                             1023 ; 162  |// If we are in an MTP build then we don't use as many transfers buffers.
                             1024 ; 163  |#if (defined(MTP_BUILD))
                             1025 ; 164  |#define MAX_USB_TRANSFERS_QUEUED 16
                             1026 ; 165  |
                             1027 ; 166  |////!
                             1028 ; 167  |////! This varible holds the watchdog count for the store flush.
                             1029 ; 168  |////!
                             1030 ; 169  |///
                             1031 ; 170  |#include <types.h>
                             1032 ; 171  |extern volatile INT g_StoreWatchDogCount;
                             1033 ; 172  |extern const INT g_StoreWatchDogTimeout;
                             1034 ; 173  |#endif
                             1035 ; 174  |
                             1036 ; 175  |////////////////////////////////////////////////////////////////////////////////
                             1037 ; 176  |// These are needed here for Mass Storage Class
                             1038 ; 177  |// Needs to be cleaned up
                             1039 ; 178  |////////////////////////////////////////////////////////////////////////////////
                             1040 ; 179  |#if (!defined(STMP_BUILD_PLAYER))
                             1041 ; 180  |#define SCRATCH_USER_Y_SIZE 512
                             1042 ; 181  |#define SCRATCH_USER_X_SIZE 512
                             1043 ; 182  |
                             1044 ; 183  |#define BROWNOUT_LEVEL1_DETECTED                0x000001
                             1045 ; 184  |
                             1046 ; 185  |#endif
                             1047 ; 186  |
                             1048 ; 187  |
                             1049 ; 188  |/////////////////////////////////////////////////////////////////////////////////
                             1050 ; 189  |// SmartMedia/NAND defs
                             1051 ; 190  |#define SM_MAX_PHYSICAL_DEVICES SM_INTERNAL_CHIPS+NUM_SM_EXTERNAL
                             1052 ; 191  |#define SM_REMOVABLE_DEVICE_NUM SM_INTERNAL_CHIPS
                             1053 ; 192  |
                             1054 ; 193  |/////////////////////////////////////////////////////////////////////////////////
                             1055 ; 194  |// Sysloadresources defs
                             1056 ; 195  |#define SM_MAX_RESOURCE_DEVICES SM_INTERNAL_CHIPS+NUM_SM_EXTERNAL
                             1057 ; 196  |
                             1058 ; 197  |/////////////////////////////////////////////////////////////////////////////////
                             1059 ; 198  |// MMC defs
                             1060 ; 199  |#define MMC_MAX_PARTITIONS 1
                             1061 ; 200  |#define MMC_MAX_LOGICAL_DEVICES MMC_MAX_PHYSICAL_DEVICES*MMC_MAX_PARTITIONS
                             1062 ; 201  |
                             1063 ; 202  |/////////////////////////////////////////////////////////////////////////////////
                             1064 ; 203  |// SPI defs
                             1065 ; 204  |#define SPI_MAX_DEVICES MMC_MAX_PHYSICAL_DEVICES
                             1066 ; 205  |
                             1067 ; 206  |/////////////////////////////////////////////////////////////////////////////////
                             1068 ; 207  |// Global media defs
                             1069 ; 208  |#define MAX_PHYSICAL_DEVICES SM_MAX_PHYSICAL_DEVICES+MMC_MAX_PHYSICAL_DEVICES
                             1070 ; 209  |#define MAX_LOGICAL_DEVICES SM_MAX_LOGICAL_DEVICES+MMC_MAX_LOGICAL_DEVICES
                             1071 ; 210  |
                             1072 ; 211  |/////////////////////////////////////////////////////////////////////////////////
TASKING DSP2410 assembler v1.5r1 Build 138 SN 00100122
                                                                                                                            Page  18

M:ADDR CODE           CYCLES LINE SOURCELINE
                             1073 ; 212  |// DO NOT CHANGE THESE!!!
                             1074 ; 213  |#define SM_MAX_PARTITIONS 4
                             1075 ; 214  |#define MAX_HANDLES 2
                             1076 ; 215  |/////////////////////////////////////////////////////////////////////////////////
                             1077 ; 216  |
                             1078 ; 217  |
                             1079 ; 218  |/////////////////////////////////////////////////////////////////////////////////
                             1080 ; 219  |// Battery LRADC Values 
                             1081 ; 220  |/////////////////////////////////////////////////////////////////////////////////
                             1082 ; 221  |// brownout trip point in mV (moved by RS)
                             1083 ; 222  |// BATT_SAFETY_MARGIN:  percentage value used by:
                             1084 ; 223  |//   * SysSaveSettings to determine if enough power is left to attempt a settings save. 
                             1085 ; 224  |//   * Recorder to conditionally prevent the start or continuation of 
                             1086 ; 225  |//     audio recording to media.
                             1087 ; 226  |#define BATT_SAFETY_MARGIN 10
                             1088 ; 227  |
                             1089 ; 228  |//; player resource drive refresh allowed only when battery usable % is above this value. 
                                  
                             1090 ; 229  |//; 50% of usable range [0.9V to 1.5V] is around 1.2V This is the safe target alkaline vol
                                  tage to do a refresh.
                             1091 ; 230  |//; LIION will also require 50% which will work but that could be changed in the future. 
                             1092 ; 231  |//RESOURCE_REFRESH_MIN_BATT_PCT equ 50
                             1093 ; 232  |
                             1094 ; 233  |// stmp00005071 adds these for mp3 encode stability at low battery per battery type & mmc 
                                  presence.
                             1095 ; 234  |
                             1096 ; 235  |//// Vbat threshholds empirically tuned by profiling max bat current for 3 HW cases: 
                             1097 ; 236  |//// 1 GigaByte MMC, NAND flash only, & LiIon Buck mode. See voicemenu pre-encode Vbat che
                                  ck.
                             1098 ; 237  |#if (!defined(CLCD))
                             1099 ; 238  |#define MP3_ENC_MMC_MIN_V_BAT_MV 1100
                             1100 ; 239  |#define MP3_ENC_NANDONLY_MIN_V_BAT_MV 1000
                             1101 ; 240  |#else 
                             1102 ; 241  |#define MP3_ENC_MMC_MIN_V_BAT_MV 1250
                             1103 ; 242  |#define MP3_ENC_NANDONLY_MIN_V_BAT_MV 1150
                             1104 ; 243  |#endif
                             1105 ; 244  |#define MP3_ENC_BUCKMODE_MIN_V_BAT_MV 3300
                             1106 ; 245  |
                             1107 ; 246  |// These Vbat use-range-percentages are derived to correspond with target battery 
                             1108 ; 247  |// voltages of 1.10V for MMC, 1.0V for nand only (alkaline or nimh), and 3.3V for any LiIo
                                  n.
                             1109 ; 248  |// See mp3 encoder overlay.
                             1110 ; 249  |#define MP3_ENC_MMC_MIN_V_BAT_RANGE_PCT 33
                             1111 ; 250  |#define MP3_ENC_NANDONLY_MIN_V_BAT_RANGE_PCT 17
                             1112 ; 251  |#define MP3_ENC_BUCKMODE_MIN_V_BAT_RANGE_PCT 25
                             1113 ; 252  |
                             1114 ; 253  |/////////////////////////////////////////////////////////////////////////////////
                             1115 ; 254  |// Voice recording filenames
                             1116 ; 255  |// number of digits in filename Vxxx.wav
                             1117 ; 256  |/////////////////////////////////////////////////////////////////////////////////
                             1118 ; 257  |#define DIGITS_IN_VOICE_FILENAME 3   
                             1119 ; 258  |
                             1120 ; 259  |/////////////////////////////////////////////////////////////////////////////////
                             1121 ; 260  |// Mic Bias: Set this enable to 1 to internally generate mic bias voltage. 
                             1122 ; 261  |// Also below, must configure internal resistor value and pin to use for DC bias. 
                             1123 ; 262  |// Can set to 0 to disable internally generated mic bias voltage at pin lradc1/2.
                             1124 ; 263  |#if defined(DEVICE_3500)
                             1125 ; 264  |#define ENABLE_INTERNALLY_GENERATED_MICBIAS 1 
                             1126 ; 265  |// MIC BIAS circuit source selection: use Low Resolution ADC pin 2 or 1 to bias mic. 
                             1127 ; 266  |// Per your layout: select LRADC 2 or 1 below 
                             1128 ; 267  |//   (pin LRADC 2 for 35xx cpu card revB, LRADC 1 for 35xx cpu card revC, ref schematics, 
                                  & demo player)
TASKING DSP2410 assembler v1.5r1 Build 138 SN 00100122
                                                                                                                            Page  19

M:ADDR CODE           CYCLES LINE SOURCELINE
                             1129 ; 268  |#define LRADC_NUM_FOR_MIC_BIAS 1 
                             1130 ; 269  |// Sets internal mic bias R to value 2, 4, or 8 (in kOhms).
                             1131 ; 270  |#define MICBIAS_CONFIGURED_RESISTOR_KOHMS 8
                             1132 ; 271  |
                             1133 ; 272  |// Allows mic bias to settle before sampling. This delay currently unused. For rec btn whe
                                  n bias not yet ready.
                             1134 ; 273  |#define REC_BTN_INTERNAL_MIC_BIAS_SETTLING_DELAY_MS 400 
                             1135 ; 274  |// Option always keeps bias enabled after mainmenu init. This allows for start pop prevent
                                  ion if you use rec button from outside voice menu.
                             1136 ; 275  |// This selection costs 1 mWatt but gains the desired low record button to sampling latenc
                                  y in the record-from-music-menu use-case.
                             1137 ; 276  |#define KEEP_MIC_BIAS_ENABLED 0
                             1138 ; 277  |
                             1139 ; 278  |#else 
                             1140 ; 279  |// STMP3410
                             1141 ; 280  |#define ENABLE_INTERNALLY_GENERATED_MICBIAS 0
                             1142 ; 281  |#define LRADC_NUM_FOR_MIC_BIAS 1 
                             1143 ; 282  |#define MICBIAS_CONFIGURED_RESISTOR_KOHMS 2
                             1144 ; 283  |#endif
                             1145 ; 284  |
                             1146 ; 285  |/////////////////////////////////////////////////////////////////////////////////
                             1147 ; 286  |// Number of available soft timers
                             1148 ; 287  |/////////////////////////////////////////////////////////////////////////////////
                             1149 ; 288  |#if defined(SYNC_LYRICS)
                             1150 ; 289  |#define SOFT_TIMERS 10
                             1151 ; 290  |#else 
                             1152 ; 291  |#if defined(JPEG_DECODER)
                             1153 ; 292  |#define SOFT_TIMERS 10
                             1154 ; 293  |#else 
                             1155 ; 294  |#define SOFT_TIMERS 9
                             1156 ; 295  |#endif
                             1157 ; 296  |#endif
                             1158 ; 297  |
                             1159 ; 298  |/////////////////////////////////////////////////////////////////////////////////
                             1160 ; 299  |//  sizes
                             1161 ; 300  |/////////////////////////////////////////////////////////////////////////////////
                             1162 ; 301  |#if defined(MMC)
                             1163 ; 302  |#if defined(USE_PLAYLIST5)
                             1164 ; 303  |#define MENU_STACK_SIZE 1500
                             1165 ; 304  |#else 
                             1166 ; 305  |#define MENU_STACK_SIZE 1250
                             1167 ; 306  |#endif //if @def('USE_PLAYLIST5')
                             1168 ; 307  |#else 
                             1169 ; 308  |#if defined(USE_PLAYLIST5)
                             1170 ; 309  |#define MENU_STACK_SIZE 1500
                             1171 ; 310  |#else 
                             1172 ; 311  |#define MENU_STACK_SIZE 1250
                             1173 ; 312  |#endif //if @def('USE_PLAYLIST5')
                             1174 ; 313  |#endif //if @def('MMC')
                             1175 ; 314  |
                             1176 ; 315  |// NOTE: SDK2.6 USED 550 FOR NEXT LINE, BUT SDK3.0BETA USED 750. Should it be ifdef MTP 75
                                  0 else 550 for other builds? TOVERIFY. MYALLOC
                             1177 ; 316  |// 
                             1178 ; 317  |#define STACK_L1_SIZE 750
                             1179 ; 318  |#define STACK_L2_SIZE 100
                             1180 ; 319  |#define STACK_L3_SIZE 160
                             1181 ; 320  |
                             1182 ; 321  |// If we are in MTP mode the overlay task stack can shrink.
                             1183 ; 322  |// TODO shrink this stack for MTP, I will leave it at 500 until we verify that it 
                             1184 ; 323  |// is ok with switching code.
                             1185 ; 324  |#if defined(MTP_BUILD)
                             1186 ; 325  |#define OVERLAY_MANAGER_STACK_SIZE 300
TASKING DSP2410 assembler v1.5r1 Build 138 SN 00100122
                                                                                                                            Page  20

M:ADDR CODE           CYCLES LINE SOURCELINE
                             1187 ; 326  |#endif
                             1188 ; 327  |
                             1189 ; 328  |/////////////////////////////////////////////////////////////////////////////////
                             1190 ; 329  |// maximum number of nested funclets 
                             1191 ; 330  |/////////////////////////////////////////////////////////////////////////////////
                             1192 ; 331  |#define MAX_NESTED_FUNCLET 6 
                             1193 ; 332  |
                             1194 ; 333  |/////////////////////////////////////////////////////////////////////////////////
                             1195 ; 334  |//    LCD DEFINITIONS
                             1196 ; 335  |/////////////////////////////////////////////////////////////////////////////////
                             1197 ; 336  |
                             1198 ; 337  |#define SPACE_CHAR 0x000020          
                             1199 ; 338  |#define ZERO_CHAR 0x000030
                             1200 ; 339  |#define COLON_CHAR 0x00003A
                             1201 ; 340  |#define PERIOD_CHAR 0x00002E
                             1202 ; 341  |
                             1203 ; 342  |#if (defined(S6B33B0A_LCD))
                             1204 ; 343  |#define LCD_X_SIZE 128
                             1205 ; 344  |#define LCD_Y_SIZE 159
                             1206 ; 345  |#endif
                             1207 ; 346  |
                             1208 ; 347  |#if (defined(SED15XX_LCD))
                             1209 ; 348  |#define LCD_X_SIZE 128
                             1210 ; 349  |#define LCD_Y_SIZE 64
                             1211 ; 350  |#endif
                             1212 ; 351  |
                             1213 ; 352  |
                             1214 ; 353  |//////////////////////////////////////////////////////////////////////////////////
                             1215 ; 354  |//   Details on Customizing Contrast
                             1216 ; 355  |/////////////////////////////////////////////////////////////////////////////////
                             1217 ; 356  |//   Max supported LCD range is 0 - 3F; however due to hardware/voltage differences
                             1218 ; 357  |//   the range of visibility is usually smaller than this.  It is important to 
                             1219 ; 358  |//   calibrate the visible range, because the contrast setting is saved.
                             1220 ; 359  |//   If the user shuts off the player while lcd is not visible, the player is useless
                             1221 ; 360  |//   unless the ezact sequence is remembered.
                             1222 ; 361  |//   To find out what range your player supports: 
                             1223 ; 362  |//   change these equs to full range or comment out (full range is default)
                             1224 ; 363  |//;;;;;;
                             1225 ; 364  |// uncomment the line below to build code that will provide raw contrast value
                             1226 ; 365  |// recommended calibration using player -- uncomment 
                             1227 ; 366  |//;;;;;;
                             1228 ; 367  |//CONTRAST_CALIBRATION    equ  1
                             1229 ; 368  |////////////////////////////
                             1230 ; 369  |#if (defined(DEMO_HW))
                             1231 ; 370  |// this is the setting for ET301 demos; Next 2 line have not been updated for new Shingyi 
                                  LCD (June6'05)
                             1232 ; 371  |#define LCD_MAX_CONTRAST 0x32 
                             1233 ; 372  |#define LCD_MIN_CONTRAST 0x1E
                             1234 ; 373  |#else 
                             1235 ; 374  |
                             1236 ; 375  |#if (defined(S6B33B0A_LCD))
                             1237 ; 376  |#define LCD_MAX_CONTRAST 210
                             1238 ; 377  |#define LCD_MIN_CONTRAST 160    
                             1239 ; 378  |#endif
                             1240 ; 379  |
                             1241 ; 380  |#if (defined(SED15XX_LCD))
                             1242 ; 381  |// Next 3 line comment was for OLD shingyi LCD: (default LCD before sdk2.6)
                             1243 ; 382  |// Engineering board regs support range [17-37].
                             1244 ; 383  |//   Engineering board DC/DC support range [24-46]. 
                             1245 ; 384  |//   One default contrast range [24-42] works for both.
                             1246 ; 385  |// The 3 sets of contrast ranges below are updated for SDK2.6 to support either 
                             1247 ; 386  |// new or old ShingYih LCDs. "File" refers to \resource\shingyih\system_lcd_init_seq.src
TASKING DSP2410 assembler v1.5r1 Build 138 SN 00100122
                                                                                                                            Page  21

M:ADDR CODE           CYCLES LINE SOURCELINE
                             1248 ; 387  |// 3/10/05 - Use one of the 2 next contrast ranges depending on which
                             1249 ; 388  |// ShingYih LCD you have.  See \resources\shingyi\readme.txt 
                             1250 ; 389  |// Optimal for NEW LCD with NEW file (SDK2.6 default)  
                             1251 ; 390  |// G098064-41 LCD module (present on engr board revH LCD card)
                             1252 ; 391  |
                             1253 ; 392  |#if (defined(NEWSHINGYIH))
                             1254 ; 393  |#define LCD_MAX_CONTRAST 250
                             1255 ; 394  |#define LCD_MIN_CONTRAST 0
                             1256 ; 395  |#else 
                             1257 ; 396  |//-----
                             1258 ; 397  |// Near optimal for OLD LCD with NEW file. 
                             1259 ; 398  |// NOT optimal for the new lcd but pretty good. So u may use this if u want 1 build for bo
                                  th LCDs.
                             1260 ; 399  |#define LCD_MAX_CONTRAST 250
                             1261 ; 400  |#define LCD_MIN_CONTRAST 0
                             1262 ; 401  |
                             1263 ; 402  |//=====
                             1264 ; 403  |// Optimal for OLD ShingYih LCD with OLD file (as sdk2.521)
                             1265 ; 404  |// Suggest going with default new init file & values above for your LCD instead of this hi
                                  storic ver.
                             1266 ; 405  |//LCD_MAX_CONTRAST equ 42
                             1267 ; 406  |//LCD_MIN_CONTRAST equ 24 
                             1268 ; 407  |
                             1269 ; 408  |#endif
                             1270 ; 409  |#endif
                             1271 ; 410  |
                             1272 ; 411  |#endif
                             1273 ; 412  |
                             1274 ; 413  |//////////////////////////////////////////////////////////////////////////////////
                             1275 ; 414  |// The default value of the lcd contrast in % of range
                             1276 ; 415  |//   the default value is used when no settings.dat is available
                             1277 ; 416  |//////////////////////////////////////////////////////////////////////////////////
                             1278 ; 417  |
                             1279 ; 418  |#if (defined(S6B33B0A_LCD))
                             1280 ; 419  |// 60% of range is default value
                             1281 ; 420  |#define DEFAULT_CONTRAST 50 
                             1282 ; 421  |#endif
                             1283 ; 422  |
                             1284 ; 423  |#if (defined(SED15XX_LCD))
                             1285 ; 424  |// % of range is default value (was 60%)
                             1286 ; 425  |#define DEFAULT_CONTRAST 50 
                             1287 ; 426  |#endif
                             1288 ; 427  |
                             1289 ; 428  |
                             1290 ; 429  |// percentage change per increment/decrement message (LCD_DEC_CONTRAST/LCD_INC_CONTRAST)
                             1291 ; 430  |// make lower when doing calibration
                             1292 ; 431  |#define LCD_STEPSIZE_CONTRAST 10  
                             1293 ; 432  |
                             1294 ; 433  |
                             1295 ; 434  |/////////////////////////////////////////////////////////////////////////////////
                             1296 ; 435  |// For FFWD and RWND
                             1297 ; 436  |/////////////////////////////////////////////////////////////////////////////////
                             1298 ; 437  |#define SECONDS_TO_SKIP 1
                             1299 ; 438  |#define SECONDS_TO_SKIP1 3
                             1300 ; 439  |#define SECONDS_TO_SKIP2 6
                             1301 ; 440  |// number of seconds to cause reset to begin of song for PREV push
                             1302 ; 441  |#define PREV_SONG_THRESHOLD 5  
                             1303 ; 442  |// number of 300 mSec periods before the numbers of seconds to skip increases
                             1304 ; 443  |#define FIRST_TIME_BOUNDARY 15 
                             1305 ; 444  |// number of 300 mSec periods before the numbers of seconds to skip increases
                             1306 ; 445  |#define SECOND_TIME_BOUNDARY 30 
                             1307 ; 446  |
TASKING DSP2410 assembler v1.5r1 Build 138 SN 00100122
                                                                                                                            Page  22

M:ADDR CODE           CYCLES LINE SOURCELINE
                             1308 ; 447  |// For audible FFW/RWD
                             1309 ; 448  |#define SECONDS_TO_SKIP_FOR_3X_RATE 1
                             1310 ; 449  |#define SECONDS_TO_SKIP_FOR_60X_RATE 18
                             1311 ; 450  |#define SECONDS_TO_SKIP_FOR_600X_RATE 180
                             1312 ; 451  |#define SECONDS_TO_SKIP_FOR_1800X_RATE 540
                             1313 ; 452  |// number of 300 mSec periods before the numbers of seconds to skip increases
                             1314 ; 453  |#define LEVEL1_BOUNDARY 17 
                             1315 ; 454  |// number of 300 mSec periods before the numbers of seconds to skip increases
                             1316 ; 455  |#define LEVEL2_BOUNDARY 33 
                             1317 ; 456  |// number of 300 mSec periods before the numbers of seconds to skip increases
                             1318 ; 457  |#define LEVEL3_BOUNDARY 50 
                             1319 ; 458  |// Stmp00010296 Ticket #71685:  for song shorter than the min. skip size
                             1320 ; 459  |// if song_time < skip_size, bCurrentSongShort=>TRUE (ignore FWD/RWD commands)
                             1321 ; 460  |// Short Song Time, songs too short to play.
                             1322 ; 461  |#define SHORT_SONG_TIME SECONDS_TO_SKIP         
                             1323 ; 462  |
                             1324 ; 463  |/////////////////////////////////////////////////////////////////////////////////
                             1325 ; 464  |// MP3 Sync Values
                             1326 ; 465  |/////////////////////////////////////////////////////////////////////////////////
                             1327 ; 466  |// # bytes to look for sync before marking it bad
                             1328 ; 467  |#define MP3_SYNC_THRESHOLD 70000 
                             1329 ; 468  |// # bytes to look for sync before slowing decoder isr frequency (to let menus run)
                             1330 ; 469  |#define MP3_SYNC_THRESHOLD1 10000 
                             1331 ; 470  |// once we have sync'd, the isr should be called this frequently
                             1332 ; 471  |#define MP3_DECODERISR_FAST 7500  
                             1333 ; 472  |// if decoder is having difficulty syncing, switch isr to be called less frequently
                             1334 ; 473  |#define MP3_DECODERISR_SLOW 50000 
                             1335 ; 474  |
                             1336 ; 475  |
                             1337 ; 476  |/////////////////////////////////////////////////////////////////////////////////
                             1338 ; 477  |//// Multi-Stage Volume Control Definitions
                             1339 ; 478  |/////////////////////////////////////////////////////////////////////////////////
                             1340 ; 479  |//// Use Multi-Stage Volume
                             1341 ; 480  |#define MULTI_STAGE_VOLUME 0x1                  
                             1342 ; 481  |
                             1343 ; 482  |//// Master Volume definitions
                             1344 ; 483  |#define MIX_MSTR_MAX_VOL 0x0
                             1345 ; 484  |#define NUM_MSTR_ATT_STEPS (0x1F-MIX_MSTR_MAX_VOL)
                             1346 ; 485  |
                             1347 ; 486  |//// DAC-Mode definitions
                             1348 ; 487  |//// Adjusts 0dB point
                             1349 ; 488  |#define MIX_DAC_NOM_VOL 0x6                  
                             1350 ; 489  |#define MIX_DAC_MIN_VOL 0x1F
                             1351 ; 490  |// For minimum clipping: Set MIX_DAC_MAX_VOL below to match MIX_DAC_NOM_VOL value 2 lines 
                                  above.
                             1352 ; 491  |// For additional gain (with possible clipping): Set MIX_DAC_MAX_VOL in range below. 
                             1353 ; 492  |//                                               Each integer below MIX_DAC_NOM_VOL provid
                                  es 1.5 dB gain on Stmp34x0; 
                             1354 ; 493  |//                                               Max gain possible: 8 step diff would prov
                                  ide +12dB gain.   
                             1355 ; 494  |// range: [0 to MIX_DAC_NOM_VOL] (0 for loudest volume)
                             1356 ; 495  |#define MIX_DAC_MAX_VOL 0x0  
                             1357 ; 496  |
                             1358 ; 497  |#define NUM_DAC_ATT_STEPS (MIX_DAC_MIN_VOL-MIX_DAC_NOM_VOL+1)
                             1359 ; 498  |#define NUM_DAC_GAIN_STEPS (MIX_DAC_NOM_VOL-MIX_DAC_MAX_VOL)
                             1360 ; 499  |#define NUM_DAC_MODE_VOL_STEPS (NUM_DAC_ATT_STEPS+NUM_MSTR_ATT_STEPS+NUM_DAC_GAIN_STEPS+1)
                                  
                             1361 ; 500  |
                             1362 ; 501  |//// If there is no stored volume, set to 50% of DAC-Mode max; change if DAC Mode is not t
                                  he default
                             1363 ; 502  |//// STMP35xx has 2dB attenuation per step so default needs a few more steps above midpoin
                                  t.
TASKING DSP2410 assembler v1.5r1 Build 138 SN 00100122
                                                                                                                            Page  23

M:ADDR CODE           CYCLES LINE SOURCELINE
                             1364 ; 503  |#define DEFAULT_VOLUME ((NUM_DAC_MODE_VOL_STEPS/2)+6)         
                             1365 ; 504  |
                             1366 ; 505  |//// Set maximum restored volume to 75% of DAC-Mode max; change if DAC Mode is not the def
                                  ault
                             1367 ; 506  |#define MAX_RESTORED_VOLUME ((3*NUM_DAC_MODE_VOL_STEPS)/4)   
                             1368 ; 507  |
                             1369 ; 508  |
                             1370 ; 509  |//// Line In definitions (used for Line-In 1)
                             1371 ; 510  |//// 0dB point of the Line In
                             1372 ; 511  |#define MIX_LINE_NOM_VOL 0x8                  
                             1373 ; 512  |//// Minimum volume of Line In
                             1374 ; 513  |#define MIX_LINE_MIN_VOL 0x1F                 
                             1375 ; 514  |//// Maximum volume of Line In (can adjust extra gain)
                             1376 ; 515  |#define MIX_LINE_MAX_VOL 0x6                  
                             1377 ; 516  |#define NUM_LINE_ATT_STEPS (MIX_LINE_MIN_VOL-MIX_LINE_NOM_VOL+1)
                             1378 ; 517  |#define NUM_LINE_GAIN_STEPS (MIX_LINE_NOM_VOL-MIX_LINE_MAX_VOL)
                             1379 ; 518  |#define NUM_LINE_MODE_VOL_STEPS (NUM_LINE_ATT_STEPS+NUM_MSTR_ATT_STEPS+NUM_LINE_GAIN_STEPS
                                  +1)
                             1380 ; 519  |
                             1381 ; 520  |//// Line In definitions (used for FM tuner with 144 pin package)
                             1382 ; 521  |//// 0dB point of the Line In
                             1383 ; 522  |#define MIX_FM_NOM_VOL 0x8                  
                             1384 ; 523  |//// Minimum volume of Line In
                             1385 ; 524  |#define MIX_FM_MIN_VOL 0x1F                 
                             1386 ; 525  |//// Maximum volume of Line In (can adjust extra gain)
                             1387 ; 526  |#define MIX_FM_MAX_VOL 0x6                  
                             1388 ; 527  |#define NUM_FM_ATT_STEPS (MIX_FM_MIN_VOL-MIX_FM_NOM_VOL+1)
                             1389 ; 528  |#define NUM_FM_GAIN_STEPS (MIX_FM_NOM_VOL-MIX_FM_MAX_VOL)
                             1390 ; 529  |#define NUM_FM_MODE_VOL_STEPS (NUM_FM_ATT_STEPS+NUM_MSTR_ATT_STEPS+NUM_FM_GAIN_STEPS+1)
                             1391 ; 530  |
                             1392 ; 531  |/////////////////////////////////////////////////////////////////////////////////
                             1393 ; 532  |//// When enabled (1), periodically checks for one of several FM state machine invalid dea
                                  dlock states & recovers. 
                             1394 ; 533  |//// Define as 0 to disable FM-deadlock-state checking and recovery.
                             1395 ; 534  |#define FM_WATCHDOG_ENABLE 1
                             1396 ; 535  |
                             1397 ; 536  |#if !defined(STMP_BUILD_PLAYER)
                             1398 ; 537  |////
                             1399 ; 538  |////! This varible holds the lcd display state for the mtp project.
                             1400 ; 539  |////
                             1401 ; 540  |///
                             1402 ; 541  |#include <types.h>
                             1403 
                             1405 
                             1406 ; 1    |////////////////////////////////////////////////////////////////////////////////
                             1407 ; 2    |// Copyright(C) SigmaTel, Inc. 2000-2004
                             1408 ; 3    |//
                             1409 ; 4    |// Filename: types.h
                             1410 ; 5    |// Description: Standard data types
                             1411 ; 6    |////////////////////////////////////////////////////////////////////////////////
                             1412 ; 7    |
                             1413 ; 8    |#ifndef _TYPES_H
                             1414 ; 9    |#define _TYPES_H
                             1415 ; 10   |
                             1416 ; 11   |// TODO:  move this outta here!
                             1417 ; 12   |#if !defined(NOERROR)
                             1418 ; 13   |#define NOERROR 0
                             1419 ; 14   |#define SUCCESS 0
                             1420 ; 15   |#endif 
                             1421 ; 16   |#if !defined(SUCCESS)
                             1422 ; 17   |#define SUCCESS  0
                             1423 ; 18   |#endif
TASKING DSP2410 assembler v1.5r1 Build 138 SN 00100122
                                                                                                                            Page  24

M:ADDR CODE           CYCLES LINE SOURCELINE
                             1424 ; 19   |#if !defined(ERROR)
                             1425 ; 20   |#define ERROR   -1
                             1426 ; 21   |#endif
                             1427 ; 22   |#if !defined(FALSE)
                             1428 ; 23   |#define FALSE 0
                             1429 ; 24   |#endif
                             1430 ; 25   |#if !defined(TRUE)
                             1431 ; 26   |#define TRUE  1
                             1432 ; 27   |#endif
                             1433 ; 28   |
                             1434 ; 29   |#if !defined(NULL)
                             1435 ; 30   |#define NULL 0
                             1436 ; 31   |#endif
                             1437 ; 32   |
                             1438 ; 33   |#define MAX_INT     0x7FFFFF
                             1439 ; 34   |#define MAX_LONG    0x7FFFFFffffff
                             1440 ; 35   |        // max positive unsigned long value: -1 == 0xFFFFFFffffff
                             1441 ; 36   |#define MAX_ULONG   (-1) 
                             1442 ; 37   |
                             1443 ; 38   |#define WORD_SIZE   24              // word size in bits
                             1444 ; 39   |#define BYTES_PER_WORD 3            // 8 bit bytes
                             1445 ; 40   |
                             1446 ; 41   |
                             1447 ; 42   |#define BYTE    unsigned char       // btVarName
                             1448 ; 43   |#define CHAR    signed char         // cVarName
                             1449 ; 44   |#define USHORT  unsigned short      // usVarName
                             1450 ; 45   |#define SHORT   unsigned short      // sVarName
                             1451 ; 46   |#define WORD    unsigned int        // wVarName
                             1452 ; 47   |#define INT     signed int          // iVarName
                             1453 ; 48   |#define DWORD   unsigned long       // dwVarName
                             1454 ; 49   |#define LONG    signed long         // lVarName
                             1455 ; 50   |#define BOOL    unsigned int        // bVarName
                             1456 ; 51   |#define FRACT   _fract              // frVarName
                             1457 ; 52   |#define LFRACT  long _fract         // lfrVarName
                             1458 ; 53   |#define CIRC    _circ               // cp<type prefix>VarName (see below)
                             1459 ; 54   |#define FLOAT   float               // fVarName
                             1460 ; 55   |#define DBL     double              // dVarName
                             1461 ; 56   |#define ENUM    enum                // eVarName
                             1462 ; 57   |#define CMX     _complex            // cmxVarName
                             1463 ; 58   |typedef WORD UCS3;                   // 
                             1464 ; 59   |
                             1465 ; 60   |#define UINT16  unsigned short
                             1466 ; 61   |#define UINT8   unsigned char   
                             1467 ; 62   |#define UINT32  unsigned long
                             1468 ; 63   |#define UINT64  unsigned long   // need to figure out how to do 64 bit values.  Or port ex
                                  isiting code to only use 48 bit
                             1469 ; 64   |#define INT64   unsigned long   // need to figure out how to do 64 bit values.  Or port ex
                                  isiting code to only use 48 bit
                             1470 ; 65   |#define WCHAR   UINT16
                             1471 ; 66   |
                             1472 ; 67   |//UINT128 is 16 bytes or 6 words
                             1473 ; 68   |typedef struct UINT128_3500 {   
                             1474 ; 69   |    int val[6];     
                             1475 ; 70   |} UINT128_3500;
                             1476 ; 71   |
                             1477 ; 72   |#define UINT128   UINT128_3500
                             1478 ; 73   |
                             1479 ; 74   |// Little endian word packed byte strings:   
                             1480 ; 75   |//      _packed BYTE bTextVarName[]="a string";  bText is a packed byte string prefix
                             1481 ; 76   |// Convert to big endian words by reordering bytes from high to low using swizzle.
                             1482 ; 77   |// Little endian word packed byte strings:   
                             1483 ; 78   |//      _packed BYTE bTextVarName[]="a string";  bText is a packed byte string prefix
TASKING DSP2410 assembler v1.5r1 Build 138 SN 00100122
                                                                                                                            Page  25

M:ADDR CODE           CYCLES LINE SOURCELINE
                             1484 ; 79   |// Convert to big endian words by reordering bytes from high to low using swizzle.
                             1485 ; 80   |
                             1486 ; 81   |// Declare Memory Spaces To Use When Coding
                             1487 ; 82   |// A. Sector Buffers
                             1488 ; 83   |#define SECTOR_BUFFER_MEM_X _X
                             1489 ; 84   |#define SECTOR_BUFFER_MEM_Y _Y
                             1490 ; 85   |#define SECTOR_BUFFER_MEM SECTOR_BUFFER_MEM_X
                             1491 ; 86   |typedef WORD SECTOR_BUFFER_MEM SECTOR_BUFFER;
                             1492 ; 87   |typedef SECTOR_BUFFER * P_SECTOR_BUFFER;
                             1493 ; 88   |// B. Media DDI Memory
                             1494 ; 89   |#define MEDIA_DDI_MEM _Y
                             1495 ; 90   |
                             1496 ; 91   |
                             1497 ; 92   |
                             1498 ; 93   |// Pointers to linear structures are labeled as: p<type prefix>VarName
                             1499 ; 94   |// Examples of circular pointers:
                             1500 ; 95   |//    INT CIRC cpiVarName
                             1501 ; 96   |//    DWORD CIRC cpdwVarName
                             1502 ; 97   |
                             1503 ; 98   |#define RETCODE INT                 // rcVarName
                             1504 ; 99   |
                             1505 ; 100  |// generic bitfield structure
                             1506 ; 101  |struct Bitfield {
                             1507 ; 102  |    unsigned int B0  :1;
                             1508 ; 103  |    unsigned int B1  :1;
                             1509 ; 104  |    unsigned int B2  :1;
                             1510 ; 105  |    unsigned int B3  :1;
                             1511 ; 106  |    unsigned int B4  :1;
                             1512 ; 107  |    unsigned int B5  :1;
                             1513 ; 108  |    unsigned int B6  :1;
                             1514 ; 109  |    unsigned int B7  :1;
                             1515 ; 110  |    unsigned int B8  :1;
                             1516 ; 111  |    unsigned int B9  :1;
                             1517 ; 112  |    unsigned int B10 :1;
                             1518 ; 113  |    unsigned int B11 :1;
                             1519 ; 114  |    unsigned int B12 :1;
                             1520 ; 115  |    unsigned int B13 :1;
                             1521 ; 116  |    unsigned int B14 :1;
                             1522 ; 117  |    unsigned int B15 :1;
                             1523 ; 118  |    unsigned int B16 :1;
                             1524 ; 119  |    unsigned int B17 :1;
                             1525 ; 120  |    unsigned int B18 :1;
                             1526 ; 121  |    unsigned int B19 :1;
                             1527 ; 122  |    unsigned int B20 :1;
                             1528 ; 123  |    unsigned int B21 :1;
                             1529 ; 124  |    unsigned int B22 :1;
                             1530 ; 125  |    unsigned int B23 :1;
                             1531 ; 126  |};
                             1532 ; 127  |
                             1533 ; 128  |union BitInt {
                             1534 ; 129  |        struct Bitfield B;
                             1535 ; 130  |        int        I;
                             1536 ; 131  |};
                             1537 ; 132  |
                             1538 ; 133  |#define MAX_MSG_LENGTH 10
                             1539 ; 134  |struct CMessage
                             1540 ; 135  |{
                             1541 ; 136  |        unsigned int m_uLength;
                             1542 ; 137  |        unsigned int m_uMsg[MAX_MSG_LENGTH];
                             1543 ; 138  |};
                             1544 ; 139  |
                             1545 ; 140  |typedef struct {
TASKING DSP2410 assembler v1.5r1 Build 138 SN 00100122
                                                                                                                            Page  26

M:ADDR CODE           CYCLES LINE SOURCELINE
                             1546 ; 141  |    WORD m_wLength;
                             1547 ; 142  |    WORD m_wMessage;
                             1548 ; 143  |    WORD m_wParams[MAX_MSG_LENGTH];
                             1549 ; 144  |} Message;
                             1550 ; 145  |
                             1551 ; 146  |struct MessageQueueDescriptor
                             1552 ; 147  |{
                             1553 ; 148  |        int *m_pBase;
                             1554 ; 149  |        int m_iModulo;
                             1555 ; 150  |        int m_iSize;
                             1556 ; 151  |        int *m_pHead;
                             1557 ; 152  |        int *m_pTail;
                             1558 ; 153  |};
                             1559 ; 154  |
                             1560 ; 155  |struct ModuleEntry
                             1561 ; 156  |{
                             1562 ; 157  |    int m_iSignaledEventMask;
                             1563 ; 158  |    int m_iWaitEventMask;
                             1564 ; 159  |    int m_iResourceOfCode;
                             1565 ; 160  |    struct MessageQueueDescriptor *m_pMessageQueue;
                             1566 ; 161  |    int _asmfunc (*m_pProcessEntryPoint)(union WaitMask Signals,struct MessageQueueDescrip
                                  tor *);
                             1567 ; 162  |    int _asmfunc (*m_pInitFunction)(struct MessageQueueDescriptor *);
                             1568 ; 163  |    int m_uTimeOutHigh;
                             1569 ; 164  |    int m_uTimeOutLow;
                             1570 ; 165  |    int _asmfunc (*m_pBackgroundFunction)(struct MessageQueueDescriptor *);
                             1571 ; 166  |};
                             1572 ; 167  |
                             1573 ; 168  |union WaitMask{
                             1574 ; 169  |    struct B{
                             1575 ; 170  |        unsigned int m_bNone     :1;
                             1576 ; 171  |        unsigned int m_bMessage  :1;
                             1577 ; 172  |        unsigned int m_bTimer    :1;
                             1578 ; 173  |        unsigned int m_bButton   :1;
                             1579 ; 174  |    } B;
                             1580 ; 175  |    int I;
                             1581 ; 176  |} ;
                             1582 ; 177  |
                             1583 ; 178  |
                             1584 ; 179  |struct Button {
                             1585 ; 180  |        WORD wButtonEvent;
                             1586 ; 181  |        WORD wUnused[MAX_MSG_LENGTH];   
                             1587 ; 182  |};
                             1588 ; 183  |
                             1589 ; 184  |struct Message {
                             1590 ; 185  |        WORD wMsgLength;
                             1591 ; 186  |        WORD wMsgCommand;
                             1592 ; 187  |        WORD wMsgParms[MAX_MSG_LENGTH-1];
                             1593 ; 188  |};
                             1594 ; 189  |
                             1595 ; 190  |union EventTypes {
                             1596 ; 191  |        struct CMessage msg;
                             1597 ; 192  |        struct Button Button ;
                             1598 ; 193  |        struct Message Message;
                             1599 ; 194  |};
                             1600 ; 195  |
                             1601 ; 196  |// next 2 used to get updater build to return correct protocol ver in scsi response.
                             1602 ; 197  |#define BUILD_TYPE_UPDATER  0x100
                             1603 ; 198  |#define BUILD_TYPE_HOSTLINK 0x101
                             1604 ; 199  |#define BUILD_TYPE_PLAYER   0x102
                             1605 ; 200  |
                             1606 ; 201  |// Resets part if RETAIL build. DEBUG build executes debug instruction to halt.
TASKING DSP2410 assembler v1.5r1 Build 138 SN 00100122
                                                                                                                            Page  27

M:ADDR CODE           CYCLES LINE SOURCELINE
                             1607 ; 202  |#define SystemHalt() __asm(" include 'sysmacro.asm' \n error") 
                             1608 ; 203  |#define assert(x)    if(!(x)) __asm(" include 'sysmacro.asm' \n error")
                             1609 ; 204  |
                             1610 ; 205  |#if DEBUG
                             1611 ; 206  |// For DEBUG builds, DebugBuildAssert(condition) halts if condition evaluates to FALSE. 
                             1612 ; 207  |#define DebugBuildAssert(x)    if(!(x)) __asm(" debug ")
                             1613 ; 208  |#else 
                             1614 ; 209  |// For RETAIL builds, DebugBuildAssert(condition) does nothing & execution continues rathe
                                  r than halt or reset. 
                             1615 ; 210  |#define DebugBuildAssert(x)    
                             1616 ; 211  |#endif
                             1617 ; 212  |
                             1618 ; 213  |// Do this in your C files to make a reminder that's displayed during the build.
                             1619 ; 214  |//  #pragma asm
                             1620 ; 215  |//  WARN 'Note to builder: reminder to do this after verifying that'
                             1621 ; 216  |//  #pragma endasm
                             1622 ; 217  |
                             1623 ; 218  |
                             1624 ; 219  |#ifdef COLOR_262K
                             1625 ; 220  |#define RGB(r,g,b)    ((0x0000FC & (r)) << 10) | ((0x0000FC & (g)) << 4) | ((0x0000FC & (b
                                  )) >> 2)    //262k
                             1626 ; 221  |#elif defined(COLOR_65K)
                             1627 ; 222  |#define RGB(r,g,b)    ((0x0000F8 & (r)) << 8) | ((0x0000FC & (g)) << 3) | ((0x0000F8 & (b)
                                  ) >> 3)  //65k
                             1628 ; 223  |#else
                             1629 ; 224  |#define RGB(r,g,b)       ((0x0000F0 & (r)) << 4) | (0x0000F0 & (g)) | ((0x0000F0 & (b)) >>
                                   4)
                             1630 ; 225  |#endif
                             1631 ; 226  |    
                             1632 ; 227  |#endif // #ifndef _TYPES_H
                             1633 
                             1635 
                             1636 ; 542  |extern volatile WORD g_wActivityState;
                             1637 ; 543  |#endif // if !@def('STMP_BUILD_PLAYER')
                             1638 ; 544  |
                             1639 ; 545  |void _reentrant Init5VSense(void);
                             1640 ; 546  |void _reentrant ServiceDCDC(void);
                             1641 ; 547  |
                             1642 ; 548  |////////////////////////////////////////////////////////////////////////////
                             1643 ; 549  |//// JPEG Thumbnail Mode Setting
                             1644 ; 550  |//// number of column in thumbnail mode
                             1645 ; 551  |#define THUMBNAIL_X 2           
                             1646 ; 552  |//// number of row in  thumbnail mode
                             1647 ; 553  |#define THUMBNAIL_Y 2           
                             1648 ; 554  |//// thumbnail boundary offset x
                             1649 ; 555  |#define THUMBNAIL_X_OFFSET 4            
                             1650 ; 556  |//// thumbnail boundary offset y
                             1651 ; 557  |#define THUMBNAIL_Y_OFFSET 4            
                             1652 ; 558  |
                             1653 ; 559  |#endif // if (!@def(_PROJECT_INC))
                             1654 ; 560  |
                             1655 
                             1657 
                             1658 ; 4    |#include "messages.h"
                             1659 
                             1661 
                             1662 ; 1    |/////////////////////////////////////////////////////////////////////////////////
                             1663 ; 2    |// Copyright(C) SigmaTel, Inc. 2000
                             1664 ; 3    |// Message defs
                             1665 ; 4    |/////////////////////////////////////////////////////////////////////////////////
                             1666 ; 5    |
                             1667 ; 6    |#if (!defined(MESSAGES_INC))
TASKING DSP2410 assembler v1.5r1 Build 138 SN 00100122
                                                                                                                            Page  28

M:ADDR CODE           CYCLES LINE SOURCELINE
                             1668 ; 7    |#define MESSAGES_INC 1
                             1669 ; 8    |
                             1670 ; 9    |#define MSG_TYPE_DECODER 0x000000
                             1671 ; 10   |#define MSG_TYPE_ENCODER 0x010000
                             1672 ; 11   |#define MSG_TYPE_PARSER 0x020000
                             1673 ; 12   |#define MSG_TYPE_LCD 0x030000
                             1674 ; 13   |#define MSG_TYPE_MIXER 0x040000
                             1675 ; 14   |#define MSG_TYPE_SYSTEM 0x050000
                             1676 ; 15   |#define MSG_TYPE_MENU 0x060000
                             1677 ; 16   |#define MSG_TYPE_LED 0x070000
                             1678 ; 17   |#define MSG_TYPE_TUNER 0x080000
                             1679 ; 18   |#define MSG_TYPE_CHARLCD 0x030000
                             1680 ; 19   |#define MSG_TYPE_SOFT_TIMER 0x090000
                             1681 ; 20   |// Equalizer and other effects   
                             1682 ; 21   |#define MSG_TYPE_GEQ 0x0a0000             
                             1683 ; 22   |
                             1684 ; 23   |// Message Structure Offsets
                             1685 ; 24   |#define MSG_Length 0
                             1686 ; 25   |#define MSG_ID 1
                             1687 ; 26   |#define MSG_Argument1 2
                             1688 ; 27   |#define MSG_Argument2 3
                             1689 ; 28   |#define MSG_Argument3 4
                             1690 ; 29   |#define MSG_Argument4 5
                             1691 ; 30   |#define MSG_Argument5 6
                             1692 ; 31   |#define MSG_Argument6 7
                             1693 ; 32   |
                             1694 ; 33   |
                             1695 ; 34   |
                             1696 ; 35   |// LCD Message IDs
                             1697 ; 36   |#define LCD_FIRST_MSG_ID MSG_TYPE_LCD+0
                             1698 ; 37   |#define LCD_CLEAR_RANGE MSG_TYPE_LCD+0
                             1699 ; 38   |#define LCD_PRINT_RANGE_RSRC MSG_TYPE_LCD+1
                             1700 ; 39   |#define LCD_PRINT_RANGE_ADDR MSG_TYPE_LCD+2
                             1701 ; 40   |#define LCD_PRINT_RANGE_INV_RSRC MSG_TYPE_LCD+3
                             1702 ; 41   |#define LCD_PRINT_RANGE_INV_ADDR MSG_TYPE_LCD+4
                             1703 ; 42   |#define LCD_PRINT_STRING_RSRC MSG_TYPE_LCD+5
                             1704 ; 43   |#define LCD_PRINT_STRING_ADDR MSG_TYPE_LCD+6
                             1705 ; 44   |#define LCD_PRINT_STRING_INV_RSRC MSG_TYPE_LCD+7
                             1706 ; 45   |#define LCD_PRINT_STRING_INV_ADDR MSG_TYPE_LCD+8
                             1707 ; 46   |#define LCD_SCROLL_DISPLAY MSG_TYPE_LCD+9
                             1708 ; 47   |#define LCD_READ_LCD_ADDR MSG_TYPE_LCD+10
                             1709 ; 48   |#define LCD_SET_CONTRAST MSG_TYPE_LCD+11
                             1710 ; 49   |#define LCD_INC_CONTRAST MSG_TYPE_LCD+12
                             1711 ; 50   |#define LCD_DEC_CONTRAST MSG_TYPE_LCD+13
                             1712 ; 51   |#define LCD_BACKLIGHT_ON MSG_TYPE_LCD+14
                             1713 ; 52   |#define LCD_BACKLIGHT_OFF MSG_TYPE_LCD+15
                             1714 ; 53   |#define LCD_SET_FONT MSG_TYPE_LCD+16
                             1715 ; 54   |#define LCD_PRINT_NUMBER MSG_TYPE_LCD+17
                             1716 ; 55   |#define LCD_PRINT_TIME MSG_TYPE_LCD+18
                             1717 ; 56   |#define LCD_PRINT_TIME_LONG MSG_TYPE_LCD+19
                             1718 ; 57   |#define LCD_PRINT_STRING_UNICODE_INV_ADDR MSG_TYPE_LCD+20
                             1719 ; 58   |#define LCD_PRINT_STRING_UNICODE_ADDR MSG_TYPE_LCD+21
                             1720 ; 59   |#define LCD_PRINT_STRING_UNICODE_INV_RSRC MSG_TYPE_LCD+22
                             1721 ; 60   |#define LCD_PRINT_STRING_UNICODE_RSRC MSG_TYPE_LCD+23
                             1722 ; 61   |#define LCD_BEGIN_FRAME MSG_TYPE_LCD+24
                             1723 ; 62   |#define LCD_END_FRAME MSG_TYPE_LCD+25
                             1724 ; 63   |#define LCD_PRINT_NUMBER_INV MSG_TYPE_LCD+26
                             1725 ; 64   |#define LCD_PRINT_TIME_INV MSG_TYPE_LCD+27
                             1726 ; 65   |#define LCD_PRINT_TIME_LONG_INV MSG_TYPE_LCD+28
                             1727 ; 66   |#define LCD_SET_FRAMEBUFFER MSG_TYPE_LCD+29
                             1728 ; 67   |//send a NULL as Param1 to return to root frame buffer
                             1729 ; 68   |#define LCD_PUSH_MASK MSG_TYPE_LCD+30
TASKING DSP2410 assembler v1.5r1 Build 138 SN 00100122
                                                                                                                            Page  29

M:ADDR CODE           CYCLES LINE SOURCELINE
                             1730 ; 69   |//Param1 = left
                             1731 ; 70   |//Param2 = top
                             1732 ; 71   |//Param3 = right
                             1733 ; 72   |//Param4 = bottom
                             1734 ; 73   |#define LCD_POP_MASK MSG_TYPE_LCD+31
                             1735 ; 74   |#define LCD_PRINT_UNICODE_CHAR MSG_TYPE_LCD+32
                             1736 ; 75   |#define LCD_PRINT_UNICODE_CHAR_INV MSG_TYPE_LCD+33
                             1737 ; 76   |#define LCD_DISPLAY_HISTOGRAM MSG_TYPE_LCD+34
                             1738 ; 77   |#define LCD_PRINT_TIME_L_1DIG_HR MSG_TYPE_LCD+35
                             1739 ; 78   |
                             1740 ; 79   |#define LCD_CLEAR_RANGE_BUFFER MSG_TYPE_LCD+36
                             1741 ; 80   |#define LCD_PRINT_RANGE_RSRC_BUFFER MSG_TYPE_LCD+37
                             1742 ; 81   |#define LCD_PRINT_RANGE_INV_RSRC_BUFFER MSG_TYPE_LCD+38
                             1743 ; 82   |#define LCD_PRINT_RANGE_ADDR_BUFFER MSG_TYPE_LCD+39
                             1744 ; 83   |#define LCD_PRINT_RANGE_INV_ADDR_BUFFER MSG_TYPE_LCD+40
                             1745 ; 84   |#define LCD_PRINT_STRING_RSRC_BUFFER MSG_TYPE_LCD+41
                             1746 ; 85   |#define LCD_PRINT_STRING_INV_RSRC_BUFFER MSG_TYPE_LCD+42
                             1747 ; 86   |#define LCD_PRINT_STRING_ADDR_BUFFER MSG_TYPE_LCD+43
                             1748 ; 87   |#define LCD_PRINT_STRING_INV_ADDR_BUFFER MSG_TYPE_LCD+44
                             1749 ; 88   |#define LCD_PRINT_NUMBER_BUFFER MSG_TYPE_LCD+45
                             1750 ; 89   |#define LCD_PRINT_NUMBER_INV_BUFFER MSG_TYPE_LCD+46
                             1751 ; 90   |#define LCD_PRINT_TIME_BUFFER MSG_TYPE_LCD+47
                             1752 ; 91   |#define LCD_PRINT_TIME_INV_BUFFER MSG_TYPE_LCD+48
                             1753 ; 92   |#define LCD_PRINT_TIME_LONG_BUFFER MSG_TYPE_LCD+49
                             1754 ; 93   |#define LCD_PRINT_TIME_LONG_INV_BUFFER MSG_TYPE_LCD+50
                             1755 ; 94   |#define LCD_PRINT_STRING_UNICODE_ADDR_BUFFER MSG_TYPE_LCD+51
                             1756 ; 95   |#define LCD_PRINT_STRING_UNICODE_INV_ADDR_BUFFER MSG_TYPE_LCD+52
                             1757 ; 96   |#define LCD_PRINT_STRING_UNICODE_RSRC_BUFFER MSG_TYPE_LCD+53
                             1758 ; 97   |#define LCD_PRINT_STRING_UNICODE_INV_RSRC_BUFFER MSG_TYPE_LCD+54
                             1759 ; 98   |#define LCD_PRINT_UNICODE_CHAR_BUFFER MSG_TYPE_LCD+55
                             1760 ; 99   |#define LCD_PRINT_UNICODE_CHAR_INV_BUFFER MSG_TYPE_LCD+56
                             1761 ; 100  |#define LCD_PRINT_TIME_L_1DIG_HR_BUFFER MSG_TYPE_LCD+57
                             1762 ; 101  |#define LCD_SET_BUFFER_COLOR MSG_TYPE_LCD+58
                             1763 ; 102  |#define LCD_FORCE_BUFFER_UPDATE MSG_TYPE_LCD+59
                             1764 ; 103  |#define LCD_SET_BUFFER_WINDOW MSG_TYPE_LCD+60
                             1765 ; 104  |#define LCD_SET_COLOR MSG_TYPE_LCD+61
                             1766 ; 105  |#define LCD_SET_BUFFER_POSITION MSG_TYPE_LCD+62
                             1767 ; 106  |
                             1768 ; 107  |#define LCD_TEMP_CONTRAST MSG_TYPE_LCD+63
                             1769 ; 108  |
                             1770 ; 109  |#if defined(CLCD_16BIT)
                             1771 ; 110  |#define LCD_16BIT_ON MSG_TYPE_LCD+64
                             1772 ; 111  |#define LCD_16BIT_OFF MSG_TYPE_LCD+65
                             1773 ; 112  |
                             1774 ; 113  |#define LCD_LAST_MSG_ID MSG_TYPE_LCD+65
                             1775 ; 114  |#else 
                             1776 ; 115  |#define LCD_LAST_MSG_ID MSG_TYPE_LCD+63
                             1777 ; 116  |#endif
                             1778 ; 117  |
                             1779 ; 118  |// If you change the LCD message ID's then you must
                             1780 ; 119  |// also change the jump table in lcdapi.asm
                             1781 ; 120  |
                             1782 ; 121  |// Character LCD Message IDs
                             1783 ; 122  |#define CHARLCD_FIRST_MSG_ID MSG_TYPE_CHARLCD+0
                             1784 ; 123  |#define CHARLCD_CLEAR_RANGE MSG_TYPE_CHARLCD+0
                             1785 ; 124  |#define CHARLCD_PRINT_RSRC MSG_TYPE_CHARLCD+1
                             1786 ; 125  |#define CHARLCD_PRINT_INV_RSRC MSG_TYPE_CHARLCD+2
                             1787 ; 126  |#define CHARLCD_PRINT_ASCII_CHAR MSG_TYPE_CHARLCD+3
                             1788 ; 127  |#define CHARLCD_PRINT_ASCII_INV_CHAR MSG_TYPE_CHARLCD+4
                             1789 ; 128  |#define CHARLCD_PRINT_STRING_RSRC MSG_TYPE_CHARLCD+5
                             1790 ; 129  |#define CHARLCD_PRINT_STRING_INV_RSRC MSG_TYPE_CHARLCD+6
                             1791 ; 130  |#define CHARLCD_PRINT_STRING_ADDR MSG_TYPE_CHARLCD+7
TASKING DSP2410 assembler v1.5r1 Build 138 SN 00100122
                                                                                                                            Page  30

M:ADDR CODE           CYCLES LINE SOURCELINE
                             1792 ; 131  |#define CHARLCD_PRINT_STRING_INV_ADDR MSG_TYPE_CHARLCD+8
                             1793 ; 132  |#define CHARLCD_SCROLL_DISPLAY MSG_TYPE_CHARLCD+9
                             1794 ; 133  |#define CHARLCD_READ_LCD_ADDR MSG_TYPE_CHARLCD+10
                             1795 ; 134  |#define CHARLCD_SET_CURSOR MSG_TYPE_CHARLCD+11
                             1796 ; 135  |#define CHARLCD_SET_FONT MSG_TYPE_CHARLCD+12
                             1797 ; 136  |#define CHARLCD_PRINT_NUMBER MSG_TYPE_CHARLCD+13
                             1798 ; 137  |#define CHARLCD_PRINT_TIME MSG_TYPE_CHARLCD+14
                             1799 ; 138  |#define CHARLCD_SET_BATTERY MSG_TYPE_CHARLCD+15
                             1800 ; 139  |#define CHARLCD_SET_EQ MSG_TYPE_CHARLCD+16
                             1801 ; 140  |#define CHARLCD_SET_ICON MSG_TYPE_CHARLCD+17
                             1802 ; 141  |#define CHARLCD_SET_PLAYMODE MSG_TYPE_CHARLCD+18
                             1803 ; 142  |#define CHARLCD_SET_PLAYSTATE MSG_TYPE_CHARLCD+19
                             1804 ; 143  |#define CHARLCD_SET_VOLUME MSG_TYPE_CHARLCD+20
                             1805 ; 144  |#define CHARLCD_CLEAR_DISPLAY MSG_TYPE_CHARLCD+21
                             1806 ; 145  |#define CHARLCD_LAST_MSG_ID MSG_TYPE_CHARLCD+21
                             1807 ; 146  |// If you change the cHARACTER LCD message ID's then you must
                             1808 ; 147  |// also change the jump table in lcdapi.asm
                             1809 ; 148  |
                             1810 ; 149  |// Decoder Message IDs
                             1811 ; 150  |#define DECODER_FIRST_MSG_ID MSG_TYPE_DECODER+0
                             1812 ; 151  |#define DECODER_RESET MSG_TYPE_DECODER+0
                             1813 ; 152  |#define DECODER_SET_DIR MSG_TYPE_DECODER+1
                             1814 ; 153  |#define DECODER_PLAY MSG_TYPE_DECODER+2
                             1815 ; 154  |#define DECODER_STOP MSG_TYPE_DECODER+3
                             1816 ; 155  |#define DECODER_FFWD MSG_TYPE_DECODER+4
                             1817 ; 156  |#define DECODER_RWND MSG_TYPE_DECODER+5
                             1818 ; 157  |#define DECODER_NEXT_SONG MSG_TYPE_DECODER+6
                             1819 ; 158  |#define DECODER_PREV_SONG MSG_TYPE_DECODER+7
                             1820 ; 159  |#define DECODER_TIME_MODE MSG_TYPE_DECODER+8
                             1821 ; 160  |#define DECODER_AB_MODE MSG_TYPE_DECODER+9
                             1822 ; 161  |#define DECODER_SET_EQ MSG_TYPE_DECODER+10
                             1823 ; 162  |#define DECODER_GET_SONG_INFO MSG_TYPE_DECODER+11
                             1824 ; 163  |#define DECODER_LAST_MSG_ID MSG_TYPE_DECODER+11
                             1825 ; 164  |// If you change the Decoder message ID's, then you must
                             1826 ; 165  |// also change the jump table in decoder_overlay.asm
                             1827 ; 166  |// and in dec_adpcm_overlay.asm.
                             1828 ; 167  |
                             1829 ; 168  |// Encoder Message IDs
                             1830 ; 169  |#define ENCODER_FIRST_MSG_ID MSG_TYPE_ENCODER+0
                             1831 ; 170  |#define ENCODER_RECORD MSG_TYPE_ENCODER+0
                             1832 ; 171  |#define ENCODER_STOP MSG_TYPE_ENCODER+1
                             1833 ; 172  |#define ENCODER_TIME_MODE MSG_TYPE_ENCODER+2
                             1834 ; 173  |#define ENCODER_LAST_MSG_ID MSG_TYPE_ENCODER+3
                             1835 ; 174  |// If you change the Encoder message ID's, then you must
                             1836 ; 175  |// also change the jump table in all encoder overlay modules.
                             1837 ; 176  |
                             1838 ; 177  |// Parser Message IDs
                             1839 ; 178  |#define PARSER_FIRST_MSG_ID MSG_TYPE_PARSER+0
                             1840 ; 179  |#define PARSER_NEXT_SONG MSG_TYPE_PARSER+0
                             1841 ; 180  |#define PARSER_PREV_SONG MSG_TYPE_PARSER+1
                             1842 ; 181  |#define PARSER_REPEAT MSG_TYPE_PARSER+2
                             1843 ; 182  |#define PARSER_RANDOM MSG_TYPE_PARSER+3
                             1844 ; 183  |#define PARSER_STOP MSG_TYPE_PARSER+4
                             1845 ; 184  |#define PARSER_DEVICE_ENUMERATE MSG_TYPE_PARSER+5
                             1846 ; 185  |#define PARSER_SET_CURRENT_SONG MSG_TYPE_PARSER+6
                             1847 ; 186  |#define PARSER_LAST_MSG_ID MSG_TYPE_PARSER+6
                             1848 ; 187  |// If you change the Parser message ID's, then you must
                             1849 ; 188  |// also change the jump table in parser.asm
                             1850 ; 189  |
                             1851 ; 190  |// Button Message IDs
                             1852 ; 191  |//BUTTON_FIRST_MSG_ID      equ     MSG_TYPE_BUTTON+0
                             1853 ; 192  |//BUTTON_BUTTONS_ON        equ     MSG_TYPE_BUTTON+0
TASKING DSP2410 assembler v1.5r1 Build 138 SN 00100122
                                                                                                                            Page  31

M:ADDR CODE           CYCLES LINE SOURCELINE
                             1854 ; 193  |//BUTTON_BUTTONS_OFF       equ     MSG_TYPE_BUTTON+1
                             1855 ; 194  |//BUTTON_HOLD              equ     MSG_TYPE_BUTTON+2
                             1856 ; 195  |//BUTTON_HOLD_RELEASE      equ     MSG_TYPE_BUTTON+3
                             1857 ; 196  |//BUTTON_LAST_MSG_ID       equ     MSG_TYPE_BUTTON+3
                             1858 ; 197  |
                             1859 ; 198  |// Mixer Message IDs
                             1860 ; 199  |#define MIXER_FIRST_MSG_ID MSG_TYPE_MIXER+0
                             1861 ; 200  |#define MIXER_MASTER_INCR MSG_TYPE_MIXER+0
                             1862 ; 201  |#define MIXER_MASTER_DECR MSG_TYPE_MIXER+1
                             1863 ; 202  |#define MIXER_MASTER_SETLVL MSG_TYPE_MIXER+2
                             1864 ; 203  |#define MIXER_MASTER_MUTE MSG_TYPE_MIXER+3
                             1865 ; 204  |#define MIXER_MASTER_UNMUTE MSG_TYPE_MIXER+4
                             1866 ; 205  |#define MIXER_MASTER_FADE_OUT MSG_TYPE_MIXER+5
                             1867 ; 206  |#define MIXER_MASTER_FADE_IN MSG_TYPE_MIXER+6
                             1868 ; 207  |#define MIXER_MASTER_BAL_RIGHT MSG_TYPE_MIXER+7
                             1869 ; 208  |#define MIXER_MASTER_BAL_LEFT MSG_TYPE_MIXER+8
                             1870 ; 209  |#define MIXER_MIC_INCR MSG_TYPE_MIXER+9
                             1871 ; 210  |#define MIXER_MIC_DECR MSG_TYPE_MIXER+10
                             1872 ; 211  |#define MIXER_MIC_SETLVL MSG_TYPE_MIXER+11
                             1873 ; 212  |#define MIXER_MIC_MUTE MSG_TYPE_MIXER+12
                             1874 ; 213  |#define MIXER_MIC_UNMUTE MSG_TYPE_MIXER+13
                             1875 ; 214  |#define MIXER_MIC_BOOST MSG_TYPE_MIXER+14
                             1876 ; 215  |#define MIXER_MIC_UNBOOST MSG_TYPE_MIXER+15
                             1877 ; 216  |#define MIXER_LINE_INCR MSG_TYPE_MIXER+16
                             1878 ; 217  |#define MIXER_LINE_DECR MSG_TYPE_MIXER+17
                             1879 ; 218  |#define MIXER_LINE_SETLVL MSG_TYPE_MIXER+18
                             1880 ; 219  |#define MIXER_LINE_MUTE MSG_TYPE_MIXER+19
                             1881 ; 220  |#define MIXER_LINE_UNMUTE MSG_TYPE_MIXER+20
                             1882 ; 221  |#define MIXER_FM_INCR MSG_TYPE_MIXER+21
                             1883 ; 222  |#define MIXER_FM_DECR MSG_TYPE_MIXER+22
                             1884 ; 223  |#define MIXER_FM_SETLVL MSG_TYPE_MIXER+23
                             1885 ; 224  |#define MIXER_FM_MUTE MSG_TYPE_MIXER+24
                             1886 ; 225  |#define MIXER_FM_UNMUTE MSG_TYPE_MIXER+25
                             1887 ; 226  |#define MIXER_DAC_INCR MSG_TYPE_MIXER+26
                             1888 ; 227  |#define MIXER_DAC_DECR MSG_TYPE_MIXER+27
                             1889 ; 228  |#define MIXER_DAC_SETLVL MSG_TYPE_MIXER+28
                             1890 ; 229  |#define MIXER_DAC_MUTE MSG_TYPE_MIXER+29
                             1891 ; 230  |#define MIXER_DAC_UNMUTE MSG_TYPE_MIXER+30
                             1892 ; 231  |#define MIXER_ADC_SELECT MSG_TYPE_MIXER+31
                             1893 ; 232  |#define MIXER_ADC_INCR MSG_TYPE_MIXER+32
                             1894 ; 233  |#define MIXER_ADC_DECR MSG_TYPE_MIXER+33
                             1895 ; 234  |#define MIXER_ADC_SETLVL MSG_TYPE_MIXER+34
                             1896 ; 235  |#define MIXER_ADC_MUTE MSG_TYPE_MIXER+35
                             1897 ; 236  |#define MIXER_ADC_UNMUTE MSG_TYPE_MIXER+36
                             1898 ; 237  |#define MIXER_REC_SELECT MSG_TYPE_MIXER+37
                             1899 ; 238  |#define MIXER_POWER_DOWN MSG_TYPE_MIXER+38
                             1900 ; 239  |#define MIXER_LAST_MSG_ID MSG_TYPE_MIXER+38
                             1901 ; 240  |// If you change the mixer message ID's then you must
                             1902 ; 241  |// also change the jump table in mixer.asm
                             1903 ; 242  |#define MIXER_ON 0
                             1904 ; 243  |#define MIXER_OFF 1
                             1905 ; 244  |
                             1906 ; 245  |
                             1907 ; 246  |// System Message IDs
                             1908 ; 247  |#define SYSTEM_FIRST_MSG_ID MSG_TYPE_SYSTEM+0
                             1909 ; 248  |#define SYSTEM_SHUTDOWN MSG_TYPE_SYSTEM+0
                             1910 ; 249  |#define SYSTEM_SHUTDOWN_FALSE MSG_TYPE_SYSTEM+1
                             1911 ; 250  |#define SYSTEM_SHUTDOWN_FINAL MSG_TYPE_SYSTEM+2
                             1912 ; 251  |#define SYSTEM_LAST_MSG_ID MSG_TYPE_SYSTEM+2
                             1913 ; 252  |// If you change the system message ID's then you must
                             1914 ; 253  |// also change the jump table in systemapi.asm
                             1915 ; 254  |
TASKING DSP2410 assembler v1.5r1 Build 138 SN 00100122
                                                                                                                            Page  32

M:ADDR CODE           CYCLES LINE SOURCELINE
                             1916 ; 255  |// Menu IDs
                             1917 ; 256  |#define MENU_FIRST_MSG_ID MSG_TYPE_MENU+0
                             1918 ; 257  |#define MENU_BUTTON_EVENT MSG_TYPE_MENU+0
                             1919 ; 258  |#define MENU_DECODER_STATE_CHNG MSG_TYPE_MENU+1
                             1920 ; 259  |#define MENU_RECORDER_STATE_CHNG MSG_TYPE_MENU+2
                             1921 ; 260  |//sub parameters for this message:
                             1922 ; 261  |#define RECORDER_START 0
                             1923 ; 262  |#define RECORDER_STOP_NORMAL 0x8000
                             1924 ; 263  |#define RECORDER_STOP_FILE_ERROR 0x8001
                             1925 ; 264  |#define RECORDER_STOP_OUT_OF_SPACE 0x8002
                             1926 ; 265  |#define RECORDER_STOP_LOW_BATTERY 0x8003    
                             1927 ; 266  |#define MENU_SONG_TIME_CHNG MSG_TYPE_MENU+3
                             1928 ; 267  |#define MENU_AB_MODE_OFF MSG_TYPE_MENU+4
                             1929 ; 268  |#define MENU_BATTERY_CHNG MSG_TYPE_MENU+5
                             1930 ; 269  |#define MENU_SCROLL_TITLE MSG_TYPE_MENU+6
                             1931 ; 270  |#define MENU_AUTO_SHUTDOWN MSG_TYPE_MENU+7
                             1932 ; 271  |#define MENU_MSG_MEDIA_CHANGED MSG_TYPE_MENU+8
                             1933 ; 272  |#if (!defined(REMOVE_FM))    
                             1934 ; 273  |#define MENU_TUNER_TUNED MSG_TYPE_MENU+9
                             1935 ; 274  |#define MENU_MSG_ENC_LOW_SPACE MSG_TYPE_MENU+10
                             1936 ; 275  |#define MENU_MSG_EQ_SETTINGS MSG_TYPE_MENU+11
                             1937 ; 276  |#define MENU_LAST_MSG_ID MSG_TYPE_MENU+11
                             1938 ; 277  |#else 
                             1939 ; 278  |#define MENU_MSG_ENC_LOW_SPACE MSG_TYPE_MENU+9
                             1940 ; 279  |#define MENU_MSG_EQ_SETTINGS MSG_TYPE_MENU+10
                             1941 ; 280  |#define MENU_LAST_MSG_ID MSG_TYPE_MENU+10
                             1942 ; 281  |#endif
                             1943 ; 282  |
                             1944 ; 283  |// Note that other versions of this file have different msg equates.
                             1945 ; 284  |// If you change the system message ID's then you must
                             1946 ; 285  |// also change the jump table in all menu *.asm
                             1947 ; 286  |
                             1948 ; 287  |// LED Message IDs
                             1949 ; 288  |#define LED_FIRST_MSG_ID MSG_TYPE_LED+0
                             1950 ; 289  |#define LED_CONTROL MSG_TYPE_LED+0
                             1951 ; 290  |#define LED_RESET MSG_TYPE_LED+1
                             1952 ; 291  |#define LED_LAST_MSG_ID MSG_TYPE_LED+1
                             1953 ; 292  |// If you change the LeD message ID's then you must
                             1954 ; 293  |// also change the jump table in ledapi.asm
                             1955 ; 294  |
                             1956 ; 295  |#if (!defined(REMOVE_FM))    
                             1957 ; 296  |// FM Tuner Message IDs
                             1958 ; 297  |#define TUNER_FIRST_MSG_ID MSG_TYPE_TUNER+0
                             1959 ; 298  |#define TUNER_TUNE_FREQUENCY MSG_TYPE_TUNER+0
                             1960 ; 299  |#define TUNER_TUNE_MANUAL_UP MSG_TYPE_TUNER+1
                             1961 ; 300  |#define TUNER_TUNE_MANUAL_DOWN MSG_TYPE_TUNER+2
                             1962 ; 301  |#define TUNER_TUNE_SEARCH_UP MSG_TYPE_TUNER+3
                             1963 ; 302  |#define TUNER_TUNE_SEARCH_DOWN MSG_TYPE_TUNER+4
                             1964 ; 303  |#define TUNER_FORCED_MONO MSG_TYPE_TUNER+5
                             1965 ; 304  |#define TUNER_RESET MSG_TYPE_TUNER+6
                             1966 ; 305  |#define TUNER_POWER_ON MSG_TYPE_TUNER+7
                             1967 ; 306  |#define TUNER_POWER_OFF MSG_TYPE_TUNER+8
                             1968 ; 307  |#define TUNER_SET_SENSITIVITY MSG_TYPE_TUNER+9
                             1969 ; 308  |//one parameter--the sensitivity in uV
                             1970 ; 309  |#define TUNER_GET_STATES MSG_TYPE_TUNER+10
                             1971 ; 310  |#define TUNER_MUTE_OUTPUTS MSG_TYPE_TUNER+11
                             1972 ; 311  |#define TUNER_PRESET_STATION MSG_TYPE_TUNER+12
                             1973 ; 312  |#define TUNER_TUNE_TO_PRESET MSG_TYPE_TUNER+13
                             1974 ; 313  |#define TUNER_SET_PRESET MSG_TYPE_TUNER+14
                             1975 ; 314  |#define TUNER_ERASE_PRESET MSG_TYPE_TUNER+15
                             1976 ; 315  |#define TUNER_LAST_MSG_ID MSG_TYPE_TUNER+15
                             1977 ; 316  |#endif
TASKING DSP2410 assembler v1.5r1 Build 138 SN 00100122
                                                                                                                            Page  33

M:ADDR CODE           CYCLES LINE SOURCELINE
                             1978 ; 317  |
                             1979 ; 318  |#define SOFT_TIMER_FIRST_MSG_ID MSG_TYPE_SOFT_TIMER+0
                             1980 ; 319  |#define SOFT_TIMER_SET_TIMER MSG_TYPE_SOFT_TIMER+1
                             1981 ; 320  |#define SOFT_TIMER_KILL_TIMER MSG_TYPE_SOFT_TIMER+2
                             1982 ; 321  |#define SOFT_TIMER_LAST_MSG_ID MSG_TYPE_SOFT_TIMER+2
                             1983 ; 322  |
                             1984 ; 323  |
                             1985 ; 324  |#define GEQ_FIRST_MSG_ID MSG_TYPE_GEQ+0
                             1986 ; 325  |#define GEQ_SET_EQ MSG_TYPE_GEQ+0
                             1987 ; 326  |#define GEQ_SET_EQ_LEGACY MSG_TYPE_GEQ+1
                             1988 ; 327  |#define GEQ_SET_ALL_BAND_GAINS MSG_TYPE_GEQ+2
                             1989 ; 328  |#define GEQ_SET_GAIN MSG_TYPE_GEQ+3
                             1990 ; 329  |#define GEQ_SET_COEFFICIENTS MSG_TYPE_GEQ+4
                             1991 ; 330  |#define GEQ_SET_PARAM MSG_TYPE_GEQ+5
                             1992 ; 331  |#define GEQ_GET_SETTINGS MSG_TYPE_GEQ+6
                             1993 ; 332  |#define GEQ_LAST_MSG_ID MSG_TYPE_GEQ+6
                             1994 ; 333  |
                             1995 ; 334  |#endif // IF (!@def(MSGEQU_INC))
                             1996 ; 335  |
                             1997 ; 336  |
                             1998 
                             2000 
                             2001 ; 5    |#include "usbmsc.h"
                             2002 
                             2004 
                             2005 ; 1    |////////////////////////////////////////////////////////////////////////////////
                             2006 ; 2    |// Copyright(C) SigmaTel, Inc. 2000-2001
                             2007 ; 3    |//
                             2008 ; 4    |// Filename: usbmsc.h
                             2009 ; 5    |// Description: 
                             2010 ; 6    |////////////////////////////////////////////////////////////////////////////////
                             2011 ; 7    |
                             2012 ; 8    |#ifndef _USBMSC_H
                             2013 ; 9    |#define _USBMSC_H
                             2014 ; 10   |
                             2015 ; 11   |////////////////////////////////////////////////////////////////////////////////
                             2016 ; 12   |// Includes
                             2017 ; 13   |////////////////////////////////////////////////////////////////////////////////
                             2018 ; 14   |
                             2019 ; 15   |#include "kernel.h"
                             2020 
                             2022 
                             2023 ; 1    |///////////////////////////////////////////////////////////////////////////////
                             2024 ; 2    |///
                             2025 ; 3    |/// Filename: kernel.h
                             2026 ; 4    |/// Description: 
                             2027 ; 5    |///
                             2028 ; 6    |///
                             2029 ; 7    |/// Copyright (c) SigmaTel, Inc. Unpublished
                             2030 ; 8    |///
                             2031 ; 9    |/// SigmaTel, Inc.
                             2032 ; 10   |/// Proprietary  Confidential
                             2033 ; 11   |///
                             2034 ; 12   |/// This source code and the algorithms implemented therein constitute
                             2035 ; 13   |/// confidential information and may comprise trade secrets of SigmaTel, Inc.
                             2036 ; 14   |/// or its associates, and any use thereof is subject to the terms and
                             2037 ; 15   |/// conditions of the Confidential Disclosure Agreement pursuant to which this
                             2038 ; 16   |/// source code was originally received.
                             2039 ; 17   |///
                             2040 ; 18   |///////////////////////////////////////////////////////////////////////////////
                             2041 ; 19   |#ifndef __KERNEL_H
                             2042 ; 20   |#define __KERNEL_H
TASKING DSP2410 assembler v1.5r1 Build 138 SN 00100122
                                                                                                                            Page  34

M:ADDR CODE           CYCLES LINE SOURCELINE
                             2043 ; 21   |
                             2044 ; 22   |
                             2045 ; 23   |#include "types.h"
                             2046 ; 24   |#include "gettime.h"
                             2047 ; 25   |#include "sysirq.h"
                             2048 ; 26   |#include "icoll.h"
                             2049 ; 27   |
                             2050 ; 28   |#ifndef SYS_MAX_MSG_PARAMS
                             2051 ; 29   |#define SYS_MAX_MSG_PARAMS 10
                             2052 ; 30   |#endif
                             2053 ; 31   |
                             2054 ; 32   |#ifndef MAX_REGIONS
                             2055 ; 33   |#define MAX_REGIONS 5
                             2056 ; 34   |#endif 
                             2057 ; 35   |
                             2058 ; 36   |#define TIMEOUT_IMMEDIATE 0
                             2059 ; 37   |
                             2060 ; 38   |struct TaskEntryStruct;
                             2061 ; 39   |
                             2062 ; 40   |union SyncObjectStruct;
                             2063 ; 41   |
                             2064 ; 42   |
                             2065 ; 43   |// JCP - Already defined in types.h
                             2066 ; 44   |
                             2067 ; 45   |//typedef struct {
                             2068 ; 46   |//    WORD m_wLength;
                             2069 ; 47   |//    WORD m_wMessage;
                             2070 ; 48   |//    WORD m_wParams[SYS_MAX_MSG_PARAMS];
                             2071 ; 49   |//} Message;
                             2072 ; 50   |
                             2073 ; 51   |typedef struct {
                             2074 ; 52   |    _circ WORD    *m_pHead;
                             2075 ; 53   |    _circ WORD    *m_pTail;
                             2076 ; 54   |} CircularBufferDescriptor;
                             2077 ; 55   |
                             2078 ; 56   |typedef struct MemoryRegionStruct {
                             2079 ; 57   |    WORD m_wResourceLoaded;
                             2080 ; 58   |    _P INT *m_StartAddress;
                             2081 ; 59   |    _P INT *m_EndAddress;
                             2082 ; 60   |} MemoryRegion;
                             2083 ; 61   |
                             2084 ; 62   |
                             2085 ; 63   |typedef struct TaskEntryStruct{
                             2086 ; 64   |    CircularBufferDescriptor *m_pMessageQueue;
                             2087 ; 65   |    void   *m_pWaitingOnPtr;                                //points to either an object o
                                  r a queue we're waiting on.
                             2088 ; 66   |    WORD    m_wWaitingOnWord;
                             2089 ; 67   |    WORD    m_wState;                                       //The state is used to indicat
                                  e what the task is waiting on.
                             2090 ; 68   |    WORD   *m_pStackPointer;
                             2091 ; 69   |    WORD    m_wTaskID;                                      //The kernel does not use this
                                   for any purpose.   This is set by the developer
                             2092 ; 70   |                                                            //  and returned by SysGetTask
                                  ID() for use by functions that are required to 
                             2093 ; 71   |                                                            //  be task aware.
                             2094 ; 72   |    long    m_lTimeout;                                     //This is in absolute time (ca
                                  n compare directly to the current system time
                             2095 ; 73   |    WORD    m_wRegionResources[MAX_REGIONS];                //a snapshot of the requiremen
                                  ts of the task in terms of which resources are loaded
                             2096 ; 74   |    WORD    m_wPriority;                                    
                             2097 ; 75   |    WORD   *m_pInitialStackPointer;                         //only used at init time
                             2098 ; 76   |    WORD    m_wStackSize;
TASKING DSP2410 assembler v1.5r1 Build 138 SN 00100122
                                                                                                                            Page  35

M:ADDR CODE           CYCLES LINE SOURCELINE
                             2099 ; 77   |    _reentrant void   (*m_pEntryPoint)(void);               //only used at init time
                             2100 ; 78   |} TaskEntry;
                             2101 ; 79   |
                             2102 ; 80   |typedef union SyncObjectStruct {
                             2103 ; 81   |    TaskEntry   *m_pOwner;
                             2104 ; 82   |    struct
                             2105 ; 83   |    {
                             2106 ; 84   |    int          m_iOwner :16;
                             2107 ; 85   |    int          m_iCount : 8;
                             2108 ; 86   |    } counter;
                             2109 ; 87   |} SyncObject;
                             2110 ; 88   |
                             2111 ; 89   |typedef WORD SignalGroup;
                             2112 ; 90   |
                             2113 ; 91   |
                             2114 ; 92   |typedef struct {
                             2115 ; 93   |    WORD    m_wMessageType;
                             2116 ; 94   |    CircularBufferDescriptor    *m_pDestination;
                             2117 ; 95   |}  RoutingEntry;
                             2118 ; 96   |
                             2119 ; 97   |extern RoutingEntry g_RoutingTable[];
                             2120 ; 98   |extern TaskEntry *g_TaskList[];
                             2121 ; 99   |extern MemoryRegion *g_RegionTable[];
                             2122 ; 100  |
                             2123 ; 101  |//Time Releated Functions
                             2124 ; 102  |_reentrant WORD SysWait(INT wTimeout);
                             2125 ; 103  |
                             2126 ; 104  |//Task Related Functions
                             2127 ; 105  |_reentrant WORD SysGetTaskID(void);
                             2128 ; 106  |
                             2129 ; 107  |//Message related functions
                             2130 ; 108  |_asmfunc WORD SysWaitOnMessage(INT wTimeout, Message *pMsg);
                             2131 ; 109  |_asmfunc WORD SysPeekMessage(CircularBufferDescriptor *pQueue, Message *pMsg);
                             2132 ; 110  |_reentrant WORD SysPostMessage(WORD wLength, ...);
                             2133 ; 111  |_reentrant WORD SysPostMessageWait(INT wTimeout, WORD wLength, ...);
                             2134 ; 112  |
                             2135 ; 113  |//maybe this is too much functionality?
                             2136 ; 114  |_asmfunc WORD SysWaitOnBoth(WORD wTimeout, SyncObject *pObject, Message *pMsg);
                             2137 ; 115  |
                             2138 ; 116  |//SyncObject Related functions
                             2139 ; 117  |_asmfunc WORD SysWaitOnObject(INT wTimeout, SyncObject *pObject);
                             2140 ; 118  |_asmfunc WORD SysAssignObject(SyncObject *pObject, TaskEntry *pTaskID);
                             2141 ; 119  |_reentrant void SysReleaseObject(SyncObject *pObject);
                             2142 ; 120  |_reentrant void ISRReleaseObject(SyncObject *pObject);
                             2143 ; 121  |
                             2144 ; 122  |//Queue Related Functions
                             2145 ; 123  |_asmfunc WORD SysWaitOnQueue(INT wTimeout,CircularBufferDescriptor *pQueue, INT wSizeToBeF
                                  ree);
                             2146 ; 124  |
                             2147 ; 125  |//Event Related Functions
                             2148 ; 126  |_asmfunc WORD SysWaitOnSignal(INT wTimeout, void * pSignalGroup, int iSignal);
                             2149 ; 127  |_asmfunc void SysSignal(SignalGroup *pSignalGroup, int iSignal);
                             2150 ; 128  |
                             2151 ; 129  |//ISR function
                             2152 ; 130  |
                             2153 ; 131  |//SysCallFunctions
                             2154 ; 132  |int _asmfunc exSysCallFunction_v(void);
                             2155 ; 133  |int _asmfunc exSysCallFunction_i(int);
                             2156 ; 134  |int _asmfunc exSysCallFunction_ii(int, int);
                             2157 ; 135  |int _asmfunc exSysCallFunction_iii(int, int, int);
                             2158 ; 136  |int _asmfunc SysCallFunction(WORD * RESOURCE,int _reentrant (int,int,int*),  int, int, int
                                   *);
TASKING DSP2410 assembler v1.5r1 Build 138 SN 00100122
                                                                                                                            Page  36

M:ADDR CODE           CYCLES LINE SOURCELINE
                             2159 ; 137  |#define SysCallFunction(rsrc,func,a,b,p) SysCallFunction((void*)rsrc,(func),(a),(b),(p))
                             2160 ; 138  |
                             2161 ; 139  |void _asmfunc v_SysCallFunction_v(WORD * RESOURCE,void _reentrant (void));
                             2162 ; 140  |#define v_SysCallFunction_v(rsrc,func) v_SysCallFunction_v((void*)rsrc,(func))
                             2163 ; 141  |
                             2164 ; 142  |void _asmfunc SysCallFunction_i(WORD * RESOURCE,void _reentrant (int),int);
                             2165 ; 143  |#define SysCallFunction_i(rsrc,func,a,b,p) SysCallFunction_i((void*)rsrc,(func),(a),(b),(p
                                  ))
                             2166 ; 144  |
                             2167 ; 145  |int _asmfunc SysCallFunction_L(void* RESOURCE,int _reentrant (long,long,int*),  long, long
                                  , int *);
                             2168 ; 146  |
                             2169 ; 147  |int _asmfunc i_SysCallFunction_i(WORD * RESOURCE,int _reentrant (int), int);
                             2170 ; 148  |
                             2171 ; 149  |int _asmfunc i_SysCallFunction_iipp(WORD * RESOURCE,int _reentrant (int,int,int*,int*),  i
                                  nt, int, int *, int *);
                             2172 ; 150  |
                             2173 ; 151  |int _asmfunc i_SysCallFunction_iiip(WORD * RESOURCE,int _reentrant (int,int,int,int*),  in
                                  t, int, int, int *);
                             2174 ; 152  |
                             2175 ; 153  |int _asmfunc fSysCallFunction(WORD * RESOURCE,int _reentrant (int,int,int*),  int, int, in
                                  t *);
                             2176 ; 154  |
                             2177 ; 155  |
                             2178 ; 156  |//These values are return values, and also values that are set in the TaskEntry.m_wState t
                                  o indicate what the task
                             2179 ; 157  |//is waiting on.
                             2180 ; 158  |#define EVENT_TIMEOUT   0
                             2181 ; 159  |#define EVENT_MESSAGE   1
                             2182 ; 160  |#define EVENT_OBJECT    2
                             2183 ; 161  |#define EVENT_QUEUE     4
                             2184 ; 162  |#define EVENT_SIGNAL    5
                             2185 ; 163  |#define EVENT_RELEASING_OBJECT2 6
                             2186 ; 164  |#define EVENT_RELEASING_OBJECT1 7
                             2187 ; 165  |
                             2188 ; 166  |
                             2189 ; 167  |//this is the owner that a SyncObject should be assigned to if a task it going to wait on 
                                  a completion of the interrupt. 
                             2190 ; 168  |#define ISR_OWNER  ((TaskEntry*)(0xffff))
                             2191 ; 169  |#define KERNEL_OWNER  ((TaskEntry*)(0))
                             2192 ; 170  |
                             2193 ; 171  |
                             2194 ; 172  |#ifdef INSTRUMENT_ENABLE
                             2195 ; 173  |#include <regsgpio.h>
                             2196 ; 174  |
                             2197 ; 175  |//
                             2198 ; 176  |// Define the bit positions in the GPIO registers used for signalling.
                             2199 ; 177  |//
                             2200 ; 178  |#define GPIO_24     B0
                             2201 ; 179  |#define GPIO_36     B12
                             2202 ; 180  |#define GPIO_37     B13
                             2203 ; 181  |#define GPIO_38     B14
                             2204 ; 182  |#define GPIO_39     B15
                             2205 ; 183  |#define GPIO_42     B18
                             2206 ; 184  |#define GPIO_46     B22
                             2207 ; 185  |#define GPIO_47     B23
                             2208 ; 186  |
                             2209 ; 187  |//=============================================================================
                             2210 ; 188  |// SysSignalEvent
                             2211 ; 189  |//-----------------------------------------------------------------------------
                             2212 ; 190  |//! This macro allows code to set a gpio event that can be measured outside the
                             2213 ; 191  |//! part.
TASKING DSP2410 assembler v1.5r1 Build 138 SN 00100122
                                                                                                                            Page  37

M:ADDR CODE           CYCLES LINE SOURCELINE
                             2214 ; 192  |//! \param wGPIONumber 
                             2215 ; 193  |//!     This should be one of the Macros defined above, and indicates which 
                             2216 ; 194  |//!     GPIO will be set.
                             2217 ; 195  |//!
                             2218 ; 196  |//! \return
                             2219 ; 197  |//!     None. 
                             2220 ; 198  |//!
                             2221 ; 199  |//=============================================================================
                             2222 ; 200  |#define SysSignalEvent(wGPIONumber)         \ 
                             2223 ; 201  |{                                           \ 
                             2224 ; 202  |    HW_GP1DOR.B.##wGPIONumber = 1;          \ 
                             2225 ; 203  |}
                             2226 ; 204  |
                             2227 ; 205  |//=============================================================================
                             2228 ; 206  |// SysClearEvent
                             2229 ; 207  |//-----------------------------------------------------------------------------
                             2230 ; 208  |//! This macro allows code to clear a gpio event that can be measured outside 
                             2231 ; 209  |//! the part.
                             2232 ; 210  |//! \param wGPIONumber 
                             2233 ; 211  |//!     This should be one of the Macros defined above, and indicates which 
                             2234 ; 212  |//!     GPIO will be set.
                             2235 ; 213  |//!
                             2236 ; 214  |//! \return
                             2237 ; 215  |//!     None. 
                             2238 ; 216  |//!
                             2239 ; 217  |//=============================================================================
                             2240 ; 218  |#define SysClearEvent(wGPIONumber)          \ 
                             2241 ; 219  |{                                           \ 
                             2242 ; 220  |    HW_GP1DOR.B.##wGPIONumber = 0;          \ 
                             2243 ; 221  |}
                             2244 ; 222  |
                             2245 ; 223  |//=============================================================================
                             2246 ; 224  |// SysEnableEvent
                             2247 ; 225  |//-----------------------------------------------------------------------------
                             2248 ; 226  |//! This macro must be called by code before using the SysSetEvent or 
                             2249 ; 227  |//! SysClearEvent so that the GPIOs are set up correctly.
                             2250 ; 228  |//!
                             2251 ; 229  |//! \param wGPIONumber 
                             2252 ; 230  |//!     This should be one of the Macros defined above, and indicates which 
                             2253 ; 231  |//!     GPIO will be set.
                             2254 ; 232  |//!
                             2255 ; 233  |//! \return
                             2256 ; 234  |//!     None. 
                             2257 ; 235  |//!
                             2258 ; 236  |//=============================================================================
                             2259 ; 237  |#define SysEnableEvent(wGPIONumber)         \ 
                             2260 ; 238  |{                                           \ 
                             2261 ; 239  |    HW_GP1DOER.B.##wGPIONumber=1;           \ 
                             2262 ; 240  |    HW_GP1DOR.B.##wGPIONumber=0;            \ 
                             2263 ; 241  |    HW_GP1ENR.B.##wGPIONumber=1;            \ 
                             2264 ; 242  |    HW_GP1PWR.B.##wGPIONumber=1;            \ 
                             2265 ; 243  |}
                             2266 ; 244  |#else // INSTRUMENT_ENABLE
                             2267 ; 245  |#define SysSignalEvent(wGPIONumber)
                             2268 ; 246  |#define SysClearEvent(wGPIONumber)
                             2269 ; 247  |#define SysEnableEvent(wGPIONumber)
                             2270 ; 248  |#endif // INSTRUMENT_ENABLE
                             2271 ; 249  |    
                             2272 ; 250  |#endif
                             2273 
                             2275 
                             2276 ; 16   |#include "usb_api.h"
TASKING DSP2410 assembler v1.5r1 Build 138 SN 00100122
                                                                                                                            Page  38

M:ADDR CODE           CYCLES LINE SOURCELINE
                             2277 
                             2279 
                             2280 ; 1    |////////////////////////////////////////////////////////////////////////////////
                             2281 ; 2    |// Copyright(C) SigmaTel, Inc. 2002 - 2003
                             2282 ; 3    |//
                             2283 ; 4    |// File : USB_API.H
                             2284 ; 5    |// Description : USB_API.H defines and structures definition for USB device
                             2285 ; 6    |//               driver API.
                             2286 ; 7    |//               This 
                             2287 ; 8    |////////////////////////////////////////////////////////////////////////////////
                             2288 ; 9    |
                             2289 ; 10   |#ifndef __usb_api_h__
                             2290 ; 11   |#define __usb_api_h__ 1
                             2291 ; 12   |
                             2292 ; 13   |#include "types.h"
                             2293 
                             2295 
                             2296 ; 1    |////////////////////////////////////////////////////////////////////////////////
                             2297 ; 2    |// Copyright(C) SigmaTel, Inc. 2000-2004
                             2298 ; 3    |//
                             2299 ; 4    |// Filename: types.h
                             2300 ; 5    |// Description: Standard data types
                             2301 ; 6    |////////////////////////////////////////////////////////////////////////////////
                             2302 ; 7    |
                             2303 ; 8    |#ifndef _TYPES_H
                             2304 ; 9    |#define _TYPES_H
                             2305 ; 10   |
                             2306 ; 11   |// TODO:  move this outta here!
                             2307 ; 12   |#if !defined(NOERROR)
                             2308 ; 13   |#define NOERROR 0
                             2309 ; 14   |#define SUCCESS 0
                             2310 ; 15   |#endif 
                             2311 ; 16   |#if !defined(SUCCESS)
                             2312 ; 17   |#define SUCCESS  0
                             2313 ; 18   |#endif
                             2314 ; 19   |#if !defined(ERROR)
                             2315 ; 20   |#define ERROR   -1
                             2316 ; 21   |#endif
                             2317 ; 22   |#if !defined(FALSE)
                             2318 ; 23   |#define FALSE 0
                             2319 ; 24   |#endif
                             2320 ; 25   |#if !defined(TRUE)
                             2321 ; 26   |#define TRUE  1
                             2322 ; 27   |#endif
                             2323 ; 28   |
                             2324 ; 29   |#if !defined(NULL)
                             2325 ; 30   |#define NULL 0
                             2326 ; 31   |#endif
                             2327 ; 32   |
                             2328 ; 33   |#define MAX_INT     0x7FFFFF
                             2329 ; 34   |#define MAX_LONG    0x7FFFFFffffff
                             2330 ; 35   |        // max positive unsigned long value: -1 == 0xFFFFFFffffff
                             2331 ; 36   |#define MAX_ULONG   (-1) 
                             2332 ; 37   |
                             2333 ; 38   |#define WORD_SIZE   24              // word size in bits
                             2334 ; 39   |#define BYTES_PER_WORD 3            // 8 bit bytes
                             2335 ; 40   |
                             2336 ; 41   |
                             2337 ; 42   |#define BYTE    unsigned char       // btVarName
                             2338 ; 43   |#define CHAR    signed char         // cVarName
                             2339 ; 44   |#define USHORT  unsigned short      // usVarName
                             2340 ; 45   |#define SHORT   unsigned short      // sVarName
TASKING DSP2410 assembler v1.5r1 Build 138 SN 00100122
                                                                                                                            Page  39

M:ADDR CODE           CYCLES LINE SOURCELINE
                             2341 ; 46   |#define WORD    unsigned int        // wVarName
                             2342 ; 47   |#define INT     signed int          // iVarName
                             2343 ; 48   |#define DWORD   unsigned long       // dwVarName
                             2344 ; 49   |#define LONG    signed long         // lVarName
                             2345 ; 50   |#define BOOL    unsigned int        // bVarName
                             2346 ; 51   |#define FRACT   _fract              // frVarName
                             2347 ; 52   |#define LFRACT  long _fract         // lfrVarName
                             2348 ; 53   |#define CIRC    _circ               // cp<type prefix>VarName (see below)
                             2349 ; 54   |#define FLOAT   float               // fVarName
                             2350 ; 55   |#define DBL     double              // dVarName
                             2351 ; 56   |#define ENUM    enum                // eVarName
                             2352 ; 57   |#define CMX     _complex            // cmxVarName
                             2353 ; 58   |typedef WORD UCS3;                   // 
                             2354 ; 59   |
                             2355 ; 60   |#define UINT16  unsigned short
                             2356 ; 61   |#define UINT8   unsigned char   
                             2357 ; 62   |#define UINT32  unsigned long
                             2358 ; 63   |#define UINT64  unsigned long   // need to figure out how to do 64 bit values.  Or port ex
                                  isiting code to only use 48 bit
                             2359 ; 64   |#define INT64   unsigned long   // need to figure out how to do 64 bit values.  Or port ex
                                  isiting code to only use 48 bit
                             2360 ; 65   |#define WCHAR   UINT16
                             2361 ; 66   |
                             2362 ; 67   |//UINT128 is 16 bytes or 6 words
                             2363 ; 68   |typedef struct UINT128_3500 {   
                             2364 ; 69   |    int val[6];     
                             2365 ; 70   |} UINT128_3500;
                             2366 ; 71   |
                             2367 ; 72   |#define UINT128   UINT128_3500
                             2368 ; 73   |
                             2369 ; 74   |// Little endian word packed byte strings:   
                             2370 ; 75   |//      _packed BYTE bTextVarName[]="a string";  bText is a packed byte string prefix
                             2371 ; 76   |// Convert to big endian words by reordering bytes from high to low using swizzle.
                             2372 ; 77   |// Little endian word packed byte strings:   
                             2373 ; 78   |//      _packed BYTE bTextVarName[]="a string";  bText is a packed byte string prefix
                             2374 ; 79   |// Convert to big endian words by reordering bytes from high to low using swizzle.
                             2375 ; 80   |
                             2376 ; 81   |// Declare Memory Spaces To Use When Coding
                             2377 ; 82   |// A. Sector Buffers
                             2378 ; 83   |#define SECTOR_BUFFER_MEM_X _X
                             2379 ; 84   |#define SECTOR_BUFFER_MEM_Y _Y
                             2380 ; 85   |#define SECTOR_BUFFER_MEM SECTOR_BUFFER_MEM_X
                             2381 ; 86   |typedef WORD SECTOR_BUFFER_MEM SECTOR_BUFFER;
                             2382 ; 87   |typedef SECTOR_BUFFER * P_SECTOR_BUFFER;
                             2383 ; 88   |// B. Media DDI Memory
                             2384 ; 89   |#define MEDIA_DDI_MEM _Y
                             2385 ; 90   |
                             2386 ; 91   |
                             2387 ; 92   |
                             2388 ; 93   |// Pointers to linear structures are labeled as: p<type prefix>VarName
                             2389 ; 94   |// Examples of circular pointers:
                             2390 ; 95   |//    INT CIRC cpiVarName
                             2391 ; 96   |//    DWORD CIRC cpdwVarName
                             2392 ; 97   |
                             2393 ; 98   |#define RETCODE INT                 // rcVarName
                             2394 ; 99   |
                             2395 ; 100  |// generic bitfield structure
                             2396 ; 101  |struct Bitfield {
                             2397 ; 102  |    unsigned int B0  :1;
                             2398 ; 103  |    unsigned int B1  :1;
                             2399 ; 104  |    unsigned int B2  :1;
                             2400 ; 105  |    unsigned int B3  :1;
TASKING DSP2410 assembler v1.5r1 Build 138 SN 00100122
                                                                                                                            Page  40

M:ADDR CODE           CYCLES LINE SOURCELINE
                             2401 ; 106  |    unsigned int B4  :1;
                             2402 ; 107  |    unsigned int B5  :1;
                             2403 ; 108  |    unsigned int B6  :1;
                             2404 ; 109  |    unsigned int B7  :1;
                             2405 ; 110  |    unsigned int B8  :1;
                             2406 ; 111  |    unsigned int B9  :1;
                             2407 ; 112  |    unsigned int B10 :1;
                             2408 ; 113  |    unsigned int B11 :1;
                             2409 ; 114  |    unsigned int B12 :1;
                             2410 ; 115  |    unsigned int B13 :1;
                             2411 ; 116  |    unsigned int B14 :1;
                             2412 ; 117  |    unsigned int B15 :1;
                             2413 ; 118  |    unsigned int B16 :1;
                             2414 ; 119  |    unsigned int B17 :1;
                             2415 ; 120  |    unsigned int B18 :1;
                             2416 ; 121  |    unsigned int B19 :1;
                             2417 ; 122  |    unsigned int B20 :1;
                             2418 ; 123  |    unsigned int B21 :1;
                             2419 ; 124  |    unsigned int B22 :1;
                             2420 ; 125  |    unsigned int B23 :1;
                             2421 ; 126  |};
                             2422 ; 127  |
                             2423 ; 128  |union BitInt {
                             2424 ; 129  |        struct Bitfield B;
                             2425 ; 130  |        int        I;
                             2426 ; 131  |};
                             2427 ; 132  |
                             2428 ; 133  |#define MAX_MSG_LENGTH 10
                             2429 ; 134  |struct CMessage
                             2430 ; 135  |{
                             2431 ; 136  |        unsigned int m_uLength;
                             2432 ; 137  |        unsigned int m_uMsg[MAX_MSG_LENGTH];
                             2433 ; 138  |};
                             2434 ; 139  |
                             2435 ; 140  |typedef struct {
                             2436 ; 141  |    WORD m_wLength;
                             2437 ; 142  |    WORD m_wMessage;
                             2438 ; 143  |    WORD m_wParams[MAX_MSG_LENGTH];
                             2439 ; 144  |} Message;
                             2440 ; 145  |
                             2441 ; 146  |struct MessageQueueDescriptor
                             2442 ; 147  |{
                             2443 ; 148  |        int *m_pBase;
                             2444 ; 149  |        int m_iModulo;
                             2445 ; 150  |        int m_iSize;
                             2446 ; 151  |        int *m_pHead;
                             2447 ; 152  |        int *m_pTail;
                             2448 ; 153  |};
                             2449 ; 154  |
                             2450 ; 155  |struct ModuleEntry
                             2451 ; 156  |{
                             2452 ; 157  |    int m_iSignaledEventMask;
                             2453 ; 158  |    int m_iWaitEventMask;
                             2454 ; 159  |    int m_iResourceOfCode;
                             2455 ; 160  |    struct MessageQueueDescriptor *m_pMessageQueue;
                             2456 ; 161  |    int _asmfunc (*m_pProcessEntryPoint)(union WaitMask Signals,struct MessageQueueDescrip
                                  tor *);
                             2457 ; 162  |    int _asmfunc (*m_pInitFunction)(struct MessageQueueDescriptor *);
                             2458 ; 163  |    int m_uTimeOutHigh;
                             2459 ; 164  |    int m_uTimeOutLow;
                             2460 ; 165  |    int _asmfunc (*m_pBackgroundFunction)(struct MessageQueueDescriptor *);
                             2461 ; 166  |};
TASKING DSP2410 assembler v1.5r1 Build 138 SN 00100122
                                                                                                                            Page  41

M:ADDR CODE           CYCLES LINE SOURCELINE
                             2462 ; 167  |
                             2463 ; 168  |union WaitMask{
                             2464 ; 169  |    struct B{
                             2465 ; 170  |        unsigned int m_bNone     :1;
                             2466 ; 171  |        unsigned int m_bMessage  :1;
                             2467 ; 172  |        unsigned int m_bTimer    :1;
                             2468 ; 173  |        unsigned int m_bButton   :1;
                             2469 ; 174  |    } B;
                             2470 ; 175  |    int I;
                             2471 ; 176  |} ;
                             2472 ; 177  |
                             2473 ; 178  |
                             2474 ; 179  |struct Button {
                             2475 ; 180  |        WORD wButtonEvent;
                             2476 ; 181  |        WORD wUnused[MAX_MSG_LENGTH];   
                             2477 ; 182  |};
                             2478 ; 183  |
                             2479 ; 184  |struct Message {
                             2480 ; 185  |        WORD wMsgLength;
                             2481 ; 186  |        WORD wMsgCommand;
                             2482 ; 187  |        WORD wMsgParms[MAX_MSG_LENGTH-1];
                             2483 ; 188  |};
                             2484 ; 189  |
                             2485 ; 190  |union EventTypes {
                             2486 ; 191  |        struct CMessage msg;
                             2487 ; 192  |        struct Button Button ;
                             2488 ; 193  |        struct Message Message;
                             2489 ; 194  |};
                             2490 ; 195  |
                             2491 ; 196  |// next 2 used to get updater build to return correct protocol ver in scsi response.
                             2492 ; 197  |#define BUILD_TYPE_UPDATER  0x100
                             2493 ; 198  |#define BUILD_TYPE_HOSTLINK 0x101
                             2494 ; 199  |#define BUILD_TYPE_PLAYER   0x102
                             2495 ; 200  |
                             2496 ; 201  |// Resets part if RETAIL build. DEBUG build executes debug instruction to halt.
                             2497 ; 202  |#define SystemHalt() __asm(" include 'sysmacro.asm' \n error") 
                             2498 ; 203  |#define assert(x)    if(!(x)) __asm(" include 'sysmacro.asm' \n error")
                             2499 ; 204  |
                             2500 ; 205  |#if DEBUG
                             2501 ; 206  |// For DEBUG builds, DebugBuildAssert(condition) halts if condition evaluates to FALSE. 
                             2502 ; 207  |#define DebugBuildAssert(x)    if(!(x)) __asm(" debug ")
                             2503 ; 208  |#else 
                             2504 ; 209  |// For RETAIL builds, DebugBuildAssert(condition) does nothing & execution continues rathe
                                  r than halt or reset. 
                             2505 ; 210  |#define DebugBuildAssert(x)    
                             2506 ; 211  |#endif
                             2507 ; 212  |
                             2508 ; 213  |// Do this in your C files to make a reminder that's displayed during the build.
                             2509 ; 214  |//  #pragma asm
                             2510 ; 215  |//  WARN 'Note to builder: reminder to do this after verifying that'
                             2511 ; 216  |//  #pragma endasm
                             2512 ; 217  |
                             2513 ; 218  |
                             2514 ; 219  |#ifdef COLOR_262K
                             2515 ; 220  |#define RGB(r,g,b)    ((0x0000FC & (r)) << 10) | ((0x0000FC & (g)) << 4) | ((0x0000FC & (b
                                  )) >> 2)    //262k
                             2516 ; 221  |#elif defined(COLOR_65K)
                             2517 ; 222  |#define RGB(r,g,b)    ((0x0000F8 & (r)) << 8) | ((0x0000FC & (g)) << 3) | ((0x0000F8 & (b)
                                  ) >> 3)  //65k
                             2518 ; 223  |#else
                             2519 ; 224  |#define RGB(r,g,b)       ((0x0000F0 & (r)) << 4) | (0x0000F0 & (g)) | ((0x0000F0 & (b)) >>
                                   4)
TASKING DSP2410 assembler v1.5r1 Build 138 SN 00100122
                                                                                                                            Page  42

M:ADDR CODE           CYCLES LINE SOURCELINE
                             2520 ; 225  |#endif
                             2521 ; 226  |    
                             2522 ; 227  |#endif // #ifndef _TYPES_H
                             2523 
                             2525 
                             2526 ; 14   |#include "project.h"
                             2527 
                             2529 
                             2530 ; 1    |/////////////////////////////////////////////////////////////////////////////////
                             2531 ; 2    |//  Copyright(C) SigmaTel, Inc. 2000-2004
                             2532 ; 3    |//  Filename: project.inc
                             2533 ; 4    |//  Description: 
                             2534 ; 5    |/////////////////////////////////////////////////////////////////////////////////
                             2535 ; 6    |
                             2536 ; 7    |#if (!defined(_PROJECT_INC))
                             2537 ; 8    |#define _PROJECT_INC 1
                             2538 ; 9    |
                             2539 ; 10   |#if defined(STMP_BUILD_PLAYER)
                             2540 ; 11   |#include "hwequ.h"
                             2541 ; 12   |#else 
                             2542 ; 13   |//include "regscodec.inc"
                             2543 ; 14   |#endif
                             2544 ; 15   |
                             2545 ; 16   |//////////////////////////////////////////////////////////////////////////////////
                             2546 ; 17   |// Uncomment next define to allow player boot if you have stfm1000 macro enabled (defaults
                                   ON) & 
                             2547 ; 18   |// your board crystal is not able to output nominal voltage range. Used in player main.asm
                                  . STMP00012148
                             2548 ; 19   |// Defining this will result in lower battery life (price of using a lower quality crystal
                                  ). 
                             2549 ; 20   |// Those that want to save battery life and have good crystals that meet our HW team's spe
                                  cs can 
                             2550 ; 21   |// comment out this line to reduce crystal bias current and so battery current in player m
                                  ode.  
                             2551 ; 22   |#define SUPPORT_MARGINAL_XTALS 1
                             2552 ; 23   |
                             2553 ; 24   |/////////////////////////////////////////////////////////////////////////////////
                             2554 ; 25   |// BOOT SPEED CONFIG & ASSOCIATED BATTERY VOLTAGE CHECK ENABLE
                             2555 ; 26   |/////////////////////////////////////////////////////////////////////////////////
                             2556 ; 27   |// Users can enable one of ATTEMPT_FAST_BOOT or FASTEST boot or neither project define bel
                                  ow by defining
                             2557 ; 28   |// values as 0 or 1, else it defaults to the boot speed used in previous SDKs.
                             2558 ; 29   |#define ATTEMPT_FAST_BOOT 1
                             2559 ; 30   |#define ATTEMPT_FASTEST_BOOT 0   
                             2560 ; 31   |// Changing this define to 0 removes Vbat threshholding & unconditionally gives fast boot 
                                  config above- 
                             2561 ; 32   |// disabling this check is suggested for profiling if you want to try to tweak down thresh
                                  holds by maybe 50mV.
                             2562 ; 33   |// Also the tests should clear the fast boot config defines to link & boot at normal speed
                                  .
                             2563 ; 34   |#define SPEED_BOOT_BATTERY_CHECK 1
                             2564 ; 35   |
                             2565 ; 36   |/////////////////////////////////////////////////////////////////////////////////
                             2566 ; 37   |// MEDIA DEFINITIONS
                             2567 ; 38   |/////////////////////////////////////////////////////////////////////////////////
                             2568 ; 39   |
                             2569 ; 40   |/////////////////////////////////////////////////////////////////////////////////
                             2570 ; 41   |// MNAND - Number of chips forming the internal physical device (i.e. # of NANDs)
                             2571 ; 42   |#if defined(NAND1)
                             2572 ; 43   |#define SM_INTERNAL_CHIPS 1
                             2573 ; 44   |#else 
                             2574 ; 45   |#if defined(NAND2)
TASKING DSP2410 assembler v1.5r1 Build 138 SN 00100122
                                                                                                                            Page  43

M:ADDR CODE           CYCLES LINE SOURCELINE
                             2575 ; 46   |#define SM_INTERNAL_CHIPS 2
                             2576 ; 47   |#else 
                             2577 ; 48   |#if defined(NAND3)
                             2578 ; 49   |#define SM_INTERNAL_CHIPS 3
                             2579 ; 50   |#else 
                             2580 ; 51   |#if defined(NAND4)
                             2581 ; 52   |#define SM_INTERNAL_CHIPS 4
                             2582 ; 53   |#else 
                             2583 ; 54   |#define SM_INTERNAL_CHIPS 1
                             2584 ; 55   |#endif
                             2585 ; 56   |#endif
                             2586 ; 57   |#endif
                             2587 ; 58   |#endif
                             2588 ; 59   |
                             2589 ; 60   |/////////////////////////////////////////////////////////////////////////////////
                             2590 ; 61   |// If SMARTMEDIA_DETECT_ACTIVE_HIGH is defined:
                             2591 ; 62   |//   SmartMedia will be detected as inserted if the GPIO pin reads 1 and removed if it rea
                                  ds 0.  
                             2592 ; 63   |// If SMARTMEDIA_DETECT_ACTIVE_HIGH is not defined ** comment out next line **
                             2593 ; 64   |//   SmartMedia will be detected as inserted if the GPIO pin reads 0 and removed if it rea
                                  ds 1.
                             2594 ; 65   |//*** comment out if active high ****
                             2595 ; 66   |//SMARTMEDIA_DETECT_ACTIVE_HIGH  equ     1
                             2596 ; 67   |
                             2597 ; 68   |#if defined(SMEDIA)
                             2598 ; 69   |#define NUM_REMOVABLE_MEDIA 1
                             2599 ; 70   |#define NUM_SM_EXTERNAL 1
                             2600 ; 71   |#define MMC_MAX_PHYSICAL_DEVICES 0
                             2601 ; 72   |#define SM_MAX_LOGICAL_DEVICES 2
                             2602 ; 73   |#else 
                             2603 ; 74   |#if defined(MMC)
                             2604 ; 75   |#define NUM_REMOVABLE_MEDIA 1
                             2605 ; 76   |#define NUM_SM_EXTERNAL 0
                             2606 ; 77   |#define MMC_MAX_PHYSICAL_DEVICES 1
                             2607 ; 78   |#define SM_MAX_LOGICAL_DEVICES 1
                             2608 ; 79   |#else 
                             2609 ; 80   |#define NUM_REMOVABLE_MEDIA 0
                             2610 ; 81   |#define NUM_SM_EXTERNAL 0
                             2611 ; 82   |#define MMC_MAX_PHYSICAL_DEVICES 0
                             2612 ; 83   |#define SM_MAX_LOGICAL_DEVICES 1
                             2613 ; 84   |#endif
                             2614 ; 85   |#endif
                             2615 ; 86   |
                             2616 ; 87   |/////////////////////////////////////////////////////////////////////////////////
                             2617 ; 88   |// Mass Storage Class definitions
                             2618 ; 89   |/////////////////////////////////////////////////////////////////////////////////
                             2619 ; 90   |// Set to 0 if Composite Device build is desired.    
                             2620 ; 91   |#define MULTI_LUN_BUILD 1   
                             2621 ; 92   |
                             2622 ; 93   |////////////////////////////////////////////////////////////////////////////////
                             2623 ; 94   |//  SCSI
                             2624 ; 95   |#if (MULTI_LUN_BUILD==0)
                             2625 ; 96   |  #if (NUM_REMOVABLE_MEDIA == 1)
                             2626 ; 97   |    #define SCSI_NUM_TARGETS                        2
                             2627 ; 98   |    #define SCSI_DEVICE_NUM_LUNS_DEV_0              1
                             2628 ; 99   |    #define SCSI_DEVICE_NUM_LUNS_DEV_1              1
                             2629 ; 100  |  #else
                             2630 ; 101  |    #define SCSI_NUM_TARGETS                        1
                             2631 ; 102  |    #define SCSI_DEVICE_NUM_LUNS_DEV_0              1
                             2632 ; 103  |  #endif
                             2633 ; 104  |#else
                             2634 ; 105  |    #define SCSI_NUM_TARGETS                        1
TASKING DSP2410 assembler v1.5r1 Build 138 SN 00100122
                                                                                                                            Page  44

M:ADDR CODE           CYCLES LINE SOURCELINE
                             2635 ; 106  |  #if (NUM_REMOVABLE_MEDIA == 1)
                             2636 ; 107  |    #define SCSI_DEVICE_NUM_LUNS_DEV_0              2
                             2637 ; 108  |  #else
                             2638 ; 109  |    #define SCSI_DEVICE_NUM_LUNS_DEV_0              1  
                             2639 ; 110  |  #endif
                             2640 ; 111  |#endif
                             2641 ; 112  |
                             2642 ; 113  |
                             2643 ; 114  |#define USBMSC_NUM_DEVICES                      SCSI_NUM_TARGETS
                             2644 ; 115  |
                             2645 ; 116  |
                             2646 ; 117  |////////////////////////////////////////////////////////////////////////////////
                             2647 ; 118  |// Define number of logical medias and drives for three builds (MTP, USBMSC, and Player)
                             2648 ; 119  |////////////////////////////////////////////////////////////////////////////////
                             2649 ; 120  |#ifdef MMC
                             2650 ; 121  |#ifdef MTP_BUILD
                             2651 ; 122  |// --------------------
                             2652 ; 123  |// MTP and MMC
                             2653 ; 124  |// --------------------
                             2654 ; 125  |#define NUM_LOGICAL_MEDIA       2
                             2655 ; 126  |#define NUM_LOGICAL_DRIVES      8
                             2656 ; 127  |#else  // ifndef MTP_BUILD
                             2657 ; 128  |#ifdef STMP_BUILD_PLAYER
                             2658 ; 129  |// --------------------
                             2659 ; 130  |// Player and MMC
                             2660 ; 131  |// --------------------
                             2661 ; 132  |#else
                             2662 ; 133  |// --------------------
                             2663 ; 134  |// USBMSC and MMC
                             2664 ; 135  |// --------------------
                             2665 ; 136  |#define NUM_LOGICAL_MEDIA       3
                             2666 ; 137  |#define NUM_LOGICAL_DRIVES      8
                             2667 ; 138  |#endif // ifdef STMP_BUILD_PLAYER
                             2668 ; 139  |#endif // ifdef MTP_BUILD
                             2669 ; 140  |#else  // ifndef MMC
                             2670 ; 141  |#ifdef MTP_BUILD
                             2671 ; 142  |// --------------------
                             2672 ; 143  |// MTP and NAND only
                             2673 ; 144  |// --------------------
                             2674 ; 145  |#define NUM_LOGICAL_MEDIA       1
                             2675 ; 146  |#define NUM_LOGICAL_DRIVES      7
                             2676 ; 147  |#else  // ifndef MTP_BUILD
                             2677 ; 148  |#ifdef STMP_BUILD_PLAYER
                             2678 ; 149  |// --------------------
                             2679 ; 150  |// Player and NAND only
                             2680 ; 151  |// --------------------
                             2681 ; 152  |#else
                             2682 ; 153  |// --------------------
                             2683 ; 154  |// USBMSC and NAND only
                             2684 ; 155  |// --------------------
                             2685 ; 156  |#define NUM_LOGICAL_MEDIA       2
                             2686 ; 157  |#define NUM_LOGICAL_DRIVES      7
                             2687 ; 158  |#endif // ifdef STMP_BUILD_PLAYER
                             2688 ; 159  |#endif // ifdef MTP_BUILD
                             2689 ; 160  |#endif // ifdef MMC 
                             2690 ; 161  |
                             2691 ; 162  |// If we are in an MTP build then we don't use as many transfers buffers.
                             2692 ; 163  |#if (defined(MTP_BUILD))
                             2693 ; 164  |#define MAX_USB_TRANSFERS_QUEUED 16
                             2694 ; 165  |
                             2695 ; 166  |////!
                             2696 ; 167  |////! This varible holds the watchdog count for the store flush.
TASKING DSP2410 assembler v1.5r1 Build 138 SN 00100122
                                                                                                                            Page  45

M:ADDR CODE           CYCLES LINE SOURCELINE
                             2697 ; 168  |////!
                             2698 ; 169  |///
                             2699 ; 170  |#include <types.h>
                             2700 ; 171  |extern volatile INT g_StoreWatchDogCount;
                             2701 ; 172  |extern const INT g_StoreWatchDogTimeout;
                             2702 ; 173  |#endif
                             2703 ; 174  |
                             2704 ; 175  |////////////////////////////////////////////////////////////////////////////////
                             2705 ; 176  |// These are needed here for Mass Storage Class
                             2706 ; 177  |// Needs to be cleaned up
                             2707 ; 178  |////////////////////////////////////////////////////////////////////////////////
                             2708 ; 179  |#if (!defined(STMP_BUILD_PLAYER))
                             2709 ; 180  |#define SCRATCH_USER_Y_SIZE 512
                             2710 ; 181  |#define SCRATCH_USER_X_SIZE 512
                             2711 ; 182  |
                             2712 ; 183  |#define BROWNOUT_LEVEL1_DETECTED                0x000001
                             2713 ; 184  |
                             2714 ; 185  |#endif
                             2715 ; 186  |
                             2716 ; 187  |
                             2717 ; 188  |/////////////////////////////////////////////////////////////////////////////////
                             2718 ; 189  |// SmartMedia/NAND defs
                             2719 ; 190  |#define SM_MAX_PHYSICAL_DEVICES SM_INTERNAL_CHIPS+NUM_SM_EXTERNAL
                             2720 ; 191  |#define SM_REMOVABLE_DEVICE_NUM SM_INTERNAL_CHIPS
                             2721 ; 192  |
                             2722 ; 193  |/////////////////////////////////////////////////////////////////////////////////
                             2723 ; 194  |// Sysloadresources defs
                             2724 ; 195  |#define SM_MAX_RESOURCE_DEVICES SM_INTERNAL_CHIPS+NUM_SM_EXTERNAL
                             2725 ; 196  |
                             2726 ; 197  |/////////////////////////////////////////////////////////////////////////////////
                             2727 ; 198  |// MMC defs
                             2728 ; 199  |#define MMC_MAX_PARTITIONS 1
                             2729 ; 200  |#define MMC_MAX_LOGICAL_DEVICES MMC_MAX_PHYSICAL_DEVICES*MMC_MAX_PARTITIONS
                             2730 ; 201  |
                             2731 ; 202  |/////////////////////////////////////////////////////////////////////////////////
                             2732 ; 203  |// SPI defs
                             2733 ; 204  |#define SPI_MAX_DEVICES MMC_MAX_PHYSICAL_DEVICES
                             2734 ; 205  |
                             2735 ; 206  |/////////////////////////////////////////////////////////////////////////////////
                             2736 ; 207  |// Global media defs
                             2737 ; 208  |#define MAX_PHYSICAL_DEVICES SM_MAX_PHYSICAL_DEVICES+MMC_MAX_PHYSICAL_DEVICES
                             2738 ; 209  |#define MAX_LOGICAL_DEVICES SM_MAX_LOGICAL_DEVICES+MMC_MAX_LOGICAL_DEVICES
                             2739 ; 210  |
                             2740 ; 211  |/////////////////////////////////////////////////////////////////////////////////
                             2741 ; 212  |// DO NOT CHANGE THESE!!!
                             2742 ; 213  |#define SM_MAX_PARTITIONS 4
                             2743 ; 214  |#define MAX_HANDLES 2
                             2744 ; 215  |/////////////////////////////////////////////////////////////////////////////////
                             2745 ; 216  |
                             2746 ; 217  |
                             2747 ; 218  |/////////////////////////////////////////////////////////////////////////////////
                             2748 ; 219  |// Battery LRADC Values 
                             2749 ; 220  |/////////////////////////////////////////////////////////////////////////////////
                             2750 ; 221  |// brownout trip point in mV (moved by RS)
                             2751 ; 222  |// BATT_SAFETY_MARGIN:  percentage value used by:
                             2752 ; 223  |//   * SysSaveSettings to determine if enough power is left to attempt a settings save. 
                             2753 ; 224  |//   * Recorder to conditionally prevent the start or continuation of 
                             2754 ; 225  |//     audio recording to media.
                             2755 ; 226  |#define BATT_SAFETY_MARGIN 10
                             2756 ; 227  |
                             2757 ; 228  |//; player resource drive refresh allowed only when battery usable % is above this value. 
                                  
TASKING DSP2410 assembler v1.5r1 Build 138 SN 00100122
                                                                                                                            Page  46

M:ADDR CODE           CYCLES LINE SOURCELINE
                             2758 ; 229  |//; 50% of usable range [0.9V to 1.5V] is around 1.2V This is the safe target alkaline vol
                                  tage to do a refresh.
                             2759 ; 230  |//; LIION will also require 50% which will work but that could be changed in the future. 
                             2760 ; 231  |//RESOURCE_REFRESH_MIN_BATT_PCT equ 50
                             2761 ; 232  |
                             2762 ; 233  |// stmp00005071 adds these for mp3 encode stability at low battery per battery type & mmc 
                                  presence.
                             2763 ; 234  |
                             2764 ; 235  |//// Vbat threshholds empirically tuned by profiling max bat current for 3 HW cases: 
                             2765 ; 236  |//// 1 GigaByte MMC, NAND flash only, & LiIon Buck mode. See voicemenu pre-encode Vbat che
                                  ck.
                             2766 ; 237  |#if (!defined(CLCD))
                             2767 ; 238  |#define MP3_ENC_MMC_MIN_V_BAT_MV 1100
                             2768 ; 239  |#define MP3_ENC_NANDONLY_MIN_V_BAT_MV 1000
                             2769 ; 240  |#else 
                             2770 ; 241  |#define MP3_ENC_MMC_MIN_V_BAT_MV 1250
                             2771 ; 242  |#define MP3_ENC_NANDONLY_MIN_V_BAT_MV 1150
                             2772 ; 243  |#endif
                             2773 ; 244  |#define MP3_ENC_BUCKMODE_MIN_V_BAT_MV 3300
                             2774 ; 245  |
                             2775 ; 246  |// These Vbat use-range-percentages are derived to correspond with target battery 
                             2776 ; 247  |// voltages of 1.10V for MMC, 1.0V for nand only (alkaline or nimh), and 3.3V for any LiIo
                                  n.
                             2777 ; 248  |// See mp3 encoder overlay.
                             2778 ; 249  |#define MP3_ENC_MMC_MIN_V_BAT_RANGE_PCT 33
                             2779 ; 250  |#define MP3_ENC_NANDONLY_MIN_V_BAT_RANGE_PCT 17
                             2780 ; 251  |#define MP3_ENC_BUCKMODE_MIN_V_BAT_RANGE_PCT 25
                             2781 ; 252  |
                             2782 ; 253  |/////////////////////////////////////////////////////////////////////////////////
                             2783 ; 254  |// Voice recording filenames
                             2784 ; 255  |// number of digits in filename Vxxx.wav
                             2785 ; 256  |/////////////////////////////////////////////////////////////////////////////////
                             2786 ; 257  |#define DIGITS_IN_VOICE_FILENAME 3   
                             2787 ; 258  |
                             2788 ; 259  |/////////////////////////////////////////////////////////////////////////////////
                             2789 ; 260  |// Mic Bias: Set this enable to 1 to internally generate mic bias voltage. 
                             2790 ; 261  |// Also below, must configure internal resistor value and pin to use for DC bias. 
                             2791 ; 262  |// Can set to 0 to disable internally generated mic bias voltage at pin lradc1/2.
                             2792 ; 263  |#if defined(DEVICE_3500)
                             2793 ; 264  |#define ENABLE_INTERNALLY_GENERATED_MICBIAS 1 
                             2794 ; 265  |// MIC BIAS circuit source selection: use Low Resolution ADC pin 2 or 1 to bias mic. 
                             2795 ; 266  |// Per your layout: select LRADC 2 or 1 below 
                             2796 ; 267  |//   (pin LRADC 2 for 35xx cpu card revB, LRADC 1 for 35xx cpu card revC, ref schematics, 
                                  & demo player)
                             2797 ; 268  |#define LRADC_NUM_FOR_MIC_BIAS 1 
                             2798 ; 269  |// Sets internal mic bias R to value 2, 4, or 8 (in kOhms).
                             2799 ; 270  |#define MICBIAS_CONFIGURED_RESISTOR_KOHMS 8
                             2800 ; 271  |
                             2801 ; 272  |// Allows mic bias to settle before sampling. This delay currently unused. For rec btn whe
                                  n bias not yet ready.
                             2802 ; 273  |#define REC_BTN_INTERNAL_MIC_BIAS_SETTLING_DELAY_MS 400 
                             2803 ; 274  |// Option always keeps bias enabled after mainmenu init. This allows for start pop prevent
                                  ion if you use rec button from outside voice menu.
                             2804 ; 275  |// This selection costs 1 mWatt but gains the desired low record button to sampling latenc
                                  y in the record-from-music-menu use-case.
                             2805 ; 276  |#define KEEP_MIC_BIAS_ENABLED 0
                             2806 ; 277  |
                             2807 ; 278  |#else 
                             2808 ; 279  |// STMP3410
                             2809 ; 280  |#define ENABLE_INTERNALLY_GENERATED_MICBIAS 0
                             2810 ; 281  |#define LRADC_NUM_FOR_MIC_BIAS 1 
                             2811 ; 282  |#define MICBIAS_CONFIGURED_RESISTOR_KOHMS 2
TASKING DSP2410 assembler v1.5r1 Build 138 SN 00100122
                                                                                                                            Page  47

M:ADDR CODE           CYCLES LINE SOURCELINE
                             2812 ; 283  |#endif
                             2813 ; 284  |
                             2814 ; 285  |/////////////////////////////////////////////////////////////////////////////////
                             2815 ; 286  |// Number of available soft timers
                             2816 ; 287  |/////////////////////////////////////////////////////////////////////////////////
                             2817 ; 288  |#if defined(SYNC_LYRICS)
                             2818 ; 289  |#define SOFT_TIMERS 10
                             2819 ; 290  |#else 
                             2820 ; 291  |#if defined(JPEG_DECODER)
                             2821 ; 292  |#define SOFT_TIMERS 10
                             2822 ; 293  |#else 
                             2823 ; 294  |#define SOFT_TIMERS 9
                             2824 ; 295  |#endif
                             2825 ; 296  |#endif
                             2826 ; 297  |
                             2827 ; 298  |/////////////////////////////////////////////////////////////////////////////////
                             2828 ; 299  |//  sizes
                             2829 ; 300  |/////////////////////////////////////////////////////////////////////////////////
                             2830 ; 301  |#if defined(MMC)
                             2831 ; 302  |#if defined(USE_PLAYLIST5)
                             2832 ; 303  |#define MENU_STACK_SIZE 1500
                             2833 ; 304  |#else 
                             2834 ; 305  |#define MENU_STACK_SIZE 1250
                             2835 ; 306  |#endif //if @def('USE_PLAYLIST5')
                             2836 ; 307  |#else 
                             2837 ; 308  |#if defined(USE_PLAYLIST5)
                             2838 ; 309  |#define MENU_STACK_SIZE 1500
                             2839 ; 310  |#else 
                             2840 ; 311  |#define MENU_STACK_SIZE 1250
                             2841 ; 312  |#endif //if @def('USE_PLAYLIST5')
                             2842 ; 313  |#endif //if @def('MMC')
                             2843 ; 314  |
                             2844 ; 315  |// NOTE: SDK2.6 USED 550 FOR NEXT LINE, BUT SDK3.0BETA USED 750. Should it be ifdef MTP 75
                                  0 else 550 for other builds? TOVERIFY. MYALLOC
                             2845 ; 316  |// 
                             2846 ; 317  |#define STACK_L1_SIZE 750
                             2847 ; 318  |#define STACK_L2_SIZE 100
                             2848 ; 319  |#define STACK_L3_SIZE 160
                             2849 ; 320  |
                             2850 ; 321  |// If we are in MTP mode the overlay task stack can shrink.
                             2851 ; 322  |// TODO shrink this stack for MTP, I will leave it at 500 until we verify that it 
                             2852 ; 323  |// is ok with switching code.
                             2853 ; 324  |#if defined(MTP_BUILD)
                             2854 ; 325  |#define OVERLAY_MANAGER_STACK_SIZE 300
                             2855 ; 326  |#endif
                             2856 ; 327  |
                             2857 ; 328  |/////////////////////////////////////////////////////////////////////////////////
                             2858 ; 329  |// maximum number of nested funclets 
                             2859 ; 330  |/////////////////////////////////////////////////////////////////////////////////
                             2860 ; 331  |#define MAX_NESTED_FUNCLET 6 
                             2861 ; 332  |
                             2862 ; 333  |/////////////////////////////////////////////////////////////////////////////////
                             2863 ; 334  |//    LCD DEFINITIONS
                             2864 ; 335  |/////////////////////////////////////////////////////////////////////////////////
                             2865 ; 336  |
                             2866 ; 337  |#define SPACE_CHAR 0x000020          
                             2867 ; 338  |#define ZERO_CHAR 0x000030
                             2868 ; 339  |#define COLON_CHAR 0x00003A
                             2869 ; 340  |#define PERIOD_CHAR 0x00002E
                             2870 ; 341  |
                             2871 ; 342  |#if (defined(S6B33B0A_LCD))
                             2872 ; 343  |#define LCD_X_SIZE 128
TASKING DSP2410 assembler v1.5r1 Build 138 SN 00100122
                                                                                                                            Page  48

M:ADDR CODE           CYCLES LINE SOURCELINE
                             2873 ; 344  |#define LCD_Y_SIZE 159
                             2874 ; 345  |#endif
                             2875 ; 346  |
                             2876 ; 347  |#if (defined(SED15XX_LCD))
                             2877 ; 348  |#define LCD_X_SIZE 128
                             2878 ; 349  |#define LCD_Y_SIZE 64
                             2879 ; 350  |#endif
                             2880 ; 351  |
                             2881 ; 352  |
                             2882 ; 353  |//////////////////////////////////////////////////////////////////////////////////
                             2883 ; 354  |//   Details on Customizing Contrast
                             2884 ; 355  |/////////////////////////////////////////////////////////////////////////////////
                             2885 ; 356  |//   Max supported LCD range is 0 - 3F; however due to hardware/voltage differences
                             2886 ; 357  |//   the range of visibility is usually smaller than this.  It is important to 
                             2887 ; 358  |//   calibrate the visible range, because the contrast setting is saved.
                             2888 ; 359  |//   If the user shuts off the player while lcd is not visible, the player is useless
                             2889 ; 360  |//   unless the ezact sequence is remembered.
                             2890 ; 361  |//   To find out what range your player supports: 
                             2891 ; 362  |//   change these equs to full range or comment out (full range is default)
                             2892 ; 363  |//;;;;;;
                             2893 ; 364  |// uncomment the line below to build code that will provide raw contrast value
                             2894 ; 365  |// recommended calibration using player -- uncomment 
                             2895 ; 366  |//;;;;;;
                             2896 ; 367  |//CONTRAST_CALIBRATION    equ  1
                             2897 ; 368  |////////////////////////////
                             2898 ; 369  |#if (defined(DEMO_HW))
                             2899 ; 370  |// this is the setting for ET301 demos; Next 2 line have not been updated for new Shingyi 
                                  LCD (June6'05)
                             2900 ; 371  |#define LCD_MAX_CONTRAST 0x32 
                             2901 ; 372  |#define LCD_MIN_CONTRAST 0x1E
                             2902 ; 373  |#else 
                             2903 ; 374  |
                             2904 ; 375  |#if (defined(S6B33B0A_LCD))
                             2905 ; 376  |#define LCD_MAX_CONTRAST 210
                             2906 ; 377  |#define LCD_MIN_CONTRAST 160    
                             2907 ; 378  |#endif
                             2908 ; 379  |
                             2909 ; 380  |#if (defined(SED15XX_LCD))
                             2910 ; 381  |// Next 3 line comment was for OLD shingyi LCD: (default LCD before sdk2.6)
                             2911 ; 382  |// Engineering board regs support range [17-37].
                             2912 ; 383  |//   Engineering board DC/DC support range [24-46]. 
                             2913 ; 384  |//   One default contrast range [24-42] works for both.
                             2914 ; 385  |// The 3 sets of contrast ranges below are updated for SDK2.6 to support either 
                             2915 ; 386  |// new or old ShingYih LCDs. "File" refers to \resource\shingyih\system_lcd_init_seq.src
                             2916 ; 387  |// 3/10/05 - Use one of the 2 next contrast ranges depending on which
                             2917 ; 388  |// ShingYih LCD you have.  See \resources\shingyi\readme.txt 
                             2918 ; 389  |// Optimal for NEW LCD with NEW file (SDK2.6 default)  
                             2919 ; 390  |// G098064-41 LCD module (present on engr board revH LCD card)
                             2920 ; 391  |
                             2921 ; 392  |#if (defined(NEWSHINGYIH))
                             2922 ; 393  |#define LCD_MAX_CONTRAST 250
                             2923 ; 394  |#define LCD_MIN_CONTRAST 0
                             2924 ; 395  |#else 
                             2925 ; 396  |//-----
                             2926 ; 397  |// Near optimal for OLD LCD with NEW file. 
                             2927 ; 398  |// NOT optimal for the new lcd but pretty good. So u may use this if u want 1 build for bo
                                  th LCDs.
                             2928 ; 399  |#define LCD_MAX_CONTRAST 250
                             2929 ; 400  |#define LCD_MIN_CONTRAST 0
                             2930 ; 401  |
                             2931 ; 402  |//=====
                             2932 ; 403  |// Optimal for OLD ShingYih LCD with OLD file (as sdk2.521)
TASKING DSP2410 assembler v1.5r1 Build 138 SN 00100122
                                                                                                                            Page  49

M:ADDR CODE           CYCLES LINE SOURCELINE
                             2933 ; 404  |// Suggest going with default new init file & values above for your LCD instead of this hi
                                  storic ver.
                             2934 ; 405  |//LCD_MAX_CONTRAST equ 42
                             2935 ; 406  |//LCD_MIN_CONTRAST equ 24 
                             2936 ; 407  |
                             2937 ; 408  |#endif
                             2938 ; 409  |#endif
                             2939 ; 410  |
                             2940 ; 411  |#endif
                             2941 ; 412  |
                             2942 ; 413  |//////////////////////////////////////////////////////////////////////////////////
                             2943 ; 414  |// The default value of the lcd contrast in % of range
                             2944 ; 415  |//   the default value is used when no settings.dat is available
                             2945 ; 416  |//////////////////////////////////////////////////////////////////////////////////
                             2946 ; 417  |
                             2947 ; 418  |#if (defined(S6B33B0A_LCD))
                             2948 ; 419  |// 60% of range is default value
                             2949 ; 420  |#define DEFAULT_CONTRAST 50 
                             2950 ; 421  |#endif
                             2951 ; 422  |
                             2952 ; 423  |#if (defined(SED15XX_LCD))
                             2953 ; 424  |// % of range is default value (was 60%)
                             2954 ; 425  |#define DEFAULT_CONTRAST 50 
                             2955 ; 426  |#endif
                             2956 ; 427  |
                             2957 ; 428  |
                             2958 ; 429  |// percentage change per increment/decrement message (LCD_DEC_CONTRAST/LCD_INC_CONTRAST)
                             2959 ; 430  |// make lower when doing calibration
                             2960 ; 431  |#define LCD_STEPSIZE_CONTRAST 10  
                             2961 ; 432  |
                             2962 ; 433  |
                             2963 ; 434  |/////////////////////////////////////////////////////////////////////////////////
                             2964 ; 435  |// For FFWD and RWND
                             2965 ; 436  |/////////////////////////////////////////////////////////////////////////////////
                             2966 ; 437  |#define SECONDS_TO_SKIP 1
                             2967 ; 438  |#define SECONDS_TO_SKIP1 3
                             2968 ; 439  |#define SECONDS_TO_SKIP2 6
                             2969 ; 440  |// number of seconds to cause reset to begin of song for PREV push
                             2970 ; 441  |#define PREV_SONG_THRESHOLD 5  
                             2971 ; 442  |// number of 300 mSec periods before the numbers of seconds to skip increases
                             2972 ; 443  |#define FIRST_TIME_BOUNDARY 15 
                             2973 ; 444  |// number of 300 mSec periods before the numbers of seconds to skip increases
                             2974 ; 445  |#define SECOND_TIME_BOUNDARY 30 
                             2975 ; 446  |
                             2976 ; 447  |// For audible FFW/RWD
                             2977 ; 448  |#define SECONDS_TO_SKIP_FOR_3X_RATE 1
                             2978 ; 449  |#define SECONDS_TO_SKIP_FOR_60X_RATE 18
                             2979 ; 450  |#define SECONDS_TO_SKIP_FOR_600X_RATE 180
                             2980 ; 451  |#define SECONDS_TO_SKIP_FOR_1800X_RATE 540
                             2981 ; 452  |// number of 300 mSec periods before the numbers of seconds to skip increases
                             2982 ; 453  |#define LEVEL1_BOUNDARY 17 
                             2983 ; 454  |// number of 300 mSec periods before the numbers of seconds to skip increases
                             2984 ; 455  |#define LEVEL2_BOUNDARY 33 
                             2985 ; 456  |// number of 300 mSec periods before the numbers of seconds to skip increases
                             2986 ; 457  |#define LEVEL3_BOUNDARY 50 
                             2987 ; 458  |// Stmp00010296 Ticket #71685:  for song shorter than the min. skip size
                             2988 ; 459  |// if song_time < skip_size, bCurrentSongShort=>TRUE (ignore FWD/RWD commands)
                             2989 ; 460  |// Short Song Time, songs too short to play.
                             2990 ; 461  |#define SHORT_SONG_TIME SECONDS_TO_SKIP         
                             2991 ; 462  |
                             2992 ; 463  |/////////////////////////////////////////////////////////////////////////////////
                             2993 ; 464  |// MP3 Sync Values
TASKING DSP2410 assembler v1.5r1 Build 138 SN 00100122
                                                                                                                            Page  50

M:ADDR CODE           CYCLES LINE SOURCELINE
                             2994 ; 465  |/////////////////////////////////////////////////////////////////////////////////
                             2995 ; 466  |// # bytes to look for sync before marking it bad
                             2996 ; 467  |#define MP3_SYNC_THRESHOLD 70000 
                             2997 ; 468  |// # bytes to look for sync before slowing decoder isr frequency (to let menus run)
                             2998 ; 469  |#define MP3_SYNC_THRESHOLD1 10000 
                             2999 ; 470  |// once we have sync'd, the isr should be called this frequently
                             3000 ; 471  |#define MP3_DECODERISR_FAST 7500  
                             3001 ; 472  |// if decoder is having difficulty syncing, switch isr to be called less frequently
                             3002 ; 473  |#define MP3_DECODERISR_SLOW 50000 
                             3003 ; 474  |
                             3004 ; 475  |
                             3005 ; 476  |/////////////////////////////////////////////////////////////////////////////////
                             3006 ; 477  |//// Multi-Stage Volume Control Definitions
                             3007 ; 478  |/////////////////////////////////////////////////////////////////////////////////
                             3008 ; 479  |//// Use Multi-Stage Volume
                             3009 ; 480  |#define MULTI_STAGE_VOLUME 0x1                  
                             3010 ; 481  |
                             3011 ; 482  |//// Master Volume definitions
                             3012 ; 483  |#define MIX_MSTR_MAX_VOL 0x0
                             3013 ; 484  |#define NUM_MSTR_ATT_STEPS (0x1F-MIX_MSTR_MAX_VOL)
                             3014 ; 485  |
                             3015 ; 486  |//// DAC-Mode definitions
                             3016 ; 487  |//// Adjusts 0dB point
                             3017 ; 488  |#define MIX_DAC_NOM_VOL 0x6                  
                             3018 ; 489  |#define MIX_DAC_MIN_VOL 0x1F
                             3019 ; 490  |// For minimum clipping: Set MIX_DAC_MAX_VOL below to match MIX_DAC_NOM_VOL value 2 lines 
                                  above.
                             3020 ; 491  |// For additional gain (with possible clipping): Set MIX_DAC_MAX_VOL in range below. 
                             3021 ; 492  |//                                               Each integer below MIX_DAC_NOM_VOL provid
                                  es 1.5 dB gain on Stmp34x0; 
                             3022 ; 493  |//                                               Max gain possible: 8 step diff would prov
                                  ide +12dB gain.   
                             3023 ; 494  |// range: [0 to MIX_DAC_NOM_VOL] (0 for loudest volume)
                             3024 ; 495  |#define MIX_DAC_MAX_VOL 0x0  
                             3025 ; 496  |
                             3026 ; 497  |#define NUM_DAC_ATT_STEPS (MIX_DAC_MIN_VOL-MIX_DAC_NOM_VOL+1)
                             3027 ; 498  |#define NUM_DAC_GAIN_STEPS (MIX_DAC_NOM_VOL-MIX_DAC_MAX_VOL)
                             3028 ; 499  |#define NUM_DAC_MODE_VOL_STEPS (NUM_DAC_ATT_STEPS+NUM_MSTR_ATT_STEPS+NUM_DAC_GAIN_STEPS+1)
                                  
                             3029 ; 500  |
                             3030 ; 501  |//// If there is no stored volume, set to 50% of DAC-Mode max; change if DAC Mode is not t
                                  he default
                             3031 ; 502  |//// STMP35xx has 2dB attenuation per step so default needs a few more steps above midpoin
                                  t.
                             3032 ; 503  |#define DEFAULT_VOLUME ((NUM_DAC_MODE_VOL_STEPS/2)+6)         
                             3033 ; 504  |
                             3034 ; 505  |//// Set maximum restored volume to 75% of DAC-Mode max; change if DAC Mode is not the def
                                  ault
                             3035 ; 506  |#define MAX_RESTORED_VOLUME ((3*NUM_DAC_MODE_VOL_STEPS)/4)   
                             3036 ; 507  |
                             3037 ; 508  |
                             3038 ; 509  |//// Line In definitions (used for Line-In 1)
                             3039 ; 510  |//// 0dB point of the Line In
                             3040 ; 511  |#define MIX_LINE_NOM_VOL 0x8                  
                             3041 ; 512  |//// Minimum volume of Line In
                             3042 ; 513  |#define MIX_LINE_MIN_VOL 0x1F                 
                             3043 ; 514  |//// Maximum volume of Line In (can adjust extra gain)
                             3044 ; 515  |#define MIX_LINE_MAX_VOL 0x6                  
                             3045 ; 516  |#define NUM_LINE_ATT_STEPS (MIX_LINE_MIN_VOL-MIX_LINE_NOM_VOL+1)
                             3046 ; 517  |#define NUM_LINE_GAIN_STEPS (MIX_LINE_NOM_VOL-MIX_LINE_MAX_VOL)
                             3047 ; 518  |#define NUM_LINE_MODE_VOL_STEPS (NUM_LINE_ATT_STEPS+NUM_MSTR_ATT_STEPS+NUM_LINE_GAIN_STEPS
                                  +1)
TASKING DSP2410 assembler v1.5r1 Build 138 SN 00100122
                                                                                                                            Page  51

M:ADDR CODE           CYCLES LINE SOURCELINE
                             3048 ; 519  |
                             3049 ; 520  |//// Line In definitions (used for FM tuner with 144 pin package)
                             3050 ; 521  |//// 0dB point of the Line In
                             3051 ; 522  |#define MIX_FM_NOM_VOL 0x8                  
                             3052 ; 523  |//// Minimum volume of Line In
                             3053 ; 524  |#define MIX_FM_MIN_VOL 0x1F                 
                             3054 ; 525  |//// Maximum volume of Line In (can adjust extra gain)
                             3055 ; 526  |#define MIX_FM_MAX_VOL 0x6                  
                             3056 ; 527  |#define NUM_FM_ATT_STEPS (MIX_FM_MIN_VOL-MIX_FM_NOM_VOL+1)
                             3057 ; 528  |#define NUM_FM_GAIN_STEPS (MIX_FM_NOM_VOL-MIX_FM_MAX_VOL)
                             3058 ; 529  |#define NUM_FM_MODE_VOL_STEPS (NUM_FM_ATT_STEPS+NUM_MSTR_ATT_STEPS+NUM_FM_GAIN_STEPS+1)
                             3059 ; 530  |
                             3060 ; 531  |/////////////////////////////////////////////////////////////////////////////////
                             3061 ; 532  |//// When enabled (1), periodically checks for one of several FM state machine invalid dea
                                  dlock states & recovers. 
                             3062 ; 533  |//// Define as 0 to disable FM-deadlock-state checking and recovery.
                             3063 ; 534  |#define FM_WATCHDOG_ENABLE 1
                             3064 ; 535  |
                             3065 ; 536  |#if !defined(STMP_BUILD_PLAYER)
                             3066 ; 537  |////
                             3067 ; 538  |////! This varible holds the lcd display state for the mtp project.
                             3068 ; 539  |////
                             3069 ; 540  |///
                             3070 ; 541  |#include <types.h>
                             3071 ; 542  |extern volatile WORD g_wActivityState;
                             3072 ; 543  |#endif // if !@def('STMP_BUILD_PLAYER')
                             3073 ; 544  |
                             3074 ; 545  |void _reentrant Init5VSense(void);
                             3075 ; 546  |void _reentrant ServiceDCDC(void);
                             3076 ; 547  |
                             3077 ; 548  |////////////////////////////////////////////////////////////////////////////
                             3078 ; 549  |//// JPEG Thumbnail Mode Setting
                             3079 ; 550  |//// number of column in thumbnail mode
                             3080 ; 551  |#define THUMBNAIL_X 2           
                             3081 ; 552  |//// number of row in  thumbnail mode
                             3082 ; 553  |#define THUMBNAIL_Y 2           
                             3083 ; 554  |//// thumbnail boundary offset x
                             3084 ; 555  |#define THUMBNAIL_X_OFFSET 4            
                             3085 ; 556  |//// thumbnail boundary offset y
                             3086 ; 557  |#define THUMBNAIL_Y_OFFSET 4            
                             3087 ; 558  |
                             3088 ; 559  |#endif // if (!@def(_PROJECT_INC))
                             3089 ; 560  |
                             3090 
                             3092 
                             3093 ; 15   |
                             3094 ; 16   |#ifndef _USB_MEM
                             3095 ; 17   |//if not overwridden, default to the compiler default memory space
                             3096 ; 18   |#define _USB_MEM
                             3097 ; 19   |#endif
                             3098 ; 20   |
                             3099 ; 21   |#define USB_LANGUAGE_ENGLISH 0x0409
                             3100 ; 22   |#define USB_LANGUAGE_CHINESE_PRC 0x0804
                             3101 ; 23   |#define USB_LANGUAGE_CHINESE_TAIWAN 0x0404
                             3102 ; 24   |#define USB_LANGUAGE_JAPANESE 0x0411
                             3103 ; 25   |
                             3104 ; 26   |#define MAX_STRING 30
                             3105 ; 27   |
                             3106 ; 28   |#define  USB_SPEED_FULL                      (0)
                             3107 ; 29   |#define  USB_SPEED_LOW                       (1)
                             3108 ; 30   |#define  USB_SPEED_HIGH                      (2)
                             3109 ; 31   |
TASKING DSP2410 assembler v1.5r1 Build 138 SN 00100122
                                                                                                                            Page  52

M:ADDR CODE           CYCLES LINE SOURCELINE
                             3110 ; 32   |#define EP_FS_MAX_PACKET_SIZE               (64)    
                             3111 ; 33   |
                             3112 ; 34   |#define EP_HS_MAX_PACKET_SIZE               (512)   
                             3113 ; 35   |
                             3114 ; 36   |// Data transferred to devices based on Sigmatel 3500 chip may sometimes be 
                             3115 ; 37   |// corrupted. The corruption occurs when device is connected in USB High Speed 
                             3116 ; 38   |// mode, and size of the transfer in bytes is divisible by 128, but not 
                             3117 ; 39   |// divisible by the packet size. The workaround is implemented in Microsoft MTP 
                             3118 ; 40   |// driver to allow support for those devices.
                             3119 ; 41   |
                             3120 ; 42   |// the bug can corrupt the end of data buffer. It occurs when host sends out a 
                             3121 ; 43   |// short packet that is multiple of 128 bytes. During this scenario the USB core
                             3122 ; 44   |// does writes that are voided (byte enable == all zero), which was an undefined 
                             3123 ; 45   |// capability and thus the gasket did not apply a proper response. This should 
                             3124 ; 46   |// not affect Mass Storage applications because data transfers are 512 bytes and 
                             3125 ; 47   |// scsi commands are < 16 bytes. Other applications with their own driver will
                             3126 ; 48   |// need to pad the packets if they fall into the error case. "What this basically 
                             3127 ; 49   |// boils down to is that any time the host sends a short packet of 128, 256 or
                             3128 ; 50   |// 384 bytes to a high-speed connected player a number of bytes will be corrupted.
                             3129 ; 51   |// This is easiest to reproduce in SendObject commands but can strike any of the 
                             3130 ; 52   |// commands that take an arbitrary amount of data.
                             3131 ; 53   |#define ARC_HS_128_MODULO_BUG               (128)
                             3132 ; 54   |
                             3133 ; 55   |
                             3134 ; 56   |/* Error codes */
                             3135 ; 57   |#define USB_OK                              (0x00)
                             3136 ; 58   |#define USBERR_REGISTER_SERVICE             (0x01)  // Failed to register a service
                             3137 ; 59   |#define USBERR_NO_SERVICE                   (0x02)  // No registered service found 
                             3138 ; 60   |#define USBERR_TX_FAILED                    (0x03)  // Fail to prepare XD descriptor
                             3139 ; 61   |#define USBERR_SIZE_TOO_LARGE               (0x04)  // Number of bytes to transfer is too 
                                  large
                             3140 ; 62   |#define USBERR_EP_INIT_FAILED               (0x05)  // Endpoint init fail
                             3141 ; 63   |#define USBERR_CONFIG_FAILED                (0x06)  // Error reported by the application
                             3142 ; 64   |                                                    // if the new config failed or not sup
                                  ported
                             3143 ; 65   |#define USBERR_DEVICE_NOT_CONFIGURED        (0x07)  // Error reported by the transfer func
                                  tion
                             3144 ; 66   |                                                    // if attempting to transfer while the
                                   device
                             3145 ; 67   |                                                    // is not configured
                             3146 ; 68   |#define USBERR_INIT_FAILED                  (0x08)  // Fail to initialize the USB API
                             3147 ; 69   |
                             3148 ; 70   |
                             3149 ; 71   |/* Endpoint types */
                             3150 ; 72   |#define  USB_CONTROL_ENDPOINT             (0)
                             3151 ; 73   |#define  USB_ISOCHRONOUS_ENDPOINT         (1)
                             3152 ; 74   |#define  USB_BULK_ENDPOINT                (2)
                             3153 ; 75   |#define  USB_INTERRUPT_ENDPOINT           (3)
                             3154 ; 76   |
                             3155 ; 77   |/* End point direction */
                             3156 ; 78   |#define  USB_OUT                         (0)
                             3157 ; 79   |#define  USB_IN                          (1)
                             3158 ; 80   |
                             3159 ; 81   |/* End point packed size */
                             3160 ; 82   |#define  USB_FS_MAX_PACKET_SIZE           (64)
                             3161 ; 83   |#define  USB_HS_BULK_OUT_MAX_PACKET_SIZE  (256)
                             3162 ; 84   |#define  USB_HS_BULK_IN_MAX_PACKET_SIZE   (128)
                             3163 ; 85   |
                             3164 ; 86   |
                             3165 ; 87   |#define  USB_TEST_MODE_TEST_J             (0x01)
                             3166 ; 88   |#define  USB_TEST_MODE_TEST_K             (0x02)
                             3167 ; 89   |#define  USB_TEST_MODE_TEST_SE0_NAK       (0x03)
TASKING DSP2410 assembler v1.5r1 Build 138 SN 00100122
                                                                                                                            Page  53

M:ADDR CODE           CYCLES LINE SOURCELINE
                             3168 ; 90   |#define  USB_TEST_MODE_TEST_PACKET        (0x04)
                             3169 ; 91   |
                             3170 ; 92   |/* Available service types */
                             3171 ; 93   |/* Services 0 through 15 are reserved for endpoints */
                             3172 ; 94   |#define  USB_SERVICE_EP0                  (0x00)
                             3173 ; 95   |#define  USB_SERVICE_EP1                  (0x01)
                             3174 ; 96   |#define  USB_SERVICE_EP2                  (0x02)
                             3175 ; 97   |#define  USB_SERVICE_EP3                  (0x03)
                             3176 ; 98   |#define  USB_SERVICE_EP4                  (0x04)
                             3177 ; 99   |#define  USB_SERVICE_EP5                  (0x05)
                             3178 ; 100  |#define  USB_SERVICE_EP6                  (0x06)
                             3179 ; 101  |#define  USB_SERVICE_EP7                  (0x07)
                             3180 ; 102  |#define  USB_SERVICE_EP8                  (0x08)
                             3181 ; 103  |#define  USB_SERVICE_EP9                  (0x09)
                             3182 ; 104  |#define  USB_SERVICE_EP10                 (0x0a)
                             3183 ; 105  |#define  USB_SERVICE_EP11                 (0x0b)
                             3184 ; 106  |#define  USB_SERVICE_EP12                 (0x0c)
                             3185 ; 107  |#define  USB_SERVICE_EP13                 (0x0d)
                             3186 ; 108  |#define  USB_SERVICE_EP14                 (0x0e)
                             3187 ; 109  |#define  USB_SERVICE_EP15                 (0x0f)
                             3188 ; 110  |#define  USB_SERVICE_BUS_RESET            (0x10)
                             3189 ; 111  |#define  USB_SERVICE_SUSPEND              (0x11)
                             3190 ; 112  |#define  USB_SERVICE_SOF                  (0x12)
                             3191 ; 113  |#define  USB_SERVICE_RESUME               (0x13)
                             3192 ; 114  |#define  USB_SERVICE_SLEEP                (0x14)
                             3193 ; 115  |#define  USB_SERVICE_SPEED_DETECTION      (0x15)
                             3194 ; 116  |#define  USB_SERVICE_TEST                 (0x16)
                             3195 ; 117  |#define  USB_SERVICE_CHANGE_CONFIG        (0x17)
                             3196 ; 118  |#define  USB_SERVICE_CHANGE_IFACE         (0x18)   
                             3197 ; 119  |#define  NON_EP_SERVICES                  (USB_SERVICE_SPEED_DETECTION - USB_SERVICE_EP15)
                                  
                             3198 ; 120  |
                             3199 ; 121  |// This is the maximum service structures allocated 
                             3200 ; 122  |// One for each End point + the common services (non endpoint services) 
                             3201 ; 123  |#define MAX_NUMBER_SERVICES               (MAX_NUM_EP + NON_EP_SERVICES)  
                             3202 ; 124  |
                             3203 ; 125  |#define NUMBER_BYTES_IN_SETUP               (8)
                             3204 ; 126  |
                             3205 ; 127  |// possible values of btStatus on the xd_struct
                             3206 ; 128  |#define  USB_STATUS_TRANSFER_IDLE           (0)
                             3207 ; 129  |#define  USB_STATUS_TRANSFER_SUCCESS        (1)            
                             3208 ; 130  |#define  USB_STATUS_TRANSFER_ACCEPTED       (2)
                             3209 ; 131  |#define  USB_STATUS_TRANSFER_IN_PROGRESS    (3)
                             3210 ; 132  |#define  USB_STATUS_TRANSFER_ERROR          (4)
                             3211 ; 133  |
                             3212 ; 134  |// types of status set/returned by set_status() and get_status()
                             3213 ; 135  |#define  USB_STATUS_DEVICE_STATE          (0x01)
                             3214 ; 136  |#define  USB_STATUS_INTERFACE             (0x02)
                             3215 ; 137  |#define  USB_STATUS_ADDRESS               (0x03)
                             3216 ; 138  |#define  USB_STATUS_CURRENT_CONFIG        (0x04)
                             3217 ; 139  |#define  USB_STATUS_SOF_COUNT             (0x05)
                             3218 ; 140  |#define  USB_STATUS                       (0x06)
                             3219 ; 141  |#define  USB_STATUS_TEST_MODE             (0x07)
                             3220 ; 142  |#define  USB_STATUS_DEVICE_SPEED          (0x08)  
                             3221 ; 143  |#define  USB_STATUS_DEVICE_TEST           (0x09)  
                             3222 ; 144  |#define  USB_STATUS_CURRENT_IFACE         (0x0a)
                             3223 ; 145  |#define  USB_STATUS_CONNECTION            (0x0b)  
                             3224 ; 146  |// For status endpoint, the endpoint number is coded in the less significant nibble
                             3225 ; 147  |#define  USB_STATUS_ENDPOINT              (0x10)
                             3226 ; 148  |#define  USB_STATUS_ENDPOINT_NUMBER_MASK  (0x0F)
                             3227 ; 149  |
                             3228 ; 150  |#define USB_MAX_SIZE_PER_TRANSFER       (0x4000)    // This is the maximum size that
TASKING DSP2410 assembler v1.5r1 Build 138 SN 00100122
                                                                                                                            Page  54

M:ADDR CODE           CYCLES LINE SOURCELINE
                             3229 ; 151  |                                                    // we allow per transfer
                             3230 ; 152  |
                             3231 ; 153  |//Possible states the device can be in
                             3232 ; 154  |#define  USB_STATE_UNKNOWN                   (0xff)
                             3233 ; 155  |#define  USB_STATE_UNPLUGGED                 (0x05) // USB Cable unplugged
                             3234 ; 156  |#define  USB_STATE_PLUGGED                   (0x04) // USB Cable inserted
                             3235 ; 157  |#define  USB_STATE_POWERED                   (0x03)
                             3236 ; 158  |#define  USB_STATE_DEFAULT                   (0x02)
                             3237 ; 159  |#define  USB_STATE_ADDRESSED                 (0x01)
                             3238 ; 160  |#define  USB_STATE_CONFIGURED                (0x00)
                             3239 ; 161  |#define  USB_STATE_SUSPENDED                 (0x80)
                             3240 ; 162  |
                             3241 ; 163  |// Possible states the connection can be in
                             3242 ; 164  |//#define USB_STATE_UNKNOWN                 (0xff)
                             3243 ; 165  |#define USB_CONNECTED                       (0x00)
                             3244 ; 166  |#define USB_DISCONNECTED                    (0x01)
                             3245 ; 167  |
                             3246 ; 168  |
                             3247 ; 169  |
                             3248 ; 170  |typedef union
                             3249 ; 171  |{
                             3250 ; 172  |    struct
                             3251 ; 173  |    {
                             3252 ; 174  |        int Recipient               : 5;
                             3253 ; 175  |        int Type                    : 2;
                             3254 ; 176  |        int DataTransferDirection   : 1;
                             3255 ; 177  |        int Request                 : 8;
                             3256 ; 178  |        int                         : 8;
                             3257 ; 179  |    } B;
                             3258 ; 180  |    
                             3259 ; 181  |    int I;
                             3260 ; 182  |} USBRequestType ;
                             3261 
                             3275 
                             3276 ; 183  |
                             3277 ; 184  |typedef struct {
                             3278 ; 185  |   BYTE     bValid;
                             3279 ; 186  |   USBRequestType RequestType;
                             3280 ; 187  |   BYTE     btRequest;
                             3281 ; 188  |   WORD     wValue;
                             3282 ; 189  |   WORD     wIndex;
                             3283 ; 190  |   WORD     wLength;
                             3284 ; 191  |    } USB_SetupData;
                             3285 ; 192  |
                             3286 ; 193  |// Descriptor sizes in bytes
                             3287 ; 194  |#define SIZE_DEVICE_DESCRIPTOR_IN_BYTES     (18)
                             3288 ; 195  |#define SIZE_DEVICE_DESCRIPTOR_IN_WORDS     (6)
                             3289 ; 196  |#define SIZE_DEVICE_QUALIFIER_DESCRIPTOR_IN_BYTES   (10)
                             3290 ; 197  |#define SIZE_DEVICE_QUALIFIER_DESCRIPTOR_IN_WORDS   (4)
                             3291 ; 198  |#define SIZE_CONFIG_DESCRIPTOR_IN_BYTES     (9)
                             3292 ; 199  |#define SIZE_CONFIG_DESCRIPTOR_IN_WORDS     (3)
                             3293 ; 200  |#define SIZE_INTERFACE_DESCRIPTOR_IN_BYTES  (9)
                             3294 ; 201  |#define SIZE_INTERFACE_DESCRIPTOR_IN_WORDS  (3)
                             3295 ; 202  |#define SIZE_ENDPOINT_DESCRIPTOR_IN_BYTES   (7)
                             3296 ; 203  |
                             3297 ; 204  |
                             3298 ; 205  |// Descriptor types
                             3299 ; 206  |#define DESCRIPTOR_TYPE_DEVICE              (0x01)
                             3300 ; 207  |#define DESCRIPTOR_TYPE_CONFIG              (0x02)
                             3301 ; 208  |#define DESCRIPTOR_TYPE_STRING              (0x03)
                             3302 ; 209  |#define DESCRIPTOR_TYPE_INTERFACE           (0x04)
                             3303 ; 210  |#define DESCRIPTOR_TYPE_ENDPOINT            (0x05)
TASKING DSP2410 assembler v1.5r1 Build 138 SN 00100122
                                                                                                                            Page  55

M:ADDR CODE           CYCLES LINE SOURCELINE
                             3304 ; 211  |#define DESCRIPTOR_TYPE_DEVICE_QUALIFIER    (0x06)
                             3305 ; 212  |#define DESCRIPTOR_TYPE_OTHER_SPEED_CONFIG  (0x07)
                             3306 ; 213  |#define DESCRIPTOR_TYPE_INTERFACE_POWER     (0x08)
                             3307 ; 214  |
                             3308 ; 215  |
                             3309 ; 216  |#define USB_REQUEST_DIRECTION_HOST_TO_DEVICE    ((WORD)0x000000)
                             3310 ; 217  |#define USB_REQUEST_DIRECTION_DEVICE_TO_HOST    ((WORD)0x000001)
                             3311 ; 218  |
                             3312 ; 219  |#define USB_REQUEST_TYPE_STANDARD               ((WORD)0x000000)
                             3313 ; 220  |#define USB_REQUEST_TYPE_CLASS                  ((WORD)0x000001)
                             3314 ; 221  |#define USB_REQUEST_TYPE_VENDOR                 ((WORD)0x000002)
                             3315 ; 222  |#define USB_REQUEST_TYPE_RESERVED               ((WORD)0x000003)
                             3316 ; 223  |
                             3317 ; 224  |#define USB_REQUEST_RECIPIENT_DEVICE            ((WORD)0x000000)
                             3318 ; 225  |#define USB_REQUEST_RECIPIENT_INTERFACE         ((WORD)0x000001)
                             3319 ; 226  |#define USB_REQUEST_RECIPIENT_ENDPOINT          ((WORD)0x000002)
                             3320 ; 227  |#define USB_REQUEST_RECIPIENT_OTHER             ((WORD)0x000003)
                             3321 ; 228  |
                             3322 ; 229  |#define USB_REQUEST_STANDARD_GET_STATUS         ((WORD)0x000000)
                             3323 ; 230  |#define USB_REQUEST_STANDARD_CLEAR_FEATURE      ((WORD)0x000001)
                             3324 ; 231  |#define USB_REQUEST_STANDARD_RESERVED_1         ((WORD)0x000002)
                             3325 ; 232  |#define USB_REQUEST_STANDARD_SET_FEATURE        ((WORD)0x000003)
                             3326 ; 233  |#define USB_REQUEST_STANDARD_RESERVED_2         ((WORD)0x000004)
                             3327 ; 234  |#define USB_REQUEST_STANDARD_SET_ADDRESS        ((WORD)0x000005)
                             3328 ; 235  |#define USB_REQUEST_STANDARD_GET_DESCRIPTOR     ((WORD)0x000006)
                             3329 ; 236  |#define USB_REQUEST_STANDARD_SET_DESCRIPTOR     ((WORD)0x000007)
                             3330 ; 237  |#define USB_REQUEST_STANDARD_GET_CONFIGURATION  ((WORD)0x000008)
                             3331 ; 238  |#define USB_REQUEST_STANDARD_SET_CONFIGURATION  ((WORD)0x000009)
                             3332 ; 239  |#define USB_REQUEST_STANDARD_GET_INTERFACE      ((WORD)0x00000A)
                             3333 ; 240  |#define USB_REQUEST_STANDARD_SET_INTERFACE      ((WORD)0x00000B)
                             3334 ; 241  |#define USB_REQUEST_STANDARD_SYNCH_FRAME        ((WORD)0x00000C)
                             3335 ; 242  |
                             3336 ; 243  |#define USB_CLEAR_FEATURE_ENDPOINT_HALT         (0)
                             3337 ; 244  |#define USB_CLEAR_FEATURE_REMOTE_WAKEUP         (1)
                             3338 ; 245  |
                             3339 ; 246  |
                             3340 ; 247  |// Struct Device Descriptor
                             3341 ; 248  |typedef struct {
                             3342 ; 249  |    BYTE    bLength;                // (0) Size of this descriptor in bytes (18)
                             3343 ; 250  |    BYTE    btDescriptorType;       // (1) Device descriptor type (1)
                             3344 ; 251  |    BYTE    btBcdUsbLsb;            // (2) USB specification release number (for version 2
                                  .00 0x00)
                             3345 ; 252  |    BYTE    btBcdUsbMsb;            // (3)                                  (for version 2
                                  .00 0x02)     
                             3346 ; 253  |    BYTE    btDeviceClass;          // (4) Class code
                             3347 ; 254  |    BYTE    btDeviceSubclass;       // (5) Subclass code
                             3348 ; 255  |    BYTE    btDeviceProtocol;       // (6) Protocol code
                             3349 ; 256  |    BYTE    btMaxPacketSize0;       // (7) Maximum packet size for endpoint 0 (8, 16, 32 o
                                  r 64)
                             3350 ; 257  |    BYTE    btIdVendorLsb;          // (8) Vendor Id
                             3351 ; 258  |    BYTE    btIdVendorMsb;          // (9)
                             3352 ; 259  |    BYTE    btIdProductLsb;         // (10) Product Id
                             3353 ; 260  |    BYTE    btIdProductMsb;         // (11)
                             3354 ; 261  |    BYTE    btBcdReleaseLsb;        // (12) Device release number in BCD
                             3355 ; 262  |    BYTE    btBcdReleaseMsb;        // (13)
                             3356 ; 263  |    BYTE    btIndexManufacturer;    // (14) Index of string descriptor describing Manufact
                                  urer
                             3357 ; 264  |    BYTE    btIndexProduct;         // (15) Index of string descriptor describing Product
                             3358 ; 265  |    BYTE    btIndexSerialNumber;    // (16) Index of string descriptor describing Device S
                                  erial Number
                             3359 ; 266  |    BYTE    btNumConfigurations;    // (17) Number of possible configurations
                             3360 ; 267  |} Struct_Standard_Dev_Desc;
TASKING DSP2410 assembler v1.5r1 Build 138 SN 00100122
                                                                                                                            Page  56

M:ADDR CODE           CYCLES LINE SOURCELINE
                             3361 ; 268  |
                             3362 ; 269  |// Struct Device Qualifier Descriptor
                             3363 ; 270  |typedef struct {
                             3364 ; 271  |    BYTE    bLength;                // (0) Size of this descriptor in bytes (10)
                             3365 ; 272  |    BYTE    btDescriptorType;       // (1) Device descriptor type (6)
                             3366 ; 273  |    BYTE    btBcdUsbLsb;            // (2) USB specification release number (for version 2
                                  .00 0x00)
                             3367 ; 274  |    BYTE    btBcdUsbMsb;            // (3)                                  (for version 2
                                  .00 0x02)     
                             3368 ; 275  |    BYTE    btDeviceClass;          // (4) Class code
                             3369 ; 276  |    BYTE    btDeviceSubclass;       // (5) Subclass code
                             3370 ; 277  |    BYTE    btDeviceProtocol;       // (6) Protocol code
                             3371 ; 278  |    BYTE    btMaxPacketSize0;       // (7) Maximum packet size for endpoint 0 other speed 
                                  (8, 16, 32 or 64)
                             3372 ; 279  |    BYTE    btNumConfigurations;    // (8) Number of other-speed possible configurations
                             3373 ; 280  |    BYTE    btReserved;             // (9) Reserved for future use, must be 0
                             3374 ; 281  |} Struct_Dev_Qualifier_Desc;
                             3375 ; 282  |
                             3376 ; 283  |// Struct Configuration Descriptor
                             3377 ; 284  |typedef struct {
                             3378 ; 285  |    BYTE    bLength;                // (0) Size of this descriptor in bytes (9)
                             3379 ; 286  |    BYTE    btDescriptorType;       // (1) Device descriptor type (2 or 7)
                             3380 ; 287  |    BYTE    btTotalLengthLsb;       // (2) Total length of data returned for this config.
                             3381 ; 288  |    BYTE    btTotalLengthMsb;       // (3)                                  
                             3382 ; 289  |    BYTE    btNumInterfaces;        // (4) Number of Interfaces supported by this configur
                                  ation
                             3383 ; 290  |    BYTE    btConfigurationValue;   // (5) Value to use as an argument to the SetConfigura
                                  tion() request
                             3384 ; 291  |    BYTE    btIndexConfiguration;   // (6) Index of string descriptor describing this conf
                                  iguration
                             3385 ; 292  |    BYTE    btBitMapAttributes;     // (7) Configuration Characteristics
                             3386 ; 293  |                                    //     D7:      Reserved (set to one)
                             3387 ; 294  |                                    //     D6:      Self-powered
                             3388 ; 295  |                                    //     D5:      Remote Wakeup
                             3389 ; 296  |                                    //     D4..0:   Reserved (reset to zero)        
                             3390 ; 297  |    BYTE    btMaxPower;             // (8) Maximum power consumption expressed in 2mA unit
                                  s.
                             3391 ; 298  |} Struct_Standard_Config_Desc, Struct_Other_Speed_Config_Desc;
                             3392 ; 299  |
                             3393 ; 300  |// Struct Interface Descriptor
                             3394 ; 301  |typedef struct {
                             3395 ; 302  |    BYTE    bLength;                // (0) Size of this descriptor in bytes (9)
                             3396 ; 303  |    BYTE    btDescriptorType;       // (1) Device descriptor type (4)
                             3397 ; 304  |    BYTE    btInterfaceNum;         // (2) Number of this interface. Zero-based value.
                             3398 ; 305  |    BYTE    btAlternateSetting;     // (3)                                  
                             3399 ; 306  |    BYTE    btNumEndpoints;         // (4) Number of endpointsused by this interface (excl
                                  uding endpoint 0).
                             3400 ; 307  |    BYTE    btInterfaceClass;       // (5) Class code
                             3401 ; 308  |    BYTE    btInterfaceSubClass;    // (6) Sub Class code
                             3402 ; 309  |    BYTE    btInterfaceProtocol;    // (7) Protocol Code
                             3403 ; 310  |    BYTE    btIndexInterface;       // (8) Index of string descriptor describing this inte
                                  rface
                             3404 ; 311  |} Struct_Standard_Interface_Desc;
                             3405 ; 312  |
                             3406 ; 313  |// Struct Endpoint Descriptor
                             3407 ; 314  |typedef struct {
                             3408 ; 315  |    BYTE    bLength;                // (0) Size of this descriptor in bytes (7)
                             3409 ; 316  |    BYTE    btDescriptorType;       // (1) Device descriptor type (5)
                             3410 ; 317  |    BYTE    btEndpointAddress;      // (2) Address of the endpoint on the USB device descr
                                  ibed by this descriptor
                             3411 ; 318  |                                    //      Bit 3..0: Endpoint number
                             3412 ; 319  |                                    //      Bit 6..4: Reserved, reset to zero
TASKING DSP2410 assembler v1.5r1 Build 138 SN 00100122
                                                                                                                            Page  57

M:ADDR CODE           CYCLES LINE SOURCELINE
                             3413 ; 320  |                                    //      Bit 7:    Direction. Ignored for control endpo
                                  ints (0 OUT, 1 IN)
                             3414 ; 321  |    BYTE    btBitMapAttributes;     // (3) Endpoint attributes
                             3415 ; 322  |                                    //      bits 1..0: Transfer Type (00 Control, 01 Iso, 
                                  10 Bulk, 11 Int)
                             3416 ; 323  |                                    //      bits 5..2: If not an iso endpoints, they are r
                                  eserved and must be reset to zero.
                             3417 ; 324  |                                    //      bits 7..6: Reserved bits, must be reset to zer
                                  o.                                    
                             3418 ; 325  |    BYTE    btMaxPacketSizeLsb;     // (4) Maximum packet size. Refer to standard for bits
                                   specification
                             3419 ; 326  |    BYTE    btMaxPacketSizeMsb;     // (5)
                             3420 ; 327  |    BYTE    btInterval;             // (6) Interval for polling endpoint for data transfer
                                  s (refer to standard)
                             3421 ; 328  |} Struct_Standard_Endpoint_Desc;
                             3422 ; 329  |
                             3423 ; 330  |typedef struct {
                             3424 ; 331  |    BYTE    btLength;                   // (0) Size of this descriptor in bytes (2*MAX_USB
                                  _LANG + 2)
                             3425 ; 332  |    BYTE    btDescriptorType;           // (1) String descriptor type (3)
                             3426 ; 333  |    BYTE    btString[MAX_STRING*2];       
                             3427 ; 334  |} Struct_String_Desc;
                             3428 ; 335  |
                             3429 ; 336  |//
                             3430 ; 337  |// Externals
                             3431 ; 338  |//
                             3432 ; 339  |extern void _reentrant usb_dci_chip_enable (void);
                             3433 ; 340  |extern void _reentrant usb_dci_shutdown(void);
                             3434 ; 341  |
                             3435 ; 342  |BYTE _reentrant usb_device_init(void);
                             3436 ; 343  |void _inline usb_device_shutdown(void)
                             3437 ; 344  |{
                             3438 ; 345  |    usb_dci_shutdown();
                             3439 ; 346  |}
                             3440 ; 347  |
                             3441 ; 348  |BYTE _reentrant usb_device_register_service(BYTE btType, void (* Service)(BOOL bSetup, BYT
                                  E btDirection, BYTE _USB_MEM * pbtBuffer, WORD wLength,WORD wPrivateData)); 
                             3442 ; 349  |//Remove unused function usb_device_get_service() to reclain _P memroy.
                             3443 ; 350  |//BYTE _reentrant usb_device_get_service(BYTE btType, void (* Service)(BOOL bSetup, BYTE b
                                  tDirection, BYTE _USB_MEM * pbtBuffer, WORD wLength)); 
                             3444 ; 351  |
                             3445 ; 352  |BYTE _reentrant usb_device_init_endpoint(BYTE btEndpoint, USHORT usMaxPacketSize, BYTE btD
                                  irection, BYTE btType, BOOL bFlag);
                             3446 ; 353  |
                             3447 ; 354  |extern USB_SetupData *_reentrant usb_dci_get_setup_data(BYTE btEndpoint);
                             3448 
                             3457 
                             3458 ; 355  |#define usb_device_read_setup_data(btEndpoint) usb_dci_get_setup_data(btEndpoint)
                             3459 ; 356  |
                             3460 ; 357  |void _reentrant usb_device_get_status(BYTE btType, USHORT * pusStatus);
                             3461 ; 358  |void _reentrant usb_device_set_status(BYTE btType, USHORT usStatus);
                             3462 ; 359  |BYTE _reentrant usb_device_get_transfer_status(BYTE btEndpoint, BYTE btDirection);
                             3463 ; 360  |
                             3464 ; 361  |extern void _reentrant usb_dci_stall_endpoint(BYTE btEndpoint, BYTE btDirection);
                             3465 ; 362  |#define usb_device_stall_endpoint(btEndpoint, btDirection) usb_dci_stall_endpoint((btEndpo
                                  int), (btDirection))
                             3466 ; 363  |
                             3467 ; 364  |extern void _reentrant usb_dci_unstall_endpoint(BYTE btEndpoint, BYTE btDirection);
                             3468 ; 365  |#define usb_device_unstall_endpoint(btEndpoint, btDirection) usb_dci_unstall_endpoint((btE
                                  ndpoint), (btDirection))
                             3469 ; 366  |
                             3470 ; 367  |extern void _reentrant usb_dci_finish_transaction(BYTE btEndpoint);
TASKING DSP2410 assembler v1.5r1 Build 138 SN 00100122
                                                                                                                            Page  58

M:ADDR CODE           CYCLES LINE SOURCELINE
                             3471 ; 368  |#define usb_device_finish_transaction(btEndpoint) usb_dci_finish_transaction(btEndpoint);
                             3472 ; 369  |
                             3473 ; 370  |////////////////////////////////////////////////////////////////////////////////
                             3474 ; 371  |//
                             3475 ; 372  |//>  Name:          usb_device_enable
                             3476 ; 373  |//
                             3477 ; 374  |//   Type:          Function
                             3478 ; 375  |//
                             3479 ; 376  |//   Description:   Enables the USB device for transfers
                             3480 ; 377  |//
                             3481 ; 378  |//   Inputs:        none
                             3482 ; 379  |//
                             3483 ; 380  |//   Outputs:       USB_OK or error code
                             3484 ; 381  |//
                             3485 ; 382  |//   Notes:         none
                             3486 ; 383  |//<
                             3487 ; 384  |////////////////////////////////////////////////////////////////////////////////
                             3488 ; 385  |void _inline usb_device_enable(void)
                             3489 ; 386  |{
                             3490 ; 387  |    usb_dci_chip_enable();
                             3491 ; 388  |}
                             3492 ; 389  |
                             3493 ; 390  |void _reentrant usb_device_release(void);
                             3494 ; 391  |void _reentrant usb_device_hold(void);
                             3495 ; 392  |BYTE _reentrant usb_device_is_hold(void);
                             3496 ; 393  |void _reentrant usb_device_data_phase_required(void);
                             3497 ; 394  |
                             3498 ; 395  |BOOL _reentrant usb_device_is_first_init(void);
                             3499 ; 396  |void _reentrant usb_device_set_first_init(void);
                             3500 ; 397  |void _reentrant usb_device_clear_first_init(void);
                             3501 ; 398  |
                             3502 ; 399  |WORD _reentrant usb_get_current_limit(void);
                             3503 ; 400  |RETCODE _reentrant usb_set_current_limit(WORD);
                             3504 ; 401  |
                             3505 ; 402  |////////////////////////////////////////////////////////////////////
                             3506 ; 403  |extern BYTE _reentrant usb_dci_get_endpoint_status(BYTE btEndpoint);
                             3507 ; 404  |#define usb_device_get_endpoint_status(btEndpoint) usb_dci_get_endpoint_status(btEndpoint)
                                  
                             3508 ; 405  |
                             3509 ; 406  |#define USB_ENDPOINT_STATUS_OK                          0
                             3510 ; 407  |#define USB_ENDPOINT_STATUS_STALLED                     1
                             3511 ; 408  |#define USB_ENDPOINT_STATUS_RECIEVED_UNSTALL_REQUEST    2
                             3512 ; 409  |// WHQL
                             3513 ; 410  |#define USB_ENDPOINT_STATUS_HOST_STALLED                3
                             3514 ; 411  |////////////////////////////////////////////////////////////////////
                             3515 ; 412  |
                             3516 ; 413  |
                             3517 ; 414  |BYTE _reentrant usb_device_send_data(BYTE btEndpoint, WORD _X * pbtStmpWordAdd, BYTE btByt
                                  eOffset, USHORT usSize, WORD wPrivateData, BOOL bIsDataPhase);
                             3518 ; 415  |BYTE _reentrant usb_device_recv_data(BYTE btEndpoint, WORD _X * pbtStmpWordAdd, BYTE btByt
                                  eOffset, USHORT usSize, WORD wPrivateData, BOOL bIsDataPhase);
                             3519 ; 416  |void _reentrant ch9ServiceEp0(BOOL bSetup, BYTE btDirection, WORD _X *pbtBuffer, WORD wLen
                                  gth,WORD wPrivateData);
                             3520 ; 417  |BYTE _reentrant usb_device_transfer_data(BYTE btEndpoint, WORD _X* pbtStmpWordAdd, 
                             3521 ; 418  |                                         BYTE btByteOffset, USHORT usSize, WORD wPrivateDa
                                  ta, 
                             3522 ; 419  |                                         BOOL bIsDataPhase, WORD wDirection);
                             3523 ; 420  |
                             3524 ; 421  |#ifndef CUSTOMIZE_UNICODE
                             3525 ; 422  |extern const BYTE g_Manufacturer[];
                             3526 ; 423  |extern const BYTE g_ProductName[];
                             3527 ; 424  |extern const BYTE g_ConfigString[];
TASKING DSP2410 assembler v1.5r1 Build 138 SN 00100122
                                                                                                                            Page  59

M:ADDR CODE           CYCLES LINE SOURCELINE
                             3528 ; 425  |extern const BYTE g_Interface0String[];
                             3529 ; 426  |extern const BYTE g_Interface1String[];
                             3530 ; 427  |extern const BYTE g_MSOSDescriptorString[];
                             3531 ; 428  |#else   // CUSTOMIZE_UNICODE
                             3532 ; 429  |extern const WORD g_Manufacturer[];
                             3533 ; 430  |extern const WORD g_ProductName[];
                             3534 ; 431  |extern const WORD g_ConfigString[];
                             3535 ; 432  |extern const WORD g_Interface0String[];
                             3536 ; 433  |extern const WORD g_Interface1String[];
                             3537 ; 434  |extern const WORD g_MSOSDescriptorString[];
                             3538 ; 435  |#endif
                             3539 ; 436  |extern WORD g_LanguageList[];
                             3540 ; 437  |
                             3541 ; 438  |extern const BYTE g_SCSIVendorID[];
                             3542 ; 439  |extern const BYTE g_SCSIProductID[];
                             3543 ; 440  |extern void *g_pStrings[];
                             3544 ; 441  |
                             3545 ; 442  |extern WORD g_wUSBVendorID;
                             3546 ; 443  |extern WORD g_wUSBProductID;
                             3547 ; 444  |extern WORD g_wUSBReleaseID;
                             3548 ; 445  |
                             3549 ; 446  |#endif
                             3550 ; 447  |/* EOF */
                             3551 ; 448  |
                             3552 
                             3554 
                             3555 ; 17   |#include "scsi.h"
                             3556 
                             3558 
                             3559 ; 1    |////////////////////////////////////////////////////////////////////////////////
                             3560 ; 2    |// Copyright(C) SigmaTel, Inc. 2000-2001
                             3561 ; 3    |//
                             3562 ; 4    |// Filename: scsi.h
                             3563 ; 5    |// Description: 
                             3564 ; 6    |////////////////////////////////////////////////////////////////////////////////
                             3565 ; 7    |
                             3566 ; 8    |#ifndef _SCSI_H
                             3567 ; 9    |#define _SCSI_H
                             3568 ; 10   |
                             3569 ; 11   |#include "types.h"
                             3570 
                             3572 
                             3573 ; 1    |////////////////////////////////////////////////////////////////////////////////
                             3574 ; 2    |// Copyright(C) SigmaTel, Inc. 2000-2004
                             3575 ; 3    |//
                             3576 ; 4    |// Filename: types.h
                             3577 ; 5    |// Description: Standard data types
                             3578 ; 6    |////////////////////////////////////////////////////////////////////////////////
                             3579 ; 7    |
                             3580 ; 8    |#ifndef _TYPES_H
                             3581 ; 9    |#define _TYPES_H
                             3582 ; 10   |
                             3583 ; 11   |// TODO:  move this outta here!
                             3584 ; 12   |#if !defined(NOERROR)
                             3585 ; 13   |#define NOERROR 0
                             3586 ; 14   |#define SUCCESS 0
                             3587 ; 15   |#endif 
                             3588 ; 16   |#if !defined(SUCCESS)
                             3589 ; 17   |#define SUCCESS  0
                             3590 ; 18   |#endif
                             3591 ; 19   |#if !defined(ERROR)
                             3592 ; 20   |#define ERROR   -1
TASKING DSP2410 assembler v1.5r1 Build 138 SN 00100122
                                                                                                                            Page  60

M:ADDR CODE           CYCLES LINE SOURCELINE
                             3593 ; 21   |#endif
                             3594 ; 22   |#if !defined(FALSE)
                             3595 ; 23   |#define FALSE 0
                             3596 ; 24   |#endif
                             3597 ; 25   |#if !defined(TRUE)
                             3598 ; 26   |#define TRUE  1
                             3599 ; 27   |#endif
                             3600 ; 28   |
                             3601 ; 29   |#if !defined(NULL)
                             3602 ; 30   |#define NULL 0
                             3603 ; 31   |#endif
                             3604 ; 32   |
                             3605 ; 33   |#define MAX_INT     0x7FFFFF
                             3606 ; 34   |#define MAX_LONG    0x7FFFFFffffff
                             3607 ; 35   |        // max positive unsigned long value: -1 == 0xFFFFFFffffff
                             3608 ; 36   |#define MAX_ULONG   (-1) 
                             3609 ; 37   |
                             3610 ; 38   |#define WORD_SIZE   24              // word size in bits
                             3611 ; 39   |#define BYTES_PER_WORD 3            // 8 bit bytes
                             3612 ; 40   |
                             3613 ; 41   |
                             3614 ; 42   |#define BYTE    unsigned char       // btVarName
                             3615 ; 43   |#define CHAR    signed char         // cVarName
                             3616 ; 44   |#define USHORT  unsigned short      // usVarName
                             3617 ; 45   |#define SHORT   unsigned short      // sVarName
                             3618 ; 46   |#define WORD    unsigned int        // wVarName
                             3619 ; 47   |#define INT     signed int          // iVarName
                             3620 ; 48   |#define DWORD   unsigned long       // dwVarName
                             3621 ; 49   |#define LONG    signed long         // lVarName
                             3622 ; 50   |#define BOOL    unsigned int        // bVarName
                             3623 ; 51   |#define FRACT   _fract              // frVarName
                             3624 ; 52   |#define LFRACT  long _fract         // lfrVarName
                             3625 ; 53   |#define CIRC    _circ               // cp<type prefix>VarName (see below)
                             3626 ; 54   |#define FLOAT   float               // fVarName
                             3627 ; 55   |#define DBL     double              // dVarName
                             3628 ; 56   |#define ENUM    enum                // eVarName
                             3629 ; 57   |#define CMX     _complex            // cmxVarName
                             3630 ; 58   |typedef WORD UCS3;                   // 
                             3631 ; 59   |
                             3632 ; 60   |#define UINT16  unsigned short
                             3633 ; 61   |#define UINT8   unsigned char   
                             3634 ; 62   |#define UINT32  unsigned long
                             3635 ; 63   |#define UINT64  unsigned long   // need to figure out how to do 64 bit values.  Or port ex
                                  isiting code to only use 48 bit
                             3636 ; 64   |#define INT64   unsigned long   // need to figure out how to do 64 bit values.  Or port ex
                                  isiting code to only use 48 bit
                             3637 ; 65   |#define WCHAR   UINT16
                             3638 ; 66   |
                             3639 ; 67   |//UINT128 is 16 bytes or 6 words
                             3640 ; 68   |typedef struct UINT128_3500 {   
                             3641 ; 69   |    int val[6];     
                             3642 ; 70   |} UINT128_3500;
                             3643 ; 71   |
                             3644 ; 72   |#define UINT128   UINT128_3500
                             3645 ; 73   |
                             3646 ; 74   |// Little endian word packed byte strings:   
                             3647 ; 75   |//      _packed BYTE bTextVarName[]="a string";  bText is a packed byte string prefix
                             3648 ; 76   |// Convert to big endian words by reordering bytes from high to low using swizzle.
                             3649 ; 77   |// Little endian word packed byte strings:   
                             3650 ; 78   |//      _packed BYTE bTextVarName[]="a string";  bText is a packed byte string prefix
                             3651 ; 79   |// Convert to big endian words by reordering bytes from high to low using swizzle.
                             3652 ; 80   |
TASKING DSP2410 assembler v1.5r1 Build 138 SN 00100122
                                                                                                                            Page  61

M:ADDR CODE           CYCLES LINE SOURCELINE
                             3653 ; 81   |// Declare Memory Spaces To Use When Coding
                             3654 ; 82   |// A. Sector Buffers
                             3655 ; 83   |#define SECTOR_BUFFER_MEM_X _X
                             3656 ; 84   |#define SECTOR_BUFFER_MEM_Y _Y
                             3657 ; 85   |#define SECTOR_BUFFER_MEM SECTOR_BUFFER_MEM_X
                             3658 ; 86   |typedef WORD SECTOR_BUFFER_MEM SECTOR_BUFFER;
                             3659 ; 87   |typedef SECTOR_BUFFER * P_SECTOR_BUFFER;
                             3660 ; 88   |// B. Media DDI Memory
                             3661 ; 89   |#define MEDIA_DDI_MEM _Y
                             3662 ; 90   |
                             3663 ; 91   |
                             3664 ; 92   |
                             3665 ; 93   |// Pointers to linear structures are labeled as: p<type prefix>VarName
                             3666 ; 94   |// Examples of circular pointers:
                             3667 ; 95   |//    INT CIRC cpiVarName
                             3668 ; 96   |//    DWORD CIRC cpdwVarName
                             3669 ; 97   |
                             3670 ; 98   |#define RETCODE INT                 // rcVarName
                             3671 ; 99   |
                             3672 ; 100  |// generic bitfield structure
                             3673 ; 101  |struct Bitfield {
                             3674 ; 102  |    unsigned int B0  :1;
                             3675 ; 103  |    unsigned int B1  :1;
                             3676 ; 104  |    unsigned int B2  :1;
                             3677 ; 105  |    unsigned int B3  :1;
                             3678 ; 106  |    unsigned int B4  :1;
                             3679 ; 107  |    unsigned int B5  :1;
                             3680 ; 108  |    unsigned int B6  :1;
                             3681 ; 109  |    unsigned int B7  :1;
                             3682 ; 110  |    unsigned int B8  :1;
                             3683 ; 111  |    unsigned int B9  :1;
                             3684 ; 112  |    unsigned int B10 :1;
                             3685 ; 113  |    unsigned int B11 :1;
                             3686 ; 114  |    unsigned int B12 :1;
                             3687 ; 115  |    unsigned int B13 :1;
                             3688 ; 116  |    unsigned int B14 :1;
                             3689 ; 117  |    unsigned int B15 :1;
                             3690 ; 118  |    unsigned int B16 :1;
                             3691 ; 119  |    unsigned int B17 :1;
                             3692 ; 120  |    unsigned int B18 :1;
                             3693 ; 121  |    unsigned int B19 :1;
                             3694 ; 122  |    unsigned int B20 :1;
                             3695 ; 123  |    unsigned int B21 :1;
                             3696 ; 124  |    unsigned int B22 :1;
                             3697 ; 125  |    unsigned int B23 :1;
                             3698 ; 126  |};
                             3699 ; 127  |
                             3700 ; 128  |union BitInt {
                             3701 ; 129  |        struct Bitfield B;
                             3702 ; 130  |        int        I;
                             3703 ; 131  |};
                             3704 ; 132  |
                             3705 ; 133  |#define MAX_MSG_LENGTH 10
                             3706 ; 134  |struct CMessage
                             3707 ; 135  |{
                             3708 ; 136  |        unsigned int m_uLength;
                             3709 ; 137  |        unsigned int m_uMsg[MAX_MSG_LENGTH];
                             3710 ; 138  |};
                             3711 ; 139  |
                             3712 ; 140  |typedef struct {
                             3713 ; 141  |    WORD m_wLength;
                             3714 ; 142  |    WORD m_wMessage;
TASKING DSP2410 assembler v1.5r1 Build 138 SN 00100122
                                                                                                                            Page  62

M:ADDR CODE           CYCLES LINE SOURCELINE
                             3715 ; 143  |    WORD m_wParams[MAX_MSG_LENGTH];
                             3716 ; 144  |} Message;
                             3717 ; 145  |
                             3718 ; 146  |struct MessageQueueDescriptor
                             3719 ; 147  |{
                             3720 ; 148  |        int *m_pBase;
                             3721 ; 149  |        int m_iModulo;
                             3722 ; 150  |        int m_iSize;
                             3723 ; 151  |        int *m_pHead;
                             3724 ; 152  |        int *m_pTail;
                             3725 ; 153  |};
                             3726 ; 154  |
                             3727 ; 155  |struct ModuleEntry
                             3728 ; 156  |{
                             3729 ; 157  |    int m_iSignaledEventMask;
                             3730 ; 158  |    int m_iWaitEventMask;
                             3731 ; 159  |    int m_iResourceOfCode;
                             3732 ; 160  |    struct MessageQueueDescriptor *m_pMessageQueue;
                             3733 ; 161  |    int _asmfunc (*m_pProcessEntryPoint)(union WaitMask Signals,struct MessageQueueDescrip
                                  tor *);
                             3734 ; 162  |    int _asmfunc (*m_pInitFunction)(struct MessageQueueDescriptor *);
                             3735 ; 163  |    int m_uTimeOutHigh;
                             3736 ; 164  |    int m_uTimeOutLow;
                             3737 ; 165  |    int _asmfunc (*m_pBackgroundFunction)(struct MessageQueueDescriptor *);
                             3738 ; 166  |};
                             3739 ; 167  |
                             3740 ; 168  |union WaitMask{
                             3741 ; 169  |    struct B{
                             3742 ; 170  |        unsigned int m_bNone     :1;
                             3743 ; 171  |        unsigned int m_bMessage  :1;
                             3744 ; 172  |        unsigned int m_bTimer    :1;
                             3745 ; 173  |        unsigned int m_bButton   :1;
                             3746 ; 174  |    } B;
                             3747 ; 175  |    int I;
                             3748 ; 176  |} ;
                             3749 ; 177  |
                             3750 ; 178  |
                             3751 ; 179  |struct Button {
                             3752 ; 180  |        WORD wButtonEvent;
                             3753 ; 181  |        WORD wUnused[MAX_MSG_LENGTH];   
                             3754 ; 182  |};
                             3755 ; 183  |
                             3756 ; 184  |struct Message {
                             3757 ; 185  |        WORD wMsgLength;
                             3758 ; 186  |        WORD wMsgCommand;
                             3759 ; 187  |        WORD wMsgParms[MAX_MSG_LENGTH-1];
                             3760 ; 188  |};
                             3761 ; 189  |
                             3762 ; 190  |union EventTypes {
                             3763 ; 191  |        struct CMessage msg;
                             3764 ; 192  |        struct Button Button ;
                             3765 ; 193  |        struct Message Message;
                             3766 ; 194  |};
                             3767 ; 195  |
                             3768 ; 196  |// next 2 used to get updater build to return correct protocol ver in scsi response.
                             3769 ; 197  |#define BUILD_TYPE_UPDATER  0x100
                             3770 ; 198  |#define BUILD_TYPE_HOSTLINK 0x101
                             3771 ; 199  |#define BUILD_TYPE_PLAYER   0x102
                             3772 ; 200  |
                             3773 ; 201  |// Resets part if RETAIL build. DEBUG build executes debug instruction to halt.
                             3774 ; 202  |#define SystemHalt() __asm(" include 'sysmacro.asm' \n error") 
                             3775 ; 203  |#define assert(x)    if(!(x)) __asm(" include 'sysmacro.asm' \n error")
TASKING DSP2410 assembler v1.5r1 Build 138 SN 00100122
                                                                                                                            Page  63

M:ADDR CODE           CYCLES LINE SOURCELINE
                             3776 ; 204  |
                             3777 ; 205  |#if DEBUG
                             3778 ; 206  |// For DEBUG builds, DebugBuildAssert(condition) halts if condition evaluates to FALSE. 
                             3779 ; 207  |#define DebugBuildAssert(x)    if(!(x)) __asm(" debug ")
                             3780 ; 208  |#else 
                             3781 ; 209  |// For RETAIL builds, DebugBuildAssert(condition) does nothing & execution continues rathe
                                  r than halt or reset. 
                             3782 ; 210  |#define DebugBuildAssert(x)    
                             3783 ; 211  |#endif
                             3784 ; 212  |
                             3785 ; 213  |// Do this in your C files to make a reminder that's displayed during the build.
                             3786 ; 214  |//  #pragma asm
                             3787 ; 215  |//  WARN 'Note to builder: reminder to do this after verifying that'
                             3788 ; 216  |//  #pragma endasm
                             3789 ; 217  |
                             3790 ; 218  |
                             3791 ; 219  |#ifdef COLOR_262K
                             3792 ; 220  |#define RGB(r,g,b)    ((0x0000FC & (r)) << 10) | ((0x0000FC & (g)) << 4) | ((0x0000FC & (b
                                  )) >> 2)    //262k
                             3793 ; 221  |#elif defined(COLOR_65K)
                             3794 ; 222  |#define RGB(r,g,b)    ((0x0000F8 & (r)) << 8) | ((0x0000FC & (g)) << 3) | ((0x0000F8 & (b)
                                  ) >> 3)  //65k
                             3795 ; 223  |#else
                             3796 ; 224  |#define RGB(r,g,b)       ((0x0000F0 & (r)) << 4) | (0x0000F0 & (g)) | ((0x0000F0 & (b)) >>
                                   4)
                             3797 ; 225  |#endif
                             3798 ; 226  |    
                             3799 ; 227  |#endif // #ifndef _TYPES_H
                             3800 
                             3802 
                             3803 ; 12   |#include "filesystem.h"
                             3804 
                             3806 
                             3807 ; 1    |////////////////////////////////////////////////////////////////////////////////
                             3808 ; 2    |//  Copyright(C) SigmaTel, Inc. 2001
                             3809 ; 3    |//
                             3810 ; 4    |//  File        : FileSystem.h
                             3811 ; 5    |//  Description : Header File for File System
                             3812 ; 6    |////////////////////////////////////////////////////////////////////////////////
                             3813 ; 7    |
                             3814 ; 8    |#ifndef _FILESYSTEM_H
                             3815 ; 9    |#define _FILESYSTEM_H
                             3816 ; 10   |
                             3817 ; 11   |#include "types.h"
                             3818 
                             3820 
                             3821 ; 1    |////////////////////////////////////////////////////////////////////////////////
                             3822 ; 2    |// Copyright(C) SigmaTel, Inc. 2000-2004
                             3823 ; 3    |//
                             3824 ; 4    |// Filename: types.h
                             3825 ; 5    |// Description: Standard data types
                             3826 ; 6    |////////////////////////////////////////////////////////////////////////////////
                             3827 ; 7    |
                             3828 ; 8    |#ifndef _TYPES_H
                             3829 ; 9    |#define _TYPES_H
                             3830 ; 10   |
                             3831 ; 11   |// TODO:  move this outta here!
                             3832 ; 12   |#if !defined(NOERROR)
                             3833 ; 13   |#define NOERROR 0
                             3834 ; 14   |#define SUCCESS 0
                             3835 ; 15   |#endif 
                             3836 ; 16   |#if !defined(SUCCESS)
TASKING DSP2410 assembler v1.5r1 Build 138 SN 00100122
                                                                                                                            Page  64

M:ADDR CODE           CYCLES LINE SOURCELINE
                             3837 ; 17   |#define SUCCESS  0
                             3838 ; 18   |#endif
                             3839 ; 19   |#if !defined(ERROR)
                             3840 ; 20   |#define ERROR   -1
                             3841 ; 21   |#endif
                             3842 ; 22   |#if !defined(FALSE)
                             3843 ; 23   |#define FALSE 0
                             3844 ; 24   |#endif
                             3845 ; 25   |#if !defined(TRUE)
                             3846 ; 26   |#define TRUE  1
                             3847 ; 27   |#endif
                             3848 ; 28   |
                             3849 ; 29   |#if !defined(NULL)
                             3850 ; 30   |#define NULL 0
                             3851 ; 31   |#endif
                             3852 ; 32   |
                             3853 ; 33   |#define MAX_INT     0x7FFFFF
                             3854 ; 34   |#define MAX_LONG    0x7FFFFFffffff
                             3855 ; 35   |        // max positive unsigned long value: -1 == 0xFFFFFFffffff
                             3856 ; 36   |#define MAX_ULONG   (-1) 
                             3857 ; 37   |
                             3858 ; 38   |#define WORD_SIZE   24              // word size in bits
                             3859 ; 39   |#define BYTES_PER_WORD 3            // 8 bit bytes
                             3860 ; 40   |
                             3861 ; 41   |
                             3862 ; 42   |#define BYTE    unsigned char       // btVarName
                             3863 ; 43   |#define CHAR    signed char         // cVarName
                             3864 ; 44   |#define USHORT  unsigned short      // usVarName
                             3865 ; 45   |#define SHORT   unsigned short      // sVarName
                             3866 ; 46   |#define WORD    unsigned int        // wVarName
                             3867 ; 47   |#define INT     signed int          // iVarName
                             3868 ; 48   |#define DWORD   unsigned long       // dwVarName
                             3869 ; 49   |#define LONG    signed long         // lVarName
                             3870 ; 50   |#define BOOL    unsigned int        // bVarName
                             3871 ; 51   |#define FRACT   _fract              // frVarName
                             3872 ; 52   |#define LFRACT  long _fract         // lfrVarName
                             3873 ; 53   |#define CIRC    _circ               // cp<type prefix>VarName (see below)
                             3874 ; 54   |#define FLOAT   float               // fVarName
                             3875 ; 55   |#define DBL     double              // dVarName
                             3876 ; 56   |#define ENUM    enum                // eVarName
                             3877 ; 57   |#define CMX     _complex            // cmxVarName
                             3878 ; 58   |typedef WORD UCS3;                   // 
                             3879 ; 59   |
                             3880 ; 60   |#define UINT16  unsigned short
                             3881 ; 61   |#define UINT8   unsigned char   
                             3882 ; 62   |#define UINT32  unsigned long
                             3883 ; 63   |#define UINT64  unsigned long   // need to figure out how to do 64 bit values.  Or port ex
                                  isiting code to only use 48 bit
                             3884 ; 64   |#define INT64   unsigned long   // need to figure out how to do 64 bit values.  Or port ex
                                  isiting code to only use 48 bit
                             3885 ; 65   |#define WCHAR   UINT16
                             3886 ; 66   |
                             3887 ; 67   |//UINT128 is 16 bytes or 6 words
                             3888 ; 68   |typedef struct UINT128_3500 {   
                             3889 ; 69   |    int val[6];     
                             3890 ; 70   |} UINT128_3500;
                             3891 ; 71   |
                             3892 ; 72   |#define UINT128   UINT128_3500
                             3893 ; 73   |
                             3894 ; 74   |// Little endian word packed byte strings:   
                             3895 ; 75   |//      _packed BYTE bTextVarName[]="a string";  bText is a packed byte string prefix
                             3896 ; 76   |// Convert to big endian words by reordering bytes from high to low using swizzle.
TASKING DSP2410 assembler v1.5r1 Build 138 SN 00100122
                                                                                                                            Page  65

M:ADDR CODE           CYCLES LINE SOURCELINE
                             3897 ; 77   |// Little endian word packed byte strings:   
                             3898 ; 78   |//      _packed BYTE bTextVarName[]="a string";  bText is a packed byte string prefix
                             3899 ; 79   |// Convert to big endian words by reordering bytes from high to low using swizzle.
                             3900 ; 80   |
                             3901 ; 81   |// Declare Memory Spaces To Use When Coding
                             3902 ; 82   |// A. Sector Buffers
                             3903 ; 83   |#define SECTOR_BUFFER_MEM_X _X
                             3904 ; 84   |#define SECTOR_BUFFER_MEM_Y _Y
                             3905 ; 85   |#define SECTOR_BUFFER_MEM SECTOR_BUFFER_MEM_X
                             3906 ; 86   |typedef WORD SECTOR_BUFFER_MEM SECTOR_BUFFER;
                             3907 ; 87   |typedef SECTOR_BUFFER * P_SECTOR_BUFFER;
                             3908 ; 88   |// B. Media DDI Memory
                             3909 ; 89   |#define MEDIA_DDI_MEM _Y
                             3910 ; 90   |
                             3911 ; 91   |
                             3912 ; 92   |
                             3913 ; 93   |// Pointers to linear structures are labeled as: p<type prefix>VarName
                             3914 ; 94   |// Examples of circular pointers:
                             3915 ; 95   |//    INT CIRC cpiVarName
                             3916 ; 96   |//    DWORD CIRC cpdwVarName
                             3917 ; 97   |
                             3918 ; 98   |#define RETCODE INT                 // rcVarName
                             3919 ; 99   |
                             3920 ; 100  |// generic bitfield structure
                             3921 ; 101  |struct Bitfield {
                             3922 ; 102  |    unsigned int B0  :1;
                             3923 ; 103  |    unsigned int B1  :1;
                             3924 ; 104  |    unsigned int B2  :1;
                             3925 ; 105  |    unsigned int B3  :1;
                             3926 ; 106  |    unsigned int B4  :1;
                             3927 ; 107  |    unsigned int B5  :1;
                             3928 ; 108  |    unsigned int B6  :1;
                             3929 ; 109  |    unsigned int B7  :1;
                             3930 ; 110  |    unsigned int B8  :1;
                             3931 ; 111  |    unsigned int B9  :1;
                             3932 ; 112  |    unsigned int B10 :1;
                             3933 ; 113  |    unsigned int B11 :1;
                             3934 ; 114  |    unsigned int B12 :1;
                             3935 ; 115  |    unsigned int B13 :1;
                             3936 ; 116  |    unsigned int B14 :1;
                             3937 ; 117  |    unsigned int B15 :1;
                             3938 ; 118  |    unsigned int B16 :1;
                             3939 ; 119  |    unsigned int B17 :1;
                             3940 ; 120  |    unsigned int B18 :1;
                             3941 ; 121  |    unsigned int B19 :1;
                             3942 ; 122  |    unsigned int B20 :1;
                             3943 ; 123  |    unsigned int B21 :1;
                             3944 ; 124  |    unsigned int B22 :1;
                             3945 ; 125  |    unsigned int B23 :1;
                             3946 ; 126  |};
                             3947 ; 127  |
                             3948 ; 128  |union BitInt {
                             3949 ; 129  |        struct Bitfield B;
                             3950 ; 130  |        int        I;
                             3951 ; 131  |};
                             3952 ; 132  |
                             3953 ; 133  |#define MAX_MSG_LENGTH 10
                             3954 ; 134  |struct CMessage
                             3955 ; 135  |{
                             3956 ; 136  |        unsigned int m_uLength;
                             3957 ; 137  |        unsigned int m_uMsg[MAX_MSG_LENGTH];
                             3958 ; 138  |};
TASKING DSP2410 assembler v1.5r1 Build 138 SN 00100122
                                                                                                                            Page  66

M:ADDR CODE           CYCLES LINE SOURCELINE
                             3959 ; 139  |
                             3960 ; 140  |typedef struct {
                             3961 ; 141  |    WORD m_wLength;
                             3962 ; 142  |    WORD m_wMessage;
                             3963 ; 143  |    WORD m_wParams[MAX_MSG_LENGTH];
                             3964 ; 144  |} Message;
                             3965 ; 145  |
                             3966 ; 146  |struct MessageQueueDescriptor
                             3967 ; 147  |{
                             3968 ; 148  |        int *m_pBase;
                             3969 ; 149  |        int m_iModulo;
                             3970 ; 150  |        int m_iSize;
                             3971 ; 151  |        int *m_pHead;
                             3972 ; 152  |        int *m_pTail;
                             3973 ; 153  |};
                             3974 ; 154  |
                             3975 ; 155  |struct ModuleEntry
                             3976 ; 156  |{
                             3977 ; 157  |    int m_iSignaledEventMask;
                             3978 ; 158  |    int m_iWaitEventMask;
                             3979 ; 159  |    int m_iResourceOfCode;
                             3980 ; 160  |    struct MessageQueueDescriptor *m_pMessageQueue;
                             3981 ; 161  |    int _asmfunc (*m_pProcessEntryPoint)(union WaitMask Signals,struct MessageQueueDescrip
                                  tor *);
                             3982 ; 162  |    int _asmfunc (*m_pInitFunction)(struct MessageQueueDescriptor *);
                             3983 ; 163  |    int m_uTimeOutHigh;
                             3984 ; 164  |    int m_uTimeOutLow;
                             3985 ; 165  |    int _asmfunc (*m_pBackgroundFunction)(struct MessageQueueDescriptor *);
                             3986 ; 166  |};
                             3987 ; 167  |
                             3988 ; 168  |union WaitMask{
                             3989 ; 169  |    struct B{
                             3990 ; 170  |        unsigned int m_bNone     :1;
                             3991 ; 171  |        unsigned int m_bMessage  :1;
                             3992 ; 172  |        unsigned int m_bTimer    :1;
                             3993 ; 173  |        unsigned int m_bButton   :1;
                             3994 ; 174  |    } B;
                             3995 ; 175  |    int I;
                             3996 ; 176  |} ;
                             3997 ; 177  |
                             3998 ; 178  |
                             3999 ; 179  |struct Button {
                             4000 ; 180  |        WORD wButtonEvent;
                             4001 ; 181  |        WORD wUnused[MAX_MSG_LENGTH];   
                             4002 ; 182  |};
                             4003 ; 183  |
                             4004 ; 184  |struct Message {
                             4005 ; 185  |        WORD wMsgLength;
                             4006 ; 186  |        WORD wMsgCommand;
                             4007 ; 187  |        WORD wMsgParms[MAX_MSG_LENGTH-1];
                             4008 ; 188  |};
                             4009 ; 189  |
                             4010 ; 190  |union EventTypes {
                             4011 ; 191  |        struct CMessage msg;
                             4012 ; 192  |        struct Button Button ;
                             4013 ; 193  |        struct Message Message;
                             4014 ; 194  |};
                             4015 ; 195  |
                             4016 ; 196  |// next 2 used to get updater build to return correct protocol ver in scsi response.
                             4017 ; 197  |#define BUILD_TYPE_UPDATER  0x100
                             4018 ; 198  |#define BUILD_TYPE_HOSTLINK 0x101
                             4019 ; 199  |#define BUILD_TYPE_PLAYER   0x102
TASKING DSP2410 assembler v1.5r1 Build 138 SN 00100122
                                                                                                                            Page  67

M:ADDR CODE           CYCLES LINE SOURCELINE
                             4020 ; 200  |
                             4021 ; 201  |// Resets part if RETAIL build. DEBUG build executes debug instruction to halt.
                             4022 ; 202  |#define SystemHalt() __asm(" include 'sysmacro.asm' \n error") 
                             4023 ; 203  |#define assert(x)    if(!(x)) __asm(" include 'sysmacro.asm' \n error")
                             4024 ; 204  |
                             4025 ; 205  |#if DEBUG
                             4026 ; 206  |// For DEBUG builds, DebugBuildAssert(condition) halts if condition evaluates to FALSE. 
                             4027 ; 207  |#define DebugBuildAssert(x)    if(!(x)) __asm(" debug ")
                             4028 ; 208  |#else 
                             4029 ; 209  |// For RETAIL builds, DebugBuildAssert(condition) does nothing & execution continues rathe
                                  r than halt or reset. 
                             4030 ; 210  |#define DebugBuildAssert(x)    
                             4031 ; 211  |#endif
                             4032 ; 212  |
                             4033 ; 213  |// Do this in your C files to make a reminder that's displayed during the build.
                             4034 ; 214  |//  #pragma asm
                             4035 ; 215  |//  WARN 'Note to builder: reminder to do this after verifying that'
                             4036 ; 216  |//  #pragma endasm
                             4037 ; 217  |
                             4038 ; 218  |
                             4039 ; 219  |#ifdef COLOR_262K
                             4040 ; 220  |#define RGB(r,g,b)    ((0x0000FC & (r)) << 10) | ((0x0000FC & (g)) << 4) | ((0x0000FC & (b
                                  )) >> 2)    //262k
                             4041 ; 221  |#elif defined(COLOR_65K)
                             4042 ; 222  |#define RGB(r,g,b)    ((0x0000F8 & (r)) << 8) | ((0x0000FC & (g)) << 3) | ((0x0000F8 & (b)
                                  ) >> 3)  //65k
                             4043 ; 223  |#else
                             4044 ; 224  |#define RGB(r,g,b)       ((0x0000F0 & (r)) << 4) | (0x0000F0 & (g)) | ((0x0000F0 & (b)) >>
                                   4)
                             4045 ; 225  |#endif
                             4046 ; 226  |    
                             4047 ; 227  |#endif // #ifndef _TYPES_H
                             4048 
                             4050 
                             4051 ; 12   |
                             4052 ; 13   |
                             4053 ; 14   |// File attributes
                             4054 ; 15   |#ifndef _FS_ATTRIBUTES
                             4055 ; 16   |#define _FS_ATTRIBUTES
                             4056 ; 17   |#define READ        1
                             4057 ; 18   |#define WRITE       2
                             4058 ; 19   |#define WRITE_PLUS  3
                             4059 ; 20   |#define APPEND      4
                             4060 ; 21   |#define TRUNCATE    8
                             4061 ; 22   |#define CREATE      16
                             4062 ; 23   |#endif
                             4063 ; 24   |
                             4064 ; 25   |//#ifndef FAT12
                             4065 ; 26   |//#define FAT12   1
                             4066 ; 27   |//#endif
                             4067 ; 28   |//
                             4068 ; 29   |#ifndef FAT16
                             4069 ; 30   |#define FAT16   2
                             4070 ; 31   |#endif
                             4071 ; 32   |
                             4072 ; 33   |#define MEM_SPACE_P 0x100000
                             4073 ; 34   |#define MEM_SPACE_Y 0x400000
                             4074 ; 35   |#define MEM_SPACE_X 0x800000
                             4075 ; 36   |
                             4076 ; 37   |#define FILE_SYS_MODE_READ  0
                             4077 ; 38   |#define FILE_SYS_MODE_WRITE 1
                             4078 ; 39   | 
TASKING DSP2410 assembler v1.5r1 Build 138 SN 00100122
                                                                                                                            Page  68

M:ADDR CODE           CYCLES LINE SOURCELINE
                             4079 ; 40   |#define ATTR_READ_ONLY      0x01
                             4080 ; 41   |#define ATTR_HIDDEN         0x02
                             4081 ; 42   |#define ATTR_SYSTEM         0x04
                             4082 ; 43   |#define ATTR_VOLUME_ID      0x08
                             4083 ; 44   |#define ATTR_DIRECTORY      0x10
                             4084 ; 45   |#define ATTR_ARCHIVE        0x20
                             4085 ; 46   |#define ATTR_LONG_NAME      ATTR_READ_ONLY|ATTR_HIDDEN|ATTR_SYSTEM|ATTR_VOLUME_ID
                             4086 ; 47   |
                             4087 ; 48   |#define SEEK_SET           -1
                             4088 ; 49   |#define SEEK_CUR            0
                             4089 ; 50   |#define SEEK_END            1
                             4090 ; 51   |
                             4091 ; 52   |#define DEVICE_INSTALLED              (WORD)(0)
                             4092 ; 53   |#define DEVICE_NOT_FOUND              (WORD)(2)
                             4093 ; 54   |#define INVALID_FILESYSTEM                        (WORD)(3)
                             4094 ; 55   |#define DEVICE_INVALID                (WORD)(-1)
                             4095 ; 56   |#define DEVICE_ERROR_WRITE_PROTECTED  (WORD)(-2)
                             4096 ; 57   |
                             4097 ; 58   |#define MEDIA_SIZE_TOTAL_SECTORS    0
                             4098 ; 59   |#define MEDIA_SIZE_TOTAL_BYTES      1
                             4099 ; 60   |#define MEDIA_SIZE_BYTES_PER_SECTOR 2
                             4100 ; 61   |#define MEDIA_SIZE_IN_MEGABYTES     3     
                             4101 ; 62   |
                             4102 ; 63   |#define READ_TYPE_NORMAL            0
                             4103 ; 64   |#define READ_TYPE_FAT               1
                             4104 ; 65   |#define READ_TYPE_RAW               2
                             4105 ; 66   |
                             4106 ; 67   |
                             4107 ; 68   |#ifdef MEDIA_DDI_PARTIAL_SEQ_ENABLE
                             4108 ; 69   |    #define WRITE_TYPE_RANDOM                   0
                             4109 ; 70   |    #define WRITE_TYPE_SEQ_FIRST                1
                             4110 ; 71   |    #define WRITE_TYPE_SEQ_NEXT                 2
                             4111 ; 72   |    #define WRITE_TYPE_RESET_CLEAN_UP           3
                             4112 ; 73   |    #define WRITE_TYPE_PARTIAL_SEQ_FIRST        4
                             4113 ; 74   |    #define WRITE_TYPE_PARTIAL_SEQ_NEXT         5
                             4114 ; 75   |    #define WRITE_TYPE_PARTIAL_SEQ_LAST         6
                             4115 ; 76   |    #ifdef MEDIA_DDI_RAW_SECTOR_SERVER_ENABLE
                             4116 ; 77   |        #define WRITE_TYPE_RANDOM_RAW               7
                             4117 ; 78   |        #define WRITE_TYPE_SEQ_FIRST_RAW            8
                             4118 ; 79   |        #define WRITE_TYPE_SEQ_NEXT_RAW             9
                             4119 ; 80   |        #define WRITE_TYPE_PARTIAL_SEQ_FIRST_RAW    10
                             4120 ; 81   |        #define WRITE_TYPE_PARTIAL_SEQ_NEXT_RAW     11
                             4121 ; 82   |        #define WRITE_TYPE_PARTIAL_SEQ_LAST_RAW     12
                             4122 ; 83   |    #endif
                             4123 ; 84   |#else
                             4124 ; 85   |    #define WRITE_TYPE_RANDOM                   0
                             4125 ; 86   |    #define WRITE_TYPE_SEQ_FIRST                1
                             4126 ; 87   |    #define WRITE_TYPE_SEQ_NEXT                 2
                             4127 ; 88   |    #ifdef MEDIA_DDI_RAW_SECTOR_SERVER_ENABLE
                             4128 ; 89   |        #define WRITE_TYPE_RANDOM_RAW               3
                             4129 ; 90   |        #define WRITE_TYPE_SEQ_FIRST_RAW            4
                             4130 ; 91   |        #define WRITE_TYPE_SEQ_NEXT_RAW             5
                             4131 ; 92   |    #endif
                             4132 ; 93   |#endif
                             4133 ; 94   |    #define WRITE_TYPE_UNDEFINED 0xFFFFFF
                             4134 ; 95   |
                             4135 ; 96   |
                             4136 ; 97   |#ifndef MAX_FILENAME_LENGTH
                             4137 ; 98   |#define MAX_FILENAME_LENGTH 256
                             4138 ; 99   |#endif
                             4139 ; 100  |
                             4140 ; 101  |typedef struct {
TASKING DSP2410 assembler v1.5r1 Build 138 SN 00100122
                                                                                                                            Page  69

M:ADDR CODE           CYCLES LINE SOURCELINE
                             4141 ; 102  |    WORD wNumberOfZones;
                             4142 ; 103  |    WORD wSizeInMegaBytes;
                             4143 ; 104  |} SMARTMEDIA_CHIP_INFO;
                             4144 ; 105  |
                             4145 ; 106  |typedef struct {
                             4146 ; 107  |    WORD wBootIdentification;
                             4147 ; 108  |    WORD wStartHeadNumber;
                             4148 ; 109  |    WORD wStartSectorNumber;
                             4149 ; 110  |    WORD wStartCylinderNumber;
                             4150 ; 111  |    WORD wSystemIdentification;
                             4151 ; 112  |    WORD wEndHeadNumber;
                             4152 ; 113  |    WORD wEndSectorNumber;
                             4153 ; 114  |    WORD wEndCylinderNumber;
                             4154 ; 115  |    WORD wStartLogicalSectorNumberHigh;
                             4155 ; 116  |    WORD wStartLogicalSectorNumberLow;
                             4156 ; 117  |    WORD wPartitionSizeHigh;
                             4157 ; 118  |    WORD wPartitionSizeLow;
                             4158 ; 119  |} SMARTMEDIA_PARTITION_TABLE;
                             4159 ; 120  |
                             4160 ; 121  |typedef struct {
                             4161 ; 122  |    WORD wWord0;
                             4162 ; 123  |    WORD wWord1;
                             4163 ; 124  |    WORD wWord2;
                             4164 ; 125  |} SMARTMEDIA_CIS_IDI_MANUFACTURER_NAME;
                             4165 ; 126  |
                             4166 ; 127  |typedef struct {
                             4167 ; 128  |    WORD wWord0;
                             4168 ; 129  |    WORD wWord1;
                             4169 ; 130  |} SMARTMEDIA_CIS_IDI_PRODUCT_NAME;
                             4170 ; 131  |
                             4171 ; 132  |typedef struct {
                             4172 ; 133  |    WORD wWord0;
                             4173 ; 134  |    WORD wWord1;
                             4174 ; 135  |} SMARTMEDIA_CIS_IDI_PRODUCT_VERSION;
                             4175 ; 136  |
                             4176 ; 137  |typedef struct {
                             4177 ; 138  |    WORD wWord0;
                             4178 ; 139  |    WORD wWord1;
                             4179 ; 140  |    WORD wWord2;
                             4180 ; 141  |    WORD wWord3;
                             4181 ; 142  |} SMARTMEDIA_CIS_IDI_SERIAL_NUMBER;
                             4182 ; 143  |
                             4183 ; 144  |typedef struct {
                             4184 ; 145  |    WORD wWord0;
                             4185 ; 146  |} SMARTMEDIA_CIS_IDI_MODEL_NUMBER;
                             4186 
                             4209 
                             4210 ; 147  |
                             4211 ; 148  |typedef struct {
                             4212 ; 149  |    SMARTMEDIA_CIS_IDI_MANUFACTURER_NAME ManufacturerName;
                             4213 ; 150  |    SMARTMEDIA_CIS_IDI_PRODUCT_NAME ProductName;
                             4214 ; 151  |    SMARTMEDIA_CIS_IDI_PRODUCT_VERSION ProductVersion;
                             4215 ; 152  |    SMARTMEDIA_CIS_IDI_SERIAL_NUMBER SerialNumber;
                             4216 ; 153  |    SMARTMEDIA_CIS_IDI_MODEL_NUMBER ModelNumber;
                             4217 ; 154  |} SMARTMEDIA_CIS_IDI_TABLE;
                             4218 
                             4240 
                             4241 ; 155  |   
                             4242 ; 156  |typedef struct {
                             4243 ; 157  |    WORD wPageSizeInBytes;
                             4244 ; 158  |    WORD wRedundantAreaSizeInBytes;
                             4245 ; 159  |    WORD wNumberOfPagesPerBlock;
TASKING DSP2410 assembler v1.5r1 Build 138 SN 00100122
                                                                                                                            Page  70

M:ADDR CODE           CYCLES LINE SOURCELINE
                             4246 ; 160  |    WORD wNumberOfBlocksPerZone;
                             4247 ; 161  |    WORD wNumberOfZonesInMedia;
                             4248 ; 162  |    WORD wMediaSizeInMBytes;
                             4249 ; 163  |    SMARTMEDIA_PARTITION_TABLE * pPartitionTable;
                             4250 ; 164  |    SMARTMEDIA_CIS_IDI_TABLE * pCisIdiTable;
                             4251 ; 165  |    WORD wMediaFlagStatus;
                             4252 ; 166  |    WORD wNumberOfBlocksToTheCisIdiBlock;
                             4253 ; 167  |    WORD wTotalNumberOfPhysicalBlocks;
                             4254 ; 168  |    WORD wNumberOfSystemBlocks;
                             4255 ; 169  |} SMARTMEDIA_ENTRY_TABLE;
                             4256 ; 170  |
                             4257 ; 171  |typedef struct {
                             4258 ; 172  |    WORD wDevice;        
                             4259 ; 173  |    WORD wDirtyBlockFlag;
                             4260 ; 174  |    WORD wCleanTailFlag; 
                             4261 ; 175  |    WORD wLogDOSPage;    
                             4262 ; 176  |    WORD wSrcLogBlock;   
                             4263 ; 177  |    WORD wSrcPhyBlock;   
                             4264 ; 178  |    WORD wDestPhyBlock;  
                             4265 ; 179  |    WORD wStartSrcPage;  
                             4266 ; 180  |    WORD wStartDestPage; 
                             4267 ; 181  |    WORD wPagesToCopy;   
                             4268 ; 182  |    WORD wReplaceBuff;   
                             4269 ; 183  |    WORD wReplaceRdnt;
                             4270 ; 184  |    #ifdef MEDIA_DDI_PARTIAL_SEQ_ENABLE
                             4271 ; 185  |        WORD wFirstCount;
                             4272 ; 186  |        WORD wNextCount;
                             4273 ; 187  |        WORD wLastCount;
                             4274 ; 188  |    #endif
                             4275 ; 189  |} SMARTMEDIA_FWPPS_TABLE;
                             4276 ; 190  |
                             4277 ; 191  |typedef struct {
                             4278 ; 192  |    WORD wWord0;
                             4279 ; 193  |    WORD wWord1;
                             4280 ; 194  |    WORD wWord2;
                             4281 ; 195  |    WORD wWord3;
                             4282 ; 196  |} DIRECTORY_NAME;
                             4283 ; 197  |
                             4284 ; 198  |typedef struct {
                             4285 ; 199  |    WORD wWord0;
                             4286 ; 200  |    WORD wWord1;
                             4287 ; 201  |} DIRECTORY_EXTENSION;
                             4288 ; 202  |
                             4289 ; 203  |typedef struct {
                             4290 ; 204  |    WORD wWord0;
                             4291 ; 205  |    WORD wWord1;
                             4292 ; 206  |} DIRECTORY_SIZE;
                             4293 
                             4308 
                             4309 ; 207  |
                             4310 ; 208  |typedef struct {
                             4311 ; 209  |    DIRECTORY_NAME Name;
                             4312 ; 210  |    DIRECTORY_EXTENSION Extension;
                             4313 ; 211  |    WORD wAttribute;
                             4314 ; 212  |    WORD wReserved[4];
                             4315 ; 213  |    WORD wCreationTime;
                             4316 ; 214  |    WORD wCreationData;
                             4317 ; 215  |    WORD wFirstCluster;
                             4318 ; 216  |    DIRECTORY_SIZE Size;
                             4319 ; 217  |    WORD wCurrentCluster;
                             4320 ; 218  |    WORD wPointer;
                             4321 ; 219  |    WORD wRecord;
TASKING DSP2410 assembler v1.5r1 Build 138 SN 00100122
                                                                                                                            Page  71

M:ADDR CODE           CYCLES LINE SOURCELINE
                             4322 ; 220  |    WORD wRd;
                             4323 ; 221  |} DIRECTORY_FILE_CONTROL_BLOCK;
                             4324 ; 222  |
                             4325 ; 223  |// TODO:  clean this up.  There are two versions.
                             4326 ; 224  |struct FCB
                             4327 ; 225  |{
                             4328 ; 226  |    _packed BYTE m_szFileName[9];       //0-2
                             4329 ; 227  |    int     m_wReserved;                //3
                             4330 ; 228  |    _packed BYTE m_szExt[4];            //4-5
                             4331 ; 229  |    int     m_wAttributes;              //6
                             4332 ; 230  |    int     m_wReserved2[4];            //7,8,9,a
                             4333 ; 231  |    int     m_wTimeofCreation;          //b
                             4334 ; 232  |    int     m_wDateofCreation;          //c
                             4335 ; 233  |    int     m_wFirstCluster;            //d
                             4336 ; 234  |    int     m_wFileSizeHigh;            //e
                             4337 ; 235  |    int     m_wFileSizeLow;             //f
                             4338 ; 236  |};
                             4339 
                             4355 
                             4356 ; 237  |
                             4357 ; 238  |
                             4358 ; 239  |typedef struct {
                             4359 ; 240  |    WORD wFirstClusterCurrentDirectory;
                             4360 ; 241  |    WORD wFirstClusterParentDirectory;
                             4361 ; 242  |    WORD wAbsSectorCurrentlyCached;
                             4362 ; 243  |    WORD wCurrentRelativeSector;
                             4363 ; 244  |    WORD wNumberOfSectors;
                             4364 ; 245  |    WORD wCurrentRecordLoadedInDcb;
                             4365 ; 246  |    WORD wBufferedRecord;
                             4366 ; 247  |    WORD wMaxNumberRecordsCurrentDirectory;
                             4367 ; 248  |    WORD * pwPointerToBuffer;
                             4368 ; 249  |    WORD * pwPointerToPath;
                             4369 ; 250  |    DIRECTORY_FILE_CONTROL_BLOCK * pDirFcb;
                             4370 ; 251  |} DIRECTORY_CONTROL_BLOCK;
                             4371 ; 252  |
                             4372 ; 253  |typedef struct {
                             4373 ; 254  |    WORD wWord0;
                             4374 ; 255  |    WORD wWord1;
                             4375 ; 256  |    WORD wWord2;
                             4376 ; 257  |    WORD wWord3;
                             4377 ; 258  |} FILE_NAME;
                             4378 ; 259  |
                             4379 ; 260  |typedef struct {
                             4380 ; 261  |    WORD wWord0;
                             4381 ; 262  |    WORD wWord1;
                             4382 ; 263  |} FILE_EXTENSION;
                             4383 ; 264  |
                             4384 ; 265  |typedef struct {
                             4385 ; 266  |    WORD wWord0;
                             4386 ; 267  |    WORD wWord1;
                             4387 ; 268  |} FILE_SIZE;
                             4388 ; 269  |
                             4389 ; 270  |typedef union {
                             4390 ; 271  |    struct {
                             4391 ; 272  |        int Read        :1;
                             4392 ; 273  |        int Write       :1;
                             4393 ; 274  |        int Append      :1;
                             4394 ; 275  |        int Truncate    :1;
                             4395 ; 276  |        int Create      :1;
                             4396 ; 277  |        int Rsrv        :3;
                             4397 ; 278  |        int Mode        :8;
                             4398 ; 279  |        int Device      :8;
TASKING DSP2410 assembler v1.5r1 Build 138 SN 00100122
                                                                                                                            Page  72

M:ADDR CODE           CYCLES LINE SOURCELINE
                             4399 ; 280  |    } B;
                             4400 ; 281  |    int I;
                             4401 ; 282  |} FILE_FLAGS;
                             4402 ; 283  |
                             4403 ; 284  |typedef struct {
                             4404 ; 285  |    WORD wWord0;
                             4405 ; 286  |    WORD wWord1;
                             4406 ; 287  |} FILE_BYTE_CURRENT;
                             4407 
                             4447 
                             4448 ; 288  |
                             4449 ; 289  |typedef struct {
                             4450 ; 290  |    FILE_NAME Name;
                             4451 ; 291  |    FILE_EXTENSION Extension;
                             4452 ; 292  |    WORD wAttributes;
                             4453 ; 293  |    WORD wReserved[4];
                             4454 ; 294  |    WORD wCreationTime;
                             4455 ; 295  |    WORD wCreationData;
                             4456 ; 296  |    WORD wFirstCluster;
                             4457 ; 297  |    FILE_SIZE Size;
                             4458 ; 298  |    WORD wCurrentCluster;
                             4459 ; 299  |    WORD wPointer;
                             4460 ; 300  |    WORD wRecord;
                             4461 ; 301  |    WORD wRd;
                             4462 ; 302  |    FILE_FLAGS Flags;
                             4463 ; 303  |    FILE_BYTE_CURRENT FcbByteCurrent;
                             4464 ; 304  |    WORD wFcbFlagEndOfCx;
                             4465 ; 305  |} FILE_CONTROL_BLOCK;    
                             4466 ; 306  |
                             4467 ; 307  |typedef struct {
                             4468 ; 308  |    WORD wWord0;
                             4469 ; 309  |    WORD wWord1;
                             4470 ; 310  |    WORD wWord2;
                             4471 ; 311  |    WORD wWord3;
                             4472 ; 312  |} VOLUME_LABEL;
                             4473 ; 313  |
                             4474 ; 314  |typedef struct {
                             4475 ; 315  |    WORD wFATPhysicalBlock1;
                             4476 ; 316  |    WORD wFATPhysicalBlock2;
                             4477 ; 317  |    WORD wFATPhysicalBlock3;
                             4478 ; 318  |    WORD wFATPhysicalBlock4;
                             4479 ; 319  |} FAT_PHYSICAL_BLOCK_LIST;
                             4480 
                             4487 
                             4488 ; 320  |
                             4489 ; 321  |typedef struct {
                             4490 ; 322  |    WORD wFATSectorInCache;
                             4491 ; 323  |    WORD wLastClusterFree;
                             4492 ; 324  |    WORD wNumberOfUsedClusters;
                             4493 ; 325  |    WORD wNumberOfFreeClusters;
                             4494 ; 326  |    WORD wNumberOfBadClusters;
                             4495 ; 327  |    WORD wNumberOfReservedClusters;
                             4496 ; 328  |    WORD wControl;
                             4497 ; 329  |    WORD * pwSectorCache;
                             4498 ; 330  |    FAT_PHYSICAL_BLOCK_LIST FATPhysicalLocationList;
                             4499 ; 331  |} FAT_TABLE;
                             4500 
                             4507 
                             4508 ; 332  |
                             4509 ; 333  |typedef struct {
                             4510 ; 334  |    WORD wStateMediaTable;
                             4511 ; 335  |    WORD wTypeFs;
TASKING DSP2410 assembler v1.5r1 Build 138 SN 00100122
                                                                                                                            Page  73

M:ADDR CODE           CYCLES LINE SOURCELINE
                             4512 ; 336  |    WORD wBytesPerSector;
                             4513 ; 337  |    WORD wSectorsPerCluster;
                             4514 ; 338  |    WORD wNumberOfReservedSectors;
                             4515 ; 339  |    WORD wMaximumNumberOfFATs;
                             4516 ; 340  |    WORD wMaxRootDirectoryEntries;
                             4517 ; 341  |    WORD wTotalSectors;
                             4518 ; 342  |    WORD wNumberOfFATSectors;
                             4519 ; 343  |    WORD wNumberOfSectorsPerTrack;
                             4520 ; 344  |    WORD wNumberOfHeads;
                             4521 ; 345  |    WORD wNumberOfHiddenSectorsMSB;
                             4522 ; 346  |    WORD wNumberOfHiddenSectorsLSB;
                             4523 ; 347  |    WORD wTotalSectors32MSB;
                             4524 ; 348  |    WORD wTotalSectors32LSB;
                             4525 ; 349  |    WORD wDriverNumber;
                             4526 ; 350  |    WORD wExtendedBootSignature;
                             4527 ; 351  |    WORD wVolumeIDMSB;
                             4528 ; 352  |    WORD wVolumeIDLSB;
                             4529 ; 353  |    VOLUME_LABEL VolumeLabel;
                             4530 ; 354  |    WORD * pwWriteBuffer;
                             4531 ; 355  |    WORD wPrimaryFATRelativeSector;
                             4532 ; 356  |    WORD wSecondaryFATRelativeSector;
                             4533 ; 357  |    WORD wRootDirectoryRelativeSector;
                             4534 ; 358  |    WORD wFirstSectorNumberDataZone;
                             4535 ; 359  |    WORD wMaxNumberOfFATEntries;
                             4536 ; 360  |    WORD wRootDirectorySizeInSectors;
                             4537 ; 361  |    WORD wDataAreaSizeInSectors;
                             4538 ; 362  |} MEDIA_TABLE;
                             4539 
                             4596 
                             4597 ; 363  |
                             4598 ; 364  |typedef struct {
                             4599 ; 365  |    MEDIA_TABLE * pMediaTable;
                             4600 ; 366  |    DIRECTORY_CONTROL_BLOCK * pDirectoryControlBlock;
                             4601 ; 367  |    FAT_TABLE * pFATTable;
                             4602 ; 368  |} DEVICE_CONTROL_TABLE;
                             4603 ; 369  |    
                             4604 ; 370  |typedef struct {
                             4605 ; 371  |    WORD dwTotalSizeInMegaBytes;        // dwTotalSizeInMegaBytes is limited
                             4606 ; 372  |                                        //  to 2-bytes for compatibility with
                             4607 ; 373  |                                        //  older host drivers.
                             4608 ; 374  |    DWORD dwTotalNumberOfSectors;
                             4609 ; 375  |    DWORD dwTotalNumberOfBytes;
                             4610 ; 376  |    WORD wSectorSizeInBytes;
                             4611 ; 377  |} MEDIA_SIZE;
                             4612 ; 378  |
                             4613 ; 379  |typedef struct {
                             4614 ; 380  |    BOOL    bInstalled;
                             4615 ; 381  |    INT     iPbsSectorOffset;   // from the beginning of the data drive 
                             4616 ; 382  |    DWORD   dwSize;
                             4617 ; 383  |} DATA_DRIVE_PBS_LOC;
                             4618 ; 384  |extern  INT _reentrant FSFileOpen(_packed BYTE *fname,INT attribute, INT DeviceNumber);
                             4619 ; 385  |extern  INT _reentrant FSFastOpen(DWORD Key, INT attribute);
                             4620 ; 386  |extern  INT FSFileDelete(_packed BYTE *fname,INT DeviceNumber);
                             4621 ; 387  |extern  INT FSFileCreate(_packed BYTE *fname,INT DeviceNumber);
                             4622 ; 388  |extern  INT _reentrant FSChangeDir(_packed BYTE *dirname,INT DeviceNumber);
                             4623 ; 389  |extern  INT _reentrant FSCreateDir(_packed BYTE *dirname,INT DeviceNumber);
                             4624 ; 390  |extern  INT _reentrant FSDeleteDir(_packed BYTE *dirname,INT DeviceNumber);
                             4625 ; 391  |extern  INT _reentrant FSFileAppend(_packed BYTE *fname,INT DeviceNumber);
                             4626 ; 392  |extern  INT _reentrant FSFileRead(INT BytestoRead, INT Handle, INT memory_type, INT modulo
                                  , WORD *buffer);
                             4627 ; 393  |extern  INT _reentrant FSFileWrite(INT wNumberBytes, INT Handle, INT memory_type, INT iMod
                                  ulo, WORD *buffer);
TASKING DSP2410 assembler v1.5r1 Build 138 SN 00100122
                                                                                                                            Page  74

M:ADDR CODE           CYCLES LINE SOURCELINE
                             4628 ; 394  |extern  INT _reentrant FSFileClose(INT Handle);
                             4629 ; 395  |extern  LONG _reentrant FSFileSize(INT HandleNumber);
                             4630 ; 396  |extern  LONG  FSSize(INT DeviceNum, INT TYPE);   
                             4631 ; 397  |extern  INT FSFreeClusters(INT Device);
                             4632 ; 398  |extern  INT BytesPerCluster(INT Device);
                             4633 ; 399  |
                             4634 ; 400  |
                             4635 ; 401  |
                             4636 ; 402  |//extern  INT FSFileCreate(_packed BYTE *pbFileName, BYTE bDevice);
                             4637 ; 403  |//extern  INT FSFileDelete(_packed BYTE *pbFileName, BYTE bDevice);
                             4638 ; 404  |extern  INT FSFileRename(_packed BYTE *pbCurFilename, _packed BYTE *pbNewFilename, BYTE bD
                                  evice);
                             4639 ; 405  |//extern  INT _reentrant FSFileAttribute(_packed BYTE *pbFilename, WORD wAttributes, BYTE 
                                  bDevice);
                             4640 ; 406  |//extern  INT FSFileAppend(_packed BYTE *pbFileName, BYTE bDevice);
                             4641 ; 407  |//extern  INT FSFileOpen(_packed BYTE *pbFileName, WORD wAttributes, BYTE bDevice);
                             4642 ; 408  |//extern  INT FSFileClose(INT bHandle);
                             4643 ; 409  |//extern  INT FSFileRead(WORD wNumberBytes, BYTE bHandle, WORD wMemSpace, INT iModulo, WOR
                                  D *pwBuffer);
                             4644 ; 410  |//extern  INT FSFileWrite(WORD wNumberBytes, BYTE bHandle, WORD wMemSpace, INT iModulo, WO
                                  RD *pwBuffer);
                             4645 ; 411  |extern  INT _reentrant fseek( INT handle , LONG offset, INT iOrigin );
                             4646 ; 412  |extern  INT _reentrant FSFileEof(INT Handle);
                             4647 ; 413  |extern INT _reentrant FSFileAttribute(INT Attributes, _packed BYTE *fname, INT DeviceNumbe
                                  r);
                             4648 ; 414  |extern INT _reentrant FSFileAttributeClear(INT Attributes, _packed BYTE *fname, INT Device
                                  Number);
                             4649 ; 415  |//extern  LONG FSFileSize(INT bHandle);
                             4650 ; 416  |extern _asmfunc INT FSPresent(BYTE bDevice);
                             4651 ; 417  |extern _asmfunc INT FSType(BYTE bDevice);
                             4652 ; 418  |//extern LONG FSSize(WORD wDevice, WORD wReturnType);
                             4653 ; 419  |//extern INT FSChangeDir(_packed BYTE *pbDirName, BYTE bDevice);
                             4654 ; 420  |//extern INT FSCreateDir(_packed BYTE *pbDirName, BYTE bDevice);
                             4655 ; 421  |//extern INT FSDeleteDir(_packed BYTE *pbDirName, BYTE bDevice);
                             4656 ; 422  |extern _asmfunc void SysLoadFATWrite(void);
                             4657 ; 423  |extern _asmfunc INT SysUnLoadFATWrite(void);
                             4658 ; 424  |extern LONG _reentrant ftell(INT iHandle);
                             4659 ; 425  |extern _asmfunc struct FCB * ReadDirectory(int iDevice, int iEntry);
                             4660 ; 426  |
                             4661 ; 427  |#endif
                             4662 
                             4664 
                             4665 ; 13   |#include "sectorarrayhandler.h"
                             4666 
                             4668 
                             4669 ; 1    |#ifndef __SECTOR_ARRAY_HANDLER_H
                             4670 ; 2    |#define __SECTOR_ARRAY_HANDLER_H
                             4671 ; 3    |
                             4672 ; 4    |#define SECTOR_STATE_FREE 0
                             4673 ; 5    |#define SECTOR_STATE_FILLING 1
                             4674 ; 6    |#define SECTOR_STATE_FILLED 2
                             4675 ; 7    |
                             4676 ; 8    |typedef struct
                             4677 ; 9    |{
                             4678 ; 10   |    int iState;
                             4679 ; 11   |    WORD _X *pwData;
                             4680 ; 12   |} SECTOR_TYPE;
                             4681 
                             4688 
                             4689 ; 13   |
                             4690 ; 14   |
                             4691 ; 15   |
TASKING DSP2410 assembler v1.5r1 Build 138 SN 00100122
                                                                                                                            Page  75

M:ADDR CODE           CYCLES LINE SOURCELINE
                             4692 ; 16   |typedef struct SectorArray
                             4693 ; 17   |{
                             4694 ; 18   |    SECTOR_TYPE*pSectors;
                             4695 ; 19   |    INT iNumSectorBuffers;
                             4696 ; 20   |    WORD wHeadIndex;
                             4697 ; 21   |    WORD wFillingIndex;
                             4698 ; 22   |    WORD wTailIndex;
                             4699 ; 23   |    WORD wSectorsInFlight;
                             4700 ; 24   |}  SECTOR_ARRAY;
                             4701 
                             4712 
                             4713 ; 25   |
                             4714 ; 26   |
                             4715 ; 27   |
                             4716 ; 28   |_reentrant SECTOR_TYPE*ReadSectorArrayHandlerGetFreeSector(SECTOR_ARRAY*);
                             4717 ; 29   |_reentrant void ReadSectorArrayHandlerFreeSector(SECTOR_ARRAY*);
                             4718 ; 30   |_reentrant void ReadSectorArrayHandlerFreeAllSectors(SECTOR_ARRAY*);
                             4719 ; 31   |
                             4720 ; 32   |_reentrant SECTOR_TYPE*WriteSectorArrayHandlerGetFreeSector(SECTOR_ARRAY*);
                             4721 ; 33   |_reentrant SECTOR_TYPE*WriteSectorArrayHandlerGetFilledSector(SECTOR_ARRAY*);
                             4722 ; 34   |_reentrant void WriteSectorArrayHandlerFillSector(SECTOR_ARRAY*);
                             4723 ; 35   |_reentrant void WriteSectorArrayHandlerFreeSector(SECTOR_ARRAY*,SECTOR_TYPE*);
                             4724 ; 36   |
                             4725 ; 37   |_reentrant void SectorArrayInitialize(SECTOR_ARRAY *, WORD wSectorCount,WORD wSectorSize, 
                                  SECTOR_TYPE *pSectorTypeArray,WORD _X *pSectorDataBuffer);
                             4726 ; 38   |
                             4727 ; 39   |
                             4728 ; 40   |#endif 
                             4729 
                             4731 
                             4732 ; 14   |////////////////////////////////////////////////////////////////////////////////
                             4733 ; 15   |// Debug stuff
                             4734 ; 16   |////////////////////////////////////////////////////////////////////////////////
                             4735 ; 17   |
                             4736 ; 18   |    #ifdef SCSI_COMMAND_HISTORY
                             4737 ; 19   |#define SCSI_COMMAND_HISTORY_SIZE       500
                             4738 ; 20   |#define SCSI_CDB_SIZE_IN_WORDS          6
                             4739 ; 21   |    #endif
                             4740 ; 22   |    
                             4741 ; 23   |////////////////////////////////////////////////////////////////////////////////
                             4742 ; 24   |// Defs
                             4743 ; 25   |////////////////////////////////////////////////////////////////////////////////
                             4744 ; 26   |
                             4745 ; 27   |#define SCSI_CDB_BUFFER_OP_CODE_MASK    (WORD)0x0000FF
                             4746 ; 28   |
                             4747 ; 29   |////////////////////////////////////////////////////////////////////////////////
                             4748 ; 30   |// Supported SCSI commands
                             4749 ; 31   |#define SCSI_OPCODE_INQUIRY                         0x12
                             4750 ; 32   |#define SCSI_OPCODE_READ_CAPACITY                   0x25
                             4751 ; 33   |#define SCSI_OPCODE_READ_FORMAT_CAPACITIES          0x23
                             4752 ; 34   |#define SCSI_OPCODE_READ_6                          0x08
                             4753 ; 35   |#define SCSI_OPCODE_READ_10                         0x28
                             4754 ; 36   |#define SCSI_OPCODE_READ_12                         0xA8
                             4755 ; 37   |#define SCSI_OPCODE_READ_16                         0x88
                             4756 ; 38   |#define SCSI_OPCODE_WRITE_6                         0x0A
                             4757 ; 39   |#define SCSI_OPCODE_WRITE_10                        0x2A
                             4758 ; 40   |#define SCSI_OPCODE_WRITE_12                        0xAA
                             4759 ; 41   |#define SCSI_OPCODE_WRITE_16                        0x8A
                             4760 ; 42   |#define SCSI_OPCODE_REQUEST_SENSE                   0x03
                             4761 ; 43   |#define SCSI_OPCODE_TEST_UNIT_READY                 0x00
                             4762 ; 44   |#define SCSI_OPCODE_START_STOP_UNIT                 0x1B
                             4763 ; 45   |#define SCSI_OPCODE_FORMAT_UNIT                     0x04
TASKING DSP2410 assembler v1.5r1 Build 138 SN 00100122
                                                                                                                            Page  76

M:ADDR CODE           CYCLES LINE SOURCELINE
                             4764 ; 46   |#define SCSI_OPCODE_RESERVE_10                      0x56
                             4765 ; 47   |#define SCSI_OPCODE_RELEASE_10                      0x57
                             4766 ; 48   |#define SCSI_OPCODE_SEND_DIAGNOSTIC                 0x1D
                             4767 ; 49   |#define SCSI_OPCODE_MODE_SENSE_6                    0x1A
                             4768 ; 50   |#define SCSI_OPCODE_MODE_SENSE_10                   0x5A
                             4769 ; 51   |#define SCSI_OPCODE_PREVENT_ALLOW_MEDIUM_REMOVAL    0x1E
                             4770 ; 52   |#define SCSI_OPCODE_START_STOP_UNIT                 0x1B // Start Stop Unit from the SBC-2
                                   spec
                             4771 ; 53   |#define SCSI_OPCODE_READ_BUFFER                     0x3C
                             4772 ; 54   |
                             4773 ; 55   |#define SCSI_CDB_SIZE_INQUIRY                       6
                             4774 ; 56   |#define SCSI_CDB_SIZE_READ_CAPACITY                 10
                             4775 ; 57   |#define SCSI_CDB_SIZE_READ_6                        6
                             4776 ; 58   |#define SCSI_CDB_SIZE_READ_10                       10
                             4777 ; 59   |#define SCSI_CDB_SIZE_READ_12                       12
                             4778 ; 60   |#define SCSI_CDB_SIZE_READ_16                       16
                             4779 ; 61   |#define SCSI_CDB_SIZE_WRITE_6                       6
                             4780 ; 62   |#define SCSI_CDB_SIZE_WRITE_10                      10
                             4781 ; 63   |#define SCSI_CDB_SIZE_WRITE_12                      12
                             4782 ; 64   |#define SCSI_CDB_SIZE_WRITE_16                      16
                             4783 ; 65   |#define SCSI_CDB_SIZE_REQUEST_SENSE                 6
                             4784 ; 66   |#define SCSI_CDB_SIZE_TEST_UNIT_READY               6
                             4785 ; 67   |#define SCSI_CDB_SIZE_START_STOP_UNIT               6
                             4786 ; 68   |#define SCSI_CDB_SIZE_FORMAT_UNIT                   6
                             4787 ; 69   |#define SCSI_CDB_SIZE_RESERVE_10                    10
                             4788 ; 70   |#define SCSI_CDB_SIZE_RELEASE_10                    10
                             4789 ; 71   |#define SCSI_CDB_SIZE_SEND_DIAGNOSTIC               6
                             4790 ; 72   |#define SCSI_CDB_SIZE_MODE_SENSE_6                  6
                             4791 ; 73   |#define SCSI_CDB_SIZE_MODE_SENSE_10                 10
                             4792 ; 74   |#define SCSI_CDB_SIZE_PREVENT_ALLOW_MEDIUM_REMOVAL  6
                             4793 ; 75   |#define SCSI_CDB_SIZE_START_STOP_UNIT               6
                             4794 ; 76   |
                             4795 ; 77   |////////////////////////////////////////////////////////////////////////////////
                             4796 ; 78   |// Unsupported SCSI commands known to have been received.  Unknown SCSI commands
                             4797 ; 79   |//  not in this list are only trapped in development builds.  Release builds
                             4798 ; 80   |//  simply fail all commands not in this list.  Use the
                             4799 ; 81   |//  SCSI_TRAP_UNKNOWN_OPCODES build option in the make file to trap.
                             4800 ; 82   |#define SCSI_OPCODE_READ_FORMAT_CAPACITIES          0x23 // Read Format Capacities from th
                                  e
                             4801 ; 83   |                                                         //  SFF-8070i spec
                             4802 ; 84   |#define SCSI_OPCODE_VERIFY_10                       0x2F // Verify(10) from the SBC-2 spec
                                  
                             4803 ; 85   |
                             4804 ; 86   |////////////////////////////////////////////////////////////////////////////////
                             4805 ; 87   |// Data direction defs
                             4806 ; 88   |#define SCSI_DATA_TO_HOST               0
                             4807 ; 89   |#define SCSI_DATA_FROM_HOST             1
                             4808 ; 90   |
                             4809 ; 91   |////////////////////////////////////////////////////////////////////////////////
                             4810 ; 92   |// Sense Data defs
                             4811 ; 93   |#define SENSE_DATA_RESPONSE_CODE_CURRENT_ERRORS     0x70
                             4812 ; 94   |#define SENSE_DATA_RESPONSE_CODE_DEFERRED_ERRORS    0x71
                             4813 ; 95   |#define SENSE_DATA_INFORMATION_VALID                1<<7
                             4814 ; 96   |#define SENSE_DATA_INFORMATION_INVALID              0
                             4815 ; 97   |#define SENSE_DATA_ILI_CORRECT                      0<<4
                             4816 ; 98   |#define SENSE_DATA_ILI_INCORRECT                    1<<4
                             4817 ; 99   |
                             4818 ; 100  |////////////////////////////////////////////////////////////////////////////////
                             4819 ; 101  |// Sense Key defs
                             4820 ; 102  |#define SCSI_SENSE_KEY_NO_SENSE             0<<16
                             4821 ; 103  |#define SCSI_SENSE_KEY_RECOVERED_ERROR      1<<16
                             4822 ; 104  |#define SCSI_SENSE_KEY_NOT_READY            2<<16
TASKING DSP2410 assembler v1.5r1 Build 138 SN 00100122
                                                                                                                            Page  77

M:ADDR CODE           CYCLES LINE SOURCELINE
                             4823 ; 105  |#define SCSI_SENSE_KEY_MEDIUM_ERROR         3<<16
                             4824 ; 106  |#define SCSI_SENSE_KEY_HARDWARE_ERROR       4<<16
                             4825 ; 107  |#define SCSI_SENSE_KEY_ILLEGAL_REQUEST      5<<16
                             4826 ; 108  |#define SCSI_SENSE_KEY_UNIT_ATTENTION       6<<16
                             4827 ; 109  |#define SCSI_SENSE_KEY_DATA_PROTECT         7<<16
                             4828 ; 110  |#define SCSI_SENSE_KEY_BLANK_CHECK          8<<16
                             4829 ; 111  |#define SCSI_SENSE_KEY_VENDOR_SPECIFIC      9<<16
                             4830 ; 112  |#define SCSI_SENSE_KEY_COPY_ABORTED         10<<16
                             4831 ; 113  |#define SCSI_SENSE_KEY_ABORTED_COMMAND      11<<16
                             4832 ; 114  |#define SCSI_SENSE_KEY_OBSOLETE             12<<16
                             4833 ; 115  |#define SCSI_SENSE_KEY_VOLUME_OVERFLOW      13<<16
                             4834 ; 116  |#define SCSI_SENSE_KEY_MISCOMPARE           14<<16
                             4835 ; 117  |#define SCSI_SENSE_KEY_RESERVED             15<<16
                             4836 ; 118  |
                             4837 ; 119  |////////////////////////////////////////////////////////////////////////////////
                             4838 ; 120  |// Additional Sense Code & Qualifier defs.  Asc is the LSB.
                             4839 ; 121  |#define SCSI_ASC_NO_ADDITIONAL_SENSE_INFO                               0x0000
                             4840 ; 122  |
                             4841 ; 123  |#define SCSI_ASC_LOGICAL_UNIT_NOT_READY_MANUAL_INTERVENTION_REQUIRED    0x0304
                             4842 ; 124  |
                             4843 ; 125  |#define SCSI_ASC_LOGICAL_UNIT_DOES_NOT_RESPOND_TO_SELECTION             0x0005
                             4844 ; 126  |
                             4845 ; 127  |#define SCSI_ASC_INVALID_COMMAND_OPERATION_CODE                         0x0020
                             4846 ; 128  |
                             4847 ; 129  |#define SCSI_ASC_LOGICAL_UNIT_NOT_SUPPORTED                             0x0025
                             4848 ; 130  |
                             4849 ; 131  |#define SCSI_ASC_LOGICAL_BLOCK_ADDRESS_OUT_OF_RANGE                     0x0021 
                             4850 ; 132  |
                             4851 ; 133  |#define SCSI_ASC_WRITE_PROTECTED                                        0x0027
                             4852 ; 134  |
                             4853 ; 135  |#define SCSI_ASC_NOT_READY_TO_READY_CHANGE_MEDIUM_MAY_HAVE_CHANGED      0x0028
                             4854 ; 136  |
                             4855 ; 137  |#define SCSI_ASC_DEVICE_INTERNAL_RESET                                  0x0429
                             4856 ; 138  |
                             4857 ; 139  |#define SCSI_ASC_INCOMPATIBLE_MEDIUM_INSTALLED                          0x0030
                             4858 ; 140  |#define SCSI_ASC_CANNOT_READ_MEDIUM_UNKNOWN_FORMAT                      0x0130
                             4859 ; 141  |#define SCSI_ASC_CANNOT_READ_MEDIUM_INCOMPATIBLE_FORMAT                 0x0230
                             4860 ; 142  |#define SCSI_ASC_CANNOT_WRITE_MEDIUM_UNKNOWN_FORMAT                     0x0430
                             4861 ; 143  |#define SCSI_ASC_CANNOT_WRITE_MEDIUM_INCOMPATIBLE_FORMAT                0x0530
                             4862 ; 144  |
                             4863 ; 145  |#define SCSI_ASC_MEDIUM_FORMAT_CORRUPTED                                0x0031
                             4864 ; 146  |
                             4865 ; 147  |#define SCSI_ASC_UNRECOVERED_READ_ERROR                                 0x0011
                             4866 ; 148  |
                             4867 ; 149  |#define SCSI_ASC_MEDIUM_NOT_PRESENT                                     0x003A
                             4868 ; 150  |#define SCSI_ASC_MEDIUM_DESTINATION_ELEMENT_FULL                        0x003B
                             4869 ; 151  |
                             4870 ; 152  |#define SCSI_ASC_INQUIRY_DATA_HAS_CHANGED                               0x033F
                             4871 ; 153  |#define SCSI_ASC_REPORTED_LUNS_DATA_HAS_CHANGED                         0x0E3F
                             4872 ; 154  |
                             4873 ; 155  |#define SCSI_ASC_LOGICIAL_UNIT_FAILED_SELF_CONFIGURATION                0x004C
                             4874 ; 156  |
                             4875 ; 157  |#define SCSI_ASC_INVALID_FIELD_IN_CDB                                   0x0024
                             4876 ; 158  |
                             4877 ; 159  |#define SCSI_ASC_LOGICAL_UNIT_FAILURE                                   0x013E
                             4878 ; 160  |#define SCSI_ASC_LOGICAL_UNIT_NOT_READY_INIT_CMD_REQUIRED               0x0204
                             4879 ; 161  |
                             4880 ; 162  |////////////////////////////////////////////////////////////////////////////////
                             4881 ; 163  |// Inquiry Peripheral Qualifier defs
                             4882 ; 164  |#define SCSI_INQUIRY_PERIPHERAL_QUALIFIER_LUN_CONNECTED         0
                             4883 ; 165  |#define SCSI_INQUIRY_PERIPHERAL_QUALIFIER_LUN_NOT_CONNECTED     1
                             4884 ; 166  |#define SCSI_INQUIRY_PERIPHERAL_QUALIFIER_RESERVED              2
TASKING DSP2410 assembler v1.5r1 Build 138 SN 00100122
                                                                                                                            Page  78

M:ADDR CODE           CYCLES LINE SOURCELINE
                             4885 ; 167  |#define SCSI_INQUIRY_PERIPHERAL_QUALIFIER_NO_SUPPORT            3
                             4886 ; 168  |
                             4887 ; 169  |////////////////////////////////////////////////////////////////////////////////
                             4888 ; 170  |// Inquiry Peripheral Qualifier defs
                             4889 ; 171  |#define SCSI_INQUIRY_PERIPHERAL_DEVICE_TYPE_DIRECT_ACCESS       0
                             4890 ; 172  |#define SCSI_INQUIRY_PERIPHERAL_DEVICE_TYPE_NO_SUPPORT          0x1F
                             4891 ; 173  |
                             4892 ; 174  |////////////////////////////////////////////////////////////////////////////////
                             4893 ; 175  |// Inquiry RMB defs
                             4894 ; 176  |#define SCSI_INQUIRY_RMB_DEVICE_IS_NOT_REMOVABLE                0
                             4895 ; 177  |#define SCSI_INQUIRY_RMB_DEVICE_IS_REMOVABLE                    1
                             4896 ; 178  |
                             4897 ; 179  |////////////////////////////////////////////////////////////////////////////////
                             4898 ; 180  |// Inquiry Vendor Specific SigmaTel struct defs
                             4899 ; 181  |#define SCSI_INQUIRY_VENDOR_SPECIFIC_STRUCT_MDS                 1
                             4900 ; 182  |
                             4901 ; 183  |#define SCSI_MDS_FLAGS_SYSTEM_MEDIA_FLAG_NON_SYSTEM             (WORD)0x00
                             4902 ; 184  |#define SCSI_MDS_FLAGS_SYSTEM_MEDIA_FLAG_SYSTEM                 (WORD)0x01
                             4903 ; 185  |                                                                
                             4904 ; 186  |#define SCSI_MDS_MEDIA_TYPE_NAND                                (WORD)0x00
                             4905 ; 187  |#define SCSI_MDS_MEDIA_TYPE_SMARTMEDIA                          (WORD)0x01
                             4906 ; 188  |#define SCSI_MDS_MEDIA_TYPE_MMC_1_4                             (WORD)0x10
                             4907 ; 189  |#define SCSI_MDS_MEDIA_TYPE_MMC_2_1_1                           (WORD)0x11
                             4908 ; 190  |#define SCSI_MDS_MEDIA_TYPE_MMC_3_1                             (WORD)0x12
                             4909 ; 191  |#define SCSI_MDS_MEDIA_TYPE_MMC_UNKNOWN_VERSION                 (WORD)0x13
                             4910 ; 192  |#define SCSI_MDS_MEDIA_TYPE_SD_1_0                              (WORD)0x20
                             4911 ; 193  |#define SCSI_MDS_MEDIA_TYPE_SD_UNKNOWN_VERSION                  (WORD)0x21
                             4912 ; 194  |
                             4913 ; 195  |////////////////////////////////////////////////////////////////////////////////
                             4914 ; 196  |// Error codes
                             4915 ; 197  |////////////////////////////////////////////////////////////////////////////////
                             4916 ; 198  |
                             4917 ; 199  |#define SCSI_PROJECT_SPECIFIC_INIT_FAILED                       (WORD)0x000001
                             4918 ; 200  |#define SCSI_DEVICE_INIT_ALL_FAILED                             (WORD)0x000002
                             4919 ; 201  |#define SCSI_ERROR_LUN_NOT_READY                                (WORD)0x000003
                             4920 ; 202  |#define SCSI_ERROR_INVALID_COMMAND                              (WORD)0x000004
                             4921 ; 203  |#define SCSI_ERROR_USB_MSC_RESET_DURING_SCSI_COMMAND            (WORD)0x000005
                             4922 ; 204  |#define SCSI_ERROR_READ_SECTOR_FAILURE                          (WORD)0x000006
                             4923 ; 205  |#define SCSI_ERROR_WRITE_SECTOR_FAILURE                         (WORD)0x000007
                             4924 ; 206  |#define SCSI_ERROR_WAIT_FOR_USB_TIMEOUT                         (WORD)0x000008
                             4925 ; 207  |#define SCSI_READ_FAILURE_TIMEOUT_USB_WILL_NOT_STOP             (WORD)0x000009
                             4926 ; 208  |#define SCSI_WRITE_FAILURE_TIMEOUT_USB_WILL_NOT_STOP            (WORD)0x00000A
                             4927 ; 209  |#define SCSI_ERROR_USB_DISCONNECT                               (WORD)0x00000B
                             4928 ; 210  |#define SCSI_ERROR_DDI_CALL_FAILED                              (WORD)0x00000C
                             4929 ; 211  |#define SCSI_ERROR_LBA_OUT_OF_RANGE                         (RETCODE)(0x000100)
                             4930 ; 212  |#define SCSI_WRITE_FAILURE_ZONE_FULL                        (RETCODE)(0x9AAAAA)
                             4931 ; 213  |
                             4932 ; 214  |////////////////////////////////////////////////////////////////////////////////
                             4933 ; 215  |// Typedefs
                             4934 ; 216  |////////////////////////////////////////////////////////////////////////////////
                             4935 ; 217  |
                             4936 ; 218  |typedef RETCODE (*SCSI_CH)(WORD wDeviceNum, WORD _X* pCdb);
                             4937 ; 219  |typedef RETCODE (*SCSI_PROJECT_INIT)(void);
                             4938 ; 220  |typedef RETCODE (*SCSI_LUN_FLAG_MEDIA_CHANGE_FUNCTION)(void);
                             4939 ; 221  |
                             4940 ; 222  |typedef struct
                             4941 ; 223  |{
                             4942 ; 224  |    WORD wValid;
                             4943 ; 225  |    WORD wSenseKey;
                             4944 ; 226  |    WORD wIli;
                             4945 ; 227  |    DWORD dwInformation;
                             4946 ; 228  |    WORD wAscqAsc; 
TASKING DSP2410 assembler v1.5r1 Build 138 SN 00100122
                                                                                                                            Page  79

M:ADDR CODE           CYCLES LINE SOURCELINE
                             4947 ; 229  |    WORD wAddlData;
                             4948 ; 230  |} SCSI_SENSE_DATA;
                             4949 ; 231  |
                             4950 ; 232  |typedef enum
                             4951 ; 233  |{
                             4952 ; 234  |    ScsiMediaStateUnknown = 0,
                             4953 ; 235  |    ScsiMediaStateReady = 1,
                             4954 ; 236  |    ScsiMediaStateFormatRequired = 2,
                             4955 ; 237  |    ScsiMediaStateHardwareFailed = 3
                             4956 ; 238  |} SCSI_MEDIA_STATE;
                             4957 
                             4982 
                             4983 ; 239  |
                             4984 ; 240  |typedef struct
                             4985 ; 241  |{
                             4986 ; 242  |    DWORD dwNumBytesXferred;
                             4987 ; 243  |    WORD wCompletionStatus;
                             4988 ; 244  |    SCSI_SENSE_DATA SenseData;
                             4989 ; 245  |    BOOL bStopped;
                             4990 ; 246  |    BOOL bWriteProtected;
                             4991 ; 247  |    BOOL bMediaConnected;
                             4992 ; 248  |    BOOL bMediaIsRemovable;
                             4993 ; 249  |    WORD wRemovableType;
                             4994 ; 250  |    WORD wRemovableEntry;
                             4995 ; 251  |    WORD wRemovableMask;
                             4996 ; 252  |    BOOL bMediaEnumerated;
                             4997 ; 253  |    BOOL bMediaChanged;
                             4998 ; 254  |    BOOL bMediaInsertionDetected;
                             4999 ; 255  |    BOOL bMediaValid;
                             5000 ; 256  |    SCSI_MEDIA_STATE eMediaState;
                             5001 ; 257  |    WORD wFileSystemDriveNumber;
                             5002 ; 258  |    WORD wFileSystemMediaNumber;
                             5003 ; 259  |    BOOL bStartUnitAttention;
                             5004 ; 260  |    MEDIA_SIZE MediaSize;
                             5005 ; 261  |    WORD wInquiryVendorData[10];
                             5006 ; 262  |    WORD wInquiryVendorSpecific[7];
                             5007 ; 263  |    SCSI_LUN_FLAG_MEDIA_CHANGE_FUNCTION FlagMediaChange;
                             5008 ; 264  |    DWORD dwSequentialBoundaryMask;
                             5009 ; 265  |    DWORD dwSequentialBoundary;
                             5010 ; 266  |} SCSI_LUN;
                             5011 
                             5016 
                             5017 ; 267  |
                             5018 ; 268  |
                             5019 ; 269  |typedef struct SCSICommandEntryStruct
                             5020 ; 270  |{
                             5021 ; 271  |
                             5022 ; 272  |    WORD     wCommand;
                             5023 ; 273  |    SCSI_CH  pFunc;
                             5024 ; 274  |} SCSI_COMMAND_ENTRY;
                             5025 ; 275  |
                             5026 ; 276  |
                             5027 ; 277  |////////////////////////////////////////////////////////////////////////////////
                             5028 ; 278  |// Prototypes
                             5029 ; 279  |////////////////////////////////////////////////////////////////////////////////
                             5030 ; 280  |
                             5031 ; 281  |RETCODE _reentrant ScsiDeviceTaskRouter(WORD wDeviceNum, WORD _X * pCdb);
                             5032 ; 282  |RETCODE _reentrant ScsiDeviceTaskManager(WORD wDeviceNum, WORD wOpCode, WORD _X * pCdb, SC
                                  SI_CH pFunc);
                             5033 ; 283  |RETCODE _reentrant ScsiDeviceServer(WORD wDeviceNum, WORD _X* pCdb,    SCSI_CH pFunc);
                             5034 ; 284  |
                             5035 ; 285  |SCSI_CH _reentrant ScsiValidOperationCode(WORD wOpCode);
TASKING DSP2410 assembler v1.5r1 Build 138 SN 00100122
                                                                                                                            Page  80

M:ADDR CODE           CYCLES LINE SOURCELINE
                             5036 
                             5041 
                             5042 ; 286  |SCSI_CH _reentrant SearchForSCSICommand(SCSI_COMMAND_ENTRY *pList, WORD wOpCode);
                             5043 ; 287  |
                             5044 ; 288  |RETCODE _reentrant ScsiInit(void);
                             5045 ; 289  |RETCODE _reentrant ScsiDeviceInitializeAll(void);
                             5046 ; 290  |RETCODE _reentrant ScsiDeviceInitialize(WORD wNum);
                             5047 ; 291  |RETCODE _reentrant ScsiLunInitialize(WORD wDevNum, WORD wLun);
                             5048 ; 292  |RETCODE ScsiLunSetupSize(WORD wDevNum, WORD wLun);
                             5049 ; 293  |RETCODE ScsiLunSetupInquiryVendorSpecificData(WORD wDevNum, WORD wLun);
                             5050 
                             5078 
                             5079 ; 294  |RETCODE _reentrant ScsiLunSetupDefaultSenseData(SCSI_LUN * pLun);
                             5080 ; 295  |RETCODE _reentrant ScsiDummyFlagMediaChange(void);
                             5081 ; 296  |
                             5082 ; 297  |#define SCSI_IDLE      0       // Not reading or writing
                             5083 ; 298  |#define SCSI_READING   1       // A read operation is in progress
                             5084 ; 299  |#define SCSI_WRITING   2       // A write operation is in progress
                             5085 ; 300  |
                             5086 ; 301  |extern WORD g_wSCSIActivityState;
                             5087 ; 302  |
                             5088 ; 303  |RETCODE _reentrant SCSIWriteSectorHelper(WORD wDevice, WORD wDrive, DWORD dwStartSector, W
                                  ORD wSectorCount, BOOL bUseMultiwrite);
                             5089 ; 304  |RETCODE _reentrant SCSIReadSectorHelper(WORD wDevice, WORD wDrive, DWORD dwStartSector, WO
                                  RD wSectorCount);
                             5090 ; 305  |
                             5091 ; 306  |SCSI_CH _reentrant GetVendorSpecificSCSIHandler(WORD wOpCode);
                             5092 ; 307  |SCSI_CH _reentrant GetCustomerExtentionSCSIHandler(WORD wOpCode);
                             5093 ; 308  |
                             5094 ; 309  |#endif // #ifndef _SCSI_H
                             5095 
                             5097 
                             5098 ; 18   |
                             5099 ; 19   |////////////////////////////////////////////////////////////////////////////////
                             5100 ; 20   |// Defs
                             5101 ; 21   |////////////////////////////////////////////////////////////////////////////////
                             5102 ; 22   |
                             5103 ; 23   |#define USB_INTERFACE_CLASS_MASS_STORAGE    0x08
                             5104 ; 24   |
                             5105 ; 25   |#define USB_INTERFACE_SUB_CLASS_RBC                             0x01
                             5106 ; 26   |#define USB_INTERFACE_SUB_CLASS_SFF_8020I                       0x02
                             5107 ; 27   |#define USB_INTERFACE_SUB_CLASS_MMC_2                           0x02
                             5108 ; 28   |#define USB_INTERFACE_SUB_CLASS_QIC_157                         0x03
                             5109 ; 29   |#define USB_INTERFACE_SUB_CLASS_UFI                             0x04
                             5110 ; 30   |#define USB_INTERFACE_SUB_CLASS_SFF_8070I                       0x05
                             5111 ; 31   |#define USB_INTERFACE_SUB_CLASS_SCSI_TRANSPARENT_COMMAND_SET    0x06
                             5112 ; 32   |
                             5113 ; 33   |#define USB_INTERFACE_PROTOCOL_CBI_CCI                          0x01
                             5114 ; 34   |#define USB_INTERFACE_PROTOCOL_CBI_NO_CCI                       0x02
                             5115 ; 35   |#define USB_INTERFACE_PROTOCOL_BULK_ONLY                        0x50
                             5116 ; 36   |
                             5117 ; 37   |#define USBMSC_CBW_SIGNATURE            (DWORD)0x43425355
                             5118 ; 38   |#define USBMSC_CBW_BULK_OUT_SIZE        (WORD)0x00001F
                             5119 ; 39   |
                             5120 ; 40   |#define USBMSC_BULK_OUT_SCSI_CDB_START  5
                             5121 ; 41   |
                             5122 ; 42   |// This is the number of sector buffers if the data area is interpreted as the smallest se
                                  ctor buffer size
                             5123 ; 43   |#define USBMSC_MAX_NUM_SECTOR_BUFFERS       (16)
                             5124 ; 44   |// We add one to pad at the beginning of the buffer and end of each entry to avoid the USB
                                   DMA defect
TASKING DSP2410 assembler v1.5r1 Build 138 SN 00100122
                                                                                                                            Page  81

M:ADDR CODE           CYCLES LINE SOURCELINE
                             5125 ; 45   |#define USBMSC_TOTAL_BUFFER_SIZE            ((SECTOR_BUFFER_ALLOC_SIZE(SSFDC_SECTOR_TOTAL_
                                  SIZE)*USBMSC_MAX_NUM_SECTOR_BUFFERS)+1)
                             5126 ; 46   |
                             5127 ; 47   |#define USBMSC_CSW_SIGNATURE_LOW        (WORD)0x425355
                             5128 ; 48   |#define USBMSC_CSW_SIGNATURE_HIGH       (WORD)0x000053
                             5129 ; 49   |#define USBMSC_CSW_COMMAND_PASSED       (WORD)0x000000
                             5130 ; 50   |#define USBMSC_CSW_COMMAND_FAILED       (WORD)0x000001
                             5131 ; 51   |#define USBMSC_CSW_PHASE_ERROR          (WORD)0x000002
                             5132 ; 52   |
                             5133 ; 53   |#define GET_MAX_LUN_STAGE_DATA_0        (WORD)0x000000
                             5134 ; 54   |#define GET_MAX_LUN_STAGE_DATA_1        (WORD)0x000001
                             5135 ; 55   |
                             5136 ; 56   |#define USBMSC_MAX_LUNS                 4
                             5137 ; 57   |
                             5138 ; 58   |#define USBMSC_DEVICE_0                 0
                             5139 ; 59   |#define USBMSC_DEVICE_1                 1
                             5140 ; 60   |#define USBMSC_DEVICE_2                 2
                             5141 ; 61   |#define USBMSC_DEVICE_3                 3
                             5142 ; 62   |
                             5143 ; 63   |////////////////////////////////////////////////////////////////////////////////
                             5144 ; 64   |// Errors
                             5145 ; 65   |
                             5146 ; 66   |#define USBMSC_ERROR_INVALID_DEVICE                             (WORD)0xFFFFFF
                             5147 ; 67   |#define USBMSC_ERROR_INVALID_LUN                                (WORD)0xFFFFFE
                             5148 ; 68   |#define USBMSC_DEVICE_INIT_ALL_FAILED                           (WORD)0x000001
                             5149 ; 69   |#define USBMSC_DEVICE_INIT_FAILED                               (WORD)0x000002
                             5150 ; 70   |
                             5151 ; 71   |////////////////////////////////////////////////////////////////////////////////
                             5152 ; 72   |// Typedefs
                             5153 ; 73   |////////////////////////////////////////////////////////////////////////////////
                             5154 ; 74   |
                             5155 ; 75   |typedef RETCODE (*USBMSC_DEVICE_INIT_FUNCTION)(void);
                             5156 ; 76   |typedef RETCODE (*USBMSC_DEVICE_RESET_FUNCTION)(void);
                             5157 ; 77   |
                             5158 ; 78   |typedef union
                             5159 ; 79   |{
                             5160 ; 80   |    struct
                             5161 ; 81   |    {
                             5162 ; 82   |        int Reserved    : 6;
                             5163 ; 83   |        int Obsolete    : 1;
                             5164 ; 84   |        int Direction   : 1;
                             5165 ; 85   |    } B;
                             5166 ; 86   |    int I;
                             5167 ; 87   |} USBMSC_CBW_FLAGS;
                             5168 
                             5180 
                             5181 ; 88   |
                             5182 ; 89   |typedef struct
                             5183 ; 90   |{
                             5184 ; 91   |    DWORD dwCBWSignature;
                             5185 ; 92   |    DWORD dwCBWTag;
                             5186 ; 93   |    DWORD dwCBWDataTransferLength;
                             5187 ; 94   |    USBMSC_CBW_FLAGS CBWFlags;
                             5188 ; 95   |    WORD wCBWLUN;
                             5189 ; 96   |    WORD wReserved0;
                             5190 ; 97   |    WORD wCBWCBLength;
                             5191 ; 98   |    WORD wReserved1;
                             5192 ; 99   |} USBMSC_CBW;
                             5193 
                             5212 
                             5213 ; 100  |
                             5214 ; 101  |
TASKING DSP2410 assembler v1.5r1 Build 138 SN 00100122
                                                                                                                            Page  82

M:ADDR CODE           CYCLES LINE SOURCELINE
                             5215 ; 102  |
                             5216 ; 103  |
                             5217 ; 104  |typedef struct
                             5218 ; 105  |{
                             5219 ; 106  |    SyncObject  TransferObject;
                             5220 ; 107  |    WORD wDeviceNumber;
                             5221 ; 108  |    WORD wBulkInEndpointNum;
                             5222 ; 109  |    WORD _X *CommandOutBuffer;
                             5223 ; 110  |    WORD _X *CommandInBuffer;
                             5224 ; 111  |    WORD wTransferSize;
                             5225 ; 112  |    WORD wBulkOutEndpointNum;
                             5226 ; 113  |    WORD wInterface;
                             5227 ; 114  |    WORD wNumLunsSupported;
                             5228 ; 115  |    USBMSC_CBW CBW;
                             5229 ; 116  |    SCSI_LUN Lun[USBMSC_MAX_LUNS];
                             5230 ; 117  |    BOOL bCommandActive;
                             5231 ; 118  |    BOOL bMSCReset;
                             5232 ; 119  |    USBMSC_DEVICE_INIT_FUNCTION InitializeFunction;
                             5233 ; 120  |    USBMSC_DEVICE_RESET_FUNCTION ResetFunction;
                             5234 ; 121  |    SECTOR_ARRAY  SectorArray;
                             5235 ; 122  |} USBMSC_DEVICE;
                             5236 ; 123  |
                             5237 ; 124  |
                             5238 ; 125  |extern long int g_lUSBMSCBulkInBytes;
                             5239 ; 126  |extern long int g_lUSBMSCLastBulkInTime;
                             5240 ; 127  |extern long int g_lUSBMSCFirstBulkInTime;
                             5241 ; 128  |extern long int g_lUSBMSCBulkOutBytes;
                             5242 ; 129  |extern long int g_lUSBMSCLastBulkOutTime;
                             5243 ; 130  |extern long int g_lUSBMSCFirstBulkOutTime;
                             5244 
                             5264 
                             5265 ; 131  |
                             5266 ; 132  |extern USBMSC_DEVICE UsbMscDevice[];
                             5267 ; 133  |extern WORD g_wUsbMscNumDevices;
                             5268 ; 134  |
                             5269 ; 135  |
                             5270 ; 136  |////////////////////////////////////////////////////////////////////////////////
                             5271 ; 137  |// Prototypes
                             5272 ; 138  |////////////////////////////////////////////////////////////////////////////////
                             5273 ; 139  |
                             5274 ; 140  |void _reentrant UsbMscHandler0(void);
                             5275 ; 141  |void _reentrant UsbMscHandler1(void);
                             5276 ; 142  |RETCODE _reentrant UsbMscCbwProcessor(WORD wNum);
                             5277 ; 143  |RETCODE _reentrant UsbMscSendCsw(WORD wNum);
                             5278 ; 144  |RETCODE _reentrant UsbMscDriverInitialize(void);
                             5279 ; 145  |RETCODE _reentrant UsbMscDeviceInitializeAll(void);
                             5280 ; 146  |RETCODE _reentrant UsbMscDeviceInitialize(WORD wNum);
                             5281 ; 147  |RETCODE _reentrant UsbMscDeviceReset(WORD wNum);
                             5282 ; 148  |
                             5283 ; 149  |
                             5284 ; 150  |#define SECTOR_HANDLER  0x800000
                             5285 ; 151  |#define COMMAND_HANDLER 0x400000
                             5286 ; 152  |
                             5287 ; 153  |void _reentrant UsbMscBulkOutService(BOOL bSetup, BYTE btDirection, _packed BYTE _USB_MEM 
                                  *pBuffer, WORD wLength,WORD wPrivateData);
                             5288 ; 154  |void _reentrant UsbMscBulkInService(BOOL bSetup, BYTE btDirection, _packed BYTE _USB_MEM *
                                  pBuffer, WORD wLength,WORD wPrivateData);
                             5289 ; 155  |void _reentrant UsbMscResetService(BOOL bSetup, BYTE btDirection, BYTE _USB_MEM * pbtBuffe
                                  r, WORD wLength,WORD wPrivateData);
                             5290 ; 156  |void _reentrant UsbMscResumeService(BOOL bSetup, BYTE btDirection, BYTE _USB_MEM * pbtBuff
                                  er, WORD wLength,WORD wPrivateData);
TASKING DSP2410 assembler v1.5r1 Build 138 SN 00100122
                                                                                                                            Page  83

M:ADDR CODE           CYCLES LINE SOURCELINE
                             5291 ; 157  |void _reentrant UsbMscSuspendService(BOOL bSetup, BYTE btDirection, BYTE _USB_MEM * pbtBuf
                                  fer, WORD wLength,WORD wPrivateData);
                             5292 ; 158  |
                             5293 ; 159  |RETCODE _reentrant UsbMscCheckDiskAll(void);
                             5294 ; 160  |
                             5295 ; 161  |#define DISPLAY_USB_ACTIVE  0       // Currently reading or writing
                             5296 ; 162  |#define USB_BLINK_RATE_ON       50      // 50msec
                             5297 ; 163  |#define USB_BLINK_RATE_OFF      300     // 450mse
                             5298 ; 164  |
                             5299 ; 165  |#define PERSISTANT_BIT_FOR_LOW_POWER_MODE (HW_RTC_PERSISTANT1.B.b0)
                             5300 ; 166  |
                             5301 ; 167  |
                             5302 ; 168  |#endif // #ifndef _USBMSC_H
                             5303 
                             5305 
                             5306 ; 6    |#include "usb_api.h"
                             5307 
                             5309 
                             5310 ; 1    |////////////////////////////////////////////////////////////////////////////////
                             5311 ; 2    |// Copyright(C) SigmaTel, Inc. 2002 - 2003
                             5312 ; 3    |//
                             5313 ; 4    |// File : USB_API.H
                             5314 ; 5    |// Description : USB_API.H defines and structures definition for USB device
                             5315 ; 6    |//               driver API.
                             5316 ; 7    |//               This 
                             5317 ; 8    |////////////////////////////////////////////////////////////////////////////////
                             5318 ; 9    |
                             5319 ; 10   |#ifndef __usb_api_h__
                             5320 ; 11   |#define __usb_api_h__ 1
                             5321 ; 12   |
                             5322 ; 13   |#include "types.h"
                             5323 ; 14   |#include "project.h"
                             5324 ; 15   |
                             5325 ; 16   |#ifndef _USB_MEM
                             5326 ; 17   |//if not overwridden, default to the compiler default memory space
                             5327 ; 18   |#define _USB_MEM
                             5328 ; 19   |#endif
                             5329 ; 20   |
                             5330 ; 21   |#define USB_LANGUAGE_ENGLISH 0x0409
                             5331 ; 22   |#define USB_LANGUAGE_CHINESE_PRC 0x0804
                             5332 ; 23   |#define USB_LANGUAGE_CHINESE_TAIWAN 0x0404
                             5333 ; 24   |#define USB_LANGUAGE_JAPANESE 0x0411
                             5334 ; 25   |
                             5335 ; 26   |#define MAX_STRING 30
                             5336 ; 27   |
                             5337 ; 28   |#define  USB_SPEED_FULL                      (0)
                             5338 ; 29   |#define  USB_SPEED_LOW                       (1)
                             5339 ; 30   |#define  USB_SPEED_HIGH                      (2)
                             5340 ; 31   |
                             5341 ; 32   |#define EP_FS_MAX_PACKET_SIZE               (64)    
                             5342 ; 33   |
                             5343 ; 34   |#define EP_HS_MAX_PACKET_SIZE               (512)   
                             5344 ; 35   |
                             5345 ; 36   |// Data transferred to devices based on Sigmatel 3500 chip may sometimes be 
                             5346 ; 37   |// corrupted. The corruption occurs when device is connected in USB High Speed 
                             5347 ; 38   |// mode, and size of the transfer in bytes is divisible by 128, but not 
                             5348 ; 39   |// divisible by the packet size. The workaround is implemented in Microsoft MTP 
                             5349 ; 40   |// driver to allow support for those devices.
                             5350 ; 41   |
                             5351 ; 42   |// the bug can corrupt the end of data buffer. It occurs when host sends out a 
                             5352 ; 43   |// short packet that is multiple of 128 bytes. During this scenario the USB core
                             5353 ; 44   |// does writes that are voided (byte enable == all zero), which was an undefined 
TASKING DSP2410 assembler v1.5r1 Build 138 SN 00100122
                                                                                                                            Page  84

M:ADDR CODE           CYCLES LINE SOURCELINE
                             5354 ; 45   |// capability and thus the gasket did not apply a proper response. This should 
                             5355 ; 46   |// not affect Mass Storage applications because data transfers are 512 bytes and 
                             5356 ; 47   |// scsi commands are < 16 bytes. Other applications with their own driver will
                             5357 ; 48   |// need to pad the packets if they fall into the error case. "What this basically 
                             5358 ; 49   |// boils down to is that any time the host sends a short packet of 128, 256 or
                             5359 ; 50   |// 384 bytes to a high-speed connected player a number of bytes will be corrupted.
                             5360 ; 51   |// This is easiest to reproduce in SendObject commands but can strike any of the 
                             5361 ; 52   |// commands that take an arbitrary amount of data.
                             5362 ; 53   |#define ARC_HS_128_MODULO_BUG               (128)
                             5363 ; 54   |
                             5364 ; 55   |
                             5365 ; 56   |/* Error codes */
                             5366 ; 57   |#define USB_OK                              (0x00)
                             5367 ; 58   |#define USBERR_REGISTER_SERVICE             (0x01)  // Failed to register a service
                             5368 ; 59   |#define USBERR_NO_SERVICE                   (0x02)  // No registered service found 
                             5369 ; 60   |#define USBERR_TX_FAILED                    (0x03)  // Fail to prepare XD descriptor
                             5370 ; 61   |#define USBERR_SIZE_TOO_LARGE               (0x04)  // Number of bytes to transfer is too 
                                  large
                             5371 ; 62   |#define USBERR_EP_INIT_FAILED               (0x05)  // Endpoint init fail
                             5372 ; 63   |#define USBERR_CONFIG_FAILED                (0x06)  // Error reported by the application
                             5373 ; 64   |                                                    // if the new config failed or not sup
                                  ported
                             5374 ; 65   |#define USBERR_DEVICE_NOT_CONFIGURED        (0x07)  // Error reported by the transfer func
                                  tion
                             5375 ; 66   |                                                    // if attempting to transfer while the
                                   device
                             5376 ; 67   |                                                    // is not configured
                             5377 ; 68   |#define USBERR_INIT_FAILED                  (0x08)  // Fail to initialize the USB API
                             5378 ; 69   |
                             5379 ; 70   |
                             5380 ; 71   |/* Endpoint types */
                             5381 ; 72   |#define  USB_CONTROL_ENDPOINT             (0)
                             5382 ; 73   |#define  USB_ISOCHRONOUS_ENDPOINT         (1)
                             5383 ; 74   |#define  USB_BULK_ENDPOINT                (2)
                             5384 ; 75   |#define  USB_INTERRUPT_ENDPOINT           (3)
                             5385 ; 76   |
                             5386 ; 77   |/* End point direction */
                             5387 ; 78   |#define  USB_OUT                         (0)
                             5388 ; 79   |#define  USB_IN                          (1)
                             5389 ; 80   |
                             5390 ; 81   |/* End point packed size */
                             5391 ; 82   |#define  USB_FS_MAX_PACKET_SIZE           (64)
                             5392 ; 83   |#define  USB_HS_BULK_OUT_MAX_PACKET_SIZE  (256)
                             5393 ; 84   |#define  USB_HS_BULK_IN_MAX_PACKET_SIZE   (128)
                             5394 ; 85   |
                             5395 ; 86   |
                             5396 ; 87   |#define  USB_TEST_MODE_TEST_J             (0x01)
                             5397 ; 88   |#define  USB_TEST_MODE_TEST_K             (0x02)
                             5398 ; 89   |#define  USB_TEST_MODE_TEST_SE0_NAK       (0x03)
                             5399 ; 90   |#define  USB_TEST_MODE_TEST_PACKET        (0x04)
                             5400 ; 91   |
                             5401 ; 92   |/* Available service types */
                             5402 ; 93   |/* Services 0 through 15 are reserved for endpoints */
                             5403 ; 94   |#define  USB_SERVICE_EP0                  (0x00)
                             5404 ; 95   |#define  USB_SERVICE_EP1                  (0x01)
                             5405 ; 96   |#define  USB_SERVICE_EP2                  (0x02)
                             5406 ; 97   |#define  USB_SERVICE_EP3                  (0x03)
                             5407 ; 98   |#define  USB_SERVICE_EP4                  (0x04)
                             5408 ; 99   |#define  USB_SERVICE_EP5                  (0x05)
                             5409 ; 100  |#define  USB_SERVICE_EP6                  (0x06)
                             5410 ; 101  |#define  USB_SERVICE_EP7                  (0x07)
                             5411 ; 102  |#define  USB_SERVICE_EP8                  (0x08)
TASKING DSP2410 assembler v1.5r1 Build 138 SN 00100122
                                                                                                                            Page  85

M:ADDR CODE           CYCLES LINE SOURCELINE
                             5412 ; 103  |#define  USB_SERVICE_EP9                  (0x09)
                             5413 ; 104  |#define  USB_SERVICE_EP10                 (0x0a)
                             5414 ; 105  |#define  USB_SERVICE_EP11                 (0x0b)
                             5415 ; 106  |#define  USB_SERVICE_EP12                 (0x0c)
                             5416 ; 107  |#define  USB_SERVICE_EP13                 (0x0d)
                             5417 ; 108  |#define  USB_SERVICE_EP14                 (0x0e)
                             5418 ; 109  |#define  USB_SERVICE_EP15                 (0x0f)
                             5419 ; 110  |#define  USB_SERVICE_BUS_RESET            (0x10)
                             5420 ; 111  |#define  USB_SERVICE_SUSPEND              (0x11)
                             5421 ; 112  |#define  USB_SERVICE_SOF                  (0x12)
                             5422 ; 113  |#define  USB_SERVICE_RESUME               (0x13)
                             5423 ; 114  |#define  USB_SERVICE_SLEEP                (0x14)
                             5424 ; 115  |#define  USB_SERVICE_SPEED_DETECTION      (0x15)
                             5425 ; 116  |#define  USB_SERVICE_TEST                 (0x16)
                             5426 ; 117  |#define  USB_SERVICE_CHANGE_CONFIG        (0x17)
                             5427 ; 118  |#define  USB_SERVICE_CHANGE_IFACE         (0x18)   
                             5428 ; 119  |#define  NON_EP_SERVICES                  (USB_SERVICE_SPEED_DETECTION - USB_SERVICE_EP15)
                                  
                             5429 ; 120  |
                             5430 ; 121  |// This is the maximum service structures allocated 
                             5431 ; 122  |// One for each End point + the common services (non endpoint services) 
                             5432 ; 123  |#define MAX_NUMBER_SERVICES               (MAX_NUM_EP + NON_EP_SERVICES)  
                             5433 ; 124  |
                             5434 ; 125  |#define NUMBER_BYTES_IN_SETUP               (8)
                             5435 ; 126  |
                             5436 ; 127  |// possible values of btStatus on the xd_struct
                             5437 ; 128  |#define  USB_STATUS_TRANSFER_IDLE           (0)
                             5438 ; 129  |#define  USB_STATUS_TRANSFER_SUCCESS        (1)            
                             5439 ; 130  |#define  USB_STATUS_TRANSFER_ACCEPTED       (2)
                             5440 ; 131  |#define  USB_STATUS_TRANSFER_IN_PROGRESS    (3)
                             5441 ; 132  |#define  USB_STATUS_TRANSFER_ERROR          (4)
                             5442 ; 133  |
                             5443 ; 134  |// types of status set/returned by set_status() and get_status()
                             5444 ; 135  |#define  USB_STATUS_DEVICE_STATE          (0x01)
                             5445 ; 136  |#define  USB_STATUS_INTERFACE             (0x02)
                             5446 ; 137  |#define  USB_STATUS_ADDRESS               (0x03)
                             5447 ; 138  |#define  USB_STATUS_CURRENT_CONFIG        (0x04)
                             5448 ; 139  |#define  USB_STATUS_SOF_COUNT             (0x05)
                             5449 ; 140  |#define  USB_STATUS                       (0x06)
                             5450 ; 141  |#define  USB_STATUS_TEST_MODE             (0x07)
                             5451 ; 142  |#define  USB_STATUS_DEVICE_SPEED          (0x08)  
                             5452 ; 143  |#define  USB_STATUS_DEVICE_TEST           (0x09)  
                             5453 ; 144  |#define  USB_STATUS_CURRENT_IFACE         (0x0a)
                             5454 ; 145  |#define  USB_STATUS_CONNECTION            (0x0b)  
                             5455 ; 146  |// For status endpoint, the endpoint number is coded in the less significant nibble
                             5456 ; 147  |#define  USB_STATUS_ENDPOINT              (0x10)
                             5457 ; 148  |#define  USB_STATUS_ENDPOINT_NUMBER_MASK  (0x0F)
                             5458 ; 149  |
                             5459 ; 150  |#define USB_MAX_SIZE_PER_TRANSFER       (0x4000)    // This is the maximum size that
                             5460 ; 151  |                                                    // we allow per transfer
                             5461 ; 152  |
                             5462 ; 153  |//Possible states the device can be in
                             5463 ; 154  |#define  USB_STATE_UNKNOWN                   (0xff)
                             5464 ; 155  |#define  USB_STATE_UNPLUGGED                 (0x05) // USB Cable unplugged
                             5465 ; 156  |#define  USB_STATE_PLUGGED                   (0x04) // USB Cable inserted
                             5466 ; 157  |#define  USB_STATE_POWERED                   (0x03)
                             5467 ; 158  |#define  USB_STATE_DEFAULT                   (0x02)
                             5468 ; 159  |#define  USB_STATE_ADDRESSED                 (0x01)
                             5469 ; 160  |#define  USB_STATE_CONFIGURED                (0x00)
                             5470 ; 161  |#define  USB_STATE_SUSPENDED                 (0x80)
                             5471 ; 162  |
                             5472 ; 163  |// Possible states the connection can be in
TASKING DSP2410 assembler v1.5r1 Build 138 SN 00100122
                                                                                                                            Page  86

M:ADDR CODE           CYCLES LINE SOURCELINE
                             5473 ; 164  |//#define USB_STATE_UNKNOWN                 (0xff)
                             5474 ; 165  |#define USB_CONNECTED                       (0x00)
                             5475 ; 166  |#define USB_DISCONNECTED                    (0x01)
                             5476 ; 167  |
                             5477 ; 168  |
                             5478 ; 169  |
                             5479 ; 170  |typedef union
                             5480 ; 171  |{
                             5481 ; 172  |    struct
                             5482 ; 173  |    {
                             5483 ; 174  |        int Recipient               : 5;
                             5484 ; 175  |        int Type                    : 2;
                             5485 ; 176  |        int DataTransferDirection   : 1;
                             5486 ; 177  |        int Request                 : 8;
                             5487 ; 178  |        int                         : 8;
                             5488 ; 179  |    } B;
                             5489 ; 180  |    
                             5490 ; 181  |    int I;
                             5491 ; 182  |} USBRequestType ;
                             5492 ; 183  |
                             5493 ; 184  |typedef struct {
                             5494 ; 185  |   BYTE     bValid;
                             5495 ; 186  |   USBRequestType RequestType;
                             5496 ; 187  |   BYTE     btRequest;
                             5497 ; 188  |   WORD     wValue;
                             5498 ; 189  |   WORD     wIndex;
                             5499 ; 190  |   WORD     wLength;
                             5500 ; 191  |    } USB_SetupData;
                             5501 ; 192  |
                             5502 ; 193  |// Descriptor sizes in bytes
                             5503 ; 194  |#define SIZE_DEVICE_DESCRIPTOR_IN_BYTES     (18)
                             5504 ; 195  |#define SIZE_DEVICE_DESCRIPTOR_IN_WORDS     (6)
                             5505 ; 196  |#define SIZE_DEVICE_QUALIFIER_DESCRIPTOR_IN_BYTES   (10)
                             5506 ; 197  |#define SIZE_DEVICE_QUALIFIER_DESCRIPTOR_IN_WORDS   (4)
                             5507 ; 198  |#define SIZE_CONFIG_DESCRIPTOR_IN_BYTES     (9)
                             5508 ; 199  |#define SIZE_CONFIG_DESCRIPTOR_IN_WORDS     (3)
                             5509 ; 200  |#define SIZE_INTERFACE_DESCRIPTOR_IN_BYTES  (9)
                             5510 ; 201  |#define SIZE_INTERFACE_DESCRIPTOR_IN_WORDS  (3)
                             5511 ; 202  |#define SIZE_ENDPOINT_DESCRIPTOR_IN_BYTES   (7)
                             5512 ; 203  |
                             5513 ; 204  |
                             5514 ; 205  |// Descriptor types
                             5515 ; 206  |#define DESCRIPTOR_TYPE_DEVICE              (0x01)
                             5516 ; 207  |#define DESCRIPTOR_TYPE_CONFIG              (0x02)
                             5517 ; 208  |#define DESCRIPTOR_TYPE_STRING              (0x03)
                             5518 ; 209  |#define DESCRIPTOR_TYPE_INTERFACE           (0x04)
                             5519 ; 210  |#define DESCRIPTOR_TYPE_ENDPOINT            (0x05)
                             5520 ; 211  |#define DESCRIPTOR_TYPE_DEVICE_QUALIFIER    (0x06)
                             5521 ; 212  |#define DESCRIPTOR_TYPE_OTHER_SPEED_CONFIG  (0x07)
                             5522 ; 213  |#define DESCRIPTOR_TYPE_INTERFACE_POWER     (0x08)
                             5523 ; 214  |
                             5524 ; 215  |
                             5525 ; 216  |#define USB_REQUEST_DIRECTION_HOST_TO_DEVICE    ((WORD)0x000000)
                             5526 ; 217  |#define USB_REQUEST_DIRECTION_DEVICE_TO_HOST    ((WORD)0x000001)
                             5527 ; 218  |
                             5528 ; 219  |#define USB_REQUEST_TYPE_STANDARD               ((WORD)0x000000)
                             5529 ; 220  |#define USB_REQUEST_TYPE_CLASS                  ((WORD)0x000001)
                             5530 ; 221  |#define USB_REQUEST_TYPE_VENDOR                 ((WORD)0x000002)
                             5531 ; 222  |#define USB_REQUEST_TYPE_RESERVED               ((WORD)0x000003)
                             5532 ; 223  |
                             5533 ; 224  |#define USB_REQUEST_RECIPIENT_DEVICE            ((WORD)0x000000)
                             5534 ; 225  |#define USB_REQUEST_RECIPIENT_INTERFACE         ((WORD)0x000001)
TASKING DSP2410 assembler v1.5r1 Build 138 SN 00100122
                                                                                                                            Page  87

M:ADDR CODE           CYCLES LINE SOURCELINE
                             5535 ; 226  |#define USB_REQUEST_RECIPIENT_ENDPOINT          ((WORD)0x000002)
                             5536 ; 227  |#define USB_REQUEST_RECIPIENT_OTHER             ((WORD)0x000003)
                             5537 ; 228  |
                             5538 ; 229  |#define USB_REQUEST_STANDARD_GET_STATUS         ((WORD)0x000000)
                             5539 ; 230  |#define USB_REQUEST_STANDARD_CLEAR_FEATURE      ((WORD)0x000001)
                             5540 ; 231  |#define USB_REQUEST_STANDARD_RESERVED_1         ((WORD)0x000002)
                             5541 ; 232  |#define USB_REQUEST_STANDARD_SET_FEATURE        ((WORD)0x000003)
                             5542 ; 233  |#define USB_REQUEST_STANDARD_RESERVED_2         ((WORD)0x000004)
                             5543 ; 234  |#define USB_REQUEST_STANDARD_SET_ADDRESS        ((WORD)0x000005)
                             5544 ; 235  |#define USB_REQUEST_STANDARD_GET_DESCRIPTOR     ((WORD)0x000006)
                             5545 ; 236  |#define USB_REQUEST_STANDARD_SET_DESCRIPTOR     ((WORD)0x000007)
                             5546 ; 237  |#define USB_REQUEST_STANDARD_GET_CONFIGURATION  ((WORD)0x000008)
                             5547 ; 238  |#define USB_REQUEST_STANDARD_SET_CONFIGURATION  ((WORD)0x000009)
                             5548 ; 239  |#define USB_REQUEST_STANDARD_GET_INTERFACE      ((WORD)0x00000A)
                             5549 ; 240  |#define USB_REQUEST_STANDARD_SET_INTERFACE      ((WORD)0x00000B)
                             5550 ; 241  |#define USB_REQUEST_STANDARD_SYNCH_FRAME        ((WORD)0x00000C)
                             5551 ; 242  |
                             5552 ; 243  |#define USB_CLEAR_FEATURE_ENDPOINT_HALT         (0)
                             5553 ; 244  |#define USB_CLEAR_FEATURE_REMOTE_WAKEUP         (1)
                             5554 ; 245  |
                             5555 ; 246  |
                             5556 ; 247  |// Struct Device Descriptor
                             5557 ; 248  |typedef struct {
                             5558 ; 249  |    BYTE    bLength;                // (0) Size of this descriptor in bytes (18)
                             5559 ; 250  |    BYTE    btDescriptorType;       // (1) Device descriptor type (1)
                             5560 ; 251  |    BYTE    btBcdUsbLsb;            // (2) USB specification release number (for version 2
                                  .00 0x00)
                             5561 ; 252  |    BYTE    btBcdUsbMsb;            // (3)                                  (for version 2
                                  .00 0x02)     
                             5562 ; 253  |    BYTE    btDeviceClass;          // (4) Class code
                             5563 ; 254  |    BYTE    btDeviceSubclass;       // (5) Subclass code
                             5564 ; 255  |    BYTE    btDeviceProtocol;       // (6) Protocol code
                             5565 ; 256  |    BYTE    btMaxPacketSize0;       // (7) Maximum packet size for endpoint 0 (8, 16, 32 o
                                  r 64)
                             5566 ; 257  |    BYTE    btIdVendorLsb;          // (8) Vendor Id
                             5567 ; 258  |    BYTE    btIdVendorMsb;          // (9)
                             5568 ; 259  |    BYTE    btIdProductLsb;         // (10) Product Id
                             5569 ; 260  |    BYTE    btIdProductMsb;         // (11)
                             5570 ; 261  |    BYTE    btBcdReleaseLsb;        // (12) Device release number in BCD
                             5571 ; 262  |    BYTE    btBcdReleaseMsb;        // (13)
                             5572 ; 263  |    BYTE    btIndexManufacturer;    // (14) Index of string descriptor describing Manufact
                                  urer
                             5573 ; 264  |    BYTE    btIndexProduct;         // (15) Index of string descriptor describing Product
                             5574 ; 265  |    BYTE    btIndexSerialNumber;    // (16) Index of string descriptor describing Device S
                                  erial Number
                             5575 ; 266  |    BYTE    btNumConfigurations;    // (17) Number of possible configurations
                             5576 ; 267  |} Struct_Standard_Dev_Desc;
                             5577 ; 268  |
                             5578 ; 269  |// Struct Device Qualifier Descriptor
                             5579 ; 270  |typedef struct {
                             5580 ; 271  |    BYTE    bLength;                // (0) Size of this descriptor in bytes (10)
                             5581 ; 272  |    BYTE    btDescriptorType;       // (1) Device descriptor type (6)
                             5582 ; 273  |    BYTE    btBcdUsbLsb;            // (2) USB specification release number (for version 2
                                  .00 0x00)
                             5583 ; 274  |    BYTE    btBcdUsbMsb;            // (3)                                  (for version 2
                                  .00 0x02)     
                             5584 ; 275  |    BYTE    btDeviceClass;          // (4) Class code
                             5585 ; 276  |    BYTE    btDeviceSubclass;       // (5) Subclass code
                             5586 ; 277  |    BYTE    btDeviceProtocol;       // (6) Protocol code
                             5587 ; 278  |    BYTE    btMaxPacketSize0;       // (7) Maximum packet size for endpoint 0 other speed 
                                  (8, 16, 32 or 64)
                             5588 ; 279  |    BYTE    btNumConfigurations;    // (8) Number of other-speed possible configurations
TASKING DSP2410 assembler v1.5r1 Build 138 SN 00100122
                                                                                                                            Page  88

M:ADDR CODE           CYCLES LINE SOURCELINE
                             5589 ; 280  |    BYTE    btReserved;             // (9) Reserved for future use, must be 0
                             5590 ; 281  |} Struct_Dev_Qualifier_Desc;
                             5591 ; 282  |
                             5592 ; 283  |// Struct Configuration Descriptor
                             5593 ; 284  |typedef struct {
                             5594 ; 285  |    BYTE    bLength;                // (0) Size of this descriptor in bytes (9)
                             5595 ; 286  |    BYTE    btDescriptorType;       // (1) Device descriptor type (2 or 7)
                             5596 ; 287  |    BYTE    btTotalLengthLsb;       // (2) Total length of data returned for this config.
                             5597 ; 288  |    BYTE    btTotalLengthMsb;       // (3)                                  
                             5598 ; 289  |    BYTE    btNumInterfaces;        // (4) Number of Interfaces supported by this configur
                                  ation
                             5599 ; 290  |    BYTE    btConfigurationValue;   // (5) Value to use as an argument to the SetConfigura
                                  tion() request
                             5600 ; 291  |    BYTE    btIndexConfiguration;   // (6) Index of string descriptor describing this conf
                                  iguration
                             5601 ; 292  |    BYTE    btBitMapAttributes;     // (7) Configuration Characteristics
                             5602 ; 293  |                                    //     D7:      Reserved (set to one)
                             5603 ; 294  |                                    //     D6:      Self-powered
                             5604 ; 295  |                                    //     D5:      Remote Wakeup
                             5605 ; 296  |                                    //     D4..0:   Reserved (reset to zero)        
                             5606 ; 297  |    BYTE    btMaxPower;             // (8) Maximum power consumption expressed in 2mA unit
                                  s.
                             5607 ; 298  |} Struct_Standard_Config_Desc, Struct_Other_Speed_Config_Desc;
                             5608 ; 299  |
                             5609 ; 300  |// Struct Interface Descriptor
                             5610 ; 301  |typedef struct {
                             5611 ; 302  |    BYTE    bLength;                // (0) Size of this descriptor in bytes (9)
                             5612 ; 303  |    BYTE    btDescriptorType;       // (1) Device descriptor type (4)
                             5613 ; 304  |    BYTE    btInterfaceNum;         // (2) Number of this interface. Zero-based value.
                             5614 ; 305  |    BYTE    btAlternateSetting;     // (3)                                  
                             5615 ; 306  |    BYTE    btNumEndpoints;         // (4) Number of endpointsused by this interface (excl
                                  uding endpoint 0).
                             5616 ; 307  |    BYTE    btInterfaceClass;       // (5) Class code
                             5617 ; 308  |    BYTE    btInterfaceSubClass;    // (6) Sub Class code
                             5618 ; 309  |    BYTE    btInterfaceProtocol;    // (7) Protocol Code
                             5619 ; 310  |    BYTE    btIndexInterface;       // (8) Index of string descriptor describing this inte
                                  rface
                             5620 ; 311  |} Struct_Standard_Interface_Desc;
                             5621 ; 312  |
                             5622 ; 313  |// Struct Endpoint Descriptor
                             5623 ; 314  |typedef struct {
                             5624 ; 315  |    BYTE    bLength;                // (0) Size of this descriptor in bytes (7)
                             5625 ; 316  |    BYTE    btDescriptorType;       // (1) Device descriptor type (5)
                             5626 ; 317  |    BYTE    btEndpointAddress;      // (2) Address of the endpoint on the USB device descr
                                  ibed by this descriptor
                             5627 ; 318  |                                    //      Bit 3..0: Endpoint number
                             5628 ; 319  |                                    //      Bit 6..4: Reserved, reset to zero
                             5629 ; 320  |                                    //      Bit 7:    Direction. Ignored for control endpo
                                  ints (0 OUT, 1 IN)
                             5630 ; 321  |    BYTE    btBitMapAttributes;     // (3) Endpoint attributes
                             5631 ; 322  |                                    //      bits 1..0: Transfer Type (00 Control, 01 Iso, 
                                  10 Bulk, 11 Int)
                             5632 ; 323  |                                    //      bits 5..2: If not an iso endpoints, they are r
                                  eserved and must be reset to zero.
                             5633 ; 324  |                                    //      bits 7..6: Reserved bits, must be reset to zer
                                  o.                                    
                             5634 ; 325  |    BYTE    btMaxPacketSizeLsb;     // (4) Maximum packet size. Refer to standard for bits
                                   specification
                             5635 ; 326  |    BYTE    btMaxPacketSizeMsb;     // (5)
                             5636 ; 327  |    BYTE    btInterval;             // (6) Interval for polling endpoint for data transfer
                                  s (refer to standard)
                             5637 ; 328  |} Struct_Standard_Endpoint_Desc;
TASKING DSP2410 assembler v1.5r1 Build 138 SN 00100122
                                                                                                                            Page  89

M:ADDR CODE           CYCLES LINE SOURCELINE
                             5638 ; 329  |
                             5639 ; 330  |typedef struct {
                             5640 ; 331  |    BYTE    btLength;                   // (0) Size of this descriptor in bytes (2*MAX_USB
                                  _LANG + 2)
                             5641 ; 332  |    BYTE    btDescriptorType;           // (1) String descriptor type (3)
                             5642 ; 333  |    BYTE    btString[MAX_STRING*2];       
                             5643 ; 334  |} Struct_String_Desc;
                             5644 ; 335  |
                             5645 ; 336  |//
                             5646 ; 337  |// Externals
                             5647 ; 338  |//
                             5648 ; 339  |extern void _reentrant usb_dci_chip_enable (void);
                             5649 ; 340  |extern void _reentrant usb_dci_shutdown(void);
                             5650 ; 341  |
                             5651 ; 342  |BYTE _reentrant usb_device_init(void);
                             5652 ; 343  |void _inline usb_device_shutdown(void)
                             5653 ; 344  |{
                             5654 ; 345  |    usb_dci_shutdown();
                             5655 ; 346  |}
                             5656 ; 347  |
                             5657 ; 348  |BYTE _reentrant usb_device_register_service(BYTE btType, void (* Service)(BOOL bSetup, BYT
                                  E btDirection, BYTE _USB_MEM * pbtBuffer, WORD wLength,WORD wPrivateData)); 
                             5658 ; 349  |//Remove unused function usb_device_get_service() to reclain _P memroy.
                             5659 ; 350  |//BYTE _reentrant usb_device_get_service(BYTE btType, void (* Service)(BOOL bSetup, BYTE b
                                  tDirection, BYTE _USB_MEM * pbtBuffer, WORD wLength)); 
                             5660 ; 351  |
                             5661 ; 352  |BYTE _reentrant usb_device_init_endpoint(BYTE btEndpoint, USHORT usMaxPacketSize, BYTE btD
                                  irection, BYTE btType, BOOL bFlag);
                             5662 ; 353  |
                             5663 ; 354  |extern USB_SetupData *_reentrant usb_dci_get_setup_data(BYTE btEndpoint);
                             5664 ; 355  |#define usb_device_read_setup_data(btEndpoint) usb_dci_get_setup_data(btEndpoint)
                             5665 ; 356  |
                             5666 ; 357  |void _reentrant usb_device_get_status(BYTE btType, USHORT * pusStatus);
                             5667 ; 358  |void _reentrant usb_device_set_status(BYTE btType, USHORT usStatus);
                             5668 ; 359  |BYTE _reentrant usb_device_get_transfer_status(BYTE btEndpoint, BYTE btDirection);
                             5669 ; 360  |
                             5670 ; 361  |extern void _reentrant usb_dci_stall_endpoint(BYTE btEndpoint, BYTE btDirection);
                             5671 ; 362  |#define usb_device_stall_endpoint(btEndpoint, btDirection) usb_dci_stall_endpoint((btEndpo
                                  int), (btDirection))
                             5672 ; 363  |
                             5673 ; 364  |extern void _reentrant usb_dci_unstall_endpoint(BYTE btEndpoint, BYTE btDirection);
                             5674 ; 365  |#define usb_device_unstall_endpoint(btEndpoint, btDirection) usb_dci_unstall_endpoint((btE
                                  ndpoint), (btDirection))
                             5675 ; 366  |
                             5676 ; 367  |extern void _reentrant usb_dci_finish_transaction(BYTE btEndpoint);
                             5677 ; 368  |#define usb_device_finish_transaction(btEndpoint) usb_dci_finish_transaction(btEndpoint);
                             5678 ; 369  |
                             5679 ; 370  |////////////////////////////////////////////////////////////////////////////////
                             5680 ; 371  |//
                             5681 ; 372  |//>  Name:          usb_device_enable
                             5682 ; 373  |//
                             5683 ; 374  |//   Type:          Function
                             5684 ; 375  |//
                             5685 ; 376  |//   Description:   Enables the USB device for transfers
                             5686 ; 377  |//
                             5687 ; 378  |//   Inputs:        none
                             5688 ; 379  |//
                             5689 ; 380  |//   Outputs:       USB_OK or error code
                             5690 ; 381  |//
                             5691 ; 382  |//   Notes:         none
                             5692 ; 383  |//<
                             5693 ; 384  |////////////////////////////////////////////////////////////////////////////////
TASKING DSP2410 assembler v1.5r1 Build 138 SN 00100122
                                                                                                                            Page  90

M:ADDR CODE           CYCLES LINE SOURCELINE
                             5694 ; 385  |void _inline usb_device_enable(void)
                             5695 ; 386  |{
                             5696 ; 387  |    usb_dci_chip_enable();
                             5697 ; 388  |}
                             5698 ; 389  |
                             5699 ; 390  |void _reentrant usb_device_release(void);
                             5700 ; 391  |void _reentrant usb_device_hold(void);
                             5701 ; 392  |BYTE _reentrant usb_device_is_hold(void);
                             5702 ; 393  |void _reentrant usb_device_data_phase_required(void);
                             5703 ; 394  |
                             5704 ; 395  |BOOL _reentrant usb_device_is_first_init(void);
                             5705 ; 396  |void _reentrant usb_device_set_first_init(void);
                             5706 ; 397  |void _reentrant usb_device_clear_first_init(void);
                             5707 ; 398  |
                             5708 ; 399  |WORD _reentrant usb_get_current_limit(void);
                             5709 ; 400  |RETCODE _reentrant usb_set_current_limit(WORD);
                             5710 ; 401  |
                             5711 ; 402  |////////////////////////////////////////////////////////////////////
                             5712 ; 403  |extern BYTE _reentrant usb_dci_get_endpoint_status(BYTE btEndpoint);
                             5713 ; 404  |#define usb_device_get_endpoint_status(btEndpoint) usb_dci_get_endpoint_status(btEndpoint)
                                  
                             5714 ; 405  |
                             5715 ; 406  |#define USB_ENDPOINT_STATUS_OK                          0
                             5716 ; 407  |#define USB_ENDPOINT_STATUS_STALLED                     1
                             5717 ; 408  |#define USB_ENDPOINT_STATUS_RECIEVED_UNSTALL_REQUEST    2
                             5718 ; 409  |// WHQL
                             5719 ; 410  |#define USB_ENDPOINT_STATUS_HOST_STALLED                3
                             5720 ; 411  |////////////////////////////////////////////////////////////////////
                             5721 ; 412  |
                             5722 ; 413  |
                             5723 ; 414  |BYTE _reentrant usb_device_send_data(BYTE btEndpoint, WORD _X * pbtStmpWordAdd, BYTE btByt
                                  eOffset, USHORT usSize, WORD wPrivateData, BOOL bIsDataPhase);
                             5724 ; 415  |BYTE _reentrant usb_device_recv_data(BYTE btEndpoint, WORD _X * pbtStmpWordAdd, BYTE btByt
                                  eOffset, USHORT usSize, WORD wPrivateData, BOOL bIsDataPhase);
                             5725 ; 416  |void _reentrant ch9ServiceEp0(BOOL bSetup, BYTE btDirection, WORD _X *pbtBuffer, WORD wLen
                                  gth,WORD wPrivateData);
                             5726 ; 417  |BYTE _reentrant usb_device_transfer_data(BYTE btEndpoint, WORD _X* pbtStmpWordAdd, 
                             5727 ; 418  |                                         BYTE btByteOffset, USHORT usSize, WORD wPrivateDa
                                  ta, 
                             5728 ; 419  |                                         BOOL bIsDataPhase, WORD wDirection);
                             5729 ; 420  |
                             5730 ; 421  |#ifndef CUSTOMIZE_UNICODE
                             5731 ; 422  |extern const BYTE g_Manufacturer[];
                             5732 ; 423  |extern const BYTE g_ProductName[];
                             5733 ; 424  |extern const BYTE g_ConfigString[];
                             5734 ; 425  |extern const BYTE g_Interface0String[];
                             5735 ; 426  |extern const BYTE g_Interface1String[];
                             5736 ; 427  |extern const BYTE g_MSOSDescriptorString[];
                             5737 ; 428  |#else   // CUSTOMIZE_UNICODE
                             5738 ; 429  |extern const WORD g_Manufacturer[];
                             5739 ; 430  |extern const WORD g_ProductName[];
                             5740 ; 431  |extern const WORD g_ConfigString[];
                             5741 ; 432  |extern const WORD g_Interface0String[];
                             5742 ; 433  |extern const WORD g_Interface1String[];
                             5743 ; 434  |extern const WORD g_MSOSDescriptorString[];
                             5744 ; 435  |#endif
                             5745 ; 436  |extern WORD g_LanguageList[];
                             5746 ; 437  |
                             5747 ; 438  |extern const BYTE g_SCSIVendorID[];
                             5748 ; 439  |extern const BYTE g_SCSIProductID[];
                             5749 ; 440  |extern void *g_pStrings[];
                             5750 ; 441  |
TASKING DSP2410 assembler v1.5r1 Build 138 SN 00100122
                                                                                                                            Page  91

M:ADDR CODE           CYCLES LINE SOURCELINE
                             5751 ; 442  |extern WORD g_wUSBVendorID;
                             5752 ; 443  |extern WORD g_wUSBProductID;
                             5753 ; 444  |extern WORD g_wUSBReleaseID;
                             5754 ; 445  |
                             5755 ; 446  |#endif
                             5756 ; 447  |/* EOF */
                             5757 ; 448  |
                             5758 
                             5760 
                             5761 ; 7    |#include "batterycharge.h"
                             5762 
                             5764 
                             5765 ; 1    |#ifndef __BATTERYCHARGE_H
                             5766 ; 2    |#define __BATTERYCHARGE_H
                             5767 ; 3    |
                             5768 ; 4    |//entry point for menus. function called via SysCallFunction()
                             5769 ; 5    |#ifdef STMP_BUILD_PLAYER
                             5770 ; 6    |_reentrant int BatteryChargeStateMachine(int a, int b, int *c);
                             5771 ; 7    |#else
                             5772 ; 8    |_reentrant void BatteryChargeStateMachine(void);
                             5773 ; 9    |#endif
                             5774 ; 10   |
                             5775 ; 11   |_reentrant WORD BatteryChargeInitialize(void);
                             5776 ; 12   |_reentrant void BatteryChargeDisableCharging(BOOL);
                             5777 ; 13   |_reentrant void BatteryChargeEnableCharging(void);
                             5778 ; 14   |_reentrant BOOL BatteryChargeIsCharging(void);
                             5779 ; 15   |_reentrant BOOL BatteryChargeIsTrickleCharging(void);
                             5780 ; 16   |
                             5781 ; 17   |_reentrant WORD BatteryChargeImplementationInitialize(void);
                             5782 ; 18   |_reentrant void BatteryChargeImplementationSample(BOOL);
                             5783 ; 19   |_reentrant WORD BatteryChargeImplementatonGetCurrentLimit(void);
                             5784 ; 20   |
                             5785 ; 21   |
                             5786 ; 22   |#endif 
                             5787 
                             5789 
                             5790 ; 8    |#include "regsdcdc.h"
                             5791 
                             5793 
                             5794 ; 1    |#if !(defined(regsdcdcinc))
                             5795 ; 2    |
                             5796 ; 3    |#define regssysteminc 1
                             5797 ; 4    |
                             5798 ; 5    |
                             5799 ; 6    |
                             5800 ; 7    |#include "types.h"
                             5801 
                             5803 
                             5804 ; 1    |////////////////////////////////////////////////////////////////////////////////
                             5805 ; 2    |// Copyright(C) SigmaTel, Inc. 2000-2004
                             5806 ; 3    |//
                             5807 ; 4    |// Filename: types.h
                             5808 ; 5    |// Description: Standard data types
                             5809 ; 6    |////////////////////////////////////////////////////////////////////////////////
                             5810 ; 7    |
                             5811 ; 8    |#ifndef _TYPES_H
                             5812 ; 9    |#define _TYPES_H
                             5813 ; 10   |
                             5814 ; 11   |// TODO:  move this outta here!
                             5815 ; 12   |#if !defined(NOERROR)
                             5816 ; 13   |#define NOERROR 0
                             5817 ; 14   |#define SUCCESS 0
TASKING DSP2410 assembler v1.5r1 Build 138 SN 00100122
                                                                                                                            Page  92

M:ADDR CODE           CYCLES LINE SOURCELINE
                             5818 ; 15   |#endif 
                             5819 ; 16   |#if !defined(SUCCESS)
                             5820 ; 17   |#define SUCCESS  0
                             5821 ; 18   |#endif
                             5822 ; 19   |#if !defined(ERROR)
                             5823 ; 20   |#define ERROR   -1
                             5824 ; 21   |#endif
                             5825 ; 22   |#if !defined(FALSE)
                             5826 ; 23   |#define FALSE 0
                             5827 ; 24   |#endif
                             5828 ; 25   |#if !defined(TRUE)
                             5829 ; 26   |#define TRUE  1
                             5830 ; 27   |#endif
                             5831 ; 28   |
                             5832 ; 29   |#if !defined(NULL)
                             5833 ; 30   |#define NULL 0
                             5834 ; 31   |#endif
                             5835 ; 32   |
                             5836 ; 33   |#define MAX_INT     0x7FFFFF
                             5837 ; 34   |#define MAX_LONG    0x7FFFFFffffff
                             5838 ; 35   |        // max positive unsigned long value: -1 == 0xFFFFFFffffff
                             5839 ; 36   |#define MAX_ULONG   (-1) 
                             5840 ; 37   |
                             5841 ; 38   |#define WORD_SIZE   24              // word size in bits
                             5842 ; 39   |#define BYTES_PER_WORD 3            // 8 bit bytes
                             5843 ; 40   |
                             5844 ; 41   |
                             5845 ; 42   |#define BYTE    unsigned char       // btVarName
                             5846 ; 43   |#define CHAR    signed char         // cVarName
                             5847 ; 44   |#define USHORT  unsigned short      // usVarName
                             5848 ; 45   |#define SHORT   unsigned short      // sVarName
                             5849 ; 46   |#define WORD    unsigned int        // wVarName
                             5850 ; 47   |#define INT     signed int          // iVarName
                             5851 ; 48   |#define DWORD   unsigned long       // dwVarName
                             5852 ; 49   |#define LONG    signed long         // lVarName
                             5853 ; 50   |#define BOOL    unsigned int        // bVarName
                             5854 ; 51   |#define FRACT   _fract              // frVarName
                             5855 ; 52   |#define LFRACT  long _fract         // lfrVarName
                             5856 ; 53   |#define CIRC    _circ               // cp<type prefix>VarName (see below)
                             5857 ; 54   |#define FLOAT   float               // fVarName
                             5858 ; 55   |#define DBL     double              // dVarName
                             5859 ; 56   |#define ENUM    enum                // eVarName
                             5860 ; 57   |#define CMX     _complex            // cmxVarName
                             5861 ; 58   |typedef WORD UCS3;                   // 
                             5862 ; 59   |
                             5863 ; 60   |#define UINT16  unsigned short
                             5864 ; 61   |#define UINT8   unsigned char   
                             5865 ; 62   |#define UINT32  unsigned long
                             5866 ; 63   |#define UINT64  unsigned long   // need to figure out how to do 64 bit values.  Or port ex
                                  isiting code to only use 48 bit
                             5867 ; 64   |#define INT64   unsigned long   // need to figure out how to do 64 bit values.  Or port ex
                                  isiting code to only use 48 bit
                             5868 ; 65   |#define WCHAR   UINT16
                             5869 ; 66   |
                             5870 ; 67   |//UINT128 is 16 bytes or 6 words
                             5871 ; 68   |typedef struct UINT128_3500 {   
                             5872 ; 69   |    int val[6];     
                             5873 ; 70   |} UINT128_3500;
                             5874 ; 71   |
                             5875 ; 72   |#define UINT128   UINT128_3500
                             5876 ; 73   |
                             5877 ; 74   |// Little endian word packed byte strings:   
TASKING DSP2410 assembler v1.5r1 Build 138 SN 00100122
                                                                                                                            Page  93

M:ADDR CODE           CYCLES LINE SOURCELINE
                             5878 ; 75   |//      _packed BYTE bTextVarName[]="a string";  bText is a packed byte string prefix
                             5879 ; 76   |// Convert to big endian words by reordering bytes from high to low using swizzle.
                             5880 ; 77   |// Little endian word packed byte strings:   
                             5881 ; 78   |//      _packed BYTE bTextVarName[]="a string";  bText is a packed byte string prefix
                             5882 ; 79   |// Convert to big endian words by reordering bytes from high to low using swizzle.
                             5883 ; 80   |
                             5884 ; 81   |// Declare Memory Spaces To Use When Coding
                             5885 ; 82   |// A. Sector Buffers
                             5886 ; 83   |#define SECTOR_BUFFER_MEM_X _X
                             5887 ; 84   |#define SECTOR_BUFFER_MEM_Y _Y
                             5888 ; 85   |#define SECTOR_BUFFER_MEM SECTOR_BUFFER_MEM_X
                             5889 ; 86   |typedef WORD SECTOR_BUFFER_MEM SECTOR_BUFFER;
                             5890 ; 87   |typedef SECTOR_BUFFER * P_SECTOR_BUFFER;
                             5891 ; 88   |// B. Media DDI Memory
                             5892 ; 89   |#define MEDIA_DDI_MEM _Y
                             5893 ; 90   |
                             5894 ; 91   |
                             5895 ; 92   |
                             5896 ; 93   |// Pointers to linear structures are labeled as: p<type prefix>VarName
                             5897 ; 94   |// Examples of circular pointers:
                             5898 ; 95   |//    INT CIRC cpiVarName
                             5899 ; 96   |//    DWORD CIRC cpdwVarName
                             5900 ; 97   |
                             5901 ; 98   |#define RETCODE INT                 // rcVarName
                             5902 ; 99   |
                             5903 ; 100  |// generic bitfield structure
                             5904 ; 101  |struct Bitfield {
                             5905 ; 102  |    unsigned int B0  :1;
                             5906 ; 103  |    unsigned int B1  :1;
                             5907 ; 104  |    unsigned int B2  :1;
                             5908 ; 105  |    unsigned int B3  :1;
                             5909 ; 106  |    unsigned int B4  :1;
                             5910 ; 107  |    unsigned int B5  :1;
                             5911 ; 108  |    unsigned int B6  :1;
                             5912 ; 109  |    unsigned int B7  :1;
                             5913 ; 110  |    unsigned int B8  :1;
                             5914 ; 111  |    unsigned int B9  :1;
                             5915 ; 112  |    unsigned int B10 :1;
                             5916 ; 113  |    unsigned int B11 :1;
                             5917 ; 114  |    unsigned int B12 :1;
                             5918 ; 115  |    unsigned int B13 :1;
                             5919 ; 116  |    unsigned int B14 :1;
                             5920 ; 117  |    unsigned int B15 :1;
                             5921 ; 118  |    unsigned int B16 :1;
                             5922 ; 119  |    unsigned int B17 :1;
                             5923 ; 120  |    unsigned int B18 :1;
                             5924 ; 121  |    unsigned int B19 :1;
                             5925 ; 122  |    unsigned int B20 :1;
                             5926 ; 123  |    unsigned int B21 :1;
                             5927 ; 124  |    unsigned int B22 :1;
                             5928 ; 125  |    unsigned int B23 :1;
                             5929 ; 126  |};
                             5930 ; 127  |
                             5931 ; 128  |union BitInt {
                             5932 ; 129  |        struct Bitfield B;
                             5933 ; 130  |        int        I;
                             5934 ; 131  |};
                             5935 ; 132  |
                             5936 ; 133  |#define MAX_MSG_LENGTH 10
                             5937 ; 134  |struct CMessage
                             5938 ; 135  |{
                             5939 ; 136  |        unsigned int m_uLength;
TASKING DSP2410 assembler v1.5r1 Build 138 SN 00100122
                                                                                                                            Page  94

M:ADDR CODE           CYCLES LINE SOURCELINE
                             5940 ; 137  |        unsigned int m_uMsg[MAX_MSG_LENGTH];
                             5941 ; 138  |};
                             5942 ; 139  |
                             5943 ; 140  |typedef struct {
                             5944 ; 141  |    WORD m_wLength;
                             5945 ; 142  |    WORD m_wMessage;
                             5946 ; 143  |    WORD m_wParams[MAX_MSG_LENGTH];
                             5947 ; 144  |} Message;
                             5948 ; 145  |
                             5949 ; 146  |struct MessageQueueDescriptor
                             5950 ; 147  |{
                             5951 ; 148  |        int *m_pBase;
                             5952 ; 149  |        int m_iModulo;
                             5953 ; 150  |        int m_iSize;
                             5954 ; 151  |        int *m_pHead;
                             5955 ; 152  |        int *m_pTail;
                             5956 ; 153  |};
                             5957 ; 154  |
                             5958 ; 155  |struct ModuleEntry
                             5959 ; 156  |{
                             5960 ; 157  |    int m_iSignaledEventMask;
                             5961 ; 158  |    int m_iWaitEventMask;
                             5962 ; 159  |    int m_iResourceOfCode;
                             5963 ; 160  |    struct MessageQueueDescriptor *m_pMessageQueue;
                             5964 ; 161  |    int _asmfunc (*m_pProcessEntryPoint)(union WaitMask Signals,struct MessageQueueDescrip
                                  tor *);
                             5965 ; 162  |    int _asmfunc (*m_pInitFunction)(struct MessageQueueDescriptor *);
                             5966 ; 163  |    int m_uTimeOutHigh;
                             5967 ; 164  |    int m_uTimeOutLow;
                             5968 ; 165  |    int _asmfunc (*m_pBackgroundFunction)(struct MessageQueueDescriptor *);
                             5969 ; 166  |};
                             5970 ; 167  |
                             5971 ; 168  |union WaitMask{
                             5972 ; 169  |    struct B{
                             5973 ; 170  |        unsigned int m_bNone     :1;
                             5974 ; 171  |        unsigned int m_bMessage  :1;
                             5975 ; 172  |        unsigned int m_bTimer    :1;
                             5976 ; 173  |        unsigned int m_bButton   :1;
                             5977 ; 174  |    } B;
                             5978 ; 175  |    int I;
                             5979 ; 176  |} ;
                             5980 ; 177  |
                             5981 ; 178  |
                             5982 ; 179  |struct Button {
                             5983 ; 180  |        WORD wButtonEvent;
                             5984 ; 181  |        WORD wUnused[MAX_MSG_LENGTH];   
                             5985 ; 182  |};
                             5986 ; 183  |
                             5987 ; 184  |struct Message {
                             5988 ; 185  |        WORD wMsgLength;
                             5989 ; 186  |        WORD wMsgCommand;
                             5990 ; 187  |        WORD wMsgParms[MAX_MSG_LENGTH-1];
                             5991 ; 188  |};
                             5992 ; 189  |
                             5993 ; 190  |union EventTypes {
                             5994 ; 191  |        struct CMessage msg;
                             5995 ; 192  |        struct Button Button ;
                             5996 ; 193  |        struct Message Message;
                             5997 ; 194  |};
                             5998 ; 195  |
                             5999 ; 196  |// next 2 used to get updater build to return correct protocol ver in scsi response.
                             6000 ; 197  |#define BUILD_TYPE_UPDATER  0x100
TASKING DSP2410 assembler v1.5r1 Build 138 SN 00100122
                                                                                                                            Page  95

M:ADDR CODE           CYCLES LINE SOURCELINE
                             6001 ; 198  |#define BUILD_TYPE_HOSTLINK 0x101
                             6002 ; 199  |#define BUILD_TYPE_PLAYER   0x102
                             6003 ; 200  |
                             6004 ; 201  |// Resets part if RETAIL build. DEBUG build executes debug instruction to halt.
                             6005 ; 202  |#define SystemHalt() __asm(" include 'sysmacro.asm' \n error") 
                             6006 ; 203  |#define assert(x)    if(!(x)) __asm(" include 'sysmacro.asm' \n error")
                             6007 ; 204  |
                             6008 ; 205  |#if DEBUG
                             6009 ; 206  |// For DEBUG builds, DebugBuildAssert(condition) halts if condition evaluates to FALSE. 
                             6010 ; 207  |#define DebugBuildAssert(x)    if(!(x)) __asm(" debug ")
                             6011 ; 208  |#else 
                             6012 ; 209  |// For RETAIL builds, DebugBuildAssert(condition) does nothing & execution continues rathe
                                  r than halt or reset. 
                             6013 ; 210  |#define DebugBuildAssert(x)    
                             6014 ; 211  |#endif
                             6015 ; 212  |
                             6016 ; 213  |// Do this in your C files to make a reminder that's displayed during the build.
                             6017 ; 214  |//  #pragma asm
                             6018 ; 215  |//  WARN 'Note to builder: reminder to do this after verifying that'
                             6019 ; 216  |//  #pragma endasm
                             6020 ; 217  |
                             6021 ; 218  |
                             6022 ; 219  |#ifdef COLOR_262K
                             6023 ; 220  |#define RGB(r,g,b)    ((0x0000FC & (r)) << 10) | ((0x0000FC & (g)) << 4) | ((0x0000FC & (b
                                  )) >> 2)    //262k
                             6024 ; 221  |#elif defined(COLOR_65K)
                             6025 ; 222  |#define RGB(r,g,b)    ((0x0000F8 & (r)) << 8) | ((0x0000FC & (g)) << 3) | ((0x0000F8 & (b)
                                  ) >> 3)  //65k
                             6026 ; 223  |#else
                             6027 ; 224  |#define RGB(r,g,b)       ((0x0000F0 & (r)) << 4) | (0x0000F0 & (g)) | ((0x0000F0 & (b)) >>
                                   4)
                             6028 ; 225  |#endif
                             6029 ; 226  |    
                             6030 ; 227  |#endif // #ifndef _TYPES_H
                             6031 
                             6033 
                             6034 ; 8    |
                             6035 ; 9    |
                             6036 ; 10   |
                             6037 ; 11   |//;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                             6038 ; 12   |
                             6039 ; 13   |//   SYSTEM STMP Registers 
                             6040 ; 14   |//      Last Edited 2.19.2003 M. May
                             6041 ; 15   |//;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                             6042 ; 16   |
                             6043 ; 17   |#define HW_DCDC_BASEADDR (0xFA0C)
                             6044 ; 18   |
                             6045 ; 19   |
                             6046 ; 20   |
                             6047 ; 21   |
                             6048 ; 22   |
                             6049 ; 23   |
                             6050 ; 24   |/////////////////////////////////////////////////////////////////////////////////
                             6051 ; 25   |
                             6052 ; 26   |//  DcDc#1 Control Register (HW_DCDC1_CTRL0) Bit Definitions
                             6053 ; 27   |
                             6054 ; 28   |#define HW_DCDC1_CTRL0_PLEVBU_WIDTH (5)
                             6055 ; 29   |#define HW_DCDC1_CTRL0_RSVD0_WIDTH (3)
                             6056 ; 30   |#define HW_DCDC1_CTRL0_PLEVBO_WIDTH (5)
                             6057 ; 31   |#define HW_DCDC1_CTRL0_RSVD1_WIDTH (3)
                             6058 ; 32   |#define HW_DCDC1_CTRL0_NLEV_WIDTH (5)
                             6059 ; 33   |
TASKING DSP2410 assembler v1.5r1 Build 138 SN 00100122
                                                                                                                            Page  96

M:ADDR CODE           CYCLES LINE SOURCELINE
                             6060 ; 34   |#define HW_DCDC1_CTRL0_RSVD2_WIDTH (3)
                             6061 ; 35   |
                             6062 ; 36   |
                             6063 ; 37   |
                             6064 ; 38   |#define HW_DCDC1_CTRL0_PLEVBU_BITPOS (0)
                             6065 ; 39   |#define HW_DCDC1_CTRL0_PLEVBO_BITPOS (8)
                             6066 ; 40   |#define HW_DCDC1_CTRL0_NLEV_BITPOS (16)
                             6067 ; 41   |
                             6068 ; 42   |
                             6069 ; 43   |
                             6070 ; 44   |#define HW_DCDC1_CTRL0_PLEVBU_SETMASK (((1<<HW_DCDC1_CTRL0_PLEVBU_WIDTH)-1)<<HW_DCDC1_CTRL
                                  0_PLEVBU_BITPOS)        
                             6071 ; 45   |#define HW_DCDC1_CTRL0_PLEVBO_SETMASK (((1<<HW_DCDC1_CTRL0_PLEVBO_WIDTH)-1)<<HW_DCDC1_CTRL
                                  0_PLEVBO_BITPOS) 
                             6072 ; 46   |#define HW_DCDC1_CTRL0_NLEV_SETMASK (((1<<HW_DCDC1_CTRL0_NLEV_WIDTH)-1)<<HW_DCDC1_CTRL0_NL
                                  EV_BITPOS)  
                             6073 ; 47   |
                             6074 ; 48   |
                             6075 ; 49   |
                             6076 ; 50   |#define HW_DCDC1_CTRL0_PLEVBU_CLRMASK (~(WORD)HW_DCDC1_CTRL0_PLEVBU_SETMASK)     
                             6077 ; 51   |#define HW_DCDC1_CTRL0_PLEVBO_CLRMASK (~(WORD)HW_DCDC1_CTRL0_PLEVBO_SETMASK) 
                             6078 ; 52   |#define HW_DCDC1_CTRL0_NLEV_CLRMASK (~(WORD)HW_DCDC1_CTRL0_NLEV_SETMASK)  
                             6079 ; 53   |
                             6080 ; 54   |
                             6081 ; 55   |
                             6082 ; 56   |
                             6083 ; 57   |
                             6084 ; 58   |typedef union               
                             6085 ; 59   |{
                             6086 ; 60   |    struct {
                             6087 ; 61   |        unsigned int PLEVBU           : HW_DCDC1_CTRL0_PLEVBU_WIDTH;
                             6088 ; 62   |        unsigned int RSVD0            : HW_DCDC1_CTRL0_RSVD0_WIDTH;
                             6089 ; 63   |        unsigned int PLEVBO           : HW_DCDC1_CTRL0_PLEVBO_WIDTH;
                             6090 ; 64   |        unsigned int RSVD1            : HW_DCDC1_CTRL0_RSVD1_WIDTH;
                             6091 ; 65   |        unsigned int NLEV             : HW_DCDC1_CTRL0_NLEV_WIDTH;
                             6092 ; 66   |        unsigned int RSVD2            : HW_DCDC1_CTRL0_RSVD2_WIDTH;
                             6093 ; 67   |    } B;
                             6094 ; 68   |    unsigned int I;
                             6095 ; 69   |} dcdc1_ctrl0_type;
                             6096 ; 70   |#define HW_DCDC1_CTRL0      (*(volatile dcdc1_ctrl0_type _X*) (HW_DCDC_BASEADDR))    /* Dc
                                  Dc#1 Limit Level Register */
                             6097 ; 71   |
                             6098 ; 72   |
                             6099 ; 73   |
                             6100 ; 74   |
                             6101 ; 75   |/////////////////////////////////////////////////////////////////////////////////
                             6102 ; 76   |
                             6103 ; 77   |//  DCDc#1 Control Register1 (HW_DCDC1_CTRL1) Bit Definitions
                             6104 ; 78   |
                             6105 ; 79   |#define HW_DCDC1_CTRL1_C_WIDTH (4)
                             6106 ; 80   |#define HW_DCDC1_CTRL1_R_WIDTH (4)
                             6107 ; 81   |#define HW_DCDC1_CTRL1_FFOR_WIDTH (3)
                             6108 ; 82   |#define HW_DCDC1_CTRL1_RSVD0_WIDTH (1)
                             6109 ; 83   |#define HW_DCDC1_CTRL1_PFMCTRL_WIDTH (12)
                             6110 ; 84   |
                             6111 ; 85   |
                             6112 ; 86   |
                             6113 ; 87   |#define HW_DCDC1_CTRL1_C_BITPOS (0)
                             6114 ; 88   |#define HW_DCDC1_CTRL1_R_BITPOS (4)
                             6115 ; 89   |#define HW_DCDC1_CTRL1_FFOR_BITPOS (8)
                             6116 ; 90   |#define HW_DCDC1_CTRL1_PFMCTRL_BITPOS (12) 
                             6117 ; 91   |
TASKING DSP2410 assembler v1.5r1 Build 138 SN 00100122
                                                                                                                            Page  97

M:ADDR CODE           CYCLES LINE SOURCELINE
                             6118 ; 92   |#define HW_DCDC1_CTRL1_C_SETMASK (((1<<HW_DCDC1_CTRL1_C_WIDTH)-1)<<HW_DCDC1_CTRL1_C_BITPOS
                                  )        
                             6119 ; 93   |#define HW_DCDC1_CTRL1_R_SETMASK (((1<<HW_DCDC1_CTRL1_R_WIDTH)-1)<<HW_DCDC1_CTRL1_R_BITPOS
                                  ) 
                             6120 ; 94   |#define HW_DCDC1_CTRL1_FFOR_SETMASK (((1<<HW_DCDC1_CTRL1_FFOR_WIDTH)-1)<<HW_DCDC1_CTRL1_FF
                                  OR_BITPOS)  
                             6121 ; 95   |#define HW_DCDC1_CTRL1_PFMCTRL_SETMASK (((1<<HW_DCDC1_CTRL1_PFMCTRL_WIDTH)-1)<<HW_DCDC1_CT
                                  RL1_PFMCTRL_BITPOS)   
                             6122 ; 96   |
                             6123 ; 97   |#define HW_DCDC1_CTRL1_C_CLRMASK (~(WORD)HW_DCDC1_CTRL1_C_SETMASK)     
                             6124 ; 98   |#define HW_DCDC1_CTRL1_R_CLRMASK (~(WORD)HW_DCDC1_CTRL1_R_SETMASK) 
                             6125 ; 99   |#define HW_DCDC1_CTRL1_FFOR_CLRMASK (~(WORD)HW_DCDC1_CTRL1_FFOR_SETMASK)  
                             6126 ; 100  |#define HW_DCDC1_CTRL1_PFMCTRL_CLRMASK (~(WORD)HW_DCDC1_CTRL1_PFMCTRL_SETMASK)  
                             6127 ; 101  |
                             6128 ; 102  |
                             6129 ; 103  |typedef union               
                             6130 ; 104  |{
                             6131 ; 105  |    struct {
                             6132 ; 106  |        unsigned int C       : HW_DCDC1_CTRL1_C_WIDTH;
                             6133 ; 107  |        unsigned int R                : HW_DCDC1_CTRL1_R_WIDTH;
                             6134 ; 108  |        unsigned int FFOR             : HW_DCDC1_CTRL1_FFOR_WIDTH;
                             6135 ; 109  |        unsigned int RSVD0            : HW_DCDC1_CTRL1_RSVD0_WIDTH;
                             6136 ; 110  |        unsigned int PFMCTRL          : HW_DCDC1_CTRL1_FFOR_WIDTH;
                             6137 ; 111  |    } B;
                             6138 ; 112  |    unsigned int I;
                             6139 ; 113  |} dcdc1_ctrl1_type;
                             6140 ; 114  |#define HW_DCDC1_CTRL1      (*(volatile dcdc1_ctrl1_type _X*) (HW_DCDC_BASEADDR+1))    /* 
                                  DcDc#1 Ctrl #1 Register */
                             6141 ; 115  |
                             6142 ; 116  |
                             6143 ; 117  |
                             6144 ; 118  |
                             6145 ; 119  |/////////////////////////////////////////////////////////////////////////////////
                             6146 ; 120  |
                             6147 ; 121  |//  DcDc VDDIO Register (HW_DCDC_VDDIO) Bit Definitions
                             6148 ; 122  |
                             6149 ; 123  |#define HW_DCDC_VDDIO_VOLTAGE_LEVEL_WIDTH (5)
                             6150 ; 124  |#define HW_DCDC_VDDIO_RSVD0_WIDTH (3)
                             6151 ; 125  |#define HW_DCDC_VDDIO_BROWNOUT_LEVEL_WIDTH (5)
                             6152 ; 126  |#define HW_DCDC_VDDIO_RSVD1_WIDTH (3)
                             6153 ; 127  |#define HW_DCDC_VDDIO_BROWNOUT_ENABLE_WIDTH (1)
                             6154 ; 128  |#define HW_DCDC_VDDIO_RSVD2_WIDTH (3)
                             6155 ; 129  |#define HW_DCDC_VDDIO_BROWNOUT_STATUS_WIDTH (1)
                             6156 ; 130  |#define HW_DCDC_VDDIO_OK_WIDTH (1)
                             6157 ; 131  |#define HW_DCDC_VDDIO_RSVD3_WIDTH (2)
                             6158 ; 132  |
                             6159 ; 133  |
                             6160 ; 134  |
                             6161 ; 135  |#define HW_DCDC_VDDIO_VOLTAGE_LEVEL_BITPOS (0)
                             6162 ; 136  |#define HW_DCDC_VDDIO_BROWNOUT_LEVEL_BITPOS (8)
                             6163 ; 137  |#define HW_DCDC_VDDIO_BROWNOUT_ENABLE_BITPOS (16)
                             6164 ; 138  |#define HW_DCDC_VDDIO_BROWNOUT_STATUS_BITPOS (20)
                             6165 ; 139  |#define HW_DCDC_VDDIO_OK_BITPOS (21)
                             6166 ; 140  |
                             6167 ; 141  |
                             6168 ; 142  |#define HW_DCDC_VDDIO_VOLTAGE_LEVEL_SETMASK (((1<<HW_DCDC_VDDIO_VOLTAGE_LEVEL_WIDTH)-1)<<H
                                  W_DCDC_VDDIO_VOLTAGE_LEVEL_BITPOS)        
                             6169 ; 143  |#define HW_DCDC_VDDIO_BROWNOUT_LEVEL_SETMASK (((1<<HW_DCDC_VDDIO_BROWNOUT_LEVEL_WIDTH)-1)<
                                  <HW_DCDC_VDDIO_BROWNOUT_LEVEL_BITPOS) 
                             6170 ; 144  |#define HW_DCDC_VDDIO_BROWNOUT_ENABLE_SETMASK (((1<<HW_DCDC_VDDIO_BROWNOUT_ENABLE_WIDTH)-1
                                  )<<HW_DCDC_VDDIO_BROWNOUT_ENABLE_BITPOS)  
TASKING DSP2410 assembler v1.5r1 Build 138 SN 00100122
                                                                                                                            Page  98

M:ADDR CODE           CYCLES LINE SOURCELINE
                             6171 ; 145  |#define HW_DCDC_VDDIO_BROWNOUT_STATUS_SETMASK (((1<<HW_DCDC_VDDIO_BROWNOUT_STATUS_WIDTH)-1
                                  )<<HW_DCDC_VDDIO_BROWNOUT_STATUS_BITPOS)  
                             6172 ; 146  |
                             6173 ; 147  |
                             6174 ; 148  |
                             6175 ; 149  |#define HW_DCDC_VDDIO_VOLTAGE_LEVEL_CLRMASK (~(WORD)HW_DCDC_VDDIO_VOLTAGE_LEVEL_SETMASK)  
                                     
                             6176 ; 150  |#define HW_DCDC_VDDIO_BROWNOUT_LEVEL_CLRMASK (~(WORD)HW_DCDC_VDDIO_BROWNOUT_LEVEL_SETMASK)
                                   
                             6177 ; 151  |#define HW_DCDC_VDDIO_BROWNOUT_ENABLE_CLRMASK (~(WORD)HW_DCDC_VDDIO_BROWNOUT_ENABLE_SETMAS
                                  K)  
                             6178 ; 152  |#define HW_DCDC_VDDIO_BROWNOUT_STATUS_CLRMASK (~(WORD)HW_DCDC_VDDIO_BROWNOUT_STATUS_SETMAS
                                  K)  
                             6179 ; 153  |
                             6180 ; 154  |
                             6181 ; 155  |typedef union               
                             6182 ; 156  |{
                             6183 ; 157  |    struct {
                             6184 ; 158  |        unsigned int VOLTAGE_LEVEL    : HW_DCDC_VDDIO_VOLTAGE_LEVEL_WIDTH;
                             6185 ; 159  |        unsigned int RSVD0            : HW_DCDC_VDDIO_RSVD0_WIDTH;
                             6186 ; 160  |        unsigned int BROWNOUT_LEVEL   : HW_DCDC_VDDIO_BROWNOUT_LEVEL_WIDTH;
                             6187 ; 161  |        unsigned int RSVD1            : HW_DCDC_VDDIO_RSVD1_WIDTH;
                             6188 ; 162  |        unsigned int BROWNOUT_ENABLE  : HW_DCDC_VDDIO_BROWNOUT_ENABLE_WIDTH;
                             6189 ; 163  |        unsigned int RSVD2            : HW_DCDC_VDDIO_RSVD2_WIDTH;
                             6190 ; 164  |        unsigned int BROWNOUT_STATUS  : HW_DCDC_VDDIO_BROWNOUT_STATUS_WIDTH;
                             6191 ; 165  |                 unsigned int VDDIO_OK        : HW_DCDC_VDDIO_OK_WIDTH;
                             6192 ; 166  |        unsigned int RSVD3            : HW_DCDC_VDDIO_RSVD3_WIDTH;
                             6193 ; 167  |    } B;
                             6194 ; 168  |    unsigned int I;
                             6195 ; 169  |} dcdc_vddio_type;
                             6196 ; 170  |#define HW_DCDC_VDDIO      (*(volatile dcdc_vddio_type _X*) (HW_DCDC_BASEADDR+2))    /* Dc
                                  Dc VDDIO Register */
                             6197 ; 171  |
                             6198 ; 172  |
                             6199 ; 173  |
                             6200 ; 174  |/////////////////////////////////////////////////////////////////////////////////
                             6201 ; 175  |//  DcDc VDDD Register (HW_DCDC_VDDD) Bit Definitions
                             6202 ; 176  |
                             6203 ; 177  |#define HW_DCDC_VDDD_VOLTAGE_LEVEL_WIDTH (5)
                             6204 ; 178  |#define HW_DCDC_VDDD_RSVD0_WIDTH (3)
                             6205 ; 179  |#define HW_DCDC_VDDD_BROWNOUT_LEVEL_WIDTH (5)
                             6206 ; 180  |#define HW_DCDC_VDDD_RSVD1_WIDTH (3)
                             6207 ; 181  |#define HW_DCDC_VDDD_BROWNOUT_ENABLE_WIDTH (1)
                             6208 ; 182  |#define HW_DCDC_VDDD_RSVD2_WIDTH (3)
                             6209 ; 183  |#define HW_DCDC_VDDD_BROWNOUT_STATUS_WIDTH (1)
                             6210 ; 184  |#define HW_DCDC_VDDD_OK_WIDTH (1)
                             6211 ; 185  |#define HW_DCDC_VDDD_RSVD3_WIDTH (2)
                             6212 ; 186  |
                             6213 ; 187  |#define HW_DCDC_VDDD_VOLTAGE_LEVEL_BITPOS (0)
                             6214 ; 188  |#define HW_DCDC_VDDD_BROWNOUT_LEVEL_BITPOS (8)
                             6215 ; 189  |#define HW_DCDC_VDDD_BROWNOUT_ENABLE_BITPOS (16)
                             6216 ; 190  |#define HW_DCDC_VDDD_BROWNOUT_STATUS_BITPOS (20)
                             6217 ; 191  |#define HW_DCDC_VDDD_OK_BITPOS (21)
                             6218 ; 192  |#define HW_DCDC_VDDD_VOLTAGE_LEVEL_SETMASK (((1<<HW_DCDC_VDDD_VOLTAGE_LEVEL_WIDTH)-1)<<HW_
                                  DCDC_VDDD_VOLTAGE_LEVEL_BITPOS)        
                             6219 ; 193  |#define HW_DCDC_VDDD_BROWNOUT_LEVEL_SETMASK (((1<<HW_DCDC_VDDD_BROWNOUT_LEVEL_WIDTH)-1)<<H
                                  W_DCDC_VDDD_BROWNOUT_LEVEL_BITPOS) 
                             6220 ; 194  |#define HW_DCDC_VDDD_BROWNOUT_ENABLE_SETMASK (((1<<HW_DCDC_VDDD_BROWNOUT_ENABLE_WIDTH)-1)<
                                  <HW_DCDC_VDDD_BROWNOUT_ENABLE_BITPOS)  
                             6221 ; 195  |#define HW_DCDC_VDDD_BROWNOUT_STATUS_SETMASK (((1<<HW_DCDC_VDDD_BROWNOUT_STATUS_WIDTH)-1)<
                                  <HW_DCDC_VDDD_BROWNOUT_STATUS_BITPOS)  
                             6222 ; 196  |
TASKING DSP2410 assembler v1.5r1 Build 138 SN 00100122
                                                                                                                            Page  99

M:ADDR CODE           CYCLES LINE SOURCELINE
                             6223 ; 197  |#define HW_DCDC_VDDD_VOLTAGE_LEVEL_CLRMASK (~(WORD)HW_DCDC_VDDD_VOLTAGE_LEVEL_SETMASK)    
                                   
                             6224 ; 198  |#define HW_DCDC_VDDD_BROWNOUT_LEVEL_CLRMASK (~(WORD)HW_DCDC_VDDD_BROWNOUT_LEVEL_SETMASK) 
                             6225 ; 199  |#define HW_DCDC_VDDD_BROWNOUT_ENABLE_CLRMASK (~(WORD)HW_DCDC_VDDD_BROWNOUT_ENABLE_SETMASK)
                                    
                             6226 ; 200  |#define HW_DCDC_VDDD_BROWNOUT_STATUS_CLRMASK (~(WORD)HW_DCDC_VDDD_BROWNOUT_STATUS_SETMASK)
                                    
                             6227 ; 201  |
                             6228 ; 202  |typedef union               
                             6229 ; 203  |{
                             6230 ; 204  |    struct {
                             6231 ; 205  |        unsigned int VOLTAGE_LEVEL    : HW_DCDC_VDDD_VOLTAGE_LEVEL_WIDTH;
                             6232 ; 206  |        unsigned int RSVD0            : HW_DCDC_VDDD_RSVD0_WIDTH;
                             6233 ; 207  |        unsigned int BROWNOUT_LEVEL   : HW_DCDC_VDDD_BROWNOUT_LEVEL_WIDTH;
                             6234 ; 208  |        unsigned int RSVD1            : HW_DCDC_VDDD_RSVD1_WIDTH;
                             6235 ; 209  |        unsigned int BROWNOUT_ENABLE  : HW_DCDC_VDDD_BROWNOUT_ENABLE_WIDTH;
                             6236 ; 210  |        unsigned int RSVD2            : HW_DCDC_VDDD_RSVD2_WIDTH;
                             6237 ; 211  |        unsigned int BROWNOUT_STATUS  : HW_DCDC_VDDD_BROWNOUT_STATUS_WIDTH;
                             6238 ; 212  |                 unsigned int VDD_OK           : HW_DCDC_VDDD_OK_WIDTH;
                             6239 ; 213  |        unsigned int RSVD3            : HW_DCDC_VDDD_RSVD3_WIDTH;
                             6240 ; 214  |    } B;
                             6241 ; 215  |   unsigned int I;
                             6242 ; 216  |        unsigned U;
                             6243 ; 217  |} dcdc_vddd_type;
                             6244 ; 218  |#define HW_DCDC_VDDD      (*(volatile dcdc_vddd_type _X*) (HW_DCDC_BASEADDR+3))    /* DcDc
                                   VDDD Register */
                             6245 ; 219  |
                             6246 ; 220  |
                             6247 ; 221  |
                             6248 ; 222  |
                             6249 ; 223  |/////////////////////////////////////////////////////////////////////////////////
                             6250 ; 224  |
                             6251 ; 225  |//  DcDc Vdda Register (HW_DCDC_VDDA) Bit Definitions
                             6252 ; 226  |
                             6253 ; 227  |#define HW_DCDC_VDDA_VOLTAGE_LEVEL_WIDTH (5)
                             6254 ; 228  |#define HW_DCDC_VDDA_RSVD0_WIDTH (3)
                             6255 ; 229  |#define HW_DCDC_VDDA_BROWNOUT_LEVEL_WIDTH (5)
                             6256 ; 230  |#define HW_DCDC_VDDA_RSVD1_WIDTH (3)
                             6257 ; 231  |#define HW_DCDC_VDDA_BROWNOUT_ENABLE_WIDTH (1)
                             6258 ; 232  |#define HW_DCDC_VDDA_RSVD2_WIDTH (3)
                             6259 ; 233  |#define HW_DCDC_VDDA_BROWNOUT_STATUS_WIDTH (1)
                             6260 ; 234  |#define HW_DCDC_VDDA_OK_WIDTH (1)
                             6261 ; 235  |#define HW_DCDC_VDDA_RSVD3_WIDTH (2)
                             6262 ; 236  |
                             6263 ; 237  |
                             6264 ; 238  |
                             6265 ; 239  |#define HW_DCDC_VDDA_VOLTAGE_LEVEL_BITPOS (0)
                             6266 ; 240  |#define HW_DCDC_VDDA_BROWNOUT_LEVEL_BITPOS (8)
                             6267 ; 241  |#define HW_DCDC_VDDA_BROWNOUT_ENABLE_BITPOS (16)
                             6268 ; 242  |#define HW_DCDC_VDDA_BROWNOUT_STATUS_BITPOS (20)
                             6269 ; 243  |#define HW_DCDC_VDDA_OK_BITPOS (21)
                             6270 ; 244  |
                             6271 ; 245  |
                             6272 ; 246  |#define HW_DCDC_VDDA_VOLTAGE_LEVEL_SETMASK (((1<<HW_DCDC_VDDA_VOLTAGE_LEVEL_WIDTH)-1)<<HW_
                                  DCDC_VDDA_VOLTAGE_LEVEL_BITPOS)        
                             6273 ; 247  |#define HW_DCDC_VDDA_BROWNOUT_LEVEL_SETMASK (((1<<HW_DCDC_VDDA_BROWNOUT_LEVEL_WIDTH)-1)<<H
                                  W_DCDC_VDDA_BROWNOUT_LEVEL_BITPOS) 
                             6274 ; 248  |#define HW_DCDC_VDDA_BROWNOUT_ENABLE_SETMASK (((1<<HW_DCDC_VDDA_BROWNOUT_ENABLE_WIDTH)-1)<
                                  <HW_DCDC_VDDA_BROWNOUT_ENABLE_BITPOS)  
                             6275 ; 249  |#define HW_DCDC_VDDA_BROWNOUT_STATUS_SETMASK (((1<<HW_DCDC_VDDA_BROWNOUT_STATUS_WIDTH)-1)<
                                  <HW_DCDC_VDDA_BROWNOUT_STATUS_BITPOS)  
                             6276 ; 250  |
TASKING DSP2410 assembler v1.5r1 Build 138 SN 00100122
                                                                                                                            Page 100

M:ADDR CODE           CYCLES LINE SOURCELINE
                             6277 ; 251  |
                             6278 ; 252  |
                             6279 ; 253  |#define HW_DCDC_VDDA_VOLTAGE_LEVEL_CLRMASK (~(WORD)HW_DCDC_VDDA_VOLTAGE_LEVEL_SETMASK)    
                                   
                             6280 ; 254  |#define HW_DCDC_VDDA_BROWNOUT_LEVEL_CLRMASK (~(WORD)HW_DCDC_VDDA_BROWNOUT_LEVEL_SETMASK) 
                             6281 ; 255  |#define HW_DCDC_VDDA_BROWNOUT_ENABLE_CLRMASK (~(WORD)HW_DCDC_VDDA_BROWNOUT_ENABLE_SETMASK)
                                    
                             6282 ; 256  |#define HW_DCDC_VDDA_BROWNOUT_STATUS_CLRMASK (~(WORD)HW_DCDC_VDDA_BROWNOUT_STATUS_SETMASK)
                                    
                             6283 ; 257  |
                             6284 ; 258  |
                             6285 ; 259  |typedef union               
                             6286 ; 260  |{
                             6287 ; 261  |    struct {
                             6288 ; 262  |        unsigned int VOLTAGE_LEVEL    : HW_DCDC_VDDA_VOLTAGE_LEVEL_WIDTH;
                             6289 ; 263  |        unsigned int RSVD0            : HW_DCDC_VDDA_RSVD0_WIDTH;
                             6290 ; 264  |        unsigned int BROWNOUT_LEVEL   : HW_DCDC_VDDA_BROWNOUT_LEVEL_WIDTH;
                             6291 ; 265  |        unsigned int RSVD1            : HW_DCDC_VDDA_RSVD1_WIDTH;
                             6292 ; 266  |        unsigned int BROWNOUT_ENABLE  : HW_DCDC_VDDA_BROWNOUT_ENABLE_WIDTH;
                             6293 ; 267  |        unsigned int RSVD2            : HW_DCDC_VDDA_RSVD2_WIDTH;
                             6294 ; 268  |        unsigned int BROWNOUT_STATUS  : HW_DCDC_VDDA_BROWNOUT_STATUS_WIDTH;
                             6295 ; 269  |             unsigned int VDDA_OK          : HW_DCDC_VDDA_OK_WIDTH;
                             6296 ; 270  |        unsigned int RSVD3            : HW_DCDC_VDDA_RSVD3_WIDTH;
                             6297 ; 271  |    } B;
                             6298 ; 272  |    unsigned int I;
                             6299 ; 273  |} dcdc_vdda_type;
                             6300 ; 274  |#define HW_DCDC_VDDA      (*(volatile dcdc_vdda_type _X*) (HW_DCDC_BASEADDR+4))    /* DcDc
                                   VDDA Register */
                             6301 ; 275  |
                             6302 ; 276  |
                             6303 ; 277  |
                             6304 ; 278  |
                             6305 ; 279  |/////////////////////////////////////////////////////////////////////////////////
                             6306 ; 280  |
                             6307 ; 281  |//  DcDc#2 Control Register 0 (HW_DCDC2_CTRL0) Bit Definitions
                             6308 ; 282  |
                             6309 ; 283  |#define HW_DCDC2_CTRL0_PLEVBU_WIDTH (5)
                             6310 ; 284  |#define HW_DCDC2_CTRL0_RSVD0_WIDTH (3)
                             6311 ; 285  |#define HW_DCDC2_CTRL0_PLEVBO_WIDTH (5)
                             6312 ; 286  |#define HW_DCDC2_CTRL0_RSVD1_WIDTH (3)
                             6313 ; 287  |#define HW_DCDC2_CTRL0_NLEV_WIDTH (5)
                             6314 ; 288  |#define HW_DCDC2_CTRL0_RSVD2_WIDTH (3)
                             6315 ; 289  |
                             6316 ; 290  |
                             6317 ; 291  |
                             6318 ; 292  |#define HW_DCDC2_CTRL0_PLEVBU_BITPOS (0)
                             6319 ; 293  |#define HW_DCDC2_CTRL0_PLEVBO_BITPOS (8)
                             6320 ; 294  |#define HW_DCDC2_CTRL0_NLEV_BITPOS (16)
                             6321 ; 295  |
                             6322 ; 296  |#define HW_DCDC2_CTRL0_PLEVBU_SETMASK (((1<<HW_DCDC2_CTRL0_PLEVBU_WIDTH)-1)<<HW_DCDC2_CTRL
                                  0_PLEVBU_BITPOS)        
                             6323 ; 297  |#define HW_DCDC2_CTRL0_PLEVBO_SETMASK (((1<<HW_DCDC2_CTRL0_PLEVBO_WIDTH)-1)<<HW_DCDC2_CTRL
                                  0_PLEVBO_BITPOS) 
                             6324 ; 298  |#define HW_DCDC2_CTRL0_NLEV_SETMASK (((1<<HW_DCDC2_CTRL0_NLEV_WIDTH)-1)<<HW_DCDC2_CTRL0_NL
                                  EV_BITPOS)  
                             6325 ; 299  |
                             6326 ; 300  |#define HW_DCDC2_CTRL0_PLEVBU_CLRMASK (~(WORD)HW_DCDC2_CTRL0_PLEVBU_SETMASK)     
                             6327 ; 301  |#define HW_DCDC2_CTRL0_PLEVBO_CLRMASK (~(WORD)HW_DCDC2_CTRL0_PLEVBO_SETMASK) 
                             6328 ; 302  |#define HW_DCDC2_CTRL0_NLEV_CLRMASK (~(WORD)HW_DCDC2_CTRL0_NLEV_SETMASK)  
                             6329 ; 303  |
                             6330 ; 304  |
                             6331 ; 305  |typedef union               
TASKING DSP2410 assembler v1.5r1 Build 138 SN 00100122
                                                                                                                            Page 101

M:ADDR CODE           CYCLES LINE SOURCELINE
                             6332 ; 306  |{
                             6333 ; 307  |    struct {
                             6334 ; 308  |        unsigned int PLEVBU           : HW_DCDC2_CTRL0_PLEVBU_WIDTH;
                             6335 ; 309  |        unsigned int RSVD0            : HW_DCDC2_CTRL0_RSVD0_WIDTH;
                             6336 ; 310  |        unsigned int PLEVBO           : HW_DCDC2_CTRL0_PLEVBO_WIDTH;
                             6337 ; 311  |        unsigned int RSVD1            : HW_DCDC2_CTRL0_RSVD1_WIDTH;
                             6338 ; 312  |        unsigned int NLEV             : HW_DCDC2_CTRL0_NLEV_WIDTH;
                             6339 ; 313  |        unsigned int RSVD2            : HW_DCDC2_CTRL0_RSVD2_WIDTH;
                             6340 ; 314  |    } B;
                             6341 ; 315  |    unsigned int I;
                             6342 ; 316  |} dcdc2_ctrl0_type; 
                             6343 ; 317  |#define HW_DCDC2_CTRL0      (*(volatile dcdc2_ctrl0_type _X*) (HW_DCDC_BASEADDR+5))    /* 
                                  DcDc#2 Limit Level Register */
                             6344 ; 318  |
                             6345 ; 319  |
                             6346 ; 320  |
                             6347 ; 321  |
                             6348 ; 322  |/////////////////////////////////////////////////////////////////////////////////
                             6349 ; 323  |
                             6350 ; 324  |//  DcDc#2 Control Register #1 (HW_DCDC2_CTRL1) Bit Definitions
                             6351 ; 325  |
                             6352 ; 326  |#define HW_DCDC2_CTRL1_C_WIDTH (4)
                             6353 ; 327  |#define HW_DCDC2_CTRL1_R_WIDTH (4)
                             6354 ; 328  |#define HW_DCDC2_CTRL1_FFOR_WIDTH (3)
                             6355 ; 329  |#define HW_DCDC2_CTRL1_RSVD0_WIDTH (1)
                             6356 ; 330  |#define HW_DCDC2_CTRL1_PFMCTRL_WIDTH (12)
                             6357 ; 331  |
                             6358 ; 332  |
                             6359 ; 333  |#define HW_DCDC2_CTRL1_C_BITPOS (0)
                             6360 ; 334  |#define HW_DCDC2_CTRL1_R_BITPOS (4)
                             6361 ; 335  |#define HW_DCDC2_CTRL1_FFOR_BITPOS (8)
                             6362 ; 336  |#define HW_DCDC2_CTRL1_PFMCTRL_BITPOS (12)
                             6363 ; 337  |
                             6364 ; 338  |
                             6365 ; 339  |
                             6366 ; 340  |#define HW_DCDC2_CTRL1_C_SETMASK (((1<<HW_DCDC2_CTRL1_C_WIDTH)-1)<<HW_DCDC2_CTRL1_C_BITPOS
                                  )        
                             6367 ; 341  |#define HW_DCDC2_CTRL1_R_SETMASK (((1<<HW_DCDC2_CTRL1_R_WIDTH)-1)<<HW_DCDC2_CTRL1_R_BITPOS
                                  ) 
                             6368 ; 342  |#define HW_DCDC2_CTRL1_FFOR_SETMASK (((1<<HW_DCDC2_CTRL1_FFOR_WIDTH)-1)<<HW_DCDC2_CTRL1_FF
                                  OR_BITPOS)  
                             6369 ; 343  |#define HW_DCDC2_CTRL1_PFMCTRL_SETMASK (((1<<HW_DCDC2_CTRL1_PFMCTRL_WIDTH)-1)<<HW_DCDC2_CT
                                  RL1_PFMCTRL_BITPOS)  
                             6370 ; 344  |
                             6371 ; 345  |
                             6372 ; 346  |
                             6373 ; 347  |#define HW_DCDC2_CTRL1_C_CLRMASK (~(WORD)HW_DCDC2_CTRL1_C_SETMASK)     
                             6374 ; 348  |#define HW_DCDC2_CTRL1_R_CLRMASK (~(WORD)HW_DCDC2_CTRL1_R_SETMASK) 
                             6375 ; 349  |#define HW_DCDC2_CTRL1_FFOR_CLRMASK (~(WORD)HW_DCDC2_CTRL1_FFOR_SETMASK)  
                             6376 ; 350  |#define HW_DCDC2_CTRL1_PFMCTRL_CLRMASK (~(WORD)HW_DCDC2_CTRL1_PFMCTRL_SETMASK)  
                             6377 ; 351  |
                             6378 ; 352  |
                             6379 ; 353  |typedef union               
                             6380 ; 354  |{
                             6381 ; 355  |    struct {
                             6382 ; 356  |        unsigned int C                : HW_DCDC2_CTRL1_C_WIDTH;
                             6383 ; 357  |        unsigned int R                : HW_DCDC2_CTRL1_R_WIDTH;
                             6384 ; 358  |        unsigned int FFOR             : HW_DCDC2_CTRL1_FFOR_WIDTH;
                             6385 ; 359  |        unsigned int RSVD0            : HW_DCDC2_CTRL1_RSVD0_WIDTH;
                             6386 ; 360  |        unsigned int PFMCTRL          : HW_DCDC2_CTRL1_FFOR_WIDTH;
                             6387 ; 361  |    } B;
                             6388 ; 362  |    unsigned int I;
TASKING DSP2410 assembler v1.5r1 Build 138 SN 00100122
                                                                                                                            Page 102

M:ADDR CODE           CYCLES LINE SOURCELINE
                             6389 ; 363  |} dcdc2_ctrl1_type;
                             6390 ; 364  |#define HW_DCDC2_CTRL1      (*(volatile dcdc2_ctrl1_type _X*) (HW_DCDC_BASEADDR+6))    /* 
                                  DcDc#2 Ctrl Register #1 */
                             6391 ; 365  |
                             6392 ; 366  |
                             6393 ; 367  |
                             6394 ; 368  |
                             6395 ; 369  |/////////////////////////////////////////////////////////////////////////////////
                             6396 ; 370  |
                             6397 ; 371  |//  Speed Monitoring Register (HW_SPEED) Bit Definitions
                             6398 ; 372  |
                             6399 ; 373  |#define HW_SPEED_OSC1_PWRUP_WIDTH (1)
                             6400 ; 374  |#define HW_SPEED_OSC1_START_COUNT_WIDTH (1)
                             6401 ; 375  |#define HW_SPEED_RSVD0_WIDTH (2)
                             6402 ; 376  |#define HW_SPEED_RINGOSC1_WIDTH (7)
                             6403 ; 377  |#define HW_SPEED_RSVD1_WIDTH (1)
                             6404 ; 378  |#define HW_SPEED_OSC2_PWRUP_WIDTH (1)
                             6405 ; 379  |#define HW_SPEED_OSC2_START_COUNT_WIDTH (1)
                             6406 ; 380  |#define HW_SPEED_RSVD2_WIDTH (2)
                             6407 ; 381  |#define HW_SPEED_RINGOSC2_WIDTH (7)
                             6408 ; 382  |#define HW_SPEED_RSVD3_WIDTH (1)
                             6409 ; 383  |
                             6410 ; 384  |
                             6411 ; 385  |
                             6412 ; 386  |#define HW_SPEED_OSC1_PWRUP_BITPOS (0)
                             6413 ; 387  |#define HW_SPEED_OSC1_START_COUNT_BITPOS (1)
                             6414 ; 388  |#define HW_SPEED_RINGOSC1_BITPOS (4)
                             6415 ; 389  |#define HW_SPEED_OSC2_PWRUP_BITPOS (12)
                             6416 ; 390  |#define HW_SPEED_OSC2_START_COUNT_BITPOS (13)
                             6417 ; 391  |#define HW_SPEED_RINGOSC2_BITPOS (16)
                             6418 ; 392  |
                             6419 ; 393  |
                             6420 ; 394  |#define HW_SPEED_OSC1_PWRUP_SETMASK (((1<<HW_SPEED_OSC1_PWRUP_WIDTH)-1)<<HW_SPEED_OSC1_PWR
                                  UP_BITPOS)        
                             6421 ; 395  |#define HW_SPEED_OSC1_START_COUNT_SETMASK (((1<<HW_SPEED_OSC1_START_COUNT_WIDTH)-1)<<HW_SP
                                  EED_OSC1_START_COUNT_BITPOS)        
                             6422 ; 396  |#define HW_SPEED_RINGOSC1_SETMASK (((1<<HW_SPEED_RINGOSC1_WIDTH)-1)<<HW_SPEED_RINGOSC1_BIT
                                  POS) 
                             6423 ; 397  |#define HW_SPEED_OSC2_PWRUP_SETMASK (((1<<HW_SPEED_OSC2_PWRUP_WIDTH)-1)<<HW_SPEED_OSC2_PWR
                                  UP_BITPOS)        
                             6424 ; 398  |
                             6425 ; 399  |#define HW_SPEED_OSC2_START_COUNT_SETMASK (((1<<HW_SPEED_OSC2_START_COUNT_WIDTH)-1)<<HW_SP
                                  EED_OSC2_START_COUNT_BITPOS)        
                             6426 ; 400  |#define HW_SPEED_RINGOSC2_SETMASK (((1<<HW_SPEED_RINGOSC2_WIDTH)-1)<<HW_SPEED_RINGOSC2_BIT
                                  POS) 
                             6427 ; 401  |
                             6428 ; 402  |
                             6429 ; 403  |
                             6430 ; 404  |#define HW_SPEED_OSC1_PWRUP_CLRMASK (~(WORD)HW_SPEED_OSC1_PWRUP_SETMASK)     
                             6431 ; 405  |#define HW_SPEED_OSC1_START_COUNT_CLRMASK (~(WORD)HW_SPEED_OSC1_START_COUNT_SETMASK)     
                             6432 ; 406  |#define HW_SPEED_RINGOSC1_CLRMASK (~(WORD)HW_SPEED_RINGOSC1_SETMASK) 
                             6433 ; 407  |#define HW_SPEED_OSC2_PWRUP_CLRMASK (~(WORD)HW_SPEED_OSC2_PWRUP_SETMASK)   
                             6434 ; 408  |#define HW_SPEED_OSC2_START_COUNT_CLRMASK (~(WORD)HW_SPEED_OSC2_START_COUNT_SETMASK)     
                             6435 ; 409  |#define HW_SPEED_RINGOSC2_CLRMASK (~(WORD)HW_SPEED_RINGOSC2_SETMASK) 
                             6436 ; 410  |
                             6437 ; 411  |
                             6438 ; 412  |typedef union               
                             6439 ; 413  |{
                             6440 ; 414  |    struct {
                             6441 ; 415  |        unsigned int OSC1_PWRUP          : HW_SPEED_OSC1_PWRUP_WIDTH;
                             6442 ; 416  |        unsigned int OSC1_START_COUNT    : HW_SPEED_OSC1_START_COUNT_WIDTH;
                             6443 ; 417  |        unsigned int RSVD0               : HW_SPEED_RSVD0_WIDTH;
TASKING DSP2410 assembler v1.5r1 Build 138 SN 00100122
                                                                                                                            Page 103

M:ADDR CODE           CYCLES LINE SOURCELINE
                             6444 ; 418  |        unsigned int RINGOSC1            : HW_SPEED_RINGOSC1_WIDTH;
                             6445 ; 419  |        unsigned int RSVD1               : HW_SPEED_RSVD1_WIDTH;
                             6446 ; 420  |        unsigned int OSC2_PWRUP          : HW_SPEED_OSC2_PWRUP_WIDTH;
                             6447 ; 421  |        unsigned int OSC2_START_COUNT    : HW_SPEED_OSC2_START_COUNT_WIDTH;
                             6448 ; 422  |        unsigned int RSVD2               : HW_SPEED_RSVD2_WIDTH;
                             6449 ; 423  |        unsigned int RINGOSC2            : HW_SPEED_RINGOSC2_WIDTH;
                             6450 ; 424  |        unsigned int RSVD3               : HW_SPEED_RSVD3_WIDTH;
                             6451 ; 425  |    } B;
                             6452 ; 426  |    unsigned int I;
                             6453 ; 427  |} speed_type;
                             6454 ; 428  |#define HW_SPEED      (*(volatile speed_type _X*) (HW_DCDC_BASEADDR+7))    /* Speed Measur
                                  ement Register */
                             6455 ; 429  |
                             6456 ; 430  |
                             6457 ; 431  |
                             6458 ; 432  |
                             6459 ; 433  |
                             6460 ; 434  |
                             6461 ; 435  |
                             6462 ; 436  |// DC DC Test Bit Register (HW_DCDCTBR) Definitions
                             6463 ; 437  |#define HW_DCDC_TBR_DCDC1_ADJ_TN_WIDTH 4
                             6464 ; 438  |#define HW_DCDC_TBR_DCDC1_DIS_5BIT_WIDTH 1
                             6465 ; 439  |#define HW_DCDC_TBR_DCDC1_BAT_ADJ_WIDTH 1
                             6466 ; 440  |#define HW_DCDC_TBR_DCDC1_CLK4X_WIDTH 1
                             6467 ; 441  |#define HW_DCDC_TBR_DCDC1_CLK2X_WIDTH 1
                             6468 ; 442  |#define HW_DCDC_TBR_DCDC1_NOZERO_WIDTH 1
                             6469 ; 443  |#define HW_DCDC_TBR_DCDC1_VDD5V_ACTIVE_WIDTH 1
                             6470 ; 444  |#define HW_DCDC_TBR_DCDC1_PFM_WIDTH 1
                             6471 ; 445  |#define HW_DCDC_TBR_DCDC1_STOPCLK_WIDTH 1
                             6472 ; 446  |#define HW_DCDC_TBR_PWRUP_VDDIO_BRNOUT_WIDTH 1
                             6473 ; 447  |#define HW_DCDC_TBR_DCDC_ANA_LESSI_WIDTH 1
                             6474 ; 448  |#define HW_DCDC_TBR_DCDC_MORE_CAP_WIDTH 1
                             6475 ; 449  |#define HW_DCDC_TBR_DCDC_ANA_BGR_BIAS_WIDTH 1
                             6476 ; 450  |#define HW_DCDC_TBR_DCDC1_NEW_SCHEME_WIDTH 1
                             6477 ; 451  |#define HW_DCDC_TBR_DCDC1_HALF_FETS_WIDTH 1
                             6478 ; 452  |#define HW_DCDC_TBR_DCDC2_DIS_5BIT_WIDTH 1
                             6479 ; 453  |#define HW_DCDC_TBR_DCDC2_CLK4X_WIDTH 1
                             6480 ; 454  |#define HW_DCDC_TBR_DCDC2_CLK2X_WIDTH 1
                             6481 ; 455  |#define HW_DCDC_TBR_DCDC2_VDD5V_ACTIVE_WIDTH 1
                             6482 ; 456  |#define HW_DCDC_TBR_DCDC2_PFM_WIDTH 1
                             6483 ; 457  |#define HW_DCDC_TBR_DCDC2_STOPCLK_WIDTH 1
                             6484 ; 458  |
                             6485 ; 459  |#define HW_DCDC_TBR_DCDC1_ADJ_TN_BITPOS (0)
                             6486 ; 460  |#define HW_DCDC_TBR_DCDC1_DIS_5BIT_BITPOS (4)
                             6487 ; 461  |#define HW_DCDC_TBR_DCDC1_BAT_ADJ_BITPOS (5)
                             6488 ; 462  |#define HW_DCDC_TBR_DCDC1_CLK4X_BITPOS (6)
                             6489 ; 463  |#define HW_DCDC_TBR_DCDC1_CLK2X_BITPOS (7)
                             6490 ; 464  |#define HW_DCDC_TBR_DCDC1_NOZERO_BITPOS (8)
                             6491 ; 465  |#define HW_DCDC_TBR_DCDC1_VDD5V_ACTIVE_BITPOS (9)
                             6492 ; 466  |#define HW_DCDC_TBR_DCDC1_PFM_BITPOS (10)
                             6493 ; 467  |#define HW_DCDC_TBR_DCDC1_STOPCLK_BITPOS (11)
                             6494 ; 468  |#define HW_DCDC_TBR_PWRUP_VDDIO_BRNOUT_BITPOS (12)
                             6495 ; 469  |#define HW_DCDC_TBR_DCDC_ANA_LESSI_BITPOS (13)
                             6496 ; 470  |#define HW_DCDC_TBR_DCDC_MORE_CAP_BITPOS (14)
                             6497 ; 471  |#define HW_DCDC_TBR_DCDC_DCDC_ANA_BGR_BIAS_BITPOS (15)
                             6498 ; 472  |#define HW_DCDC_TBR_DCDC1_NEW_SCHEME_BITPOS (16)
                             6499 ; 473  |#define HW_DCDC_TBR_DCDC1_HALF_FETS_BITPOS (17)
                             6500 ; 474  |#define HW_DCDC_TBR_DCDC2_DIS_5BIT_BITPOS (18)
                             6501 ; 475  |#define HW_DCDC_TBR_DCDC2_CLK4X_BITPOS (19)
                             6502 ; 476  |#define HW_DCDC_TBR_DCDC2_CLK2X_BITPOS (20)
                             6503 ; 477  |#define HW_DCDC_TBR_DCDC2_VDD5V_ACTIVE_BITPOS (21)
                             6504 ; 478  |#define HW_DCDC_TBR_DCDC2_PFM_BITPOS (22)
TASKING DSP2410 assembler v1.5r1 Build 138 SN 00100122
                                                                                                                            Page 104

M:ADDR CODE           CYCLES LINE SOURCELINE
                             6505 ; 479  |#define HW_DCDC_TBR_DCDC2_STOPCLK_BITPOS (23)
                             6506 ; 480  |
                             6507 ; 481  |#define HW_DCDC_TBR_DCDC1_ADJ_TN_SETMASK (((1<<HW_DCDC_TBR_DCDC1_ADJ_TN_WIDTH)-1)<<HW_DCDC
                                  _TBR_DCDC1_ADJ_TN_BITPOS)
                             6508 ; 482  |#define HW_DCDC_TBR_DCDC1_BAT_ADJ_SETMASK (((1<<HW_DCDC_TBR_DCDC1_BAT_ADJ_WIDTH)-1)<<HW_DC
                                  DC_TBR_DCDC1_BAT_ADJ_BITPOS)
                             6509 ; 483  |#define HW_DCDC_TBR_DCDC_ANA_BGR_BIAS_SETMASK (((1<<HW_DCDC_TBR_DCDC_ANA_BGR_BIAS_WIDTH)-1
                                  )<<HW_DCDC_TBR_DCDC_DCDC_ANA_BGR_BIAS_BITPOS)
                             6510 ; 484  |
                             6511 ; 485  |#define HW_DCDC_TBR_DCDC1_ADJ_TN_CLRMASK (~(WORD)HW_DCDC_TBR_DCDC1_ADJ_TN_SETMASK)
                             6512 ; 486  |#define HW_DCDC_TBR_DCDC1_BAT_ADJ_CLRMASK (~(WORD)HW_DCDC_TBR_DCDC1_BAT_ADJ_SETMASK)
                             6513 ; 487  |#define HW_DCDC_TBR_DCDC_ANA_BGR_BIAS_CLRMASK (~(WORD)HW_DCDC_TBR_DCDC_ANA_BGR_BIAS_SETMAS
                                  K)
                             6514 ; 488  |
                             6515 ; 489  |// Defines for What needs to change to be able to use a higher Core voltage and when the c
                                  hange should happen
                             6516 ; 490  |#define HW_DCDC_VDDD_CHANGE_TBR_CUTOFF_VALUE ((18<<HW_DCDC_VDDD_VOLTAGE_LEVEL_BITPOS)&HW_D
                                  CDC_VDDD_VOLTAGE_LEVEL_SETMASK)
                             6517 ; 491  |#define HW_DCDC_TBR_VDDD_HI_VALUE ((1<<HW_DCDC_TBR_DCDC_DCDC_ANA_BGR_BIAS_BITPOS)&HW_DCDC_
                                  TBR_DCDC_ANA_BGR_BIAS_SETMASK)
                             6518 ; 492  |#define HW_DCDC_TBR_VDDD_LO_VALUE (((1<<HW_DCDC_TBR_DCDC_DCDC_ANA_BGR_BIAS_BITPOS)&HW_DCDC
                                  _TBR_DCDC_ANA_BGR_BIAS_SETMASK)+((2<<HW_DCDC_TBR_DCDC1_ADJ_TN_BITPOS)&HW_DCDC_TBR_DCDC1_ADJ_TN_SET
                                  MASK)+((1<<HW_DCDC_TBR_DCDC1_BAT_ADJ_BITPOS)&HW_DCDC_TBR_DCDC1_BAT_ADJ_SETMASK))
                             6519 ; 493  |
                             6520 ; 494  |typedef union               
                             6521 ; 495  |{
                             6522 ; 496  |    struct {
                             6523 ; 497  |        unsigned int DCDC1_ADJ_TN               : HW_DCDC_TBR_DCDC1_ADJ_TN_WIDTH;
                             6524 ; 498  |        unsigned int DCDC1_DIS_5BIT             : HW_DCDC_TBR_DCDC1_DIS_5BIT_WIDTH;
                             6525 ; 499  |        unsigned int DCDC1_BAT_ADJ              : HW_DCDC_TBR_DCDC1_BAT_ADJ_WIDTH;
                             6526 ; 500  |        unsigned int DCDC1_CLK4X                : HW_DCDC_TBR_DCDC1_CLK4X_WIDTH;
                             6527 ; 501  |        unsigned int DCDC1_CLK2X                : HW_DCDC_TBR_DCDC1_CLK2X_WIDTH;
                             6528 ; 502  |        unsigned int DCDC1_NOZERO               : HW_DCDC_TBR_DCDC1_NOZERO_WIDTH;
                             6529 ; 503  |        unsigned int DCDC1_VDD5V_ACTIVE         : HW_DCDC_TBR_DCDC1_VDD5V_ACTIVE_WIDTH;
                             6530 ; 504  |        unsigned int DCDC1_PFM                  : HW_DCDC_TBR_DCDC1_PFM_WIDTH;
                             6531 ; 505  |        unsigned int DCDC1_STOPCLK              : HW_DCDC_TBR_DCDC1_STOPCLK_WIDTH;
                             6532 ; 506  |        unsigned int PWRUP_VDDIO_BRNOUT         : HW_DCDC_TBR_PWRUP_VDDIO_BRNOUT_WIDTH;
                             6533 ; 507  |        unsigned int DCDC_ANA_LESSI             : HW_DCDC_TBR_DCDC_ANA_LESSI_WIDTH;
                             6534 ; 508  |        unsigned int DCDC_MORE_CAP              : HW_DCDC_TBR_DCDC_MORE_CAP_WIDTH;
                             6535 ; 509  |        unsigned int DCDC_ANA_BGR_BIAS          : HW_DCDC_TBR_DCDC_ANA_BGR_BIAS_WIDTH;
                             6536 ; 510  |        unsigned int DCDC1_NEW_SCHEME           : HW_DCDC_TBR_DCDC1_NEW_SCHEME_WIDTH;
                             6537 ; 511  |        unsigned int DCDC1_HALF_FETS            : HW_DCDC_TBR_DCDC1_HALF_FETS_WIDTH;
                             6538 ; 512  |        unsigned int DCDC2_DIS_5BIT             : HW_DCDC_TBR_DCDC2_DIS_5BIT_WIDTH;
                             6539 ; 513  |        unsigned int DCDC2_CLK4X                : HW_DCDC_TBR_DCDC2_CLK4X_WIDTH;
                             6540 ; 514  |        unsigned int DCDC2_CLK2X                : HW_DCDC_TBR_DCDC2_CLK2X_WIDTH;
                             6541 ; 515  |        unsigned int DCDC2_VDD5V_ACTIVE         : HW_DCDC_TBR_DCDC2_VDD5V_ACTIVE_WIDTH;
                             6542 ; 516  |        unsigned int DCDC2_PFM                  : HW_DCDC_TBR_DCDC2_PFM_WIDTH;
                             6543 ; 517  |        unsigned int DCDC2_STOPCLK              : HW_DCDC_TBR_DCDC2_STOPCLK_WIDTH;
                             6544 ; 518  |    } B;
                             6545 ; 519  |    unsigned int I;
                             6546 ; 520  |} usb_dcdctbr_type;
                             6547 ; 521  |#define HW_DCDC_TBR                     (*(volatile usb_dcdctbr_type _X*) (HW_DCDC_BASEADD
                                  R+8))    /* Analog test bit register*/
                             6548 ; 522  |
                             6549 ; 523  |
                             6550 ; 524  |/////////////////////////////////////////////////////////////////////////////////
                             6551 ; 525  |
                             6552 ; 526  |//  Analog Persistent Config (HW_VDD5V_PWR_CHARGE) Bit Definitions
                             6553 ; 527  |
                             6554 ; 528  |#define HW_VDD5V_PWR_CHARGE_BATT_CURRENT_WIDTH (6)
                             6555 ; 529  |#define HW_VDD5V_PWR_CHARGE_RSVD0_WIDTH (2)
                             6556 ; 530  |#define HW_VDD5V_PWR_CHARGE_PWD_WIDTH (1)
TASKING DSP2410 assembler v1.5r1 Build 138 SN 00100122
                                                                                                                            Page 105

M:ADDR CODE           CYCLES LINE SOURCELINE
                             6557 ; 531  |#define HW_VDD5V_PWR_CHARGE_RES_WIDTH (1)
                             6558 ; 532  |#define HW_VDD5V_PWR_CHARGE_NIMH_WIDTH (1)
                             6559 ; 533  |#define HW_VDD5V_PWR_CHARGE_LI_TYPE_WIDTH (1)
                             6560 ; 534  |#define HW_VDD5V_PWR_CHARGE_DISABLE_ILIMIT_WIDTH (1)
                             6561 ; 535  |#define HW_VDD5V_PWR_CHARGE_PWDN_ON_IOBRNOUT_WIDTH (1)
                             6562 ; 536  |#define HW_VDD5V_PWR_CHARGE_DCANA_LP_WIDTH (1)
                             6563 ; 537  |#define HW_VDD5V_PWR_CHARGE_TEST_USBREGS_WIDTH (1)
                             6564 ; 538  |#define HW_VDD5V_PWR_CHARGE_DRV_BATT_WIDTH (1)
                             6565 ; 539  |#define HW_VDD5V_PWR_CHARGE_SWCHRG_BAT_WIDTH (1)
                             6566 ; 540  |#define HW_VDD5V_PWR_CHARGE_RSVD1_WIDTH (2)
                             6567 ; 541  |#define HW_VDD5V_PWR_CHARGE_VDD5V_PRESENT_WIDTH (1)
                             6568 ; 542  |#define HW_VDD5V_PWR_CHARGE_BATT_INFO_WIDTH (2)
                             6569 ; 543  |#define HW_VDD5V_PWR_CHARGE_RSVD2_WIDTH (3)
                             6570 ; 544  |
                             6571 ; 545  |#define HW_VDD5V_PWR_CHARGE_BATT_CURRENT_BITPOS (0)
                             6572 ; 546  |#define HW_VDD5V_PWR_CHARGE_PWD_BITPOS (8)
                             6573 ; 547  |#define HW_VDD5V_PWR_CHARGE_RES_BITPOS (9)
                             6574 ; 548  |#define HW_VDD5V_PWR_CHARGE_NIMH_BITPOS (10)
                             6575 ; 549  |
                             6576 ; 550  |#define HW_VDD5V_PWR_CHARGE_LI_TYPE_BITPOS (11)
                             6577 ; 551  |#define HW_VDD5V_PWR_CHARGE_DISABLE_ILIMIT_BITPOS (12)
                             6578 ; 552  |#define HW_VDD5V_PWR_CHARGE_PWDN_ON_IOBRNOUT_BITPOS (13)
                             6579 ; 553  |#define HW_VDD5V_PWR_CHARGE_DCANA_LP_BITPOS (14)
                             6580 ; 554  |#define HW_VDD5V_PWR_CHARGE_TEST_USBREGS_BITPOS (15)
                             6581 ; 555  |#define HW_VDD5V_PWR_CHARGE_DRV_BATT_BITPOS (16)
                             6582 ; 556  |#define HW_VDD5V_PWR_CHARGE_SWCHRG_BAT_BITPOS (17)
                             6583 ; 557  |#define HW_VDD5V_PWR_CHARGE_VDD5V_PRESENT_BITPOS (20)
                             6584 ; 558  |#define HW_VDD5V_PWR_CHARGE_BATT_INFO_BITPOS (21)
                             6585 ; 559  |
                             6586 ; 560  |#define HW_VDD5V_PWR_CHARGE_BATT_CURRENT_SETMASK (((1<<HW_VDD5V_PWR_CHARGE_BATT_CURRENT_WI
                                  DTH)-1)<<HW_VDD5V_PWR_CHARGE_BATT_CURRENT_BITPOS)        
                             6587 ; 561  |#define HW_VDD5V_PWR_CHARGE_PWD_SETMASK (((1<<HW_VDD5V_PWR_CHARGE_PWD_WIDTH)-1)<<HW_VDD5V_
                                  PWR_CHARGE_PWD_BITPOS)        
                             6588 ; 562  |#define HW_VDD5V_PWR_CHARGE_RES_SETMASK (((1<<HW_VDD5V_PWR_CHARGE_RES_WIDTH)-1)<<HW_VDD5V_
                                  PWR_CHARGE_RES_BITPOS) 
                             6589 ; 563  |#define HW_VDD5V_PWR_CHARGE_NIMH_SETMASK (((1<<HW_VDD5V_PWR_CHARGE_NIMH_WIDTH)-1)<<HW_VDD5
                                  V_PWR_CHARGE_NIMH_BITPOS) 
                             6590 ; 564  |#define HW_VDD5V_PWR_CHARGE_LI_TYPE_SETMASK (((1<<HW_VDD5V_PWR_CHARGE_LI_TYPE_WIDTH)-1)<<H
                                  W_VDD5V_PWR_CHARGE_LI_TYPE_BITPOS) 
                             6591 ; 565  |#define HW_VDD5V_PWR_CHARGE_DISABLE_ILIMIT_SETMASK (((1<<HW_VDD5V_PWR_CHARGE_DISABLE_ILIMI
                                  T_WIDTH)-1)<<HW_VDD5V_PWR_CHARGE_DISABLE_ILIMIT_BITPOS)        
                             6592 ; 566  |#define HW_VDD5V_PWR_CHARGE_PWDN_ON_IOBRNOUT_SETMASK (((1<<HW_VDD5V_PWR_CHARGE_PWDN_ON_IOB
                                  RNOUT_WIDTH)-1)<<HW_VDD5V_PWR_CHARGE_PWDN_ON_IOBRNOUT_BITPOS)        
                             6593 ; 567  |#define HW_VDD5V_PWR_CHARGE_DCANA_LP_SETMASK (((1<<HW_VDD5V_PWR_CHARGE_DCANA_LP_WIDTH)-1)<
                                  <HW_VDD5V_PWR_CHARGE_DCANA_LP_BITPOS) 
                             6594 ; 568  |#define HW_VDD5V_PWR_CHARGE_TEST_USBREGS_SETMASK (((1<<HW_VDD5V_PWR_CHARGE_TEST_USBREGS_WI
                                  DTH)-1)<<HW_VDD5V_PWR_CHARGE_TEST_USBREGS_BITPOS) 
                             6595 ; 569  |#define HW_VDD5V_PWR_CHARGE_DRV_BATT_SETMASK (((1<<HW_VDD5V_PWR_CHARGE_DRV_BATT_WIDTH)-1)<
                                  <HW_VDD5V_PWR_CHARGE_DRV_BATT_BITPOS) 
                             6596 ; 570  |#define HW_VDD5V_PWR_CHARGE_SWCHRG_BAT_SETMASK (((1<<HW_VDD5V_PWR_CHARGE_SWCHRG_BAT_WIDTH)
                                  -1)<<HW_VDD5V_PWR_CHARGE_SWCHRG_BAT_BITPOS) 
                             6597 ; 571  |#define HW_VDD5V_PWR_CHARGE_VDD5V_PRESENT_SETMASK (((1<<HW_VDD5V_PWR_CHARGE_VDD5V_PRESENT_
                                  WIDTH)-1)<<HW_VDD5V_PWR_CHARGE_VDD5V_PRESENT_BITPOS) 
                             6598 ; 572  |#define HW_VDD5V_PWR_CHARGE_BATT_INFO_SETMASK (((1<<HW_VDD5V_PWR_CHARGE_BATT_INFO_WIDTH)-1
                                  )<<HW_VDD5V_PWR_CHARGE_BATT_INFO_BITPOS) 
                             6599 ; 573  |
                             6600 ; 574  |
                             6601 ; 575  |#define HW_VDD5V_PWR_CHARGE_BATT_CURRENT_CLRMASK (~(WORD)HW_VDD5V_PWR_CHARGE_BATT_CURRENT_
                                  SETMASK)     
                             6602 ; 576  |#define HW_VDD5V_PWR_CHARGE_PWD_CLRMASK (~(WORD)HW_VDD5V_PWR_CHARGE_PWD_SETMASK)     
                             6603 ; 577  |#define HW_VDD5V_PWR_CHARGE_RES_CLRMASK (~(WORD)HW_VDD5V_PWR_CHARGE_RES_SETMASK) 
                             6604 ; 578  |#define HW_VDD5V_PWR_CHARGE_NIMH_CLRMASK (~(WORD)HW_VDD5V_PWR_CHARGE_NIMH_SETMASK) 
TASKING DSP2410 assembler v1.5r1 Build 138 SN 00100122
                                                                                                                            Page 106

M:ADDR CODE           CYCLES LINE SOURCELINE
                             6605 ; 579  |#define HW_VDD5V_PWR_CHARGE_LI_TYPE_CLRMASK (~(WORD)HW_VDD5V_PWR_CHARGE_LI_TYPE_SETMASK) 
                             6606 ; 580  |#define HW_VDD5V_PWR_CHARGE_DISABLE_ILIMIT_CLRMASK (~(WORD)HW_VDD5V_PWR_CHARGE_DISABLE_ILI
                                  MIT_SETMASK)     
                             6607 ; 581  |#define HW_VDD5V_PWR_CHARGE_PWDN_ON_IOBRNOUT_CLRMASK (~(WORD)HW_VDD5V_PWR_CHARGE_PWDN_ON_I
                                  OBRNOUT_SETMASK)     
                             6608 ; 582  |#define HW_VDD5V_PWR_CHARGE_DCANA_LP_CLRMASK (~(WORD)HW_VDD5V_PWR_CHARGE_DCANA_LP_SETMASK)
                                   
                             6609 ; 583  |#define HW_VDD5V_PWR_CHARGE_TEST_USBREGS_CLRMASK (~(WORD)HW_VDD5V_PWR_CHARGE_TEST_USBREGS_
                                  SETMASK) 
                             6610 ; 584  |#define HW_VDD5V_PWR_CHARGE_DRV_BATT_CLRMASK (~(WORD)HW_VDD5V_PWR_CHARGE_DRV_BATT_SETMASK)
                                   
                             6611 ; 585  |#define HW_VDD5V_PWR_CHARGE_SWCHRG_BAT_CLRMASK (~(WORD)HW_VDD5V_PWR_CHARGE_SWCHRG_BAT_SETM
                                  ASK) 
                             6612 ; 586  |#define HW_VDD5V_PWR_CHARGE_VDD5V_PRESENT_CLRMASK (~(WORD)HW_VDD5V_PWR_CHARGE_VDD5V_PRESEN
                                  T_SETMASK) 
                             6613 ; 587  |#define HW_VDD5V_PWR_CHARGE_BATT_INFO_CLRMASK (~(WORD)HW_VDD5V_PWR_CHARGE_BATT_INFO_SETMAS
                                  K) 
                             6614 ; 588  |
                             6615 ; 589  |typedef union               
                             6616 ; 590  |{
                             6617 ; 591  |    struct {
                             6618 ; 592  |        unsigned int BATT_CURRENT               : HW_VDD5V_PWR_CHARGE_BATT_CURRENT_WIDTH;
                             6619 ; 593  |        unsigned int RSVD0                      : HW_VDD5V_PWR_CHARGE_RSVD0_WIDTH;
                             6620 ; 594  |        unsigned int PWD                        : HW_VDD5V_PWR_CHARGE_PWD_WIDTH;
                             6621 ; 595  |        unsigned int RES                        : HW_VDD5V_PWR_CHARGE_RES_WIDTH;
                             6622 ; 596  |        unsigned int NIMH                       : HW_VDD5V_PWR_CHARGE_NIMH_WIDTH;
                             6623 ; 597  |        unsigned int LI_TYPE                    : HW_VDD5V_PWR_CHARGE_LI_TYPE_WIDTH;
                             6624 ; 598  |        unsigned int DISABLE_ILIMIT             : HW_VDD5V_PWR_CHARGE_DISABLE_ILIMIT_WIDTH
                                  ;
                             6625 ; 599  |        unsigned int PWDN_ON_IOBRNOUT           : HW_VDD5V_PWR_CHARGE_PWDN_ON_IOBRNOUT_WID
                                  TH;
                             6626 ; 600  |        unsigned int DCANA_LP                   : HW_VDD5V_PWR_CHARGE_DCANA_LP_WIDTH;
                             6627 ; 601  |        unsigned int TEST_USBREGS               : HW_VDD5V_PWR_CHARGE_TEST_USBREGS_WIDTH;
                             6628 ; 602  |        unsigned int DRV_BATT                   : HW_VDD5V_PWR_CHARGE_DRV_BATT_WIDTH;
                             6629 ; 603  |        unsigned int SWCHRG_BAT                 : HW_VDD5V_PWR_CHARGE_SWCHRG_BAT_WIDTH;
                             6630 ; 604  |        unsigned int RSVD1                      : HW_VDD5V_PWR_CHARGE_RSVD1_WIDTH;
                             6631 ; 605  |        unsigned int VDD5V_PRESENT              : HW_VDD5V_PWR_CHARGE_VDD5V_PRESENT_WIDTH;
                                  
                             6632 ; 606  |        unsigned int RSVD2                      : HW_VDD5V_PWR_CHARGE_RSVD2_WIDTH;
                             6633 ; 607  |    } B;
                             6634 ; 608  |    unsigned int I;
                             6635 ; 609  |} usb_pwr_charge_type;
                             6636 ; 610  |#define HW_VDD5V_PWR_CHARGE      (*(volatile usb_pwr_charge_type _X*) (HW_DCDC_BASEADDR+17
                                  ))    /* Analog Persistent Config Register */
                             6637 ; 611  |
                             6638 ; 612  |#define HW_DCDC_PERSIST_AUTO_RESTART_STAT_WIDTH 1
                             6639 ; 613  |#define HW_DCDC_PERSIST_DELAY_5V_AUTO_RESTART_STAT_WIDTH 1
                             6640 ; 614  |#define HW_DCDC_PERSIST_UPDATE_WIDTH 1
                             6641 ; 615  |#define HW_DCDC_PERSIST_AUTO_RESTART_WIDTH 1
                             6642 ; 616  |#define HW_DCDC_PERSIST_DELAY_5V_AUTO_RESTART_WIDTH 1
                             6643 ; 617  |#define HW_DCDC_PERSIST_LOW_BATT_TYPE_WIDTH 1
                             6644 ; 618  |#define HW_DCDC_PERSIST_LOW_BATTERY_ENABLE_WIDTH 1
                             6645 ; 619  |#define HW_DCDC_PERSIST_SLEEP_XTAL_ENABLE_WIDTH 1
                             6646 ; 620  |#define HW_DCDC_PERSIST_XTAL_TRIM1_WIDTH 1
                             6647 ; 621  |#define HW_DCDC_PERSIST_XTAL_TRIM0_WIDTH 1
                             6648 ; 622  |#define HW_DCDC_PERSIST_XTAL_BIAS_DOWN1_WIDTH 1
                             6649 ; 623  |#define HW_DCDC_PERSIST_XTAL_BIAS_DOWN0_WIDTH 1
                             6650 ; 624  |#define HW_DCDC_PERSIST_XTAL_TRM_ENABLE_WIDTH 1
                             6651 ; 625  |#define HW_DCDC_PERSIST_RSRVD_WIDTH 2
                             6652 ; 626  |
                             6653 ; 627  |#define HW_DCDC_PERSIST_AUTO_RESTART_STAT_BITPOS 12
                             6654 ; 628  |#define HW_DCDC_PERSIST_DELAY_5V_AUTO_RESTART_STAT_BITPOS 11
TASKING DSP2410 assembler v1.5r1 Build 138 SN 00100122
                                                                                                                            Page 107

M:ADDR CODE           CYCLES LINE SOURCELINE
                             6655 ; 629  |#define HW_DCDC_PERSIST_UPDATE_BITPOS 10
                             6656 ; 630  |#define HW_DCDC_PERSIST_AUTO_RESTART_BITPOS 9
                             6657 ; 631  |#define HW_DCDC_PERSIST_DELAY_5V_AUTO_RESTART_BITPOS 8 
                             6658 ; 632  |#define HW_DCDC_PERSIST_LOW_BATT_TYPE_BITPOS 7
                             6659 ; 633  |#define HW_DCDC_PERSIST_LOW_BATTERY_ENABLE_BITPOS 6
                             6660 ; 634  |#define HW_DCDC_PERSIST_SLEEP_XTAL_ENABLE_BITPOS 5
                             6661 ; 635  |#define HW_DCDC_PERSIST_XTAL_TRIM1_BITPOS 4
                             6662 ; 636  |#define HW_DCDC_PERSIST_XTAL_TRIM0_BITPOS 3
                             6663 ; 637  |#define HW_DCDC_PERSIST_XTAL_BIAS_DOWN1_BITPOS 2
                             6664 ; 638  |#define HW_DCDC_PERSIST_XTAL_BIAS_DOWN0_BITPOS 1
                             6665 ; 639  |#define HW_DCDC_PERSIST_XTAL_TRM_ENABLE_BITPOS 0
                             6666 ; 640  |
                             6667 ; 641  |typedef union               
                             6668 ; 642  |{
                             6669 ; 643  |    struct {       
                             6670 ; 644  |       int XTAL_TRM_ENABLE             : HW_DCDC_PERSIST_XTAL_TRM_ENABLE_WIDTH;
                             6671 ; 645  |       int XTAL_BIAS_DOWN0             : HW_DCDC_PERSIST_XTAL_BIAS_DOWN0_WIDTH;
                             6672 ; 646  |       int XTAL_BIAS_DOWN1             : HW_DCDC_PERSIST_XTAL_BIAS_DOWN1_WIDTH;
                             6673 ; 647  |       int XTAL_TRIM0                  : HW_DCDC_PERSIST_XTAL_TRIM0_WIDTH;
                             6674 ; 648  |       int XTAL_TRIM1                  : HW_DCDC_PERSIST_XTAL_TRIM1_WIDTH;
                             6675 ; 649  |       int SLEEP_XTAL_ENABLE           : HW_DCDC_PERSIST_SLEEP_XTAL_ENABLE_WIDTH;
                             6676 ; 650  |       int LOW_BATTERY_ENABLE          : HW_DCDC_PERSIST_LOW_BATTERY_ENABLE_WIDTH;
                             6677 ; 651  |       int LOW_BATT_TYPE               : HW_DCDC_PERSIST_LOW_BATT_TYPE_WIDTH;
                             6678 ; 652  |       int DELAY_5V_AUTO_RESTART       : HW_DCDC_PERSIST_DELAY_5V_AUTO_RESTART_WIDTH;
                             6679 ; 653  |       int AUTO_RESTART                : HW_DCDC_PERSIST_AUTO_RESTART_WIDTH;
                             6680 ; 654  |       int UPDATE                      : HW_DCDC_PERSIST_UPDATE_WIDTH;
                             6681 ; 655  |       int DELAY_5V_AUTO_RESTART_STAT  : HW_DCDC_PERSIST_DELAY_5V_AUTO_RESTART_STAT_WIDTH;
                                  
                             6682 ; 656  |       int AUTO_RESTART_STAT           : HW_DCDC_PERSIST_AUTO_RESTART_STAT_WIDTH;
                             6683 ; 657  |       int RSRVD                       : HW_DCDC_PERSIST_RSRVD_WIDTH;
                             6684 ; 658  |    } B;
                             6685 ; 659  |    int I;
                             6686 ; 660  |} usb_dcdcpersist_type;
                             6687 ; 661  |#define HW_DCDC_PERSIST                (*(volatile usb_dcdcpersist_type _X*) (HW_DCDC_BASE
                                  ADDR+15))    /* Analog test bit register*/
                             6688 ; 662  |
                             6689 ; 663  |
                             6690 ; 664  |
                             6691 ; 665  |#endif
                             6692 ; 666  |
                             6693 ; 667  |
                             6694 ; 668  |
                             6695 
                             6697 
                             6698 ; 9    |#include "regsrevision.h"
                             6699 
                             6701 
                             6702 ; 1    |#if !(defined(__HW_REVR))
                             6703 ; 2    |#define __HW_REVR 1
                             6704 ; 3    |
                             6705 ; 4    |
                             6706 ; 5    |#define HW_GLUE_BASEADDR 0xFA00
                             6707 ; 6    |
                             6708 ; 7    |#define HW_REVR_RMN_BITPOS (0)
                             6709 ; 8    |#define HW_REVR_DCDCMODE_BITPOS (5)
                             6710 ; 9    |#define HW_REVR_RMJ_BITPOS (8)
                             6711 ; 10   |
                             6712 ; 11   |#define HW_REVR_RMN_WIDTH (5)
                             6713 ; 12   |#define HW_REVR_DCDCMODE_WIDTH (3)
                             6714 ; 13   |
                             6715 ; 14   |#define HW_REVR_DCDCMODE_SETMASK (((1<<HW_REVR_DCDCMODE_WIDTH)-1)<<HW_REVR_DCDCMODE_BITPOS
                                  )
TASKING DSP2410 assembler v1.5r1 Build 138 SN 00100122
                                                                                                                            Page 108

M:ADDR CODE           CYCLES LINE SOURCELINE
                             6716 ; 15   |
                             6717 ; 16   |#define HW_REVR_DCDCMODE_CLRMASK (~(WORD)HW_REVR_DCDCMODE_SETMASK)
                             6718 ; 17   |
                             6719 ; 18   |
                             6720 ; 19   |/////////////////////////////////////////////////////////////////////////////////
                             6721 ; 20   |//  Revision Register (HW_REVR) bitfields and values. (read only)
                             6722 ; 21   |//  June15 2004: C struct updated to be correct: 
                             6723 ; 22   |//   Added DCDCMODE bitfield. Removed RMP bitfield. Reduced size of RMN bitfield to 5 bits
                                  .
                             6724 ; 23   |typedef union               
                             6725 ; 24   |{
                             6726 ; 25   |    struct {
                             6727 ; 26   |        unsigned RMN    :5;     //Minor Revision
                             6728 ; 27   |        unsigned DCDCMODE : 3;  //DCDC mode field function depends on DCDC mode pin strapp
                                  ing
                             6729 ; 28   |           #define DCDCMODE_7_CONVERTER1_2CH_BOOST_CONVERTER2_OFF      7
                             6730 ; 29   |           #define DCDCMODE_6_RESERVED                                 6
                             6731 ; 30   |           #define DCDCMODE_5_CONVERTER1_3CH_BOOST_CONVERTER2_OFF      5
                             6732 ; 31   |           #define DCDCMODE_4_RESERVED                                 4
                             6733 ; 32   |           #define DCDCMODE_3_CONVERTER1_1CH_BUCK_CONVERTER2_OFF       3
                             6734 ; 33   |           #define DCDCMODE_2_CONVERTER1_OFF_CONVERTER2_OFF            2
                             6735 ; 34   |           #define DCDCMODE_1_CONVERTER1_1CH_BUCK_CONVERTER2_1CH_BOOST 1
                             6736 ; 35   |           #define DCDCMODE_0_CONVERTER1_1CH_BUCK_CONVERTER2_1CH_BUCK  0
                             6737 ; 36   |           #define DCDCMODE_X_BUCK_MASKED_SETMASK 0x4
                             6738 ; 37   |        unsigned RMJ    :16;    //Major Revision
                             6739 ; 38   |    } B;
                             6740 ; 39   |
                             6741 ; 40   |    int I;
                             6742 ; 41   |
                             6743 ; 42   |} revr_type;
                             6744 ; 43   |#define HW_REVR (*(volatile revr_type _X*) (HW_GLUE_BASEADDR+2))
                             6745 ; 44   |
                             6746 ; 45   |#define HW_REVR_DCDCMODE_B0_BITPOS 5
                             6747 ; 46   |#define HW_REVR_DCDCMODE_B1_BITPOS 6
                             6748 ; 47   |#define HW_REVR_DCDCMODE_B2_BITPOS 7
                             6749 ; 48   |
                             6750 ; 49   |#define HW_REVR_DCDCMODE_BUCK_MASK_POS HW_REVR_DCDCMODE_B2_BITPOS
                             6751 ; 50   |// 3 bit bitfield: (HW_REVR_DCDCMODE_B2_BITPOS|HW_REVR_DCDCMODE_B1_BITPOS|HW_REVR_DCDCMODE
                                  _B0_BITPOS)
                             6752 ; 51   |#define HW_REVR_DCDC_MODE_SETMASK 0x0000E0
                             6753 ; 52   |#define HW_REVR_RMN_SETMASK 0xFF<<HW_REVR_RMN_BITPOS
                             6754 ; 53   |#define HW_REVR_RMJ_SETMASK 0xFFFF<<HW_REVR_RMJ_BITPOS
                             6755 ; 54   |
                             6756 ; 55   |#define HW_REVR_RMN_CLRMASK ~(WORD)HW_REVR_RMN_SETMASK
                             6757 ; 56   |#define HW_REVR_RMJ_CLRMASK ~(WORD)HW_REVR_RMJ_SETMASK
                             6758 ; 57   |
                             6759 ; 58   |#endif //!@def(__HW_REVR)
                             6760 ; 59   |
                             6761 
                             6763 
                             6764 ; 10   |#include "misc.h"
                             6765 
                             6767 
                             6768 ; 1    |////////////////////////////////////////////////////////////////////////////////
                             6769 ; 2    |// Copyright(C) SigmaTel, Inc. 2002
                             6770 ; 3    |//
                             6771 ; 4    |// Filename: misc.h
                             6772 ; 5    |// Description: 
                             6773 ; 6    |////////////////////////////////////////////////////////////////////////////////
                             6774 ; 7    |
                             6775 ; 8    |#ifndef _MISC_H
                             6776 ; 9    |#define _MISC_H
TASKING DSP2410 assembler v1.5r1 Build 138 SN 00100122
                                                                                                                            Page 109

M:ADDR CODE           CYCLES LINE SOURCELINE
                             6777 ; 10   |
                             6778 ; 11   |////////////////////////////////////////////////////////////////////////////////
                             6779 ; 12   |// Defs
                             6780 ; 13   |////////////////////////////////////////////////////////////////////////////////
                             6781 ; 14   |
                             6782 ; 15   |////////////////////////////////////////////////////////////////////////////////
                             6783 ; 16   |// Error codes
                             6784 ; 17   |////////////////////////////////////////////////////////////////////////////////
                             6785 ; 18   |
                             6786 ; 19   |////////////////////////////////////////////////////////////////////////////////
                             6787 ; 20   |// Typedefs
                             6788 ; 21   |////////////////////////////////////////////////////////////////////////////////
                             6789 ; 22   |
                             6790 ; 23   |////////////////////////////////////////////////////////////////////////////////
                             6791 ; 24   |// Prototypes
                             6792 ; 25   |////////////////////////////////////////////////////////////////////////////////
                             6793 ; 26   |
                             6794 ; 27   |RETCODE PowerInit(void);
                             6795 ; 28   |RETCODE PllInit(void);
                             6796 ; 29   |RETCODE _reentrant SystemShutdown(void);
                             6797 ; 30   |RETCODE _reentrant SysGpioDisableAll(void);
                             6798 ; 31   |RETCODE _reentrant SysPadPowerDownAll(void);
                             6799 ; 32   |RETCODE _reentrant SysPllShutdown(void);
                             6800 ; 33   |RETCODE GoToSleep(void);
                             6801 ; 34   |void _reentrant SysDelayMs(WORD wDelay);
                             6802 ; 35   |DWORD GetDclkCount(void);
                             6803 ; 36   |#ifdef USE_PLAYLIST2
                             6804 ; 37   |DWORD GetDclkCount_PL2(void);
                             6805 ; 38   |#endif
                             6806 ; 39   |void SetDclkCount(DWORD dwCount);
                             6807 ; 40   |RETCODE SmartMediaSetPortTiming(WORD wTiming);
                             6808 ; 41   |RETCODE ProgramPll(INT iSpeed);
                             6809 ; 42   |void _reentrant SystemReset(void);
                             6810 ; 43   |void _reentrant SystemPowerOff(void);
                             6811 ; 44   |void _reentrant ReconfigureAsDcc(void);
                             6812 ; 45   |void _reentrant PowerDownFMTuners(void);
                             6813 ; 46   |#ifdef TUNER_5767
                             6814 ; 47   |void _reentrant  Philips5767_3WireWriteByte(INT data);
                             6815 ; 48   |void _reentrant Philips5767_3WireClockDelay(void);
                             6816 ; 49   |#endif
                             6817 ; 50   |extern BOOL g_bPowerOff;
                             6818 ; 51   |
                             6819 ; 52   |#ifndef DISABLE_USB_CURRENT_REQUIREMENT_FOR_MMC_DRIVER
                             6820 ; 53   |extern int g_iHighPwrPeriphInitMode; // def in usbmscmisc.c
                             6821 ; 54   | #define STRUCTURE_INIT_ONLY                            2
                             6822 ; 55   | #define USB_HIGH_CURRENT_GRANTED                       3
                             6823 ; 56   |#endif
                             6824 ; 57   |
                             6825 ; 58   |#endif // #ifndef _MISC_H
                             6826 
                             6828 
                             6829 ; 11   |
                             6830 ; 12   |#include "resource.h"
                             6831 
                             6833 
                             6834 ; 1    |//  NOTE: This file was generated automatically by rscrenum.pl
                             6835 ; 2    |//  Do not edit it directly.
                             6836 ; 3    |//  Created on Mon Jun 30 17:30:17 2008 using ..\output_3500\include\resource.inc as input
                                  .
                             6837 ; 4    |
                             6838 ; 5    |
                             6839 ; 6    |
TASKING DSP2410 assembler v1.5r1 Build 138 SN 00100122
                                                                                                                            Page 110

M:ADDR CODE           CYCLES LINE SOURCELINE
                             6840 ; 7    |//  NOTE: This file was generated automatically by rscrenum.pl
                             6841 ; 8    |//  Do not edit it directly.
                             6842 ; 9    |//  Created on Sat Jun 14 11:51:41 2008 using resource.inc as input.
                             6843 ; 10   |
                             6844 ; 11   |
                             6845 ; 12   |
                             6846 ; 13   |/////////////////////////////////////////////////////////////////////////////////
                             6847 ; 14   |//  Copyright(C) SigmaTel, Inc. 2000-2006
                             6848 ; 15   |//  File        :  resource.inc
                             6849 ; 16   |//  Description :  Resource stuff
                             6850 ; 17   |/////////////////////////////////////////////////////////////////////////////////
                             6851 ; 18   |
                             6852 ; 19   |/////////////////////////////////////////////////////////////////////////////////
                             6853 ; 20   |//  usbmsc version number            no leading zeros here!
                             6854 ; 21   |/////////////////////////////////////////////////////////////////////////////////
                             6855 ; 22   |
                             6856 ; 23   |#define VERSION_MAJOR 3
                             6857 ; 24   |#define VERSION_MIDDLE 200
                             6858 ; 25   |#define VERSION_MINOR 910
                             6859 ; 26   |
                             6860 ; 27   |//Set to 34 if right side up
                             6861 ; 28   |#define LCD_SEG_OFFSET 0       
                             6862 ; 29   |
                             6863 ; 30   |/////////////////////////////////////////////////////////////////////////////////
                             6864 ; 31   |//  Common system resources
                             6865 ; 32   |/////////////////////////////////////////////////////////////////////////////////
                             6866 ; 33   |
                             6867 ; 34   |//$FILENAME connectleft.src
                             6868 ; 35   |#define ConnectImageLeft 1    
                             6869 ; 36   |//$FILENAME connectright.src
                             6870 ; 37   |#define ConnectImageRight 2    
                             6871 ; 38   |//$FILENAME ready.src
                             6872 ; 39   |#define ReadyImage 3    
                             6873 ; 40   |//$FILENAME reading.src
                             6874 ; 41   |#define ReadingImage 4    
                             6875 ; 42   |//$FILENAME writing.src
                             6876 ; 43   |#define WritingImage 5    
                             6877 ; 44   |//$FILENAME notes.src
                             6878 ; 45   |#define NotesImage 6    
                             6879 ; 46   |//$FILENAME lowbat.src
                             6880 ; 47   |#define LowBatImage 7    
                             6881 ; 48   |//$FILENAME fullspeed.src
                             6882 ; 49   |#define RSRC_FULL_SPEED 8    
                             6883 ; 50   |//$FILENAME highspeed.src
                             6884 ; 51   |#define RSRC_HIGH_SPEED 9    
                             6885 ; 52   |//$FILENAME lcd_controller_init.src
                             6886 ; 53   |#define RSRC_LCD_INIT_SEQ 10    
                             6887 ; 54   |//$FILENAME version.src
                             6888 ; 55   |#define RSRC_VERSION 11    
                             6889 ; 56   |//$FILENAME period.src
                             6890 ; 57   |#define RSRC_PERIOD 12    
                             6891 ; 58   |//$FILENAME charging.src
                             6892 ; 59   |#define RSRC_CHARGING 13    
                             6893 ; 60   |//$FILENAME charge_complete.src
                             6894 ; 61   |#define RSRC_CHARGE_COMPLETE 14    
                             6895 ; 62   |//$FILENAME font_table.src
                             6896 ; 63   |#define RSRC_FONT_TABLE 15    
                             6897 ; 64   |
                             6898 ; 65   |/////////////////////////////////////////////////////////////////////////////////
                             6899 ; 66   |//  Battery Status
                             6900 ; 67   |/////////////////////////////////////////////////////////////////////////////////
                             6901 ; 68   |//$FILENAME battery_00.src
TASKING DSP2410 assembler v1.5r1 Build 138 SN 00100122
                                                                                                                            Page 111

M:ADDR CODE           CYCLES LINE SOURCELINE
                             6902 ; 69   |#define RSRC_BATTERY_00 16    
                             6903 ; 70   |//$FILENAME battery_01.src
                             6904 ; 71   |#define RSRC_BATTERY_01 17    
                             6905 ; 72   |//$FILENAME battery_02.src
                             6906 ; 73   |#define RSRC_BATTERY_02 18    
                             6907 ; 74   |//$FILENAME battery_03.src
                             6908 ; 75   |#define RSRC_BATTERY_03 19    
                             6909 ; 76   |//$FILENAME battery_04.src
                             6910 ; 77   |#define RSRC_BATTERY_04 20    
                             6911 ; 78   |//$FILENAME battery_05.src
                             6912 ; 79   |#define RSRC_BATTERY_05 21    
                             6913 ; 80   |//$FILENAME battery_06.src
                             6914 ; 81   |#define RSRC_BATTERY_06 22    
                             6915 ; 82   |//$FILENAME battery_07.src
                             6916 ; 83   |#define RSRC_BATTERY_07 23    
                             6917 ; 84   |//$FILENAME battery_08.src
                             6918 ; 85   |#define RSRC_BATTERY_08 24    
                             6919 ; 86   |//$FILENAME battery_09.src
                             6920 ; 87   |#define RSRC_BATTERY_09 25    
                             6921 ; 88   |//$FILENAME battery_10.src
                             6922 ; 89   |#define RSRC_BATTERY_10 26    
                             6923 ; 90   |
                             6924 ; 91   |/////////////////////////////////////////////////////////////////////////////////
                             6925 ; 92   |//  Font
                             6926 ; 93   |/////////////////////////////////////////////////////////////////////////////////
                             6927 ; 94   |//$FILENAME font_PGM.src
                             6928 ; 95   |#define RSRC_PGM_8 27    
                             6929 ; 96   |//$FILENAME font_SGMs.src
                             6930 ; 97   |#define RSRC_SGMS_8 28    
                             6931 ; 98   |//$FILENAME font_script_00.src
                             6932 ; 99   |#define RSRC_SCRIPT_00_8 29    
                             6933 ; 100  |//$FILENAME font_scripts.src
                             6934 ; 101  |#define RSRC_SCRIPTS_8 30    
                             6935 ; 102  |//$FILENAME font_PDM.src
                             6936 ; 103  |#define RSRC_PDM 31    
                             6937 ; 104  |//$FILENAME font_SDMs.src
                             6938 ; 105  |#define RSRC_SDMS 32    
                             6939 ; 106  |
                             6940 ; 107  |
                             6941 ; 108  |
                             6942 ; 109  |
                             6943 ; 110  |#define RSRC_MMCMEDIAINIT 0
                             6944 ; 111  |#define RSRC_MMCMEDIAALLOCATE 0
                             6945 ; 112  |#define RSRC_MMCMEDIADISCOVERALLOCATION 0
                             6946 ; 113  |#define RSRC_MMCMEDIAGETMEDIATABLE 0
                             6947 ; 114  |#define RSRC_MMCMEDIAGETINFO 0
                             6948 ; 115  |#define RSRC_MMCMEDIAERASE 0
                             6949 ; 116  |
                             6950 ; 117  |#define RSRC_MMCDATADRIVEINIT 0
                             6951 ; 118  |#define RSRC_MMCDATADRIVEGETINFO 0
                             6952 ; 119  |#define RSRC_MMCDATADRIVESETINFO 0
                             6953 ; 120  |#define RSRC_MMCDATADRIVEREADSECTOR 0
                             6954 ; 121  |#define RSRC_MMCDATADRIVEWRITESECTOR 0 
                             6955 ; 122  |#define RSRC_MMCDATADRIVEMULTIWRITESETUP 0 
                             6956 ; 123  |#define RSRC_MMCDATADRIVEMULTIWRITESECTOR 0 
                             6957 ; 124  |#define RSRC_MMCDATADRIVEERASE 0 
                             6958 ; 125  |#define RSRC_MMCDATADRIVEFLUSH 0 
                             6959 ; 126  |
                             6960 ; 127  |
                             6961 ; 128  |#define RSRC_RAMMEDIAINIT 0
                             6962 ; 129  |#define RSRC_RAMMEDIAALLOCATE 0
                             6963 ; 130  |#define RSRC_RAMMEDIADISCOVERALLOCATION 0
TASKING DSP2410 assembler v1.5r1 Build 138 SN 00100122
                                                                                                                            Page 112

M:ADDR CODE           CYCLES LINE SOURCELINE
                             6964 ; 131  |#define RSRC_RAMMEDIAGETMEDIATABLE 0
                             6965 ; 132  |#define RSRC_RAMMEDIAGETINFO 0
                             6966 ; 133  |#define RSRC_RAMMEDIAERASE 0
                             6967 ; 134  |
                             6968 ; 135  |#define RSRC_RAMDATADRIVEINIT 0
                             6969 ; 136  |#define RSRC_RAMDATADRIVEGETINFO 0
                             6970 ; 137  |#define RSRC_RAMDATADRIVESETINFO 0
                             6971 ; 138  |#define RSRC_RAMDATADRIVEREADSECTOR 0
                             6972 ; 139  |#define RSRC_RAMDATADRIVEWRITESECTOR 0
                             6973 ; 140  |#define RSRC_RAMDATADRIVEMULTIWRITESETUP 0
                             6974 ; 141  |#define RSRC_RAMDATADRIVEMULTIWRITESECTOR 0
                             6975 ; 142  |#define RSRC_RAMDATADRIVEERASE 0
                             6976 ; 143  |#define RSRC_RAMDATADRIVEFLUSH 0
                             6977 ; 144  |
                             6978 ; 145  |#define RSRC_RAMSYSTEMDRIVEINIT 0
                             6979 ; 146  |#define RSRC_RAMSYSTEMDRIVEGETINFO 0
                             6980 ; 147  |#define RSRC_RAMSYSTEMDRIVESETINFO 0
                             6981 ; 148  |#define RSRC_RAMSYSTEMDRIVEREADSECTOR 0
                             6982 ; 149  |#define RSRC_RAMSYSTEMDRIVEWRITESECTOR 0
                             6983 ; 150  |#define RSRC_RAMSYSTEMDRIVEMULTIWRITESETUP 0
                             6984 ; 151  |#define RSRC_RAMSYSTEMDRIVEMULTIWRITESECTOR 0
                             6985 ; 152  |#define RSRC_RAMSYSTEMDRIVEERASE 0
                             6986 ; 153  |#define RSRC_RAMSYSTEMDRIVEFLUSH 0
                             6987 ; 154  |
                             6988 ; 155  |#define RSRC_NANDMEDIAINIT 0
                             6989 ; 156  |#define RSRC_NANDMEDIAALLOCATE 0
                             6990 ; 157  |#define RSRC_NANDMEDIADISCOVERALLOCATION 0
                             6991 ; 158  |#define RSRC_NANDMEDIAGETMEDIATABLE 0
                             6992 ; 159  |#define RSRC_NANDMEDIAGETINFO 0
                             6993 ; 160  |#define RSRC_NANDMEDIAERASE 0
                             6994 ; 161  |
                             6995 ; 162  |#define RSRC_NANDDATADRIVEINIT 0
                             6996 ; 163  |#define RSRC_NANDDATADRIVEGETINFO 0
                             6997 ; 164  |#define RSRC_NANDDATADRIVESETINFO 0
                             6998 ; 165  |#define RSRC_NANDDATADRIVEREADSECTOR 0
                             6999 ; 166  |#define RSRC_NANDDATADRIVEWRITESECTOR 0 
                             7000 ; 167  |#define RSRC_NANDDATADRIVEDUMBMULTIWRITESETUP 0 
                             7001 ; 168  |#define RSRC_NANDDATADRIVEDUMBMULTIWRITESECTOR 0 
                             7002 ; 169  |#define RSRC_NANDDATADRIVECACHEMULTIWRITESETUP 0 
                             7003 ; 170  |#define RSRC_NANDDATADRIVECACHEMULTIWRITESECTOR 0 
                             7004 ; 171  |#define RSRC_NANDDATADRIVEERASE 0 
                             7005 ; 172  |#define RSRC_NANDDATADRIVEFLUSH 0 
                             7006 ; 173  |
                             7007 ; 174  |#define RSRC_NANDSYSTEMDRIVEINIT 0 
                             7008 ; 175  |#define RSRC_NANDSYSTEMDRIVEGETINFO 0  
                             7009 ; 176  |#define RSRC_NANDSYSTEMDRIVESETINFO 0  
                             7010 ; 177  |#define RSRC_NANDSYSTEMDRIVEREADSECTOR 0 
                             7011 ; 178  |#define RSRC_NANDSYSTEMDRIVEWRITESECTOR 0 
                             7012 ; 179  |#define RSRC_NANDSYSTEMDRIVEMULTIWRITESETUP 0 
                             7013 ; 180  |#define RSRC_NANDSYSTEMDRIVEMULTIWRITESECTOR 0 
                             7014 ; 181  |#define RSRC_NANDSYSTEMDRIVEERASE 0 
                             7015 ; 182  |#define RSRC_NANDSYSTEMDRIVEFLUSH 0 
                             7016 ; 183  |
                             7017 ; 184  |
                             7018 
                             7020 
                             7021 ; 13   |
                             7022 ; 14   |extern _P WORD * _P _lc_u_p_usbmsc_lcd_battery_start;
                             7023 ; 15   |extern _Y WORD * _Y _lc_u_y_Usbmsc_lcd_OVLY_copy_start;
                             7024 ; 16   |extern _Y WORD * _Y _lc_u_y_Usbmsc_lcd_OVLY_copy_end;
                             7025 ; 17   |extern _Y WORD * _Y _lc_u_y_Usbmsc_lcd_battery_OVLY_copy_start;
                             7026 ; 18   |extern _Y WORD * _Y _lc_u_y_Usbmsc_lcd_battery_OVLY_copy_end;
TASKING DSP2410 assembler v1.5r1 Build 138 SN 00100122
                                                                                                                            Page 113

M:ADDR CODE           CYCLES LINE SOURCELINE
                             7027 ; 19   |
                             7028 ; 20   |extern _reentrant void CopyCodeIntoBootmanagerArea(_Y WORD * _Y pYCopyStart, 
                             7029 ; 21   |                _P WORD * _P pPCopyStart, WORD wYCopySize);
                             7030 ; 22   |
                             7031 ; 23   |extern TaskEntry g_DisplayTaskEntry;
                             7032 ; 24   |extern CircularBufferDescriptor g_DisplayTaskQueueDescriptor;
                             7033 ; 25   |
                             7034 ; 26   |extern TaskEntry g_USBInsertionMonitor;
                             7035 ; 27   |extern TaskEntry g_USBMSCHandler0;
                             7036 ; 28   |#if NUM_REMOVABLE_MEDIA == 1
                             7037 ; 29   |    #if (MULTI_LUN_BUILD==0)
                             7038 ; 30   |extern TaskEntry g_USBMSCHandler1;
                             7039 ; 31   |    #endif
                             7040 ; 32   |extern TaskEntry g_DeviceInsertion;
                             7041 ; 33   |#endif
                             7042 ; 34   |
                             7043 ; 35   |volatile WORD g_wActivityState = SCSI_IDLE;
                             7044 
                             7045 
Y:0000                       7046         org     y,".ydatasystem",init:
                             7047 Fg_wActivityState:
Y:0000 000000                7048         dc      $000000
                             7051 
                             7052 ; 36   |
                             7053 ; 37   |// This variable was introduced in SDK3.0 to solve refreshing display when using multi wri
                                  tes
                             7054 ; 38   |// in a system using overlays. Overlays will disturb multi write sequence.
                             7055 ; 39   |volatile WORD g_wActivityStateMultiWrite = SCSI_IDLE;
                             7056 
                             7057 Fg_wActivityStateMultiWrite:
Y:0001 000000                7058         dc      $000000
                             7061 
                             7062 ; 40   |BOOL gMscMtpEnable = FALSE;
                             7063 
                             7064 FgMscMtpEnable:
Y:0002 000000                7065         dc      $000000
                             7068 
                             7069 ; 41   |
                             7070 ; 42   |//The task entry points can be declared here, or from an include file.
                             7071 ; 43   |void UserInterfaceTask(void);
                             7072 ; 44   |
                             7073 ; 45   |#define USER_INTERFACE_STACK_SIZE 100
                             7074 ; 46   |//declare the task stacks.  Each task must have a stack that is tuned to its needs.
                             7075 ; 47   |WORD g_UserInterfaceStack[USER_INTERFACE_STACK_SIZE];
                             7076 ; 48   |
                             7077 ; 49   |//declare the task message queues.  Each task muct have a queue that is tuned to its needs
                                  .
                             7078 ; 50   |_circ WORD g_UserInterfaceMessageQueue[32];
                             7079 ; 51   |
                             7080 ; 52   |CircularBufferDescriptor g_UserInterfaceQueueDescriptor={ g_UserInterfaceMessageQueue,g_Us
                                  erInterfaceMessageQueue};
                             7081 
                             7082 Fg_UserInterfaceQueueDescriptor:
Y:0003 rrrrrr 00001F         7083         dc      Fg_UserInterfaceMessageQueue,32-1,Fg_UserInterfaceMessageQueue,32-1
       rrrrrr 00001F              
                             7086 
                             7087 ; 53   |
                             7088 ; 54   |//declare each task as a task entry.
                             7089 ; 55   |TaskEntry g_UserInterfaceTaskEntry = {&g_UserInterfaceQueueDescriptor,  //Message queue as
                                  sociated with the task
                             7090 
                             7091 Fg_UserInterfaceTaskEntry:
TASKING DSP2410 assembler v1.5r1 Build 138 SN 00100122
                                                                                                                            Page 114

M:ADDR CODE           CYCLES LINE SOURCELINE
Y:0007 rrrrrr 000000         7092         dc      Fg_UserInterfaceQueueDescriptor,$000000,$000000,$000000,Fg_UserInterfaceStack
       000000 000000              
       rrrrrr                     
Y:000C 000000 000000         7093         dc      $000000,$000000,$000000,$000000,$000000,$000000,$000000,$000000
       000000 000000              
       000000 000000              
       000000 000000              
Y:0014 000000 rrrrrr         7094         dc      $000000,Fg_UserInterfaceStack,$000064,FUserInterfaceTask
       000064 rrrrrr              
                             7097 
                             7098 ; 56   |                                       0,                               //Pointer to wait 
                                  on (meaning depends on state)
                             7099 ; 57   |                                       0,                               //Word to wait on 
                                  (meaning depends on state)
                             7100 ; 58   |                                       EVENT_TIMEOUT,                   //State
                             7101 ; 59   |                                       g_UserInterfaceStack,            //Current stack po
                                  inter
                             7102 ; 60   |                                       0,                               //Task ID
                             7103 ; 61   |                                       TIMEOUT_IMMEDIATE,               //initial timeout
                             7104 ; 62   |                                       {0},                             //Region resources
                                  
                             7105 ; 63   |                                       0,                               //Priority
                             7106 ; 64   |                                       g_UserInterfaceStack,            //stack pointer
                             7107 ; 65   |                                       USER_INTERFACE_STACK_SIZE,       //stack size
                             7108 ; 66   |                                       UserInterfaceTask};              //initial entry po
                                  int
                             7109 ; 67   |
                             7110 ; 68   |TaskEntry *g_TaskList[]={
                             7111 ; 69   |#if (NUM_REMOVABLE_MEDIA == 1)
                             7112 ; 70   |    #if (MULTI_LUN_BUILD==0)
                             7113 ; 71   |                        &g_USBMSCHandler1,
                             7114 ; 72   |    #endif
                             7115 
                             7116 Fg_TaskList:
Y:0018 rrrrrr                7117         dc      Fg_DeviceInsertion
                             7118 
                             7119 ; 73   |                        &g_DeviceInsertion,
                             7120 ; 74   |
                             7121 ; 75   |#endif                         
                             7122 
Y:0019 rrrrrr rrrrrr         7123         dc      Fg_USBInsertionMonitor,Fg_UserInterfaceTaskEntry,Fg_DisplayTaskEntry
       rrrrrr                     
Y:001C rrrrrr 000000         7124         dc      Fg_USBMSCHandler0,$000000
                             7128 
                             7129 ; 76   |                        &g_USBInsertionMonitor,
                             7130 ; 77   |                        &g_UserInterfaceTaskEntry,
                             7131 ; 78   |                        &g_DisplayTaskEntry,
                             7132 ; 79   |                        &g_USBMSCHandler0,
                             7133 ; 80   |                         NULL
                             7134 ; 81   |                        };
                             7135 ; 82   |
                             7136 ; 83   |//the routing table describes which messages need to go to which queues.
                             7137 ; 84   |RoutingEntry g_RoutingTable[] = 
                             7138 
                             7139 Fg_RoutingTable:
Y:001E 030000 rrrrrr         7140         dc      $030000,Fg_DisplayTaskQueueDescriptor,$000000,$000000
       000000 000000              
                             7144 
                             7145 ; 85   |{
                             7146 ; 86   |    {MSG_TYPE_LCD, &g_DisplayTaskQueueDescriptor},
                             7147 ; 87   |    NULL
                             7148 ; 88   |};
TASKING DSP2410 assembler v1.5r1 Build 138 SN 00100122
                                                                                                                            Page 115

M:ADDR CODE           CYCLES LINE SOURCELINE
                             7149 ; 89   |
                             7150 ; 90   |SyncObject g_Sync_UserScratchY;
                             7151 ; 91   |_Y WORD g_wUserScratchY[SCRATCH_USER_Y_SIZE];
                             7152 ; 92   |
                             7153 ; 93   |SyncObject g_Sync_UserScratchY;
                             7154 ; 94   |_X WORD g_wUserScratchX[SCRATCH_USER_X_SIZE];
                             7155 ; 95   |
                             7156 ; 96   |BOOL g_bShutdown = FALSE;
                             7157 
                             7158 Fg_bShutdown:
Y:0022 000000                7159         dc      $000000
                             7162 
                             7163 ; 97   |
                             7164 ; 98   |extern int g_iCommonCommands;
                             7165 ; 99   |extern int g_iUpdaterCommands;
                             7166 ; 100  |extern int g_iUnknownCommands;
                             7167 ; 101  |
                             7168 ; 102  |extern void USBLCDDisplayInit(void);
                             7169 ; 103  |extern void USBLCDCheckForTransfers(void);
                             7170 ; 104  |extern void USBLCDIdle(void);
                             7171 ; 105  |extern void USBLCDReading(void);
                             7172 ; 106  |extern void USBLCDWriting(void);
                             7173 ; 107  |//extern void USBLCDCheckBrownout(void);
                             7174 ; 108  |extern void USBLCDDisplayBatteryLevel(void);
                             7175 ; 109  |extern void USBLCDCheckBatteryLevel(void);
                             7176 ; 110  |
                             7177 ; 111  |extern void _reentrant Init5VSense(void);
                             7178 ; 112  |extern void _reentrant ServiceDCDC(void);
                             7179 ; 113  |////////////////////////////////////////////////////////////////////////////////
                             7180 ; 114  |// Defines
                             7181 ; 115  |//#define USB_THROUGHPUT          1
                             7182 ; 116  |
                             7183 ; 117  |#ifdef  USB_THROUGHPUT
                             7184 ; 118  |  #define UPDATE_RATE           1000
                             7185 ; 119  |#else
                             7186 ; 120  |  #define UPDATE_RATE           100
                             7187 ; 121  |#endif
                             7188 ; 122  |#define HALF_SEC_UPDATE_RATE    (500/UPDATE_RATE)
                             7189 ; 123  |
                             7190 ; 124  |#ifndef USB_THROUGHPUT
                             7191 ; 125  |// Function Description: 
                             7192 ; 126  |// Inputs:  no parameters
                             7193 ; 127  |// Returns: no register returns
                             7194 ; 128  |// Notes:   
                             7195 ; 129  |void UserInterfaceTask(void)
                             7196 ; 130  |{
                             7197 
P:0000                       7198         org     p,".ptextsystem":
                             7203 FUserInterfaceTask:
P:0000 05707C rrrrrr  4    4 7204         movec   ssh,y:ss_UserInterfaceTask
                             7209 
                             7210 ; 131  |    USHORT      usStatus;
                             7211 ; 132  |    //int iTransferRate; // commented out since unused
                             7212 ; 133  |    WORD State=SCSI_IDLE;
                             7213 
P:0002 260000         2    6 7215         move    #0,y0
P:0003 4E7000 rrrrrr  3    9 7217         move    y0,y:ss_UserInterfaceTask+2
                             7222 
                             7223 ; 134  |    //Message Msg; // commented out since unused
                             7224 ; 135  |    int iDelay = HALF_SEC_UPDATE_RATE;
                             7225 
P:0005 46F400 000005  3   12 7227         move    #>5,y0
TASKING DSP2410 assembler v1.5r1 Build 138 SN 00100122
                                                                                                                            Page 116

M:ADDR CODE           CYCLES LINE SOURCELINE
P:0007 4E7000 rrrrrr  3   15 7229         move    y0,y:ss_UserInterfaceTask+3
                             7234 
                             7235 ; 136  |        BOOL bNeedToReEnable = FALSE;
                             7236 
P:0009 270000         2   17 7238         move    #0,y1
P:000A 4F7000 rrrrrr  3   20 7240         move    y1,y:ss_UserInterfaceTask+4
                             7245 
                             7246 ; 137  |    unsigned int CopySize;
                             7247 ; 138  |
                             7248 ; 139  |        Init5VSense();
                             7249 
P:000C 0BF080 rrrrrr  6   26 7251         jsr     FInit5VSense
                             7252 
                             7253 ; 140  |    USBLCDDisplayInit();
                             7254 
P:000E 0BF080 rrrrrr  6   32 7256         jsr     FUSBLCDDisplayInit
                             7257 
                             7258 ; 141  |    SysWait(250);
                             7259 
P:0010 56F400 0000FA  3   35 7261         move    #>250,a
P:0012 0BF080 rrrrrr  6   41 7262         jsr     FSysWait
                             7263 
                             7264 ; 142  |
                             7265 ; 143  |    while(1)
                             7266 
                             7268 L3:
                             7269 L4:
                             7270 L5:
P:0014 57F400 rrrrrr  3   44 7271 L6:     move    #F_lc_u_y_Usbmsc_lcd_battery_OVLY_copy_end,b
P:0016 56F400 rrrrrr  3   47 7272         move    #F_lc_u_y_Usbmsc_lcd_battery_OVLY_copy_start,a
P:0018 20001C         2   49 7273         sub     a,b
P:0019 5D7000 rrrrrr  3   52 7274         move    b1,y:ss_UserInterfaceTask+5
P:001B 56F400 rrrrrr  3   55 7275         move    #F_lc_u_y_Usbmsc_lcd_OVLY_copy_end,a
P:001D 57F400 rrrrrr  3   58 7276         move    #F_lc_u_y_Usbmsc_lcd_OVLY_copy_start,b
P:001F 200014         2   60 7277         sub     b,a
P:0020 5C7000 rrrrrr  3   63 7278         move    a1,y:ss_UserInterfaceTask+6
                             7279 L7:
                             7280 
                             7281 ; 144  |    {
                             7282 ; 145  |        usb_device_get_status(USB_STATUS, &usStatus);
                             7283 
P:0022 56F400 000006  3   66 7285 L8:     move    #>6,a
P:0024 60F400 rrrrrr  3   69 7286         move    #ss_UserInterfaceTask+1,r0
P:0026 0BF080 rrrrrr  6   75 7287         jsr     Fusb_device_get_status
                             7288 
                             7289 ; 146  |
                             7290 ; 147  |        if(usStatus == USB_STATE_SUSPENDED)
                             7291 
P:0028 5EF000 rrrrrr  3   78 7293         move    y:ss_UserInterfaceTask+1,a
P:002A 44F400 000080  3   81 7294         move    #>$80,x0
P:002C 200045         2   83 7295         cmp     x0,a
P:002D 0AF0A2 rrrrrr  6   89 7296         jne     L9
P:002F 56F400 000064  3   92 7297         move    #>100,a
                             7298 
                             7299 ; 148  |        {
                             7300 ; 149  |            SysWait(UPDATE_RATE);
                             7301 
P:0031 0BF080 rrrrrr  6   98 7303         jsr     FSysWait
                             7304 
                             7305 ; 150  |        }
                             7306 
P:0033 0AF080 rrrrrr  6  104 7308         jmp     L8
TASKING DSP2410 assembler v1.5r1 Build 138 SN 00100122
                                                                                                                            Page 117

M:ADDR CODE           CYCLES LINE SOURCELINE
                             7309 
                             7310 ; 151  |        else
                             7311 ; 152  |        {
                             7312 ; 153  |            SysPostMessage(2,LCD_END_FRAME);
                             7313 
P:0035 290200         2  106 7315 L9:     move    #2,b0
P:0036 44F400 030019  3  109 7316         move    #196633,x0
P:0038 4C5F00         2  111 7317         move    x0,y:(r7)+
P:0039 595F00         2  113 7319         move    b0,y:(r7)+
P:003A 0BF080 rrrrrr  6  119 7321         jsr     FSysPostMessage
P:003C 205700         2  121 7322         move    (r7)-
P:003D 205700         2  123 7324         move    (r7)-
P:003E 56F400 000064  3  126 7326         move    #>100,a
                             7327 
                             7328 ; 154  |            SysWait(UPDATE_RATE);
                             7329 
P:0040 0BF080 rrrrrr  6  132 7331         jsr     FSysWait
                             7332 
                             7333 ; 155  |            SysPostMessage(2,LCD_BEGIN_FRAME);
                             7334 
P:0042 45F400 030018  3  135 7336         move    #196632,x1
P:0044 4D5F00         2  137 7337         move    x1,y:(r7)+
P:0045 290200         2  139 7339         move    #2,b0
P:0046 595F00         2  141 7340         move    b0,y:(r7)+
P:0047 0BF080 rrrrrr  6  147 7342         jsr     FSysPostMessage
P:0049 205700         2  149 7343         move    (r7)-
P:004A 205700         2  151 7345         move    (r7)-
                             7347 
                             7348 ; 156  |            USBLCDCheckForTransfers();
                             7349 
P:004B 0BF080 rrrrrr  6  157 7351         jsr     FUSBLCDCheckForTransfers
                             7352 
                             7353 ; 157  |
                             7354 ; 158  |            //if(g_bServiceDCDC) //note mtp system.c has this flag check. May be needed he
                                  re
                             7355 ; 159  |                ServiceDCDC();  //Service DCDC converter
                             7356 
P:004D 0BF080 rrrrrr  6  163 7358         jsr     FServiceDCDC
                             7359 
                             7360 ; 160  |
                             7361 ; 161  |        #ifdef BATTERY_CHARGE
                             7362 ; 162  |            // For 3500 Battery Monitoring must be done only during battery charging
                             7363 ; 163  |            // The rest of the time the system operates from USB +5V
                             7364 ; 164  |            // and battery monitoring does not make any sense.
                             7365 ; 165  |            // Also, battery brownout always triggered if sys operates w/ no battery.
                             7366 ; 166  |
                             7367 ; 167  |            //Only charge if we're in high usb current mode. March 11 2005 addition
                             7368 ; 168  |            if(usb_get_current_limit() <= 100) 
                             7369 
P:004F 0BF080 rrrrrr  6  169 7371         jsr     Fusb_get_current_limit
P:0051 45F400 000064  3  172 7372         move    #>100,x1
P:0053 2A0000         2  174 7373         move    #0,a2
P:0054 200065         2  176 7374         cmp     x1,a
P:0055 0AF0A7 rrrrrr  6  182 7375         jgt     L10
P:0057 56F400 000001  3  185 7376         move    #>1,a
                             7377 
                             7378 ; 169  |            {    BatteryChargeDisableCharging(TRUE); // until next stmp bootup
                             7379 
P:0059 0BF080 rrrrrr  6  191 7381         jsr     FBatteryChargeDisableCharging
                             7382 
                             7383 ; 170  |            }
                             7384 
TASKING DSP2410 assembler v1.5r1 Build 138 SN 00100122
                                                                                                                            Page 118

M:ADDR CODE           CYCLES LINE SOURCELINE
P:005B 0AF080 rrrrrr  6  197 7386         jmp     L15
                             7387 
                             7388 ; 171  |            else
                             7389 ; 172  |            {   if(usStatus !=  USB_STATE_CONFIGURED)
                             7390 
P:005D 5FF000 rrrrrr  3  200 7392 L10:    move    y:ss_UserInterfaceTask+1,b
P:005F 2B0000         2  202 7393         move    #0,b2
P:0060 20000B         2  204 7394         tst     b
P:0061 0AF0AA rrrrrr  6  210 7395         jeq     L11
                             7396 
                             7397 ; 173  |                {   if(bNeedToReEnable == FALSE)
                             7398 
P:0063 5EF000 rrrrrr  3  213 7400         move    y:ss_UserInterfaceTask+4,a
P:0065 2A0000         2  215 7401         move    #0,a2
P:0066 200003         2  217 7402         tst     a
P:0067 0AF0A2 rrrrrr  6  223 7403         jne     L15
P:0069 200013         2  225 7404         clr     a   
                             7405 
                             7406 ; 174  |                    {   BatteryChargeDisableCharging(FALSE);
                             7407 
P:006A 0BF080 rrrrrr  6  231 7409         jsr     FBatteryChargeDisableCharging
                             7410 
                             7411 ; 175  |                        bNeedToReEnable = TRUE;
                             7412 
P:006C 44F400 000001  3  234 7414         move    #>1,x0
P:006E 4C7000 rrrrrr  3  237 7417         move    x0,y:ss_UserInterfaceTask+4
                             7420 
                             7421 ; 176  |                    }
                             7422 ; 177  |                }
                             7423 
P:0070 0AF080 rrrrrr  6  243 7425         jmp     L15
                             7426 
                             7427 ; 178  |                else
                             7428 ; 179  |                {   if(bNeedToReEnable == TRUE)
                             7429 
P:0072 5FF000 rrrrrr  3  246 7431 L11:    move    y:ss_UserInterfaceTask+4,b
P:0074 47F400 000001  3  249 7432         move    #>1,y1
P:0076 2B0000         2  251 7433         move    #0,b2
P:0077 20007D         2  253 7434         cmp     y1,b
P:0078 0AF0A2 rrrrrr  6  259 7435         jne     L12
                             7436 
                             7437 ; 180  |                    {   BatteryChargeEnableCharging();
                             7438 
P:007A 0BF080 rrrrrr  6  265 7440         jsr     FBatteryChargeEnableCharging
                             7441 
                             7442 ; 181  |                        bNeedToReEnable = FALSE;
                             7443 
P:007C 250000         2  267 7445         move    #0,x1
P:007D 4D7000 rrrrrr  3  270 7448         move    x1,y:ss_UserInterfaceTask+4
                             7451 
                             7452 ; 182  |                    }               
                             7453 ; 183  |                    BatteryChargeStateMachine();
                             7454 
P:007F 0BF080 rrrrrr  6  276 7456 L12:    jsr     FBatteryChargeStateMachine
                             7457 
                             7458 ; 184  |                }
                             7459 ; 185  |            }            
                             7460 ; 186  |        #endif
                             7461 ; 187  |
                             7462 ; 188  |        #if defined(BATTERY_CHARGE) || defined(DEVICE_3410) || defined(DEVICE_3310)
                             7463 ; 189  |            // I only want to update the Battery icon once per 1/2 second
                             7464 ; 190  |            // but always check and average battery level.
TASKING DSP2410 assembler v1.5r1 Build 138 SN 00100122
                                                                                                                            Page 119

M:ADDR CODE           CYCLES LINE SOURCELINE
                             7465 ; 191  |            CopySize = (unsigned int)(&_lc_u_y_Usbmsc_lcd_battery_OVLY_copy_end-&_lc_u_y_U
                                  sbmsc_lcd_battery_OVLY_copy_start);
                             7466 
P:0081 5EF000 rrrrrr  3  279 7468 L15:    move    y:ss_UserInterfaceTask+5,a
                             7470 
                             7471 ; 192  |                
                             7472 ; 193  |            CopyCodeIntoBootmanagerArea((_Y WORD *)&_lc_u_y_Usbmsc_lcd_battery_OVLY_copy_s
                                  tart, 
                             7473 ; 194  |                                        (_P WORD * _P)&_lc_u_p_usbmsc_lcd_battery_start, C
                                  opySize);
                             7474 
P:0083 60F400 rrrrrr  3  282 7476         move    #F_lc_u_y_Usbmsc_lcd_battery_OVLY_copy_start,r0
P:0085 64F400 rrrrrr  3  285 7477         move    #F_lc_u_p_usbmsc_lcd_battery_start,r4
P:0087 6C7000 rrrrrr  3  288 7478         move    r4,y:ss_UserInterfaceTask+7
P:0089 0BF080 rrrrrr  6  294 7479         jsr     FCopyCodeIntoBootmanagerArea
                             7481 
                             7482 ; 195  |  
                             7483 ; 196  |            USBLCDCheckBatteryLevel();
                             7484 
P:008B 0BF080 rrrrrr  6  300 7486         jsr     FUSBLCDCheckBatteryLevel
                             7487 
                             7488 ; 197  |            if (iDelay-- <= 0)
                             7489 
P:008D 5EF000 rrrrrr  3  303 7491         move    y:ss_UserInterfaceTask+3,a
P:008F 200009         2  305 7492         tfr     a,b
P:0090 46F400 000001  3  308 7497         move    #>1,y0
P:0092 200054         2  310 7498         sub     y0,a
P:0093 5C7000 rrrrrr  3  313 7501         move    a1,y:ss_UserInterfaceTask+3
P:0095 20000B         2  315 7504         tst     b
P:0096 0AF0A7 rrrrrr  6  321 7505         jgt     L16
                             7506 
                             7507 ; 198  |            {
                             7508 ; 199  |                USBLCDDisplayBatteryLevel();
                             7509 
P:0098 0BF080 rrrrrr  6  327 7511         jsr     FUSBLCDDisplayBatteryLevel
                             7512 
                             7513 ; 200  |                  //On 35xx (has charger), always connected to usb 5v, so never batt brown
                                   out
                             7514 ; 201  |                  #if defined(DEVICE_3410) || defined(DEVICE_3310)
                             7515 ; 202  |                USBLCDCheckBrownout();
                             7516 ; 203  |                  #endif
                             7517 ; 204  |                iDelay = HALF_SEC_UPDATE_RATE;
                             7518 
P:009A 290500         2  329 7520         move    #5,b0
P:009B 597000 rrrrrr  3  332 7523         move    b0,y:ss_UserInterfaceTask+3
                             7526 
                             7527 ; 205  |            }
                             7528 ; 206  |
                             7529 ; 207  |            CopySize = (unsigned int)(&_lc_u_y_Usbmsc_lcd_OVLY_copy_end-&_lc_u_y_Usbmsc_lc
                                  d_OVLY_copy_start);
                             7530 
P:009D 5EF000 rrrrrr  3  335 7532 L16:    move    y:ss_UserInterfaceTask+6,a
                             7534 
                             7535 ; 208  |                
                             7536 ; 209  |            CopyCodeIntoBootmanagerArea((_Y WORD *)&_lc_u_y_Usbmsc_lcd_OVLY_copy_start, 
                             7537 ; 210  |                                        (_P WORD * _P)&_lc_u_p_usbmsc_lcd_battery_start, C
                                  opySize);
                             7538 
P:009F 60F400 rrrrrr  3  338 7540         move    #F_lc_u_y_Usbmsc_lcd_OVLY_copy_start,r0
P:00A1 6CF000 rrrrrr  3  341 7541         move    y:ss_UserInterfaceTask+7,r4
P:00A3 0BF080 rrrrrr  6  347 7542         jsr     FCopyCodeIntoBootmanagerArea
                             7544 
TASKING DSP2410 assembler v1.5r1 Build 138 SN 00100122
                                                                                                                            Page 120

M:ADDR CODE           CYCLES LINE SOURCELINE
                             7545 ; 211  |  
                             7546 ; 212  |#endif
                             7547 ; 213  |            
                             7548 ; 214  |
                             7549 ; 215  |            if(State!= g_wActivityState )
                             7550 
P:00A5 5EF000 rrrrrr  3  350 7552         move    y:Fg_wActivityState,a
P:00A7 5FF000 rrrrrr  3  353 7553         move    y:ss_UserInterfaceTask+2,b
P:00A9 2A0000         2  355 7554         move    #0,a2
P:00AA 2B0000         2  357 7555         move    #0,b2
P:00AB 20000D         2  359 7556         cmp     a,b
P:00AC 0AF0AA rrrrrr  6  365 7557         jeq     L7
                             7558 
                             7559 ; 216  |            {
                             7560 ; 217  |                State = g_wActivityState;
                             7561 
P:00AE 5EF000 rrrrrr  3  368 7563         move    y:Fg_wActivityState,a
                             7566 
                             7567 ; 218  |                switch(State)
                             7568 
P:00B0 5C7000 rrrrrr  3  371 7570         move    a1,y:ss_UserInterfaceTask+2
P:00B2 57F400 000001  3  374 7571         move    #>1,b
P:00B4 2A0000         2  376 7572         move    #0,a2
P:00B5 57F405 000002  3  379 7573         cmp     b,a     #>2,b
P:00B7 0AF0AA rrrrrr  6  385 7574         jeq     L18
P:00B9 200005         2  387 7575         cmp     b,a
P:00BA 0AF0AA rrrrrr  6  393 7576         jeq     L19
P:00BC 200003         2  395 7577         tst     a
P:00BD 0AF0A2 rrrrrr  6  401 7578         jne     L20
                             7579 
                             7580 ; 219  |                {
                             7581 ; 220  |                case SCSI_IDLE:
                             7582 ; 221  |                    USBLCDIdle();
                             7583 
P:00BF 0BF080 rrrrrr  6  407 7585         jsr     FUSBLCDIdle
                             7586 
                             7587 ; 222  |                    break;
                             7588 
P:00C1 0AF080 rrrrrr  6  413 7590         jmp     L6
                             7591 
                             7592 ; 223  |                case SCSI_READING:
                             7593 ; 224  |                    USBLCDReading();
                             7594 
P:00C3 0BF080 rrrrrr  6  419 7596 L18:    jsr     FUSBLCDReading
                             7597 
                             7598 ; 225  |                    break;
                             7599 
P:00C5 0AF080 rrrrrr  6  425 7601         jmp     L5
                             7602 
                             7603 ; 226  |                case SCSI_WRITING:
                             7604 ; 227  |                    USBLCDWriting();
                             7605 
P:00C7 0BF080 rrrrrr  6  431 7607 L19:    jsr     FUSBLCDWriting
                             7608 
                             7609 ; 228  |                    break;
                             7610 
P:00C9 0AF080 rrrrrr  6  437 7612         jmp     L4
                             7613 
                             7614 ; 229  |                default :
                             7615 ; 230  |                    USBLCDIdle();
                             7616 
P:00CB 0BF080 rrrrrr  6  443 7618 L20:    jsr     FUSBLCDIdle
TASKING DSP2410 assembler v1.5r1 Build 138 SN 00100122
                                                                                                                            Page 121

M:ADDR CODE           CYCLES LINE SOURCELINE
P:00CD 0AF080 rrrrrr  6  449 7620         jmp     L3
                             7621 
                             7622 ; 231  |                }
                             7623 ; 232  |            }
                             7624 ; 233  |            
                             7625 ; 234  |        }
                             7626 ; 235  |    }
                             7627 ; 236  |    
                             7628 ; 237  |}
                             7629 
P:00CF 05F07C rrrrrr  4  453 7631         movec   y:ss_UserInterfaceTask,ssh
P:00D1 000000         2  455 7633         nop
P:00D2 00000C         4  459 7634         rts
                             7638 
Y:0000                       7639         org     y,".yovlsystem@UserInterfaceTask",overlay:
                             7640 ss_UserInterfaceTask:
Y:0000                       7641         ds      9
   |   RESERVED                   
Y:0008
                             7642 
P:00D3                       7643         org     p,".ptextsystem":
                             7645 
                             7646 ; 238  |#endif // ifndef USB_THROUGHPUT
                             7647 ; 239  |
                             7648 ; 240  |////////////////////////////////////////////////////////////////////////////////
                             7649 ; 241  |#ifdef USB_THROUGHPUT
                             7650 ; 242  |// Function Description: 
                             7651 ; 243  |// Inputs:  no parameters
                             7652 ; 244  |// Returns: no register returns
                             7653 ; 245  |// Notes:   
                             7654 ; 246  |void UserInterfaceTask(void)
                             7655 ; 247  |{
                             7656 ; 248  |    int iTransferRate;
                             7657 ; 249  |    WORD State=SCSI_IDLE;
                             7658 ; 250  |    //Message Msg;
                             7659 ; 251  |    int iDelay = HALF_SEC_UPDATE_RATE;
                             7660 ; 252  |        BOOL bNeedToReEnable = FALSE;
                             7661 ; 253  |    USHORT usStatus;
                             7662 ; 254  |
                             7663 ; 255  |    SysPostMessage(5,LCD_CLEAR_RANGE,0,0,98,64);
                             7664 ; 256  |    SysPostMessage(5,LCD_PRINT_RANGE_RSRC,0,0,ReadyImage);
                             7665 ; 257  |    SysWait(250);
                             7666 ; 258  |    while(1)
                             7667 ; 259  |    {
                             7668 ; 260  |#ifdef BATTERY_CHARGE
                             7669 ; 261  |        //Only charge if we're in high usb current mode. March 11 2005 addition
                             7670 ; 262  |        if(usb_get_current_limit() <= 100) 
                             7671 ; 263  |        {    BatteryChargeDisableCharging(TRUE); // until next stmp bootup
                             7672 ; 264  |        }
                             7673 ; 265  |        else
                             7674 ; 266  |        {   usb_device_get_status(USB_STATUS, &usStatus);
                             7675 ; 267  |
                             7676 ; 268  |                if(usStatus !=  USB_STATE_CONFIGURED)
                             7677 ; 269  |                {
                             7678 ; 270  |                        if(bNeedToReEnable == FALSE)
                             7679 ; 271  |                        {
                             7680 ; 272  |                                BatteryChargeDisableCharging(FALSE);
                             7681 ; 273  |                                bNeedToReEnable = TRUE;
                             7682 ; 274  |                        }
                             7683 ; 275  |                }
                             7684 ; 276  |            else //Only charge if we're in high usb current mode. March 11 2005 additional
                                   check
TASKING DSP2410 assembler v1.5r1 Build 138 SN 00100122
                                                                                                                            Page 122

M:ADDR CODE           CYCLES LINE SOURCELINE
                             7685 ; 277  |                {
                             7686 ; 278  |                        if(bNeedToReEnable == TRUE)
                             7687 ; 279  |                        {
                             7688 ; 280  |                            BatteryChargeEnableCharging();
                             7689 ; 281  |                                bNeedToReEnable = FALSE;
                             7690 ; 282  |                        }       
                             7691 ; 283  |                BatteryChargeStateMachine();                
                             7692 ; 284  |             }
                             7693 ; 285  |                }
                             7694 ; 286  |#endif
                             7695 ; 287  |        SysWait(UPDATE_RATE);
                             7696 ; 288  |        if(State!= g_wActivityState )
                             7697 ; 289  |        {
                             7698 ; 290  |            State = g_wActivityState;
                             7699 ; 291  |            switch(State)
                             7700 ; 292  |            {
                             7701 ; 293  |            case SCSI_IDLE:
                             7702 ; 294  |                SysPostMessage(5,LCD_PRINT_RANGE_RSRC,0,0,ReadyImage);
                             7703 ; 295  |                break;
                             7704 ; 296  |            case SCSI_READING:
                             7705 ; 297  |                SysPostMessage(5,LCD_PRINT_RANGE_RSRC,0,0,ReadingImage);
                             7706 ; 298  |                break;
                             7707 ; 299  |            case SCSI_WRITING:
                             7708 ; 300  |                SysPostMessage(5,LCD_PRINT_RANGE_RSRC,0,0,WritingImage);
                             7709 ; 301  |                break;
                             7710 ; 302  |            }
                             7711 ; 303  |        }
                             7712 ; 304  |        
                             7713 ; 305  |        {   USHORT usStatus;  // fixes stmp 9226 and 8777 (0 or 2 usb unplug tries out of 
                                  20 would not 
                             7714 ; 306  |                              // boot player & mtp was still running due to rare irq loss)
                                  
                             7715 ; 307  |            SysDelayMs(200);
                             7716 ; 308  |            usb_device_get_status(USB_STATUS_CONNECTION,&usStatus); //we could just check 
                                  the usb 5v bit instead of calling this.
                             7717 ; 309  |            if( usStatus == USB_DISCONNECTED )
                             7718 ; 310  |            {  
                             7719 ; 311  |                SysDelay(200); // msec 
                             7720 ; 312  |                SystemShutdown();// we could use pragma asm to jump to the missed isr inst
                                  ead which resets also.
                             7721 ; 313  |                SystemReset();
                             7722 ; 314  |            }
                             7723 ; 315  |        }
                             7724 ; 316  |
                             7725 ; 317  |        iTransferRate = g_lBulkInBytes / (1+g_lLastBulkInTime-g_lFirstBulkInTime);
                             7726 ; 318  |        SysPostMessage(7,LCD_PRINT_NUMBER,0,16,iTransferRate,5,' ');
                             7727 ; 319  |        iTransferRate = g_lBulkOutBytes / (1+g_lLastBulkOutTime-g_lFirstBulkOutTime);
                             7728 ; 320  |        SysPostMessage(7,LCD_PRINT_NUMBER,0,24,iTransferRate,5,' ');
                             7729 ; 321  |
                             7730 ; 322  |        SysWait(0);
                             7731 ; 323  |        SysPostMessage(7,LCD_PRINT_NUMBER, 0,40,g_iCommonCommands,5,' ');
                             7732 ; 324  |        SysPostMessage(7,LCD_PRINT_NUMBER,32,40,g_iUpdaterCommands,5,' ');
                             7733 ; 325  |        SysPostMessage(7,LCD_PRINT_NUMBER,64,40,g_iUnknownCommands,5,' ');
                             7734 ; 326  |    }
                             7735 ; 327  |}
                             7736 ; 328  |#endif
                             7737 
                             7778 
                             7782 
Y:0000                       7783         org     y,".ybsssystem",bss:
                             7784 Fg_wUserScratchY:
TASKING DSP2410 assembler v1.5r1 Build 138 SN 00100122
                                                                                                                            Page 123

M:ADDR CODE           CYCLES LINE SOURCELINE
Y:0000                       7785         ds      512
   |   RESERVED                   
Y:01FF
                             7788 
X:0000                       7789         org     x,".xbsssystem",bss:
                             7790 Fg_wUserScratchX:
X:0000                       7791         ds      512
   |   RESERVED                   
X:01FF
                             7799 
Y:0000                       7800         org     y,".ybsssystem.g_UserInterfaceMessageQueue",bss:
                             7801         baddr   m,32
                             7802 Fg_UserInterfaceMessageQueue:
Y:0000                       7803         ds      32
   |   RESERVED                   
Y:001F
                             7809 
Y:0200                       7810         org     y,".ybsssystem",bss:
                             7811 Fg_Sync_UserScratchY:
Y:0200 RESERVED              7812         ds      1
Y:0200
                             7816 Fg_UserInterfaceStack:
Y:0201                       7817         ds      100
   |   RESERVED                   
Y:0264
                             7820 
                             7821         extern  FBatteryChargeDisableCharging, FBatteryChargeEnableCharging
                             7822         extern  FBatteryChargeStateMachine, FCopyCodeIntoBootmanagerArea
                             7823         extern  FInit5VSense, FServiceDCDC, FSysPostMessage, FSysWait
                             7824         extern  FUSBLCDCheckBatteryLevel, FUSBLCDCheckForTransfers
                             7825         extern  FUSBLCDDisplayBatteryLevel, FUSBLCDDisplayInit
                             7826         extern  FUSBLCDIdle, FUSBLCDReading, FUSBLCDWriting
                             7827         extern  p:F_lc_u_p_usbmsc_lcd_battery_start
                             7828         extern  y:F_lc_u_y_Usbmsc_lcd_OVLY_copy_end
                             7829         extern  y:F_lc_u_y_Usbmsc_lcd_OVLY_copy_start
                             7830         extern  y:F_lc_u_y_Usbmsc_lcd_battery_OVLY_copy_end
                             7831         extern  y:F_lc_u_y_Usbmsc_lcd_battery_OVLY_copy_start
                             7832         extern  y:Fg_DeviceInsertion, y:Fg_DisplayTaskEntry
                             7833         extern  y:Fg_DisplayTaskQueueDescriptor, y:Fg_USBInsertionMonitor
                             7834         extern  y:Fg_USBMSCHandler0, Fusb_device_get_status
                             7835         extern  Fusb_get_current_limit
                             7836 
                             7837         global  FUserInterfaceTask, FgMscMtpEnable, Fg_RoutingTable
                             7838         global  Fg_Sync_UserScratchY, Fg_TaskList
                             7839         global  Fg_UserInterfaceMessageQueue
                             7840         global  Fg_UserInterfaceQueueDescriptor, Fg_UserInterfaceStack
                             7841         global  Fg_UserInterfaceTaskEntry, Fg_bShutdown, Fg_wActivityState
                             7842         global  Fg_wActivityStateMultiWrite, Fg_wUserScratchX
                             7843         global  Fg_wUserScratchY
                             7844 
                             7845         local   L3, L4, L5, L6, L7, L8, L9, L10, L11, L12, L15, L16, L18
                             7846         local   L19, L20, ss_UserInterfaceTask
                             7847 
                             7848         calls   "UserInterfaceTask", "BatteryChargeDisableCharging"
                             7849         calls   "UserInterfaceTask", "BatteryChargeEnableCharging"
                             7850         calls   "UserInterfaceTask", "BatteryChargeStateMachine"
                             7851         calls   "UserInterfaceTask", "CopyCodeIntoBootmanagerArea"
                             7852         calls   "UserInterfaceTask", "Init5VSense", "ServiceDCDC"
                             7853         calls   "UserInterfaceTask", "SysPostMessage", "SysWait"
                             7854         calls   "UserInterfaceTask", "USBLCDCheckBatteryLevel"
                             7855         calls   "UserInterfaceTask", "USBLCDCheckForTransfers"
                             7856         calls   "UserInterfaceTask", "USBLCDDisplayBatteryLevel"
TASKING DSP2410 assembler v1.5r1 Build 138 SN 00100122
                                                                                                                            Page 124

M:ADDR CODE           CYCLES LINE SOURCELINE
                             7857         calls   "UserInterfaceTask", "USBLCDDisplayInit", "USBLCDIdle"
                             7858         calls   "UserInterfaceTask", "USBLCDReading", "USBLCDWriting"
                             7859         calls   "UserInterfaceTask", "usb_device_get_status"
                             7860         calls   "UserInterfaceTask", "usb_get_current_limit"
                             7861 
