TASKING DSP2410 assembler v1.5r1 Build 138 SN 00100122
                                                                                                                                                                                                                                                       Page   1
C:\STMP3XXX_SDK_FIRMWARE_320_finalfix\Projects\SDK\lcdexample\usbmsc\Make\cc8706bb.src
M:ADDR CODE           CYCLES LINE SOURCELINE
                                1 ; TASKING DSP2410 C compiler v1.5r1 Build 208 SN 00100122
                                2 ; options: -OG -si -w68 -w66 -I..\output_3500\include
                                3 ;          -I..\..\..\..\..\Projects\sdk\lcdexample\usbmsc -I -I..\..
                                4 ;          -I..\..\..\..\..\inc -I..\..\..\..\..\System\Common
                                5 ;          -I..\..\..\..\..\System\Common\symbols -I
                                6 ;          -I..\..\..\..\..\Algorithms\DRM\janus\src\h
                                7 ;          -I..\..\..\..\..\devicedriver\media\ddildl
                                8 ;          -I..\..\..\..\..\devicedriver\media\ddildl\include
                                9 ;          -I..\..\..\..\..\devicedriver\media\MediaTypeMMC\DDI\include
                               10 ;          -I..\..\..\..\..\devicedriver\media\ddildl\include
                               11 ;          -I..\..\..\..\..\devicedriver\media\MediaTypeMMC\DDI\include
                               12 ;          -I..\..\..\..\..\devicedriver\media\MediaTypeMMC\DDI\Media
                               13 ;          -I..\..\..\..\..\devicedriver\media\MediaTypeMMC\HAL\include
                               14 ;          -I..\..\..\..\..\devicedriver\media\MediaTypeRAM\include
                               15 ;          -I..\..\..\..\..\devicedriver\media\MediaTypeRAM\DDI\DataDrive\include
                               16 ;          -I..\..\..\..\..\devicedriver\media\MediaTypeRAM\DDI\include
                               17 ;          -I..\..\..\..\..\devicedriver\media\MediaTypeRAM\HAL\include
                               18 ;          -I..\..\..\..\..\devicedriver\media\MediaTypeRAM\DDI\DataDrive
                               19 ;          -I..\..\..\..\..\devicedriver\media\MediaTypeRAM\include
                               20 ;          -I..\..\..\..\..\devicedriver\media\MediaTypeRAM\DDI\SystemDrive\include
                               21 ;          -I..\..\..\..\..\devicedriver\media\MediaTypeRAM\DDI\include
                               22 ;          -I..\..\..\..\..\devicedriver\media\MediaTypeRAM\HAL\include
                               23 ;          -I..\..\..\..\..\devicedriver\media\MediaTypeRAM\DDI\SystemDrive
                               24 ;          -I..\..\..\..\..\devicedriver\media\MediaTypeRAM\include
                               25 ;          -I..\..\..\..\..\devicedriver\media\MediaTypeRAM\DDI\Media\include
                               26 ;          -I..\..\..\..\..\devicedriver\media\MediaTypeRAM\DDI\include
                               27 ;          -I..\..\..\..\..\devicedriver\media\MediaTypeRAM\HAL\include
                               28 ;          -I..\..\..\..\..\devicedriver\media\MediaTypeRAM\DDI\Media
                               29 ;          -I..\..\..\..\..\devicedriver\media\MediaTypeRAM\include
                               30 ;          -I..\..\..\..\..\devicedriver\media\MediaTypeRAM\DDI\include
                               31 ;          -I..\..\..\..\..\devicedriver\media\MediaTypeRAM\HAL\include
                               32 ;          -I..\..\..\..\..\devicedriver\media\MediaTypeNAND\include
                               33 ;          -I..\..\..\..\..\devicedriver\media\MediaTypeNAND\DDI\DataDrive\include
                               34 ;          -I..\..\..\..\..\devicedriver\media\MediaTypeNAND\DDI\include
                               35 ;          -I..\..\..\..\..\devicedriver\media\MediaTypeNAND\HAL\include
                               36 ;          -I..\..\..\..\..\devicedriver\media\MediaTypeNAND\DDI\DataDrive
                               37 ;          -I..\..\..\..\..\devicedriver\media\ddildl\include -I
                               38 ;          -I..\..\..\..\..\FileSystem\Fat32\cmp\cmp_stdtype
                               39 ;          -I..\..\..\..\..\FileSystem\Fat32\cmp\cmp_debug
                               40 ;          -I..\..\..\..\..\FileSystem\Fat32\cmp\cmp_file_system
                               41 ;          -I..\..\..\..\..\DeviceDriver\Media\cmp\cmp_media_nand
                               42 ;          -I..\..\..\..\..\devicedriver\media\MediaTypeNAND\include
                               43 ;          -I..\..\..\..\..\devicedriver\media\MediaTypeNAND\DDI\Common\include
                               44 ;          -I..\..\..\..\..\devicedriver\media\MediaTypeNAND\DDI\include
                               45 ;          -I..\..\..\..\..\devicedriver\media\MediaTypeNAND\HAL\include
                               46 ;          -I..\..\..\..\..\devicedriver\media\MediaTypeNAND\DDI\Common
                               47 ;          -I..\..\..\..\..\devicedriver\media\MediaTypeNAND\include
                               48 ;          -I..\..\..\..\..\devicedriver\media\MediaTypeNAND\DDI\SystemDrive\include
                               49 ;          -I..\..\..\..\..\devicedriver\media\MediaTypeNAND\DDI\include
                               50 ;          -I..\..\..\..\..\devicedriver\media\MediaTypeNAND\HAL\include
                               51 ;          -I..\..\..\..\..\devicedriver\media\MediaTypeNAND\DDI\SystemDrive
                               52 ;          -I..\..\..\..\..\devicedriver\media\MediaTypeNAND\include
                               53 ;          -I..\..\..\..\..\devicedriver\media\MediaTypeNAND\DDI\Media\include
                               54 ;          -I..\..\..\..\..\devicedriver\media\MediaTypeNAND\DDI\include
                               55 ;          -I..\..\..\..\..\devicedriver\media\MediaTypeNAND\HAL\include
                               56 ;          -I..\..\..\..\..\devicedriver\media\MediaTypeNAND\DDI\Media
                               57 ;          -I..\..\..\..\..\devicedriver\media\include
                               58 ;          -I..\..\..\..\..\devicedriver\media\ddildl
                               59 ;          -I..\..\..\..\..\devicedriver\media\ddildl\include
                               60 ;          -I..\..\..\..\..\devicedriver\media\MediaTypeNAND\DDI\Common\include
                               61 ;          -I..\..\..\..\..\devicedriver\media\MediaTypeNAND\DDI\include
                               62 ;          -I..\..\..\..\..\DeviceDriver\Media\MediaTypeNAND\HAL
                               63 ;          -I..\..\..\..\..\DeviceDriver\Media\MediaTypeNAND\HAL\include
                               64 ;          -I..\..\..\..\..\DeviceDriver\Media\include
                               65 ;          -I..\..\..\..\..\DeviceDriver\Media\PortHIL\GPFlash\include
                               66 ;          -I..\..\..\..\..\DeviceDriver\Media\PortHIL\GPFlash
                               67 ;          -I..\..\..\..\..\system\common\resourcemanager -I..\..\..\..\..\inc
                               68 ;          -I..\..\..\..\..\DeviceDriver\Media\usb\Ch9
                               69 ;          -I..\..\..\..\..\DeviceDriver\Media\scsi
                               70 ;          -I..\..\..\..\..\DeviceDriver\Media\usbmsc
                               71 ;          -I..\..\..\..\..\DeviceDriver\Media\mtp
                               72 ;          -I..\..\..\..\..\System\Common\updater
                               73 ;          -I..\..\..\..\..\libsource\sysserialnumber -DALL -DD3500 -DMMC
                               74 ;          -DLIION -DTUNER_STFM1000 -DSTFM1000_LCD=TRUE -DDCDC_POWER_TRANSFER
                               75 ;          -DBACKLIGHT -DWMAAPI_NO_DRM -DREVB_ENGR_BD -DSED15XX_LCD -DFAT16
                               76 ;          -DDEVICE_3500 -DENGR_BD -DUSBMSC_BUILD -DBATTERY_TYPE_LI_ION
                               77 ;          -DBATTERY_CHARGE -DUSE_PLAYLIST3_HOST -DASCII_ONLY -DRETAIL
                               78 ;          -DDEVICE_3500 -DMMC -Dk_opt_performance_enhancement
                               79 ;          -I..\..\..\..\..\devicedriver\display
                               80 ;          -I..\..\..\..\..\System\MsgModules\Hardware\Display -g -O2 -R -Cs
                               81 ;          -MmyL
                               82 
                               90 
                               91 ;usbmscproject.c:
                               92 ; 1    |////////////////////////////////////////////////////////////////////////////////
                               93 ; 2    |// Copyright(C) SigmaTel, Inc. 2002
                               94 ; 3    |//
                               95 ; 4    |// Filename: usbmscproject.c
                               96 ; 5    |// Description: Project-specific USB MSC
                               97 ; 6    |////////////////////////////////////////////////////////////////////////////////
                               98 ; 7    |
                               99 ; 8    |////////////////////////////////////////////////////////////////////////////////
                              100 ; 9    |//   Includes and external references
                              101 ; 10   |////////////////////////////////////////////////////////////////////////////////
                              102 ; 11   |
                              103 ; 12   |#include "types.h"
                              104 
                              106 
                              107 ; 1    |////////////////////////////////////////////////////////////////////////////////
                              108 ; 2    |// Copyright(C) SigmaTel, Inc. 2000-2004
                              109 ; 3    |//
                              110 ; 4    |// Filename: types.h
                              111 ; 5    |// Description: Standard data types
                              112 ; 6    |////////////////////////////////////////////////////////////////////////////////
                              113 ; 7    |
                              114 ; 8    |#ifndef _TYPES_H
                              115 ; 9    |#define _TYPES_H
                              116 ; 10   |
                              117 ; 11   |// TODO:  move this outta here!
                              118 ; 12   |#if !defined(NOERROR)
                              119 ; 13   |#define NOERROR 0
                              120 ; 14   |#define SUCCESS 0
                              121 ; 15   |#endif 
                              122 ; 16   |#if !defined(SUCCESS)
                              123 ; 17   |#define SUCCESS  0
                              124 ; 18   |#endif
                              125 ; 19   |#if !defined(ERROR)
                              126 ; 20   |#define ERROR   -1
                              127 ; 21   |#endif
                              128 ; 22   |#if !defined(FALSE)
                              129 ; 23   |#define FALSE 0
                              130 ; 24   |#endif
                              131 ; 25   |#if !defined(TRUE)
                              132 ; 26   |#define TRUE  1
                              133 ; 27   |#endif
                              134 ; 28   |
                              135 ; 29   |#if !defined(NULL)
                              136 ; 30   |#define NULL 0
                              137 ; 31   |#endif
                              138 ; 32   |
                              139 ; 33   |#define MAX_INT     0x7FFFFF
                              140 ; 34   |#define MAX_LONG    0x7FFFFFffffff
                              141 ; 35   |        // max positive unsigned long value: -1 == 0xFFFFFFffffff
                              142 ; 36   |#define MAX_ULONG   (-1) 
                              143 ; 37   |
                              144 ; 38   |#define WORD_SIZE   24              // word size in bits
                              145 ; 39   |#define BYTES_PER_WORD 3            // 8 bit bytes
                              146 ; 40   |
                              147 ; 41   |
                              148 ; 42   |#define BYTE    unsigned char       // btVarName
                              149 ; 43   |#define CHAR    signed char         // cVarName
                              150 ; 44   |#define USHORT  unsigned short      // usVarName
                              151 ; 45   |#define SHORT   unsigned short      // sVarName
                              152 ; 46   |#define WORD    unsigned int        // wVarName
                              153 ; 47   |#define INT     signed int          // iVarName
                              154 ; 48   |#define DWORD   unsigned long       // dwVarName
                              155 ; 49   |#define LONG    signed long         // lVarName
                              156 ; 50   |#define BOOL    unsigned int        // bVarName
                              157 ; 51   |#define FRACT   _fract              // frVarName
                              158 ; 52   |#define LFRACT  long _fract         // lfrVarName
                              159 ; 53   |#define CIRC    _circ               // cp<type prefix>VarName (see below)
                              160 ; 54   |#define FLOAT   float               // fVarName
                              161 ; 55   |#define DBL     double              // dVarName
                              162 ; 56   |#define ENUM    enum                // eVarName
                              163 ; 57   |#define CMX     _complex            // cmxVarName
                              164 ; 58   |typedef WORD UCS3;                   // 
                              165 ; 59   |
                              166 ; 60   |#define UINT16  unsigned short
                              167 ; 61   |#define UINT8   unsigned char   
                              168 ; 62   |#define UINT32  unsigned long
                              169 ; 63   |#define UINT64  unsigned long   // need to figure out how to do 64 bit values.  Or port exisiting code to only use 48 bit
                              170 ; 64   |#define INT64   unsigned long   // need to figure out how to do 64 bit values.  Or port exisiting code to only use 48 bit
                              171 ; 65   |#define WCHAR   UINT16
                              172 ; 66   |
                              173 ; 67   |//UINT128 is 16 bytes or 6 words
                              174 ; 68   |typedef struct UINT128_3500 {   
                              175 ; 69   |    int val[6];     
                              176 ; 70   |} UINT128_3500;
                              177 ; 71   |
                              178 ; 72   |#define UINT128   UINT128_3500
                              179 ; 73   |
                              180 ; 74   |// Little endian word packed byte strings:   
                              181 ; 75   |//      _packed BYTE bTextVarName[]="a string";  bText is a packed byte string prefix
                              182 ; 76   |// Convert to big endian words by reordering bytes from high to low using swizzle.
                              183 ; 77   |// Little endian word packed byte strings:   
                              184 ; 78   |//      _packed BYTE bTextVarName[]="a string";  bText is a packed byte string prefix
                              185 ; 79   |// Convert to big endian words by reordering bytes from high to low using swizzle.
                              186 ; 80   |
                              187 ; 81   |// Declare Memory Spaces To Use When Coding
                              188 ; 82   |// A. Sector Buffers
                              189 ; 83   |#define SECTOR_BUFFER_MEM_X _X
                              190 ; 84   |#define SECTOR_BUFFER_MEM_Y _Y
                              191 ; 85   |#define SECTOR_BUFFER_MEM SECTOR_BUFFER_MEM_X
                              192 ; 86   |typedef WORD SECTOR_BUFFER_MEM SECTOR_BUFFER;
                              193 
                              195 
                              196 ; 87   |typedef SECTOR_BUFFER * P_SECTOR_BUFFER;
                              197 ; 88   |// B. Media DDI Memory
                              198 ; 89   |#define MEDIA_DDI_MEM _Y
                              199 ; 90   |
                              200 ; 91   |
                              201 ; 92   |
                              202 ; 93   |// Pointers to linear structures are labeled as: p<type prefix>VarName
                              203 ; 94   |// Examples of circular pointers:
                              204 ; 95   |//    INT CIRC cpiVarName
                              205 ; 96   |//    DWORD CIRC cpdwVarName
                              206 ; 97   |
                              207 ; 98   |#define RETCODE INT                 // rcVarName
                              208 ; 99   |
                              209 ; 100  |// generic bitfield structure
                              210 ; 101  |struct Bitfield {
                              211 ; 102  |    unsigned int B0  :1;
                              212 ; 103  |    unsigned int B1  :1;
                              213 ; 104  |    unsigned int B2  :1;
                              214 ; 105  |    unsigned int B3  :1;
                              215 ; 106  |    unsigned int B4  :1;
                              216 ; 107  |    unsigned int B5  :1;
                              217 ; 108  |    unsigned int B6  :1;
                              218 ; 109  |    unsigned int B7  :1;
                              219 ; 110  |    unsigned int B8  :1;
                              220 ; 111  |    unsigned int B9  :1;
                              221 ; 112  |    unsigned int B10 :1;
                              222 ; 113  |    unsigned int B11 :1;
                              223 ; 114  |    unsigned int B12 :1;
                              224 ; 115  |    unsigned int B13 :1;
                              225 ; 116  |    unsigned int B14 :1;
                              226 ; 117  |    unsigned int B15 :1;
                              227 ; 118  |    unsigned int B16 :1;
                              228 ; 119  |    unsigned int B17 :1;
                              229 ; 120  |    unsigned int B18 :1;
                              230 ; 121  |    unsigned int B19 :1;
                              231 ; 122  |    unsigned int B20 :1;
                              232 ; 123  |    unsigned int B21 :1;
                              233 ; 124  |    unsigned int B22 :1;
                              234 ; 125  |    unsigned int B23 :1;
                              235 ; 126  |};
                              236 ; 127  |
                              237 ; 128  |union BitInt {
                              238 ; 129  |        struct Bitfield B;
                              239 ; 130  |        int        I;
                              240 ; 131  |};
                              241 ; 132  |
                              242 ; 133  |#define MAX_MSG_LENGTH 10
                              243 ; 134  |struct CMessage
                              244 ; 135  |{
                              245 ; 136  |        unsigned int m_uLength;
                              246 ; 137  |        unsigned int m_uMsg[MAX_MSG_LENGTH];
                              247 ; 138  |};
                              248 ; 139  |
                              249 ; 140  |typedef struct {
                              250 ; 141  |    WORD m_wLength;
                              251 ; 142  |    WORD m_wMessage;
                              252 ; 143  |    WORD m_wParams[MAX_MSG_LENGTH];
                              253 ; 144  |} Message;
                              254 ; 145  |
                              255 ; 146  |struct MessageQueueDescriptor
                              256 ; 147  |{
                              257 ; 148  |        int *m_pBase;
                              258 ; 149  |        int m_iModulo;
                              259 ; 150  |        int m_iSize;
                              260 ; 151  |        int *m_pHead;
TASKING DSP2410 assembler v1.5r1 Build 138 SN 00100122
                                                                                                                                                                                                                                                       Page   2

M:ADDR CODE           CYCLES LINE SOURCELINE
                              261 ; 152  |        int *m_pTail;
                              262 ; 153  |};
                              263 ; 154  |
                              264 ; 155  |struct ModuleEntry
                              265 ; 156  |{
                              266 ; 157  |    int m_iSignaledEventMask;
                              267 ; 158  |    int m_iWaitEventMask;
                              268 ; 159  |    int m_iResourceOfCode;
                              269 ; 160  |    struct MessageQueueDescriptor *m_pMessageQueue;
                              270 ; 161  |    int _asmfunc (*m_pProcessEntryPoint)(union WaitMask Signals,struct MessageQueueDescriptor *);
                              271 ; 162  |    int _asmfunc (*m_pInitFunction)(struct MessageQueueDescriptor *);
                              272 ; 163  |    int m_uTimeOutHigh;
                              273 ; 164  |    int m_uTimeOutLow;
                              274 ; 165  |    int _asmfunc (*m_pBackgroundFunction)(struct MessageQueueDescriptor *);
                              275 ; 166  |};
                              276 ; 167  |
                              277 ; 168  |union WaitMask{
                              278 ; 169  |    struct B{
                              279 ; 170  |        unsigned int m_bNone     :1;
                              280 ; 171  |        unsigned int m_bMessage  :1;
                              281 ; 172  |        unsigned int m_bTimer    :1;
                              282 ; 173  |        unsigned int m_bButton   :1;
                              283 ; 174  |    } B;
                              284 ; 175  |    int I;
                              285 ; 176  |} ;
                              286 ; 177  |
                              287 ; 178  |
                              288 ; 179  |struct Button {
                              289 ; 180  |        WORD wButtonEvent;
                              290 ; 181  |        WORD wUnused[MAX_MSG_LENGTH];   
                              291 ; 182  |};
                              292 ; 183  |
                              293 ; 184  |struct Message {
                              294 ; 185  |        WORD wMsgLength;
                              295 ; 186  |        WORD wMsgCommand;
                              296 ; 187  |        WORD wMsgParms[MAX_MSG_LENGTH-1];
                              297 ; 188  |};
                              298 ; 189  |
                              299 ; 190  |union EventTypes {
                              300 ; 191  |        struct CMessage msg;
                              301 ; 192  |        struct Button Button ;
                              302 ; 193  |        struct Message Message;
                              303 ; 194  |};
                              304 ; 195  |
                              305 ; 196  |// next 2 used to get updater build to return correct protocol ver in scsi response.
                              306 ; 197  |#define BUILD_TYPE_UPDATER  0x100
                              307 ; 198  |#define BUILD_TYPE_HOSTLINK 0x101
                              308 ; 199  |#define BUILD_TYPE_PLAYER   0x102
                              309 ; 200  |
                              310 ; 201  |// Resets part if RETAIL build. DEBUG build executes debug instruction to halt.
                              311 ; 202  |#define SystemHalt() __asm(" include 'sysmacro.asm' \n error") 
                              312 ; 203  |#define assert(x)    if(!(x)) __asm(" include 'sysmacro.asm' \n error")
                              313 ; 204  |
                              314 ; 205  |#if DEBUG
                              315 ; 206  |// For DEBUG builds, DebugBuildAssert(condition) halts if condition evaluates to FALSE. 
                              316 ; 207  |#define DebugBuildAssert(x)    if(!(x)) __asm(" debug ")
                              317 ; 208  |#else 
                              318 ; 209  |// For RETAIL builds, DebugBuildAssert(condition) does nothing & execution continues rather than halt or reset. 
                              319 ; 210  |#define DebugBuildAssert(x)    
                              320 ; 211  |#endif
                              321 ; 212  |
                              322 ; 213  |// Do this in your C files to make a reminder that's displayed during the build.
                              323 ; 214  |//  #pragma asm
                              324 ; 215  |//  WARN 'Note to builder: reminder to do this after verifying that'
                              325 ; 216  |//  #pragma endasm
                              326 ; 217  |
                              327 ; 218  |
                              328 ; 219  |#ifdef COLOR_262K
                              329 ; 220  |#define RGB(r,g,b)    ((0x0000FC & (r)) << 10) | ((0x0000FC & (g)) << 4) | ((0x0000FC & (b)) >> 2)    //262k
                              330 ; 221  |#elif defined(COLOR_65K)
                              331 ; 222  |#define RGB(r,g,b)    ((0x0000F8 & (r)) << 8) | ((0x0000FC & (g)) << 3) | ((0x0000F8 & (b)) >> 3)  //65k
                              332 ; 223  |#else
                              333 ; 224  |#define RGB(r,g,b)       ((0x0000F0 & (r)) << 4) | (0x0000F0 & (g)) | ((0x0000F0 & (b)) >> 4)
                              334 ; 225  |#endif
                              335 ; 226  |    
                              336 ; 227  |#endif // #ifndef _TYPES_H
                              337 
                              339 
                              340 ; 13   |#include "project.h"
                              341 
                              343 
                              344 ; 1    |/////////////////////////////////////////////////////////////////////////////////
                              345 ; 2    |//  Copyright(C) SigmaTel, Inc. 2000-2004
                              346 ; 3    |//  Filename: project.inc
                              347 ; 4    |//  Description: 
                              348 ; 5    |/////////////////////////////////////////////////////////////////////////////////
                              349 ; 6    |
                              350 ; 7    |#if (!defined(_PROJECT_INC))
                              351 ; 8    |#define _PROJECT_INC 1
                              352 ; 9    |
                              353 ; 10   |#if defined(STMP_BUILD_PLAYER)
                              354 ; 11   |#include "hwequ.h"
                              355 ; 12   |#else 
                              356 ; 13   |//include "regscodec.inc"
                              357 ; 14   |#endif
                              358 ; 15   |
                              359 ; 16   |//////////////////////////////////////////////////////////////////////////////////
                              360 ; 17   |// Uncomment next define to allow player boot if you have stfm1000 macro enabled (defaults ON) & 
                              361 ; 18   |// your board crystal is not able to output nominal voltage range. Used in player main.asm. STMP00012148
                              362 ; 19   |// Defining this will result in lower battery life (price of using a lower quality crystal). 
                              363 ; 20   |// Those that want to save battery life and have good crystals that meet our HW team's specs can 
                              364 ; 21   |// comment out this line to reduce crystal bias current and so battery current in player mode.  
                              365 ; 22   |#define SUPPORT_MARGINAL_XTALS 1
                              366 ; 23   |
                              367 ; 24   |/////////////////////////////////////////////////////////////////////////////////
                              368 ; 25   |// BOOT SPEED CONFIG & ASSOCIATED BATTERY VOLTAGE CHECK ENABLE
                              369 ; 26   |/////////////////////////////////////////////////////////////////////////////////
                              370 ; 27   |// Users can enable one of ATTEMPT_FAST_BOOT or FASTEST boot or neither project define below by defining
                              371 ; 28   |// values as 0 or 1, else it defaults to the boot speed used in previous SDKs.
                              372 ; 29   |#define ATTEMPT_FAST_BOOT 1
                              373 ; 30   |#define ATTEMPT_FASTEST_BOOT 0   
                              374 ; 31   |// Changing this define to 0 removes Vbat threshholding & unconditionally gives fast boot config above- 
                              375 ; 32   |// disabling this check is suggested for profiling if you want to try to tweak down threshholds by maybe 50mV.
                              376 ; 33   |// Also the tests should clear the fast boot config defines to link & boot at normal speed.
                              377 ; 34   |#define SPEED_BOOT_BATTERY_CHECK 1
                              378 ; 35   |
                              379 ; 36   |/////////////////////////////////////////////////////////////////////////////////
                              380 ; 37   |// MEDIA DEFINITIONS
                              381 ; 38   |/////////////////////////////////////////////////////////////////////////////////
                              382 ; 39   |
                              383 ; 40   |/////////////////////////////////////////////////////////////////////////////////
                              384 ; 41   |// MNAND - Number of chips forming the internal physical device (i.e. # of NANDs)
                              385 ; 42   |#if defined(NAND1)
                              386 ; 43   |#define SM_INTERNAL_CHIPS 1
                              387 ; 44   |#else 
                              388 ; 45   |#if defined(NAND2)
                              389 ; 46   |#define SM_INTERNAL_CHIPS 2
                              390 ; 47   |#else 
                              391 ; 48   |#if defined(NAND3)
                              392 ; 49   |#define SM_INTERNAL_CHIPS 3
                              393 ; 50   |#else 
                              394 ; 51   |#if defined(NAND4)
                              395 ; 52   |#define SM_INTERNAL_CHIPS 4
                              396 ; 53   |#else 
                              397 ; 54   |#define SM_INTERNAL_CHIPS 1
                              398 ; 55   |#endif
                              399 ; 56   |#endif
                              400 ; 57   |#endif
                              401 ; 58   |#endif
                              402 ; 59   |
                              403 ; 60   |/////////////////////////////////////////////////////////////////////////////////
                              404 ; 61   |// If SMARTMEDIA_DETECT_ACTIVE_HIGH is defined:
                              405 ; 62   |//   SmartMedia will be detected as inserted if the GPIO pin reads 1 and removed if it reads 0.  
                              406 ; 63   |// If SMARTMEDIA_DETECT_ACTIVE_HIGH is not defined ** comment out next line **
                              407 ; 64   |//   SmartMedia will be detected as inserted if the GPIO pin reads 0 and removed if it reads 1.
                              408 ; 65   |//*** comment out if active high ****
                              409 ; 66   |//SMARTMEDIA_DETECT_ACTIVE_HIGH  equ     1
                              410 ; 67   |
                              411 ; 68   |#if defined(SMEDIA)
                              412 ; 69   |#define NUM_REMOVABLE_MEDIA 1
                              413 ; 70   |#define NUM_SM_EXTERNAL 1
                              414 ; 71   |#define MMC_MAX_PHYSICAL_DEVICES 0
                              415 ; 72   |#define SM_MAX_LOGICAL_DEVICES 2
                              416 ; 73   |#else 
                              417 ; 74   |#if defined(MMC)
                              418 ; 75   |#define NUM_REMOVABLE_MEDIA 1
                              419 ; 76   |#define NUM_SM_EXTERNAL 0
                              420 ; 77   |#define MMC_MAX_PHYSICAL_DEVICES 1
                              421 ; 78   |#define SM_MAX_LOGICAL_DEVICES 1
                              422 ; 79   |#else 
                              423 ; 80   |#define NUM_REMOVABLE_MEDIA 0
                              424 ; 81   |#define NUM_SM_EXTERNAL 0
                              425 ; 82   |#define MMC_MAX_PHYSICAL_DEVICES 0
                              426 ; 83   |#define SM_MAX_LOGICAL_DEVICES 1
                              427 ; 84   |#endif
                              428 ; 85   |#endif
                              429 ; 86   |
                              430 ; 87   |/////////////////////////////////////////////////////////////////////////////////
                              431 ; 88   |// Mass Storage Class definitions
                              432 ; 89   |/////////////////////////////////////////////////////////////////////////////////
                              433 ; 90   |// Set to 0 if Composite Device build is desired.    
                              434 ; 91   |#define MULTI_LUN_BUILD 1   
                              435 ; 92   |
                              436 ; 93   |////////////////////////////////////////////////////////////////////////////////
                              437 ; 94   |//  SCSI
                              438 ; 95   |#if (MULTI_LUN_BUILD==0)
                              439 ; 96   |  #if (NUM_REMOVABLE_MEDIA == 1)
                              440 ; 97   |    #define SCSI_NUM_TARGETS                        2
                              441 ; 98   |    #define SCSI_DEVICE_NUM_LUNS_DEV_0              1
                              442 ; 99   |    #define SCSI_DEVICE_NUM_LUNS_DEV_1              1
                              443 ; 100  |  #else
                              444 ; 101  |    #define SCSI_NUM_TARGETS                        1
                              445 ; 102  |    #define SCSI_DEVICE_NUM_LUNS_DEV_0              1
                              446 ; 103  |  #endif
                              447 ; 104  |#else
                              448 ; 105  |    #define SCSI_NUM_TARGETS                        1
                              449 ; 106  |  #if (NUM_REMOVABLE_MEDIA == 1)
                              450 ; 107  |    #define SCSI_DEVICE_NUM_LUNS_DEV_0              2
                              451 ; 108  |  #else
                              452 ; 109  |    #define SCSI_DEVICE_NUM_LUNS_DEV_0              1  
                              453 ; 110  |  #endif
                              454 ; 111  |#endif
                              455 ; 112  |
                              456 ; 113  |
                              457 ; 114  |#define USBMSC_NUM_DEVICES                      SCSI_NUM_TARGETS
                              458 ; 115  |
                              459 ; 116  |
                              460 ; 117  |////////////////////////////////////////////////////////////////////////////////
                              461 ; 118  |// Define number of logical medias and drives for three builds (MTP, USBMSC, and Player)
                              462 ; 119  |////////////////////////////////////////////////////////////////////////////////
                              463 ; 120  |#ifdef MMC
                              464 ; 121  |#ifdef MTP_BUILD
                              465 ; 122  |// --------------------
                              466 ; 123  |// MTP and MMC
                              467 ; 124  |// --------------------
                              468 ; 125  |#define NUM_LOGICAL_MEDIA       2
                              469 ; 126  |#define NUM_LOGICAL_DRIVES      8
                              470 ; 127  |#else  // ifndef MTP_BUILD
                              471 ; 128  |#ifdef STMP_BUILD_PLAYER
                              472 ; 129  |// --------------------
                              473 ; 130  |// Player and MMC
                              474 ; 131  |// --------------------
                              475 ; 132  |#else
                              476 ; 133  |// --------------------
                              477 ; 134  |// USBMSC and MMC
                              478 ; 135  |// --------------------
                              479 ; 136  |#define NUM_LOGICAL_MEDIA       3
                              480 ; 137  |#define NUM_LOGICAL_DRIVES      8
                              481 ; 138  |#endif // ifdef STMP_BUILD_PLAYER
                              482 ; 139  |#endif // ifdef MTP_BUILD
                              483 ; 140  |#else  // ifndef MMC
                              484 ; 141  |#ifdef MTP_BUILD
                              485 ; 142  |// --------------------
                              486 ; 143  |// MTP and NAND only
                              487 ; 144  |// --------------------
                              488 ; 145  |#define NUM_LOGICAL_MEDIA       1
                              489 ; 146  |#define NUM_LOGICAL_DRIVES      7
                              490 ; 147  |#else  // ifndef MTP_BUILD
                              491 ; 148  |#ifdef STMP_BUILD_PLAYER
                              492 ; 149  |// --------------------
                              493 ; 150  |// Player and NAND only
                              494 ; 151  |// --------------------
                              495 ; 152  |#else
                              496 ; 153  |// --------------------
                              497 ; 154  |// USBMSC and NAND only
                              498 ; 155  |// --------------------
                              499 ; 156  |#define NUM_LOGICAL_MEDIA       2
                              500 ; 157  |#define NUM_LOGICAL_DRIVES      7
                              501 ; 158  |#endif // ifdef STMP_BUILD_PLAYER
                              502 ; 159  |#endif // ifdef MTP_BUILD
                              503 ; 160  |#endif // ifdef MMC 
                              504 ; 161  |
                              505 ; 162  |// If we are in an MTP build then we don't use as many transfers buffers.
                              506 ; 163  |#if (defined(MTP_BUILD))
                              507 ; 164  |#define MAX_USB_TRANSFERS_QUEUED 16
                              508 ; 165  |
                              509 ; 166  |////!
                              510 ; 167  |////! This varible holds the watchdog count for the store flush.
                              511 ; 168  |////!
                              512 ; 169  |///
                              513 ; 170  |#include <types.h>
TASKING DSP2410 assembler v1.5r1 Build 138 SN 00100122
                                                                                                                                                                                                                                                       Page   3

M:ADDR CODE           CYCLES LINE SOURCELINE
                              514 ; 171  |extern volatile INT g_StoreWatchDogCount;
                              515 ; 172  |extern const INT g_StoreWatchDogTimeout;
                              516 ; 173  |#endif
                              517 ; 174  |
                              518 ; 175  |////////////////////////////////////////////////////////////////////////////////
                              519 ; 176  |// These are needed here for Mass Storage Class
                              520 ; 177  |// Needs to be cleaned up
                              521 ; 178  |////////////////////////////////////////////////////////////////////////////////
                              522 ; 179  |#if (!defined(STMP_BUILD_PLAYER))
                              523 ; 180  |#define SCRATCH_USER_Y_SIZE 512
                              524 ; 181  |#define SCRATCH_USER_X_SIZE 512
                              525 ; 182  |
                              526 ; 183  |#define BROWNOUT_LEVEL1_DETECTED                0x000001
                              527 ; 184  |
                              528 ; 185  |#endif
                              529 ; 186  |
                              530 ; 187  |
                              531 ; 188  |/////////////////////////////////////////////////////////////////////////////////
                              532 ; 189  |// SmartMedia/NAND defs
                              533 ; 190  |#define SM_MAX_PHYSICAL_DEVICES SM_INTERNAL_CHIPS+NUM_SM_EXTERNAL
                              534 ; 191  |#define SM_REMOVABLE_DEVICE_NUM SM_INTERNAL_CHIPS
                              535 ; 192  |
                              536 ; 193  |/////////////////////////////////////////////////////////////////////////////////
                              537 ; 194  |// Sysloadresources defs
                              538 ; 195  |#define SM_MAX_RESOURCE_DEVICES SM_INTERNAL_CHIPS+NUM_SM_EXTERNAL
                              539 ; 196  |
                              540 ; 197  |/////////////////////////////////////////////////////////////////////////////////
                              541 ; 198  |// MMC defs
                              542 ; 199  |#define MMC_MAX_PARTITIONS 1
                              543 ; 200  |#define MMC_MAX_LOGICAL_DEVICES MMC_MAX_PHYSICAL_DEVICES*MMC_MAX_PARTITIONS
                              544 ; 201  |
                              545 ; 202  |/////////////////////////////////////////////////////////////////////////////////
                              546 ; 203  |// SPI defs
                              547 ; 204  |#define SPI_MAX_DEVICES MMC_MAX_PHYSICAL_DEVICES
                              548 ; 205  |
                              549 ; 206  |/////////////////////////////////////////////////////////////////////////////////
                              550 ; 207  |// Global media defs
                              551 ; 208  |#define MAX_PHYSICAL_DEVICES SM_MAX_PHYSICAL_DEVICES+MMC_MAX_PHYSICAL_DEVICES
                              552 ; 209  |#define MAX_LOGICAL_DEVICES SM_MAX_LOGICAL_DEVICES+MMC_MAX_LOGICAL_DEVICES
                              553 ; 210  |
                              554 ; 211  |/////////////////////////////////////////////////////////////////////////////////
                              555 ; 212  |// DO NOT CHANGE THESE!!!
                              556 ; 213  |#define SM_MAX_PARTITIONS 4
                              557 ; 214  |#define MAX_HANDLES 2
                              558 ; 215  |/////////////////////////////////////////////////////////////////////////////////
                              559 ; 216  |
                              560 ; 217  |
                              561 ; 218  |/////////////////////////////////////////////////////////////////////////////////
                              562 ; 219  |// Battery LRADC Values 
                              563 ; 220  |/////////////////////////////////////////////////////////////////////////////////
                              564 ; 221  |// brownout trip point in mV (moved by RS)
                              565 ; 222  |// BATT_SAFETY_MARGIN:  percentage value used by:
                              566 ; 223  |//   * SysSaveSettings to determine if enough power is left to attempt a settings save. 
                              567 ; 224  |//   * Recorder to conditionally prevent the start or continuation of 
                              568 ; 225  |//     audio recording to media.
                              569 ; 226  |#define BATT_SAFETY_MARGIN 10
                              570 ; 227  |
                              571 ; 228  |//; player resource drive refresh allowed only when battery usable % is above this value. 
                              572 ; 229  |//; 50% of usable range [0.9V to 1.5V] is around 1.2V This is the safe target alkaline voltage to do a refresh.
                              573 ; 230  |//; LIION will also require 50% which will work but that could be changed in the future. 
                              574 ; 231  |//RESOURCE_REFRESH_MIN_BATT_PCT equ 50
                              575 ; 232  |
                              576 ; 233  |// stmp00005071 adds these for mp3 encode stability at low battery per battery type & mmc presence.
                              577 ; 234  |
                              578 ; 235  |//// Vbat threshholds empirically tuned by profiling max bat current for 3 HW cases: 
                              579 ; 236  |//// 1 GigaByte MMC, NAND flash only, & LiIon Buck mode. See voicemenu pre-encode Vbat check.
                              580 ; 237  |#if (!defined(CLCD))
                              581 ; 238  |#define MP3_ENC_MMC_MIN_V_BAT_MV 1100
                              582 ; 239  |#define MP3_ENC_NANDONLY_MIN_V_BAT_MV 1000
                              583 ; 240  |#else 
                              584 ; 241  |#define MP3_ENC_MMC_MIN_V_BAT_MV 1250
                              585 ; 242  |#define MP3_ENC_NANDONLY_MIN_V_BAT_MV 1150
                              586 ; 243  |#endif
                              587 ; 244  |#define MP3_ENC_BUCKMODE_MIN_V_BAT_MV 3300
                              588 ; 245  |
                              589 ; 246  |// These Vbat use-range-percentages are derived to correspond with target battery 
                              590 ; 247  |// voltages of 1.10V for MMC, 1.0V for nand only (alkaline or nimh), and 3.3V for any LiIon.
                              591 ; 248  |// See mp3 encoder overlay.
                              592 ; 249  |#define MP3_ENC_MMC_MIN_V_BAT_RANGE_PCT 33
                              593 ; 250  |#define MP3_ENC_NANDONLY_MIN_V_BAT_RANGE_PCT 17
                              594 ; 251  |#define MP3_ENC_BUCKMODE_MIN_V_BAT_RANGE_PCT 25
                              595 ; 252  |
                              596 ; 253  |/////////////////////////////////////////////////////////////////////////////////
                              597 ; 254  |// Voice recording filenames
                              598 ; 255  |// number of digits in filename Vxxx.wav
                              599 ; 256  |/////////////////////////////////////////////////////////////////////////////////
                              600 ; 257  |#define DIGITS_IN_VOICE_FILENAME 3   
                              601 ; 258  |
                              602 ; 259  |/////////////////////////////////////////////////////////////////////////////////
                              603 ; 260  |// Mic Bias: Set this enable to 1 to internally generate mic bias voltage. 
                              604 ; 261  |// Also below, must configure internal resistor value and pin to use for DC bias. 
                              605 ; 262  |// Can set to 0 to disable internally generated mic bias voltage at pin lradc1/2.
                              606 ; 263  |#if defined(DEVICE_3500)
                              607 ; 264  |#define ENABLE_INTERNALLY_GENERATED_MICBIAS 1 
                              608 ; 265  |// MIC BIAS circuit source selection: use Low Resolution ADC pin 2 or 1 to bias mic. 
                              609 ; 266  |// Per your layout: select LRADC 2 or 1 below 
                              610 ; 267  |//   (pin LRADC 2 for 35xx cpu card revB, LRADC 1 for 35xx cpu card revC, ref schematics, & demo player)
                              611 ; 268  |#define LRADC_NUM_FOR_MIC_BIAS 1 
                              612 ; 269  |// Sets internal mic bias R to value 2, 4, or 8 (in kOhms).
                              613 ; 270  |#define MICBIAS_CONFIGURED_RESISTOR_KOHMS 8
                              614 ; 271  |
                              615 ; 272  |// Allows mic bias to settle before sampling. This delay currently unused. For rec btn when bias not yet ready.
                              616 ; 273  |#define REC_BTN_INTERNAL_MIC_BIAS_SETTLING_DELAY_MS 400 
                              617 ; 274  |// Option always keeps bias enabled after mainmenu init. This allows for start pop prevention if you use rec button from outside voice menu.
                              618 ; 275  |// This selection costs 1 mWatt but gains the desired low record button to sampling latency in the record-from-music-menu use-case.
                              619 ; 276  |#define KEEP_MIC_BIAS_ENABLED 0
                              620 ; 277  |
                              621 ; 278  |#else 
                              622 ; 279  |// STMP3410
                              623 ; 280  |#define ENABLE_INTERNALLY_GENERATED_MICBIAS 0
                              624 ; 281  |#define LRADC_NUM_FOR_MIC_BIAS 1 
                              625 ; 282  |#define MICBIAS_CONFIGURED_RESISTOR_KOHMS 2
                              626 ; 283  |#endif
                              627 ; 284  |
                              628 ; 285  |/////////////////////////////////////////////////////////////////////////////////
                              629 ; 286  |// Number of available soft timers
                              630 ; 287  |/////////////////////////////////////////////////////////////////////////////////
                              631 ; 288  |#if defined(SYNC_LYRICS)
                              632 ; 289  |#define SOFT_TIMERS 10
                              633 ; 290  |#else 
                              634 ; 291  |#if defined(JPEG_DECODER)
                              635 ; 292  |#define SOFT_TIMERS 10
                              636 ; 293  |#else 
                              637 ; 294  |#define SOFT_TIMERS 9
                              638 ; 295  |#endif
                              639 ; 296  |#endif
                              640 ; 297  |
                              641 ; 298  |/////////////////////////////////////////////////////////////////////////////////
                              642 ; 299  |//  sizes
                              643 ; 300  |/////////////////////////////////////////////////////////////////////////////////
                              644 ; 301  |#if defined(MMC)
                              645 ; 302  |#if defined(USE_PLAYLIST5)
                              646 ; 303  |#define MENU_STACK_SIZE 1500
                              647 ; 304  |#else 
                              648 ; 305  |#define MENU_STACK_SIZE 1250
                              649 ; 306  |#endif //if @def('USE_PLAYLIST5')
                              650 ; 307  |#else 
                              651 ; 308  |#if defined(USE_PLAYLIST5)
                              652 ; 309  |#define MENU_STACK_SIZE 1500
                              653 ; 310  |#else 
                              654 ; 311  |#define MENU_STACK_SIZE 1250
                              655 ; 312  |#endif //if @def('USE_PLAYLIST5')
                              656 ; 313  |#endif //if @def('MMC')
                              657 ; 314  |
                              658 ; 315  |// NOTE: SDK2.6 USED 550 FOR NEXT LINE, BUT SDK3.0BETA USED 750. Should it be ifdef MTP 750 else 550 for other builds? TOVERIFY. MYALLOC
                              659 ; 316  |// 
                              660 ; 317  |#define STACK_L1_SIZE 750
                              661 ; 318  |#define STACK_L2_SIZE 100
                              662 ; 319  |#define STACK_L3_SIZE 160
                              663 ; 320  |
                              664 ; 321  |// If we are in MTP mode the overlay task stack can shrink.
                              665 ; 322  |// TODO shrink this stack for MTP, I will leave it at 500 until we verify that it 
                              666 ; 323  |// is ok with switching code.
                              667 ; 324  |#if defined(MTP_BUILD)
                              668 ; 325  |#define OVERLAY_MANAGER_STACK_SIZE 300
                              669 ; 326  |#endif
                              670 ; 327  |
                              671 ; 328  |/////////////////////////////////////////////////////////////////////////////////
                              672 ; 329  |// maximum number of nested funclets 
                              673 ; 330  |/////////////////////////////////////////////////////////////////////////////////
                              674 ; 331  |#define MAX_NESTED_FUNCLET 6 
                              675 ; 332  |
                              676 ; 333  |/////////////////////////////////////////////////////////////////////////////////
                              677 ; 334  |//    LCD DEFINITIONS
                              678 ; 335  |/////////////////////////////////////////////////////////////////////////////////
                              679 ; 336  |
                              680 ; 337  |#define SPACE_CHAR 0x000020          
                              681 ; 338  |#define ZERO_CHAR 0x000030
                              682 ; 339  |#define COLON_CHAR 0x00003A
                              683 ; 340  |#define PERIOD_CHAR 0x00002E
                              684 ; 341  |
                              685 ; 342  |#if (defined(S6B33B0A_LCD))
                              686 ; 343  |#define LCD_X_SIZE 128
                              687 ; 344  |#define LCD_Y_SIZE 159
                              688 ; 345  |#endif
                              689 ; 346  |
                              690 ; 347  |#if (defined(SED15XX_LCD))
                              691 ; 348  |#define LCD_X_SIZE 128
                              692 ; 349  |#define LCD_Y_SIZE 64
                              693 ; 350  |#endif
                              694 ; 351  |
                              695 ; 352  |
                              696 ; 353  |//////////////////////////////////////////////////////////////////////////////////
                              697 ; 354  |//   Details on Customizing Contrast
                              698 ; 355  |/////////////////////////////////////////////////////////////////////////////////
                              699 ; 356  |//   Max supported LCD range is 0 - 3F; however due to hardware/voltage differences
                              700 ; 357  |//   the range of visibility is usually smaller than this.  It is important to 
                              701 ; 358  |//   calibrate the visible range, because the contrast setting is saved.
                              702 ; 359  |//   If the user shuts off the player while lcd is not visible, the player is useless
                              703 ; 360  |//   unless the ezact sequence is remembered.
                              704 ; 361  |//   To find out what range your player supports: 
                              705 ; 362  |//   change these equs to full range or comment out (full range is default)
                              706 ; 363  |//;;;;;;
                              707 ; 364  |// uncomment the line below to build code that will provide raw contrast value
                              708 ; 365  |// recommended calibration using player -- uncomment 
                              709 ; 366  |//;;;;;;
                              710 ; 367  |//CONTRAST_CALIBRATION    equ  1
                              711 ; 368  |////////////////////////////
                              712 ; 369  |#if (defined(DEMO_HW))
                              713 ; 370  |// this is the setting for ET301 demos; Next 2 line have not been updated for new Shingyi LCD (June6'05)
                              714 ; 371  |#define LCD_MAX_CONTRAST 0x32 
                              715 ; 372  |#define LCD_MIN_CONTRAST 0x1E
                              716 ; 373  |#else 
                              717 ; 374  |
                              718 ; 375  |#if (defined(S6B33B0A_LCD))
                              719 ; 376  |#define LCD_MAX_CONTRAST 210
                              720 ; 377  |#define LCD_MIN_CONTRAST 160    
                              721 ; 378  |#endif
                              722 ; 379  |
                              723 ; 380  |#if (defined(SED15XX_LCD))
                              724 ; 381  |// Next 3 line comment was for OLD shingyi LCD: (default LCD before sdk2.6)
                              725 ; 382  |// Engineering board regs support range [17-37].
                              726 ; 383  |//   Engineering board DC/DC support range [24-46]. 
                              727 ; 384  |//   One default contrast range [24-42] works for both.
                              728 ; 385  |// The 3 sets of contrast ranges below are updated for SDK2.6 to support either 
                              729 ; 386  |// new or old ShingYih LCDs. "File" refers to \resource\shingyih\system_lcd_init_seq.src
                              730 ; 387  |// 3/10/05 - Use one of the 2 next contrast ranges depending on which
                              731 ; 388  |// ShingYih LCD you have.  See \resources\shingyi\readme.txt 
                              732 ; 389  |// Optimal for NEW LCD with NEW file (SDK2.6 default)  
                              733 ; 390  |// G098064-41 LCD module (present on engr board revH LCD card)
                              734 ; 391  |
                              735 ; 392  |#if (defined(NEWSHINGYIH))
                              736 ; 393  |#define LCD_MAX_CONTRAST 250
                              737 ; 394  |#define LCD_MIN_CONTRAST 0
                              738 ; 395  |#else 
                              739 ; 396  |//-----
                              740 ; 397  |// Near optimal for OLD LCD with NEW file. 
                              741 ; 398  |// NOT optimal for the new lcd but pretty good. So u may use this if u want 1 build for both LCDs.
                              742 ; 399  |#define LCD_MAX_CONTRAST 250
                              743 ; 400  |#define LCD_MIN_CONTRAST 0
                              744 ; 401  |
                              745 ; 402  |//=====
                              746 ; 403  |// Optimal for OLD ShingYih LCD with OLD file (as sdk2.521)
                              747 ; 404  |// Suggest going with default new init file & values above for your LCD instead of this historic ver.
                              748 ; 405  |//LCD_MAX_CONTRAST equ 42
                              749 ; 406  |//LCD_MIN_CONTRAST equ 24 
                              750 ; 407  |
                              751 ; 408  |#endif
                              752 ; 409  |#endif
                              753 ; 410  |
                              754 ; 411  |#endif
                              755 ; 412  |
                              756 ; 413  |//////////////////////////////////////////////////////////////////////////////////
                              757 ; 414  |// The default value of the lcd contrast in % of range
                              758 ; 415  |//   the default value is used when no settings.dat is available
                              759 ; 416  |//////////////////////////////////////////////////////////////////////////////////
                              760 ; 417  |
                              761 ; 418  |#if (defined(S6B33B0A_LCD))
                              762 ; 419  |// 60% of range is default value
                              763 ; 420  |#define DEFAULT_CONTRAST 50 
                              764 ; 421  |#endif
TASKING DSP2410 assembler v1.5r1 Build 138 SN 00100122
                                                                                                                                                                                                                                                       Page   4

M:ADDR CODE           CYCLES LINE SOURCELINE
                              765 ; 422  |
                              766 ; 423  |#if (defined(SED15XX_LCD))
                              767 ; 424  |// % of range is default value (was 60%)
                              768 ; 425  |#define DEFAULT_CONTRAST 50 
                              769 ; 426  |#endif
                              770 ; 427  |
                              771 ; 428  |
                              772 ; 429  |// percentage change per increment/decrement message (LCD_DEC_CONTRAST/LCD_INC_CONTRAST)
                              773 ; 430  |// make lower when doing calibration
                              774 ; 431  |#define LCD_STEPSIZE_CONTRAST 10  
                              775 ; 432  |
                              776 ; 433  |
                              777 ; 434  |/////////////////////////////////////////////////////////////////////////////////
                              778 ; 435  |// For FFWD and RWND
                              779 ; 436  |/////////////////////////////////////////////////////////////////////////////////
                              780 ; 437  |#define SECONDS_TO_SKIP 1
                              781 ; 438  |#define SECONDS_TO_SKIP1 3
                              782 ; 439  |#define SECONDS_TO_SKIP2 6
                              783 ; 440  |// number of seconds to cause reset to begin of song for PREV push
                              784 ; 441  |#define PREV_SONG_THRESHOLD 5  
                              785 ; 442  |// number of 300 mSec periods before the numbers of seconds to skip increases
                              786 ; 443  |#define FIRST_TIME_BOUNDARY 15 
                              787 ; 444  |// number of 300 mSec periods before the numbers of seconds to skip increases
                              788 ; 445  |#define SECOND_TIME_BOUNDARY 30 
                              789 ; 446  |
                              790 ; 447  |// For audible FFW/RWD
                              791 ; 448  |#define SECONDS_TO_SKIP_FOR_3X_RATE 1
                              792 ; 449  |#define SECONDS_TO_SKIP_FOR_60X_RATE 18
                              793 ; 450  |#define SECONDS_TO_SKIP_FOR_600X_RATE 180
                              794 ; 451  |#define SECONDS_TO_SKIP_FOR_1800X_RATE 540
                              795 ; 452  |// number of 300 mSec periods before the numbers of seconds to skip increases
                              796 ; 453  |#define LEVEL1_BOUNDARY 17 
                              797 ; 454  |// number of 300 mSec periods before the numbers of seconds to skip increases
                              798 ; 455  |#define LEVEL2_BOUNDARY 33 
                              799 ; 456  |// number of 300 mSec periods before the numbers of seconds to skip increases
                              800 ; 457  |#define LEVEL3_BOUNDARY 50 
                              801 ; 458  |// Stmp00010296 Ticket #71685:  for song shorter than the min. skip size
                              802 ; 459  |// if song_time < skip_size, bCurrentSongShort=>TRUE (ignore FWD/RWD commands)
                              803 ; 460  |// Short Song Time, songs too short to play.
                              804 ; 461  |#define SHORT_SONG_TIME SECONDS_TO_SKIP         
                              805 ; 462  |
                              806 ; 463  |/////////////////////////////////////////////////////////////////////////////////
                              807 ; 464  |// MP3 Sync Values
                              808 ; 465  |/////////////////////////////////////////////////////////////////////////////////
                              809 ; 466  |// # bytes to look for sync before marking it bad
                              810 ; 467  |#define MP3_SYNC_THRESHOLD 70000 
                              811 ; 468  |// # bytes to look for sync before slowing decoder isr frequency (to let menus run)
                              812 ; 469  |#define MP3_SYNC_THRESHOLD1 10000 
                              813 ; 470  |// once we have sync'd, the isr should be called this frequently
                              814 ; 471  |#define MP3_DECODERISR_FAST 7500  
                              815 ; 472  |// if decoder is having difficulty syncing, switch isr to be called less frequently
                              816 ; 473  |#define MP3_DECODERISR_SLOW 50000 
                              817 ; 474  |
                              818 ; 475  |
                              819 ; 476  |/////////////////////////////////////////////////////////////////////////////////
                              820 ; 477  |//// Multi-Stage Volume Control Definitions
                              821 ; 478  |/////////////////////////////////////////////////////////////////////////////////
                              822 ; 479  |//// Use Multi-Stage Volume
                              823 ; 480  |#define MULTI_STAGE_VOLUME 0x1                  
                              824 ; 481  |
                              825 ; 482  |//// Master Volume definitions
                              826 ; 483  |#define MIX_MSTR_MAX_VOL 0x0
                              827 ; 484  |#define NUM_MSTR_ATT_STEPS (0x1F-MIX_MSTR_MAX_VOL)
                              828 ; 485  |
                              829 ; 486  |//// DAC-Mode definitions
                              830 ; 487  |//// Adjusts 0dB point
                              831 ; 488  |#define MIX_DAC_NOM_VOL 0x6                  
                              832 ; 489  |#define MIX_DAC_MIN_VOL 0x1F
                              833 ; 490  |// For minimum clipping: Set MIX_DAC_MAX_VOL below to match MIX_DAC_NOM_VOL value 2 lines above.
                              834 ; 491  |// For additional gain (with possible clipping): Set MIX_DAC_MAX_VOL in range below. 
                              835 ; 492  |//                                               Each integer below MIX_DAC_NOM_VOL provides 1.5 dB gain on Stmp34x0; 
                              836 ; 493  |//                                               Max gain possible: 8 step diff would provide +12dB gain.   
                              837 ; 494  |// range: [0 to MIX_DAC_NOM_VOL] (0 for loudest volume)
                              838 ; 495  |#define MIX_DAC_MAX_VOL 0x0  
                              839 ; 496  |
                              840 ; 497  |#define NUM_DAC_ATT_STEPS (MIX_DAC_MIN_VOL-MIX_DAC_NOM_VOL+1)
                              841 ; 498  |#define NUM_DAC_GAIN_STEPS (MIX_DAC_NOM_VOL-MIX_DAC_MAX_VOL)
                              842 ; 499  |#define NUM_DAC_MODE_VOL_STEPS (NUM_DAC_ATT_STEPS+NUM_MSTR_ATT_STEPS+NUM_DAC_GAIN_STEPS+1)
                              843 ; 500  |
                              844 ; 501  |//// If there is no stored volume, set to 50% of DAC-Mode max; change if DAC Mode is not the default
                              845 ; 502  |//// STMP35xx has 2dB attenuation per step so default needs a few more steps above midpoint.
                              846 ; 503  |#define DEFAULT_VOLUME ((NUM_DAC_MODE_VOL_STEPS/2)+6)         
                              847 ; 504  |
                              848 ; 505  |//// Set maximum restored volume to 75% of DAC-Mode max; change if DAC Mode is not the default
                              849 ; 506  |#define MAX_RESTORED_VOLUME ((3*NUM_DAC_MODE_VOL_STEPS)/4)   
                              850 ; 507  |
                              851 ; 508  |
                              852 ; 509  |//// Line In definitions (used for Line-In 1)
                              853 ; 510  |//// 0dB point of the Line In
                              854 ; 511  |#define MIX_LINE_NOM_VOL 0x8                  
                              855 ; 512  |//// Minimum volume of Line In
                              856 ; 513  |#define MIX_LINE_MIN_VOL 0x1F                 
                              857 ; 514  |//// Maximum volume of Line In (can adjust extra gain)
                              858 ; 515  |#define MIX_LINE_MAX_VOL 0x6                  
                              859 ; 516  |#define NUM_LINE_ATT_STEPS (MIX_LINE_MIN_VOL-MIX_LINE_NOM_VOL+1)
                              860 ; 517  |#define NUM_LINE_GAIN_STEPS (MIX_LINE_NOM_VOL-MIX_LINE_MAX_VOL)
                              861 ; 518  |#define NUM_LINE_MODE_VOL_STEPS (NUM_LINE_ATT_STEPS+NUM_MSTR_ATT_STEPS+NUM_LINE_GAIN_STEPS+1)
                              862 ; 519  |
                              863 ; 520  |//// Line In definitions (used for FM tuner with 144 pin package)
                              864 ; 521  |//// 0dB point of the Line In
                              865 ; 522  |#define MIX_FM_NOM_VOL 0x8                  
                              866 ; 523  |//// Minimum volume of Line In
                              867 ; 524  |#define MIX_FM_MIN_VOL 0x1F                 
                              868 ; 525  |//// Maximum volume of Line In (can adjust extra gain)
                              869 ; 526  |#define MIX_FM_MAX_VOL 0x6                  
                              870 ; 527  |#define NUM_FM_ATT_STEPS (MIX_FM_MIN_VOL-MIX_FM_NOM_VOL+1)
                              871 ; 528  |#define NUM_FM_GAIN_STEPS (MIX_FM_NOM_VOL-MIX_FM_MAX_VOL)
                              872 ; 529  |#define NUM_FM_MODE_VOL_STEPS (NUM_FM_ATT_STEPS+NUM_MSTR_ATT_STEPS+NUM_FM_GAIN_STEPS+1)
                              873 ; 530  |
                              874 ; 531  |/////////////////////////////////////////////////////////////////////////////////
                              875 ; 532  |//// When enabled (1), periodically checks for one of several FM state machine invalid deadlock states & recovers. 
                              876 ; 533  |//// Define as 0 to disable FM-deadlock-state checking and recovery.
                              877 ; 534  |#define FM_WATCHDOG_ENABLE 1
                              878 ; 535  |
                              879 ; 536  |#if !defined(STMP_BUILD_PLAYER)
                              880 ; 537  |////
                              881 ; 538  |////! This varible holds the lcd display state for the mtp project.
                              882 ; 539  |////
                              883 ; 540  |///
                              884 ; 541  |#include <types.h>
                              885 
                              887 
                              888 ; 1    |////////////////////////////////////////////////////////////////////////////////
                              889 ; 2    |// Copyright(C) SigmaTel, Inc. 2000-2004
                              890 ; 3    |//
                              891 ; 4    |// Filename: types.h
                              892 ; 5    |// Description: Standard data types
                              893 ; 6    |////////////////////////////////////////////////////////////////////////////////
                              894 ; 7    |
                              895 ; 8    |#ifndef _TYPES_H
                              896 ; 9    |#define _TYPES_H
                              897 ; 10   |
                              898 ; 11   |// TODO:  move this outta here!
                              899 ; 12   |#if !defined(NOERROR)
                              900 ; 13   |#define NOERROR 0
                              901 ; 14   |#define SUCCESS 0
                              902 ; 15   |#endif 
                              903 ; 16   |#if !defined(SUCCESS)
                              904 ; 17   |#define SUCCESS  0
                              905 ; 18   |#endif
                              906 ; 19   |#if !defined(ERROR)
                              907 ; 20   |#define ERROR   -1
                              908 ; 21   |#endif
                              909 ; 22   |#if !defined(FALSE)
                              910 ; 23   |#define FALSE 0
                              911 ; 24   |#endif
                              912 ; 25   |#if !defined(TRUE)
                              913 ; 26   |#define TRUE  1
                              914 ; 27   |#endif
                              915 ; 28   |
                              916 ; 29   |#if !defined(NULL)
                              917 ; 30   |#define NULL 0
                              918 ; 31   |#endif
                              919 ; 32   |
                              920 ; 33   |#define MAX_INT     0x7FFFFF
                              921 ; 34   |#define MAX_LONG    0x7FFFFFffffff
                              922 ; 35   |        // max positive unsigned long value: -1 == 0xFFFFFFffffff
                              923 ; 36   |#define MAX_ULONG   (-1) 
                              924 ; 37   |
                              925 ; 38   |#define WORD_SIZE   24              // word size in bits
                              926 ; 39   |#define BYTES_PER_WORD 3            // 8 bit bytes
                              927 ; 40   |
                              928 ; 41   |
                              929 ; 42   |#define BYTE    unsigned char       // btVarName
                              930 ; 43   |#define CHAR    signed char         // cVarName
                              931 ; 44   |#define USHORT  unsigned short      // usVarName
                              932 ; 45   |#define SHORT   unsigned short      // sVarName
                              933 ; 46   |#define WORD    unsigned int        // wVarName
                              934 ; 47   |#define INT     signed int          // iVarName
                              935 ; 48   |#define DWORD   unsigned long       // dwVarName
                              936 ; 49   |#define LONG    signed long         // lVarName
                              937 ; 50   |#define BOOL    unsigned int        // bVarName
                              938 ; 51   |#define FRACT   _fract              // frVarName
                              939 ; 52   |#define LFRACT  long _fract         // lfrVarName
                              940 ; 53   |#define CIRC    _circ               // cp<type prefix>VarName (see below)
                              941 ; 54   |#define FLOAT   float               // fVarName
                              942 ; 55   |#define DBL     double              // dVarName
                              943 ; 56   |#define ENUM    enum                // eVarName
                              944 ; 57   |#define CMX     _complex            // cmxVarName
                              945 ; 58   |typedef WORD UCS3;                   // 
                              946 ; 59   |
                              947 ; 60   |#define UINT16  unsigned short
                              948 ; 61   |#define UINT8   unsigned char   
                              949 ; 62   |#define UINT32  unsigned long
                              950 ; 63   |#define UINT64  unsigned long   // need to figure out how to do 64 bit values.  Or port exisiting code to only use 48 bit
                              951 ; 64   |#define INT64   unsigned long   // need to figure out how to do 64 bit values.  Or port exisiting code to only use 48 bit
                              952 ; 65   |#define WCHAR   UINT16
                              953 ; 66   |
                              954 ; 67   |//UINT128 is 16 bytes or 6 words
                              955 ; 68   |typedef struct UINT128_3500 {   
                              956 ; 69   |    int val[6];     
                              957 ; 70   |} UINT128_3500;
                              958 ; 71   |
                              959 ; 72   |#define UINT128   UINT128_3500
                              960 ; 73   |
                              961 ; 74   |// Little endian word packed byte strings:   
                              962 ; 75   |//      _packed BYTE bTextVarName[]="a string";  bText is a packed byte string prefix
                              963 ; 76   |// Convert to big endian words by reordering bytes from high to low using swizzle.
                              964 ; 77   |// Little endian word packed byte strings:   
                              965 ; 78   |//      _packed BYTE bTextVarName[]="a string";  bText is a packed byte string prefix
                              966 ; 79   |// Convert to big endian words by reordering bytes from high to low using swizzle.
                              967 ; 80   |
                              968 ; 81   |// Declare Memory Spaces To Use When Coding
                              969 ; 82   |// A. Sector Buffers
                              970 ; 83   |#define SECTOR_BUFFER_MEM_X _X
                              971 ; 84   |#define SECTOR_BUFFER_MEM_Y _Y
                              972 ; 85   |#define SECTOR_BUFFER_MEM SECTOR_BUFFER_MEM_X
                              973 ; 86   |typedef WORD SECTOR_BUFFER_MEM SECTOR_BUFFER;
                              974 ; 87   |typedef SECTOR_BUFFER * P_SECTOR_BUFFER;
                              975 ; 88   |// B. Media DDI Memory
                              976 ; 89   |#define MEDIA_DDI_MEM _Y
                              977 ; 90   |
                              978 ; 91   |
                              979 ; 92   |
                              980 ; 93   |// Pointers to linear structures are labeled as: p<type prefix>VarName
                              981 ; 94   |// Examples of circular pointers:
                              982 ; 95   |//    INT CIRC cpiVarName
                              983 ; 96   |//    DWORD CIRC cpdwVarName
                              984 ; 97   |
                              985 ; 98   |#define RETCODE INT                 // rcVarName
                              986 ; 99   |
                              987 ; 100  |// generic bitfield structure
                              988 ; 101  |struct Bitfield {
                              989 ; 102  |    unsigned int B0  :1;
                              990 ; 103  |    unsigned int B1  :1;
                              991 ; 104  |    unsigned int B2  :1;
                              992 ; 105  |    unsigned int B3  :1;
                              993 ; 106  |    unsigned int B4  :1;
                              994 ; 107  |    unsigned int B5  :1;
                              995 ; 108  |    unsigned int B6  :1;
                              996 ; 109  |    unsigned int B7  :1;
                              997 ; 110  |    unsigned int B8  :1;
                              998 ; 111  |    unsigned int B9  :1;
                              999 ; 112  |    unsigned int B10 :1;
                             1000 ; 113  |    unsigned int B11 :1;
                             1001 ; 114  |    unsigned int B12 :1;
                             1002 ; 115  |    unsigned int B13 :1;
                             1003 ; 116  |    unsigned int B14 :1;
                             1004 ; 117  |    unsigned int B15 :1;
                             1005 ; 118  |    unsigned int B16 :1;
                             1006 ; 119  |    unsigned int B17 :1;
                             1007 ; 120  |    unsigned int B18 :1;
                             1008 ; 121  |    unsigned int B19 :1;
                             1009 ; 122  |    unsigned int B20 :1;
                             1010 ; 123  |    unsigned int B21 :1;
                             1011 ; 124  |    unsigned int B22 :1;
                             1012 ; 125  |    unsigned int B23 :1;
                             1013 ; 126  |};
                             1014 ; 127  |
                             1015 ; 128  |union BitInt {
                             1016 ; 129  |        struct Bitfield B;
TASKING DSP2410 assembler v1.5r1 Build 138 SN 00100122
                                                                                                                                                                                                                                                       Page   5

M:ADDR CODE           CYCLES LINE SOURCELINE
                             1017 ; 130  |        int        I;
                             1018 ; 131  |};
                             1019 ; 132  |
                             1020 ; 133  |#define MAX_MSG_LENGTH 10
                             1021 ; 134  |struct CMessage
                             1022 ; 135  |{
                             1023 ; 136  |        unsigned int m_uLength;
                             1024 ; 137  |        unsigned int m_uMsg[MAX_MSG_LENGTH];
                             1025 ; 138  |};
                             1026 ; 139  |
                             1027 ; 140  |typedef struct {
                             1028 ; 141  |    WORD m_wLength;
                             1029 ; 142  |    WORD m_wMessage;
                             1030 ; 143  |    WORD m_wParams[MAX_MSG_LENGTH];
                             1031 ; 144  |} Message;
                             1032 ; 145  |
                             1033 ; 146  |struct MessageQueueDescriptor
                             1034 ; 147  |{
                             1035 ; 148  |        int *m_pBase;
                             1036 ; 149  |        int m_iModulo;
                             1037 ; 150  |        int m_iSize;
                             1038 ; 151  |        int *m_pHead;
                             1039 ; 152  |        int *m_pTail;
                             1040 ; 153  |};
                             1041 ; 154  |
                             1042 ; 155  |struct ModuleEntry
                             1043 ; 156  |{
                             1044 ; 157  |    int m_iSignaledEventMask;
                             1045 ; 158  |    int m_iWaitEventMask;
                             1046 ; 159  |    int m_iResourceOfCode;
                             1047 ; 160  |    struct MessageQueueDescriptor *m_pMessageQueue;
                             1048 ; 161  |    int _asmfunc (*m_pProcessEntryPoint)(union WaitMask Signals,struct MessageQueueDescriptor *);
                             1049 ; 162  |    int _asmfunc (*m_pInitFunction)(struct MessageQueueDescriptor *);
                             1050 ; 163  |    int m_uTimeOutHigh;
                             1051 ; 164  |    int m_uTimeOutLow;
                             1052 ; 165  |    int _asmfunc (*m_pBackgroundFunction)(struct MessageQueueDescriptor *);
                             1053 ; 166  |};
                             1054 ; 167  |
                             1055 ; 168  |union WaitMask{
                             1056 ; 169  |    struct B{
                             1057 ; 170  |        unsigned int m_bNone     :1;
                             1058 ; 171  |        unsigned int m_bMessage  :1;
                             1059 ; 172  |        unsigned int m_bTimer    :1;
                             1060 ; 173  |        unsigned int m_bButton   :1;
                             1061 ; 174  |    } B;
                             1062 ; 175  |    int I;
                             1063 ; 176  |} ;
                             1064 ; 177  |
                             1065 ; 178  |
                             1066 ; 179  |struct Button {
                             1067 ; 180  |        WORD wButtonEvent;
                             1068 ; 181  |        WORD wUnused[MAX_MSG_LENGTH];   
                             1069 ; 182  |};
                             1070 ; 183  |
                             1071 ; 184  |struct Message {
                             1072 ; 185  |        WORD wMsgLength;
                             1073 ; 186  |        WORD wMsgCommand;
                             1074 ; 187  |        WORD wMsgParms[MAX_MSG_LENGTH-1];
                             1075 ; 188  |};
                             1076 ; 189  |
                             1077 ; 190  |union EventTypes {
                             1078 ; 191  |        struct CMessage msg;
                             1079 ; 192  |        struct Button Button ;
                             1080 ; 193  |        struct Message Message;
                             1081 ; 194  |};
                             1082 ; 195  |
                             1083 ; 196  |// next 2 used to get updater build to return correct protocol ver in scsi response.
                             1084 ; 197  |#define BUILD_TYPE_UPDATER  0x100
                             1085 ; 198  |#define BUILD_TYPE_HOSTLINK 0x101
                             1086 ; 199  |#define BUILD_TYPE_PLAYER   0x102
                             1087 ; 200  |
                             1088 ; 201  |// Resets part if RETAIL build. DEBUG build executes debug instruction to halt.
                             1089 ; 202  |#define SystemHalt() __asm(" include 'sysmacro.asm' \n error") 
                             1090 ; 203  |#define assert(x)    if(!(x)) __asm(" include 'sysmacro.asm' \n error")
                             1091 ; 204  |
                             1092 ; 205  |#if DEBUG
                             1093 ; 206  |// For DEBUG builds, DebugBuildAssert(condition) halts if condition evaluates to FALSE. 
                             1094 ; 207  |#define DebugBuildAssert(x)    if(!(x)) __asm(" debug ")
                             1095 ; 208  |#else 
                             1096 ; 209  |// For RETAIL builds, DebugBuildAssert(condition) does nothing & execution continues rather than halt or reset. 
                             1097 ; 210  |#define DebugBuildAssert(x)    
                             1098 ; 211  |#endif
                             1099 ; 212  |
                             1100 ; 213  |// Do this in your C files to make a reminder that's displayed during the build.
                             1101 ; 214  |//  #pragma asm
                             1102 ; 215  |//  WARN 'Note to builder: reminder to do this after verifying that'
                             1103 ; 216  |//  #pragma endasm
                             1104 ; 217  |
                             1105 ; 218  |
                             1106 ; 219  |#ifdef COLOR_262K
                             1107 ; 220  |#define RGB(r,g,b)    ((0x0000FC & (r)) << 10) | ((0x0000FC & (g)) << 4) | ((0x0000FC & (b)) >> 2)    //262k
                             1108 ; 221  |#elif defined(COLOR_65K)
                             1109 ; 222  |#define RGB(r,g,b)    ((0x0000F8 & (r)) << 8) | ((0x0000FC & (g)) << 3) | ((0x0000F8 & (b)) >> 3)  //65k
                             1110 ; 223  |#else
                             1111 ; 224  |#define RGB(r,g,b)       ((0x0000F0 & (r)) << 4) | (0x0000F0 & (g)) | ((0x0000F0 & (b)) >> 4)
                             1112 ; 225  |#endif
                             1113 ; 226  |    
                             1114 ; 227  |#endif // #ifndef _TYPES_H
                             1115 
                             1117 
                             1118 ; 542  |extern volatile WORD g_wActivityState;
                             1119 ; 543  |#endif // if !@def('STMP_BUILD_PLAYER')
                             1120 ; 544  |
                             1121 ; 545  |void _reentrant Init5VSense(void);
                             1122 ; 546  |void _reentrant ServiceDCDC(void);
                             1123 ; 547  |
                             1124 ; 548  |////////////////////////////////////////////////////////////////////////////
                             1125 ; 549  |//// JPEG Thumbnail Mode Setting
                             1126 ; 550  |//// number of column in thumbnail mode
                             1127 ; 551  |#define THUMBNAIL_X 2           
                             1128 ; 552  |//// number of row in  thumbnail mode
                             1129 ; 553  |#define THUMBNAIL_Y 2           
                             1130 ; 554  |//// thumbnail boundary offset x
                             1131 ; 555  |#define THUMBNAIL_X_OFFSET 4            
                             1132 ; 556  |//// thumbnail boundary offset y
                             1133 ; 557  |#define THUMBNAIL_Y_OFFSET 4            
                             1134 ; 558  |
                             1135 ; 559  |#endif // if (!@def(_PROJECT_INC))
                             1136 ; 560  |
                             1137 
                             1139 
                             1140 ; 14   |#include "sysirq.h"
                             1141 
                             1143 
                             1144 ; 1    |////////////////////////////////////////////////////////////////////////////////
                             1145 ; 2    |// Copyright(C) SigmaTel, Inc. 2000-2001
                             1146 ; 3    |//
                             1147 ; 4    |// Filename: sysirq.h
                             1148 ; 5    |// Description: 
                             1149 ; 6    |////////////////////////////////////////////////////////////////////////////////
                             1150 ; 7    |
                             1151 ; 8    |#ifndef _SYSIRQ_H
                             1152 ; 9    |#define _SYSIRQ_H
                             1153 ; 10   |
                             1154 ; 11   |///////////////////////////////////////////////////////////////////////////////
                             1155 ; 12   |// Defs
                             1156 ; 13   |///////////////////////////////////////////////////////////////////////////////
                             1157 ; 14   |
                             1158 ; 15   |#define     INTERRUPTS_UNMASK_ALL   0x000000
                             1159 ; 16   |
                             1160 ; 17   |///////////////////////////////////////////////////////////////////////////////
                             1161 ; 18   |// Structure definitions
                             1162 ; 19   |///////////////////////////////////////////////////////////////////////////////
                             1163 ; 20   |
                             1164 ; 21   |///////////////////////////////////////////////////////////////////////////////
                             1165 ; 22   |// Prototypes
                             1166 ; 23   |///////////////////////////////////////////////////////////////////////////////
                             1167 ; 24   |
                             1168 ; 25   |WORD _reentrant SysMaskAllInterrupts(void);
                             1169 ; 26   |void _reentrant SysUnMaskAllInterrupts(WORD wLevel);
                             1170 ; 27   |WORD _reentrant SysGetIrqLevel(void);
                             1171 ; 28   |RETCODE _reentrant SysSetIrqLevel(WORD wIrqLevel);
                             1172 ; 29   |
                             1173 ; 30   |#endif // #ifndef _SYSIRQ_H
                             1174 
                             1176 
                             1177 ; 15   |#include "icoll.h"
                             1178 
                             1180 
                             1181 ; 1    |////////////////////////////////////////////////////////////////////////////////
                             1182 ; 2    |// Copyright(C) SigmaTel, Inc. 2002
                             1183 ; 3    |//
                             1184 ; 4    |// Filename: icoll.h
                             1185 ; 5    |// Description: 
                             1186 ; 6    |////////////////////////////////////////////////////////////////////////////////
                             1187 ; 7    |
                             1188 ; 8    |#ifndef _ICOLL_H
                             1189 ; 9    |#define _ICOLL_H
                             1190 ; 10   |
                             1191 ; 11   |///////////////////////////////////////////////////////////////////////////////
                             1192 ; 12   |// Defs
                             1193 ; 13   |///////////////////////////////////////////////////////////////////////////////
                             1194 ; 14   |                                                                                          
                             1195 ; 15   |#define ICOLL_SOURCE_DAC_REFILL                                 (DWORD)0             
                             1196 ; 16   |#define ICOLL_SOURCE_DAC_UNDERFLOW                              (DWORD)1             
                             1197 ; 17   |#define ICOLL_SOURCE_ADC_REFILL                                 (DWORD)2             
                             1198 ; 18   |#define ICOLL_SOURCE_ADC_OVERFLOW                               (DWORD)3             
                             1199 ; 19   |#define ICOLL_SOURCE_FLASH_DONE                                 (DWORD)4              
                             1200 ; 20   |#define ICOLL_SOURCE_COMPACTFLASH_CARD_IRQ                      (DWORD)5              
                             1201 ; 21   |#define ICOLL_SOURCE_SMARTMEDIA_TIMEOUT                         (DWORD)6              
                             1202 ; 22   |#define ICOLL_SOURCE_SMARTMEDIA_INTERFACE_INVALID_PROGRAMMING   (DWORD)7              
                             1203 ; 23   |#define ICOLL_SOURCE_COMPACTFLASH_NO_CARD                       (DWORD)8               
                             1204 ; 24   |#define ICOLL_SOURCE_COMPACTFLASH_STATUS_CHANGE                 (DWORD)9               
                             1205 ; 25   |#define ICOLL_SOURCE_GPIO_0                                     (DWORD)10               
                             1206 ; 26   |#define ICOLL_SOURCE_GPIO_1                                     (DWORD)11               
                             1207 ; 27   |#define ICOLL_SOURCE_GPIO_2                                     (DWORD)12                
                             1208 ; 28   |#define ICOLL_SOURCE_TIMER_0                                    (DWORD)13                
                             1209 ; 29   |#define ICOLL_SOURCE_TIMER_1                                    (DWORD)14                
                             1210 ; 30   |#define ICOLL_SOURCE_TIMER_2                                    (DWORD)15                
                             1211 ; 31   |#define ICOLL_SOURCE_TIMER_3                                    (DWORD)16                 
                             1212 ; 32   |#define ICOLL_SOURCE_GPIO_3                                     (DWORD)17                 
                             1213 ; 33   |#define ICOLL_SOURCE_SDRAM                                      (DWORD)18                 
                             1214 ; 34   |#define ICOLL_SOURCE_CDI                                        (DWORD)19                 
                             1215 ; 35   |
                             1216 ; 36   |#if (defined(DEVICE_3410) || defined(DEVICE_3310))
                             1217 ; 37   |
                             1218 ; 38   |#define ICOLL_SOURCE_USB_SOF                                    (DWORD)20                  
                             1219 ; 39   |#define ICOLL_SOURCE_USB_SET_INTERFACE_REQUEST                  (DWORD)21                  
                             1220 ; 40   |#define ICOLL_SOURCE_USB_HOST_RESET                             (DWORD)22                  
                             1221 ; 41   |#define ICOLL_SOURCE_USB_ENDPOINT_START                         (DWORD)23
                             1222 ; 42   |#define ICOLL_SOURCE_USB_ENDPOINT_0                             (DWORD)23                  
                             1223 ; 43   |#define ICOLL_SOURCE_USB_ENDPOINT_1                             (DWORD)24                  
                             1224 ; 44   |#define ICOLL_SOURCE_USB_ENDPOINT_2                             (DWORD)25                  
                             1225 ; 45   |#define ICOLL_SOURCE_USB_ENDPOINT_3                             (DWORD)26                  
                             1226 ; 46   |#define ICOLL_SOURCE_USB_ENDPOINT_4                             (DWORD)27                  
                             1227 ; 47   |#define ICOLL_SOURCE_USB_ENDPOINT_5                             (DWORD)28                    
                             1228 ; 48   |#define ICOLL_SOURCE_USB_ENDPOINT_6                             (DWORD)29                    
                             1229 ; 49   |#define ICOLL_SOURCE_USB_ENDPOINT_7                             (DWORD)30                    
                             1230 ; 50   |
                             1231 ; 51   |#else
                             1232 ; 52   |
                             1233 ; 53   |#define ICOLL_SOURCE_VDD_5V_CONNECTED                           (DWORD)20                  
                             1234 ; 54   |#define ICOLL_SOURCE_USB_CONTROLLER                             (DWORD)21                  
                             1235 ; 55   |#define ICOLL_SOURCE_USB_WAKEUP                                 (DWORD)22                  
                             1236 ; 56   |#define ICOLL_SOURCE_VDD_5V_DISCONNECTED                        (DWORD)23
                             1237 ; 57   |#define ICOLL_SOURCE_ESPI                                       (DWORD)24                  
                             1238 ; 58   |#define ICOLL_SOURCE_FILCO                                      (DWORD)25                  
                             1239 ; 59   |#define ICOLL_SOURCE_LRADC1                                     (DWORD)26                  
                             1240 ; 60   |#define ICOLL_SOURCE_RTC_ALARM                                  (DWORD)27                  
                             1241 ; 61   |#define ICOLL_SOURCE_LRADC2                                     (DWORD)28                  
                             1242 ; 62   |#define ICOLL_SOURCE_FLASH_ECC                                  (DWORD)29                    
                             1243 ; 63   |
                             1244 ; 64   |#endif
                             1245 ; 65   |
                             1246 ; 66   |#define ICOLL_SOURCE_CDSYNC                                     (DWORD)31                    
                             1247 ; 67   |#define ICOLL_SOURCE_CDSYNC_EXCEPTION                           (DWORD)32                     
                             1248 ; 68   |#define ICOLL_SOURCE_REED_SOLOMON                               (DWORD)33
                             1249 ; 69   |#define ICOLL_END_OF_TRUE_SOURCES                                ICOLL_SOURCE_REED_SOLOMON
                             1250 ; 70   |// The rest of these "sources" are not really ICOLL sources.  They are not
                             1251 ; 71   |//  routed through the ICOLL but are included here to make interrupt abstraction
                             1252 ; 72   |//  as simple as possible.  The ICOLL functions special-case these.
                             1253 ; 73   |#define ICOLL_SOURCE_I2C_RX_READY                               (DWORD)34
                             1254 ; 74   |#define ICOLL_SOURCE_I2C_RX_OVERFLOW                            (DWORD)35
                             1255 ; 75   |#define ICOLL_SOURCE_I2C_TX_EMPTY                               (DWORD)36
                             1256 ; 76   |#define ICOLL_SOURCE_I2C_TX_UNDERFLOW                           (DWORD)37
                             1257 ; 77   |#define ICOLL_SOURCE_SPI_COMPLETE                               (DWORD)38
                             1258 ; 78   |#define ICOLL_SOURCE_I2S_RX_OVERFLOW                            (DWORD)39
                             1259 ; 79   |#define ICOLL_SOURCE_I2S_TX_UNDERFLOW                           (DWORD)40
                             1260 ; 80   |#define ICOLL_SOURCE_I2S_RX_READY                               (DWORD)41
                             1261 ; 81   |#define ICOLL_SOURCE_I2S_TX_EMPTY                               (DWORD)42
                             1262 ; 82   |#define ICOLL_SOURCE_HARDWARE_RESET                             (DWORD)43
                             1263 ; 83   |#define ICOLL_SOURCE_STACK_ERROR                                (DWORD)44
                             1264 ; 84   |#define ICOLL_SOURCE_TRACE                                      (DWORD)45
                             1265 ; 85   |#define ICOLL_SOURCE_SWI                                        (DWORD)46
                             1266 ; 86   |#define ICOLL_SOURCE_IRQA                                       (DWORD)47
                             1267 ; 87   |#define ICOLL_SOURCE_BROWNOUT                                   (DWORD)48
                             1268 ; 88   |#define ICOLL_SOURCE_ILLEGAL_INSTRUCTION                        (DWORD)49
                             1269 ; 89   |#define ICOLL_SOURCE_END                                        ICOLL_SOURCE_ILLEGAL_INSTRUCTION
                             1270 ; 90   |#define ICOLL_NUM_SOURCES                                       ICOLL_SOURCE_END+1
                             1271 ; 91   |
                             1272 ; 92   |#define ICOLL_ICLENABLE_REG_0_LAST_SRC                          (DWORD)23
TASKING DSP2410 assembler v1.5r1 Build 138 SN 00100122
                                                                                                                                                                                                                                                       Page   6

M:ADDR CODE           CYCLES LINE SOURCELINE
                             1273 ; 93   |
                             1274 ; 94   |#define ICOLL_PRIORITY_000              0x000000
                             1275 ; 95   |#define ICOLL_PRIORITY_001              0x000001
                             1276 ; 96   |#define ICOLL_PRIORITY_010              0x000002
                             1277 ; 97   |#define ICOLL_PRIORITY_011              0x000003
                             1278 ; 98   |#define ICOLL_PRIORITY_100              0x000004
                             1279 ; 99   |#define ICOLL_PRIORITY_101              0x000005
                             1280 ; 100  |#define ICOLL_PRIORITY_110              0x000006
                             1281 ; 101  |#define ICOLL_PRIORITY_111              0x000007
                             1282 ; 102  |
                             1283 ; 103  |#define ICOLL_STEERING_IVL1             0x000000
                             1284 ; 104  |#define ICOLL_STEERING_IVL2             0x000001
                             1285 ; 105  |#define ICOLL_STEERING_IVL3             0x000002
                             1286 ; 106  |#define ICOLL_STEERING_IVL6             0x000003
                             1287 ; 107  |
                             1288 ; 108  |///////////////////////////////////////////////////////////////////////////////
                             1289 ; 109  |// ERRORS
                             1290 ; 110  |///////////////////////////////////////////////////////////////////////////////
                             1291 ; 111  |                                                                                          
                             1292 ; 112  |#define ICOLL_ERROR_INVALID_SOURCE              (RETCODE)0x000001
                             1293 ; 113  |
                             1294 ; 114  |///////////////////////////////////////////////////////////////////////////////
                             1295 ; 115  |// Structure definitions
                             1296 ; 116  |///////////////////////////////////////////////////////////////////////////////
                             1297 ; 117  |
                             1298 ; 118  |typedef void (*ISR_VECTOR)(void);
                             1299 ; 119  |
                             1300 ; 120  |typedef struct
                             1301 ; 121  |{
                             1302 ; 122  |    WORD wSource;
                             1303 ; 123  |    WORD wPriority;
                             1304 ; 124  |    WORD wSteering;
                             1305 ; 125  |} ICOLL_ELEMENT;
                             1306 ; 126  |
                             1307 ; 127  |///////////////////////////////////////////////////////////////////////////////
                             1308 ; 128  |// Prototypes
                             1309 ; 129  |///////////////////////////////////////////////////////////////////////////////
                             1310 ; 130  |
                             1311 ; 131  |void _reentrant IcollShutDown(void);
                             1312 ; 132  |RETCODE _reentrant IcollEnable(DWORD dwSource);
                             1313 ; 133  |RETCODE _reentrant IcollDisable(DWORD dwSource);
                             1314 ; 134  |BOOL _reentrant IcollGetStatus(DWORD dwSource);
                             1315 ; 135  |RETCODE _reentrant IcollSetPriority(DWORD dwSource, WORD wPriority);
                             1316 ; 136  |RETCODE _reentrant IcollSetSteering(DWORD dwSource, WORD wSteering);
                             1317 
                             1322 
                             1323 ; 137  |RETCODE _reentrant IcollInstallIsrVector(ISR_VECTOR pISR, WORD wSource);
                             1324 ; 138  |void _asmfunc IcollResetVectorTable(void);
                             1325 ; 139  |#endif // #ifndef _ICOLL_H
                             1326 
                             1328 
                             1329 ; 16   |
                             1330 ; 17   |#include "filesystem.h"
                             1331 
                             1333 
                             1334 ; 1    |////////////////////////////////////////////////////////////////////////////////
                             1335 ; 2    |//  Copyright(C) SigmaTel, Inc. 2001
                             1336 ; 3    |//
                             1337 ; 4    |//  File        : FileSystem.h
                             1338 ; 5    |//  Description : Header File for File System
                             1339 ; 6    |////////////////////////////////////////////////////////////////////////////////
                             1340 ; 7    |
                             1341 ; 8    |#ifndef _FILESYSTEM_H
                             1342 ; 9    |#define _FILESYSTEM_H
                             1343 ; 10   |
                             1344 ; 11   |#include "types.h"
                             1345 
                             1347 
                             1348 ; 1    |////////////////////////////////////////////////////////////////////////////////
                             1349 ; 2    |// Copyright(C) SigmaTel, Inc. 2000-2004
                             1350 ; 3    |//
                             1351 ; 4    |// Filename: types.h
                             1352 ; 5    |// Description: Standard data types
                             1353 ; 6    |////////////////////////////////////////////////////////////////////////////////
                             1354 ; 7    |
                             1355 ; 8    |#ifndef _TYPES_H
                             1356 ; 9    |#define _TYPES_H
                             1357 ; 10   |
                             1358 ; 11   |// TODO:  move this outta here!
                             1359 ; 12   |#if !defined(NOERROR)
                             1360 ; 13   |#define NOERROR 0
                             1361 ; 14   |#define SUCCESS 0
                             1362 ; 15   |#endif 
                             1363 ; 16   |#if !defined(SUCCESS)
                             1364 ; 17   |#define SUCCESS  0
                             1365 ; 18   |#endif
                             1366 ; 19   |#if !defined(ERROR)
                             1367 ; 20   |#define ERROR   -1
                             1368 ; 21   |#endif
                             1369 ; 22   |#if !defined(FALSE)
                             1370 ; 23   |#define FALSE 0
                             1371 ; 24   |#endif
                             1372 ; 25   |#if !defined(TRUE)
                             1373 ; 26   |#define TRUE  1
                             1374 ; 27   |#endif
                             1375 ; 28   |
                             1376 ; 29   |#if !defined(NULL)
                             1377 ; 30   |#define NULL 0
                             1378 ; 31   |#endif
                             1379 ; 32   |
                             1380 ; 33   |#define MAX_INT     0x7FFFFF
                             1381 ; 34   |#define MAX_LONG    0x7FFFFFffffff
                             1382 ; 35   |        // max positive unsigned long value: -1 == 0xFFFFFFffffff
                             1383 ; 36   |#define MAX_ULONG   (-1) 
                             1384 ; 37   |
                             1385 ; 38   |#define WORD_SIZE   24              // word size in bits
                             1386 ; 39   |#define BYTES_PER_WORD 3            // 8 bit bytes
                             1387 ; 40   |
                             1388 ; 41   |
                             1389 ; 42   |#define BYTE    unsigned char       // btVarName
                             1390 ; 43   |#define CHAR    signed char         // cVarName
                             1391 ; 44   |#define USHORT  unsigned short      // usVarName
                             1392 ; 45   |#define SHORT   unsigned short      // sVarName
                             1393 ; 46   |#define WORD    unsigned int        // wVarName
                             1394 ; 47   |#define INT     signed int          // iVarName
                             1395 ; 48   |#define DWORD   unsigned long       // dwVarName
                             1396 ; 49   |#define LONG    signed long         // lVarName
                             1397 ; 50   |#define BOOL    unsigned int        // bVarName
                             1398 ; 51   |#define FRACT   _fract              // frVarName
                             1399 ; 52   |#define LFRACT  long _fract         // lfrVarName
                             1400 ; 53   |#define CIRC    _circ               // cp<type prefix>VarName (see below)
                             1401 ; 54   |#define FLOAT   float               // fVarName
                             1402 ; 55   |#define DBL     double              // dVarName
                             1403 ; 56   |#define ENUM    enum                // eVarName
                             1404 ; 57   |#define CMX     _complex            // cmxVarName
                             1405 ; 58   |typedef WORD UCS3;                   // 
                             1406 ; 59   |
                             1407 ; 60   |#define UINT16  unsigned short
                             1408 ; 61   |#define UINT8   unsigned char   
                             1409 ; 62   |#define UINT32  unsigned long
                             1410 ; 63   |#define UINT64  unsigned long   // need to figure out how to do 64 bit values.  Or port exisiting code to only use 48 bit
                             1411 ; 64   |#define INT64   unsigned long   // need to figure out how to do 64 bit values.  Or port exisiting code to only use 48 bit
                             1412 ; 65   |#define WCHAR   UINT16
                             1413 ; 66   |
                             1414 ; 67   |//UINT128 is 16 bytes or 6 words
                             1415 ; 68   |typedef struct UINT128_3500 {   
                             1416 ; 69   |    int val[6];     
                             1417 ; 70   |} UINT128_3500;
                             1418 ; 71   |
                             1419 ; 72   |#define UINT128   UINT128_3500
                             1420 ; 73   |
                             1421 ; 74   |// Little endian word packed byte strings:   
                             1422 ; 75   |//      _packed BYTE bTextVarName[]="a string";  bText is a packed byte string prefix
                             1423 ; 76   |// Convert to big endian words by reordering bytes from high to low using swizzle.
                             1424 ; 77   |// Little endian word packed byte strings:   
                             1425 ; 78   |//      _packed BYTE bTextVarName[]="a string";  bText is a packed byte string prefix
                             1426 ; 79   |// Convert to big endian words by reordering bytes from high to low using swizzle.
                             1427 ; 80   |
                             1428 ; 81   |// Declare Memory Spaces To Use When Coding
                             1429 ; 82   |// A. Sector Buffers
                             1430 ; 83   |#define SECTOR_BUFFER_MEM_X _X
                             1431 ; 84   |#define SECTOR_BUFFER_MEM_Y _Y
                             1432 ; 85   |#define SECTOR_BUFFER_MEM SECTOR_BUFFER_MEM_X
                             1433 ; 86   |typedef WORD SECTOR_BUFFER_MEM SECTOR_BUFFER;
                             1434 ; 87   |typedef SECTOR_BUFFER * P_SECTOR_BUFFER;
                             1435 ; 88   |// B. Media DDI Memory
                             1436 ; 89   |#define MEDIA_DDI_MEM _Y
                             1437 ; 90   |
                             1438 ; 91   |
                             1439 ; 92   |
                             1440 ; 93   |// Pointers to linear structures are labeled as: p<type prefix>VarName
                             1441 ; 94   |// Examples of circular pointers:
                             1442 ; 95   |//    INT CIRC cpiVarName
                             1443 ; 96   |//    DWORD CIRC cpdwVarName
                             1444 ; 97   |
                             1445 ; 98   |#define RETCODE INT                 // rcVarName
                             1446 ; 99   |
                             1447 ; 100  |// generic bitfield structure
                             1448 ; 101  |struct Bitfield {
                             1449 ; 102  |    unsigned int B0  :1;
                             1450 ; 103  |    unsigned int B1  :1;
                             1451 ; 104  |    unsigned int B2  :1;
                             1452 ; 105  |    unsigned int B3  :1;
                             1453 ; 106  |    unsigned int B4  :1;
                             1454 ; 107  |    unsigned int B5  :1;
                             1455 ; 108  |    unsigned int B6  :1;
                             1456 ; 109  |    unsigned int B7  :1;
                             1457 ; 110  |    unsigned int B8  :1;
                             1458 ; 111  |    unsigned int B9  :1;
                             1459 ; 112  |    unsigned int B10 :1;
                             1460 ; 113  |    unsigned int B11 :1;
                             1461 ; 114  |    unsigned int B12 :1;
                             1462 ; 115  |    unsigned int B13 :1;
                             1463 ; 116  |    unsigned int B14 :1;
                             1464 ; 117  |    unsigned int B15 :1;
                             1465 ; 118  |    unsigned int B16 :1;
                             1466 ; 119  |    unsigned int B17 :1;
                             1467 ; 120  |    unsigned int B18 :1;
                             1468 ; 121  |    unsigned int B19 :1;
                             1469 ; 122  |    unsigned int B20 :1;
                             1470 ; 123  |    unsigned int B21 :1;
                             1471 ; 124  |    unsigned int B22 :1;
                             1472 ; 125  |    unsigned int B23 :1;
                             1473 ; 126  |};
                             1474 ; 127  |
                             1475 ; 128  |union BitInt {
                             1476 ; 129  |        struct Bitfield B;
                             1477 ; 130  |        int        I;
                             1478 ; 131  |};
                             1479 ; 132  |
                             1480 ; 133  |#define MAX_MSG_LENGTH 10
                             1481 ; 134  |struct CMessage
                             1482 ; 135  |{
                             1483 ; 136  |        unsigned int m_uLength;
                             1484 ; 137  |        unsigned int m_uMsg[MAX_MSG_LENGTH];
                             1485 ; 138  |};
                             1486 ; 139  |
                             1487 ; 140  |typedef struct {
                             1488 ; 141  |    WORD m_wLength;
                             1489 ; 142  |    WORD m_wMessage;
                             1490 ; 143  |    WORD m_wParams[MAX_MSG_LENGTH];
                             1491 ; 144  |} Message;
                             1492 ; 145  |
                             1493 ; 146  |struct MessageQueueDescriptor
                             1494 ; 147  |{
                             1495 ; 148  |        int *m_pBase;
                             1496 ; 149  |        int m_iModulo;
                             1497 ; 150  |        int m_iSize;
                             1498 ; 151  |        int *m_pHead;
                             1499 ; 152  |        int *m_pTail;
                             1500 ; 153  |};
                             1501 ; 154  |
                             1502 ; 155  |struct ModuleEntry
                             1503 ; 156  |{
                             1504 ; 157  |    int m_iSignaledEventMask;
                             1505 ; 158  |    int m_iWaitEventMask;
                             1506 ; 159  |    int m_iResourceOfCode;
                             1507 ; 160  |    struct MessageQueueDescriptor *m_pMessageQueue;
                             1508 ; 161  |    int _asmfunc (*m_pProcessEntryPoint)(union WaitMask Signals,struct MessageQueueDescriptor *);
                             1509 ; 162  |    int _asmfunc (*m_pInitFunction)(struct MessageQueueDescriptor *);
                             1510 ; 163  |    int m_uTimeOutHigh;
                             1511 ; 164  |    int m_uTimeOutLow;
                             1512 ; 165  |    int _asmfunc (*m_pBackgroundFunction)(struct MessageQueueDescriptor *);
                             1513 ; 166  |};
                             1514 ; 167  |
                             1515 ; 168  |union WaitMask{
                             1516 ; 169  |    struct B{
                             1517 ; 170  |        unsigned int m_bNone     :1;
                             1518 ; 171  |        unsigned int m_bMessage  :1;
                             1519 ; 172  |        unsigned int m_bTimer    :1;
                             1520 ; 173  |        unsigned int m_bButton   :1;
                             1521 ; 174  |    } B;
                             1522 ; 175  |    int I;
                             1523 ; 176  |} ;
                             1524 ; 177  |
                             1525 ; 178  |
                             1526 ; 179  |struct Button {
                             1527 ; 180  |        WORD wButtonEvent;
                             1528 ; 181  |        WORD wUnused[MAX_MSG_LENGTH];   
                             1529 ; 182  |};
                             1530 ; 183  |
TASKING DSP2410 assembler v1.5r1 Build 138 SN 00100122
                                                                                                                                                                                                                                                       Page   7

M:ADDR CODE           CYCLES LINE SOURCELINE
                             1531 ; 184  |struct Message {
                             1532 ; 185  |        WORD wMsgLength;
                             1533 ; 186  |        WORD wMsgCommand;
                             1534 ; 187  |        WORD wMsgParms[MAX_MSG_LENGTH-1];
                             1535 ; 188  |};
                             1536 ; 189  |
                             1537 ; 190  |union EventTypes {
                             1538 ; 191  |        struct CMessage msg;
                             1539 ; 192  |        struct Button Button ;
                             1540 ; 193  |        struct Message Message;
                             1541 ; 194  |};
                             1542 ; 195  |
                             1543 ; 196  |// next 2 used to get updater build to return correct protocol ver in scsi response.
                             1544 ; 197  |#define BUILD_TYPE_UPDATER  0x100
                             1545 ; 198  |#define BUILD_TYPE_HOSTLINK 0x101
                             1546 ; 199  |#define BUILD_TYPE_PLAYER   0x102
                             1547 ; 200  |
                             1548 ; 201  |// Resets part if RETAIL build. DEBUG build executes debug instruction to halt.
                             1549 ; 202  |#define SystemHalt() __asm(" include 'sysmacro.asm' \n error") 
                             1550 ; 203  |#define assert(x)    if(!(x)) __asm(" include 'sysmacro.asm' \n error")
                             1551 ; 204  |
                             1552 ; 205  |#if DEBUG
                             1553 ; 206  |// For DEBUG builds, DebugBuildAssert(condition) halts if condition evaluates to FALSE. 
                             1554 ; 207  |#define DebugBuildAssert(x)    if(!(x)) __asm(" debug ")
                             1555 ; 208  |#else 
                             1556 ; 209  |// For RETAIL builds, DebugBuildAssert(condition) does nothing & execution continues rather than halt or reset. 
                             1557 ; 210  |#define DebugBuildAssert(x)    
                             1558 ; 211  |#endif
                             1559 ; 212  |
                             1560 ; 213  |// Do this in your C files to make a reminder that's displayed during the build.
                             1561 ; 214  |//  #pragma asm
                             1562 ; 215  |//  WARN 'Note to builder: reminder to do this after verifying that'
                             1563 ; 216  |//  #pragma endasm
                             1564 ; 217  |
                             1565 ; 218  |
                             1566 ; 219  |#ifdef COLOR_262K
                             1567 ; 220  |#define RGB(r,g,b)    ((0x0000FC & (r)) << 10) | ((0x0000FC & (g)) << 4) | ((0x0000FC & (b)) >> 2)    //262k
                             1568 ; 221  |#elif defined(COLOR_65K)
                             1569 ; 222  |#define RGB(r,g,b)    ((0x0000F8 & (r)) << 8) | ((0x0000FC & (g)) << 3) | ((0x0000F8 & (b)) >> 3)  //65k
                             1570 ; 223  |#else
                             1571 ; 224  |#define RGB(r,g,b)       ((0x0000F0 & (r)) << 4) | (0x0000F0 & (g)) | ((0x0000F0 & (b)) >> 4)
                             1572 ; 225  |#endif
                             1573 ; 226  |    
                             1574 ; 227  |#endif // #ifndef _TYPES_H
                             1575 
                             1577 
                             1578 ; 12   |
                             1579 ; 13   |
                             1580 ; 14   |// File attributes
                             1581 ; 15   |#ifndef _FS_ATTRIBUTES
                             1582 ; 16   |#define _FS_ATTRIBUTES
                             1583 ; 17   |#define READ        1
                             1584 ; 18   |#define WRITE       2
                             1585 ; 19   |#define WRITE_PLUS  3
                             1586 ; 20   |#define APPEND      4
                             1587 ; 21   |#define TRUNCATE    8
                             1588 ; 22   |#define CREATE      16
                             1589 ; 23   |#endif
                             1590 ; 24   |
                             1591 ; 25   |//#ifndef FAT12
                             1592 ; 26   |//#define FAT12   1
                             1593 ; 27   |//#endif
                             1594 ; 28   |//
                             1595 ; 29   |#ifndef FAT16
                             1596 ; 30   |#define FAT16   2
                             1597 ; 31   |#endif
                             1598 ; 32   |
                             1599 ; 33   |#define MEM_SPACE_P 0x100000
                             1600 ; 34   |#define MEM_SPACE_Y 0x400000
                             1601 ; 35   |#define MEM_SPACE_X 0x800000
                             1602 ; 36   |
                             1603 ; 37   |#define FILE_SYS_MODE_READ  0
                             1604 ; 38   |#define FILE_SYS_MODE_WRITE 1
                             1605 ; 39   | 
                             1606 ; 40   |#define ATTR_READ_ONLY      0x01
                             1607 ; 41   |#define ATTR_HIDDEN         0x02
                             1608 ; 42   |#define ATTR_SYSTEM         0x04
                             1609 ; 43   |#define ATTR_VOLUME_ID      0x08
                             1610 ; 44   |#define ATTR_DIRECTORY      0x10
                             1611 ; 45   |#define ATTR_ARCHIVE        0x20
                             1612 ; 46   |#define ATTR_LONG_NAME      ATTR_READ_ONLY|ATTR_HIDDEN|ATTR_SYSTEM|ATTR_VOLUME_ID
                             1613 ; 47   |
                             1614 ; 48   |#define SEEK_SET           -1
                             1615 ; 49   |#define SEEK_CUR            0
                             1616 ; 50   |#define SEEK_END            1
                             1617 ; 51   |
                             1618 ; 52   |#define DEVICE_INSTALLED              (WORD)(0)
                             1619 ; 53   |#define DEVICE_NOT_FOUND              (WORD)(2)
                             1620 ; 54   |#define INVALID_FILESYSTEM                        (WORD)(3)
                             1621 ; 55   |#define DEVICE_INVALID                (WORD)(-1)
                             1622 ; 56   |#define DEVICE_ERROR_WRITE_PROTECTED  (WORD)(-2)
                             1623 ; 57   |
                             1624 ; 58   |#define MEDIA_SIZE_TOTAL_SECTORS    0
                             1625 ; 59   |#define MEDIA_SIZE_TOTAL_BYTES      1
                             1626 ; 60   |#define MEDIA_SIZE_BYTES_PER_SECTOR 2
                             1627 ; 61   |#define MEDIA_SIZE_IN_MEGABYTES     3     
                             1628 ; 62   |
                             1629 ; 63   |#define READ_TYPE_NORMAL            0
                             1630 ; 64   |#define READ_TYPE_FAT               1
                             1631 ; 65   |#define READ_TYPE_RAW               2
                             1632 ; 66   |
                             1633 ; 67   |
                             1634 ; 68   |#ifdef MEDIA_DDI_PARTIAL_SEQ_ENABLE
                             1635 ; 69   |    #define WRITE_TYPE_RANDOM                   0
                             1636 ; 70   |    #define WRITE_TYPE_SEQ_FIRST                1
                             1637 ; 71   |    #define WRITE_TYPE_SEQ_NEXT                 2
                             1638 ; 72   |    #define WRITE_TYPE_RESET_CLEAN_UP           3
                             1639 ; 73   |    #define WRITE_TYPE_PARTIAL_SEQ_FIRST        4
                             1640 ; 74   |    #define WRITE_TYPE_PARTIAL_SEQ_NEXT         5
                             1641 ; 75   |    #define WRITE_TYPE_PARTIAL_SEQ_LAST         6
                             1642 ; 76   |    #ifdef MEDIA_DDI_RAW_SECTOR_SERVER_ENABLE
                             1643 ; 77   |        #define WRITE_TYPE_RANDOM_RAW               7
                             1644 ; 78   |        #define WRITE_TYPE_SEQ_FIRST_RAW            8
                             1645 ; 79   |        #define WRITE_TYPE_SEQ_NEXT_RAW             9
                             1646 ; 80   |        #define WRITE_TYPE_PARTIAL_SEQ_FIRST_RAW    10
                             1647 ; 81   |        #define WRITE_TYPE_PARTIAL_SEQ_NEXT_RAW     11
                             1648 ; 82   |        #define WRITE_TYPE_PARTIAL_SEQ_LAST_RAW     12
                             1649 ; 83   |    #endif
                             1650 ; 84   |#else
                             1651 ; 85   |    #define WRITE_TYPE_RANDOM                   0
                             1652 ; 86   |    #define WRITE_TYPE_SEQ_FIRST                1
                             1653 ; 87   |    #define WRITE_TYPE_SEQ_NEXT                 2
                             1654 ; 88   |    #ifdef MEDIA_DDI_RAW_SECTOR_SERVER_ENABLE
                             1655 ; 89   |        #define WRITE_TYPE_RANDOM_RAW               3
                             1656 ; 90   |        #define WRITE_TYPE_SEQ_FIRST_RAW            4
                             1657 ; 91   |        #define WRITE_TYPE_SEQ_NEXT_RAW             5
                             1658 ; 92   |    #endif
                             1659 ; 93   |#endif
                             1660 ; 94   |    #define WRITE_TYPE_UNDEFINED 0xFFFFFF
                             1661 ; 95   |
                             1662 ; 96   |
                             1663 ; 97   |#ifndef MAX_FILENAME_LENGTH
                             1664 ; 98   |#define MAX_FILENAME_LENGTH 256
                             1665 ; 99   |#endif
                             1666 ; 100  |
                             1667 ; 101  |typedef struct {
                             1668 ; 102  |    WORD wNumberOfZones;
                             1669 ; 103  |    WORD wSizeInMegaBytes;
                             1670 ; 104  |} SMARTMEDIA_CHIP_INFO;
                             1671 ; 105  |
                             1672 ; 106  |typedef struct {
                             1673 ; 107  |    WORD wBootIdentification;
                             1674 ; 108  |    WORD wStartHeadNumber;
                             1675 ; 109  |    WORD wStartSectorNumber;
                             1676 ; 110  |    WORD wStartCylinderNumber;
                             1677 ; 111  |    WORD wSystemIdentification;
                             1678 ; 112  |    WORD wEndHeadNumber;
                             1679 ; 113  |    WORD wEndSectorNumber;
                             1680 ; 114  |    WORD wEndCylinderNumber;
                             1681 ; 115  |    WORD wStartLogicalSectorNumberHigh;
                             1682 ; 116  |    WORD wStartLogicalSectorNumberLow;
                             1683 ; 117  |    WORD wPartitionSizeHigh;
                             1684 ; 118  |    WORD wPartitionSizeLow;
                             1685 ; 119  |} SMARTMEDIA_PARTITION_TABLE;
                             1686 ; 120  |
                             1687 ; 121  |typedef struct {
                             1688 ; 122  |    WORD wWord0;
                             1689 ; 123  |    WORD wWord1;
                             1690 ; 124  |    WORD wWord2;
                             1691 ; 125  |} SMARTMEDIA_CIS_IDI_MANUFACTURER_NAME;
                             1692 ; 126  |
                             1693 ; 127  |typedef struct {
                             1694 ; 128  |    WORD wWord0;
                             1695 ; 129  |    WORD wWord1;
                             1696 ; 130  |} SMARTMEDIA_CIS_IDI_PRODUCT_NAME;
                             1697 ; 131  |
                             1698 ; 132  |typedef struct {
                             1699 ; 133  |    WORD wWord0;
                             1700 ; 134  |    WORD wWord1;
                             1701 ; 135  |} SMARTMEDIA_CIS_IDI_PRODUCT_VERSION;
                             1702 ; 136  |
                             1703 ; 137  |typedef struct {
                             1704 ; 138  |    WORD wWord0;
                             1705 ; 139  |    WORD wWord1;
                             1706 ; 140  |    WORD wWord2;
                             1707 ; 141  |    WORD wWord3;
                             1708 ; 142  |} SMARTMEDIA_CIS_IDI_SERIAL_NUMBER;
                             1709 ; 143  |
                             1710 ; 144  |typedef struct {
                             1711 ; 145  |    WORD wWord0;
                             1712 ; 146  |} SMARTMEDIA_CIS_IDI_MODEL_NUMBER;
                             1713 
                             1736 
                             1737 ; 147  |
                             1738 ; 148  |typedef struct {
                             1739 ; 149  |    SMARTMEDIA_CIS_IDI_MANUFACTURER_NAME ManufacturerName;
                             1740 ; 150  |    SMARTMEDIA_CIS_IDI_PRODUCT_NAME ProductName;
                             1741 ; 151  |    SMARTMEDIA_CIS_IDI_PRODUCT_VERSION ProductVersion;
                             1742 ; 152  |    SMARTMEDIA_CIS_IDI_SERIAL_NUMBER SerialNumber;
                             1743 ; 153  |    SMARTMEDIA_CIS_IDI_MODEL_NUMBER ModelNumber;
                             1744 ; 154  |} SMARTMEDIA_CIS_IDI_TABLE;
                             1745 
                             1767 
                             1768 ; 155  |   
                             1769 ; 156  |typedef struct {
                             1770 ; 157  |    WORD wPageSizeInBytes;
                             1771 ; 158  |    WORD wRedundantAreaSizeInBytes;
                             1772 ; 159  |    WORD wNumberOfPagesPerBlock;
                             1773 ; 160  |    WORD wNumberOfBlocksPerZone;
                             1774 ; 161  |    WORD wNumberOfZonesInMedia;
                             1775 ; 162  |    WORD wMediaSizeInMBytes;
                             1776 ; 163  |    SMARTMEDIA_PARTITION_TABLE * pPartitionTable;
                             1777 ; 164  |    SMARTMEDIA_CIS_IDI_TABLE * pCisIdiTable;
                             1778 ; 165  |    WORD wMediaFlagStatus;
                             1779 ; 166  |    WORD wNumberOfBlocksToTheCisIdiBlock;
                             1780 ; 167  |    WORD wTotalNumberOfPhysicalBlocks;
                             1781 ; 168  |    WORD wNumberOfSystemBlocks;
                             1782 ; 169  |} SMARTMEDIA_ENTRY_TABLE;
                             1783 ; 170  |
                             1784 ; 171  |typedef struct {
                             1785 ; 172  |    WORD wDevice;        
                             1786 ; 173  |    WORD wDirtyBlockFlag;
                             1787 ; 174  |    WORD wCleanTailFlag; 
                             1788 ; 175  |    WORD wLogDOSPage;    
                             1789 ; 176  |    WORD wSrcLogBlock;   
                             1790 ; 177  |    WORD wSrcPhyBlock;   
                             1791 ; 178  |    WORD wDestPhyBlock;  
                             1792 ; 179  |    WORD wStartSrcPage;  
                             1793 ; 180  |    WORD wStartDestPage; 
                             1794 ; 181  |    WORD wPagesToCopy;   
                             1795 ; 182  |    WORD wReplaceBuff;   
                             1796 ; 183  |    WORD wReplaceRdnt;
                             1797 ; 184  |    #ifdef MEDIA_DDI_PARTIAL_SEQ_ENABLE
                             1798 ; 185  |        WORD wFirstCount;
                             1799 ; 186  |        WORD wNextCount;
                             1800 ; 187  |        WORD wLastCount;
                             1801 ; 188  |    #endif
                             1802 ; 189  |} SMARTMEDIA_FWPPS_TABLE;
                             1803 ; 190  |
                             1804 ; 191  |typedef struct {
                             1805 ; 192  |    WORD wWord0;
                             1806 ; 193  |    WORD wWord1;
                             1807 ; 194  |    WORD wWord2;
                             1808 ; 195  |    WORD wWord3;
                             1809 ; 196  |} DIRECTORY_NAME;
                             1810 ; 197  |
                             1811 ; 198  |typedef struct {
                             1812 ; 199  |    WORD wWord0;
                             1813 ; 200  |    WORD wWord1;
                             1814 ; 201  |} DIRECTORY_EXTENSION;
                             1815 ; 202  |
                             1816 ; 203  |typedef struct {
                             1817 ; 204  |    WORD wWord0;
                             1818 ; 205  |    WORD wWord1;
                             1819 ; 206  |} DIRECTORY_SIZE;
                             1820 
                             1835 
                             1836 ; 207  |
                             1837 ; 208  |typedef struct {
                             1838 ; 209  |    DIRECTORY_NAME Name;
                             1839 ; 210  |    DIRECTORY_EXTENSION Extension;
TASKING DSP2410 assembler v1.5r1 Build 138 SN 00100122
                                                                                                                                                                                                                                                       Page   8

M:ADDR CODE           CYCLES LINE SOURCELINE
                             1840 ; 211  |    WORD wAttribute;
                             1841 ; 212  |    WORD wReserved[4];
                             1842 ; 213  |    WORD wCreationTime;
                             1843 ; 214  |    WORD wCreationData;
                             1844 ; 215  |    WORD wFirstCluster;
                             1845 ; 216  |    DIRECTORY_SIZE Size;
                             1846 ; 217  |    WORD wCurrentCluster;
                             1847 ; 218  |    WORD wPointer;
                             1848 ; 219  |    WORD wRecord;
                             1849 ; 220  |    WORD wRd;
                             1850 ; 221  |} DIRECTORY_FILE_CONTROL_BLOCK;
                             1851 ; 222  |
                             1852 ; 223  |// TODO:  clean this up.  There are two versions.
                             1853 ; 224  |struct FCB
                             1854 ; 225  |{
                             1855 ; 226  |    _packed BYTE m_szFileName[9];       //0-2
                             1856 ; 227  |    int     m_wReserved;                //3
                             1857 ; 228  |    _packed BYTE m_szExt[4];            //4-5
                             1858 ; 229  |    int     m_wAttributes;              //6
                             1859 ; 230  |    int     m_wReserved2[4];            //7,8,9,a
                             1860 ; 231  |    int     m_wTimeofCreation;          //b
                             1861 ; 232  |    int     m_wDateofCreation;          //c
                             1862 ; 233  |    int     m_wFirstCluster;            //d
                             1863 ; 234  |    int     m_wFileSizeHigh;            //e
                             1864 ; 235  |    int     m_wFileSizeLow;             //f
                             1865 ; 236  |};
                             1866 
                             1882 
                             1883 ; 237  |
                             1884 ; 238  |
                             1885 ; 239  |typedef struct {
                             1886 ; 240  |    WORD wFirstClusterCurrentDirectory;
                             1887 ; 241  |    WORD wFirstClusterParentDirectory;
                             1888 ; 242  |    WORD wAbsSectorCurrentlyCached;
                             1889 ; 243  |    WORD wCurrentRelativeSector;
                             1890 ; 244  |    WORD wNumberOfSectors;
                             1891 ; 245  |    WORD wCurrentRecordLoadedInDcb;
                             1892 ; 246  |    WORD wBufferedRecord;
                             1893 ; 247  |    WORD wMaxNumberRecordsCurrentDirectory;
                             1894 ; 248  |    WORD * pwPointerToBuffer;
                             1895 ; 249  |    WORD * pwPointerToPath;
                             1896 ; 250  |    DIRECTORY_FILE_CONTROL_BLOCK * pDirFcb;
                             1897 ; 251  |} DIRECTORY_CONTROL_BLOCK;
                             1898 ; 252  |
                             1899 ; 253  |typedef struct {
                             1900 ; 254  |    WORD wWord0;
                             1901 ; 255  |    WORD wWord1;
                             1902 ; 256  |    WORD wWord2;
                             1903 ; 257  |    WORD wWord3;
                             1904 ; 258  |} FILE_NAME;
                             1905 ; 259  |
                             1906 ; 260  |typedef struct {
                             1907 ; 261  |    WORD wWord0;
                             1908 ; 262  |    WORD wWord1;
                             1909 ; 263  |} FILE_EXTENSION;
                             1910 ; 264  |
                             1911 ; 265  |typedef struct {
                             1912 ; 266  |    WORD wWord0;
                             1913 ; 267  |    WORD wWord1;
                             1914 ; 268  |} FILE_SIZE;
                             1915 ; 269  |
                             1916 ; 270  |typedef union {
                             1917 ; 271  |    struct {
                             1918 ; 272  |        int Read        :1;
                             1919 ; 273  |        int Write       :1;
                             1920 ; 274  |        int Append      :1;
                             1921 ; 275  |        int Truncate    :1;
                             1922 ; 276  |        int Create      :1;
                             1923 ; 277  |        int Rsrv        :3;
                             1924 ; 278  |        int Mode        :8;
                             1925 ; 279  |        int Device      :8;
                             1926 ; 280  |    } B;
                             1927 ; 281  |    int I;
                             1928 ; 282  |} FILE_FLAGS;
                             1929 ; 283  |
                             1930 ; 284  |typedef struct {
                             1931 ; 285  |    WORD wWord0;
                             1932 ; 286  |    WORD wWord1;
                             1933 ; 287  |} FILE_BYTE_CURRENT;
                             1934 
                             1974 
                             1975 ; 288  |
                             1976 ; 289  |typedef struct {
                             1977 ; 290  |    FILE_NAME Name;
                             1978 ; 291  |    FILE_EXTENSION Extension;
                             1979 ; 292  |    WORD wAttributes;
                             1980 ; 293  |    WORD wReserved[4];
                             1981 ; 294  |    WORD wCreationTime;
                             1982 ; 295  |    WORD wCreationData;
                             1983 ; 296  |    WORD wFirstCluster;
                             1984 ; 297  |    FILE_SIZE Size;
                             1985 ; 298  |    WORD wCurrentCluster;
                             1986 ; 299  |    WORD wPointer;
                             1987 ; 300  |    WORD wRecord;
                             1988 ; 301  |    WORD wRd;
                             1989 ; 302  |    FILE_FLAGS Flags;
                             1990 ; 303  |    FILE_BYTE_CURRENT FcbByteCurrent;
                             1991 ; 304  |    WORD wFcbFlagEndOfCx;
                             1992 ; 305  |} FILE_CONTROL_BLOCK;    
                             1993 ; 306  |
                             1994 ; 307  |typedef struct {
                             1995 ; 308  |    WORD wWord0;
                             1996 ; 309  |    WORD wWord1;
                             1997 ; 310  |    WORD wWord2;
                             1998 ; 311  |    WORD wWord3;
                             1999 ; 312  |} VOLUME_LABEL;
                             2000 ; 313  |
                             2001 ; 314  |typedef struct {
                             2002 ; 315  |    WORD wFATPhysicalBlock1;
                             2003 ; 316  |    WORD wFATPhysicalBlock2;
                             2004 ; 317  |    WORD wFATPhysicalBlock3;
                             2005 ; 318  |    WORD wFATPhysicalBlock4;
                             2006 ; 319  |} FAT_PHYSICAL_BLOCK_LIST;
                             2007 
                             2014 
                             2015 ; 320  |
                             2016 ; 321  |typedef struct {
                             2017 ; 322  |    WORD wFATSectorInCache;
                             2018 ; 323  |    WORD wLastClusterFree;
                             2019 ; 324  |    WORD wNumberOfUsedClusters;
                             2020 ; 325  |    WORD wNumberOfFreeClusters;
                             2021 ; 326  |    WORD wNumberOfBadClusters;
                             2022 ; 327  |    WORD wNumberOfReservedClusters;
                             2023 ; 328  |    WORD wControl;
                             2024 ; 329  |    WORD * pwSectorCache;
                             2025 ; 330  |    FAT_PHYSICAL_BLOCK_LIST FATPhysicalLocationList;
                             2026 ; 331  |} FAT_TABLE;
                             2027 
                             2034 
                             2035 ; 332  |
                             2036 ; 333  |typedef struct {
                             2037 ; 334  |    WORD wStateMediaTable;
                             2038 ; 335  |    WORD wTypeFs;
                             2039 ; 336  |    WORD wBytesPerSector;
                             2040 ; 337  |    WORD wSectorsPerCluster;
                             2041 ; 338  |    WORD wNumberOfReservedSectors;
                             2042 ; 339  |    WORD wMaximumNumberOfFATs;
                             2043 ; 340  |    WORD wMaxRootDirectoryEntries;
                             2044 ; 341  |    WORD wTotalSectors;
                             2045 ; 342  |    WORD wNumberOfFATSectors;
                             2046 ; 343  |    WORD wNumberOfSectorsPerTrack;
                             2047 ; 344  |    WORD wNumberOfHeads;
                             2048 ; 345  |    WORD wNumberOfHiddenSectorsMSB;
                             2049 ; 346  |    WORD wNumberOfHiddenSectorsLSB;
                             2050 ; 347  |    WORD wTotalSectors32MSB;
                             2051 ; 348  |    WORD wTotalSectors32LSB;
                             2052 ; 349  |    WORD wDriverNumber;
                             2053 ; 350  |    WORD wExtendedBootSignature;
                             2054 ; 351  |    WORD wVolumeIDMSB;
                             2055 ; 352  |    WORD wVolumeIDLSB;
                             2056 ; 353  |    VOLUME_LABEL VolumeLabel;
                             2057 ; 354  |    WORD * pwWriteBuffer;
                             2058 ; 355  |    WORD wPrimaryFATRelativeSector;
                             2059 ; 356  |    WORD wSecondaryFATRelativeSector;
                             2060 ; 357  |    WORD wRootDirectoryRelativeSector;
                             2061 ; 358  |    WORD wFirstSectorNumberDataZone;
                             2062 ; 359  |    WORD wMaxNumberOfFATEntries;
                             2063 ; 360  |    WORD wRootDirectorySizeInSectors;
                             2064 ; 361  |    WORD wDataAreaSizeInSectors;
                             2065 ; 362  |} MEDIA_TABLE;
                             2066 
                             2125 
                             2126 ; 363  |
                             2127 ; 364  |typedef struct {
                             2128 ; 365  |    MEDIA_TABLE * pMediaTable;
                             2129 ; 366  |    DIRECTORY_CONTROL_BLOCK * pDirectoryControlBlock;
                             2130 ; 367  |    FAT_TABLE * pFATTable;
                             2131 ; 368  |} DEVICE_CONTROL_TABLE;
                             2132 ; 369  |    
                             2133 ; 370  |typedef struct {
                             2134 ; 371  |    WORD dwTotalSizeInMegaBytes;        // dwTotalSizeInMegaBytes is limited
                             2135 ; 372  |                                        //  to 2-bytes for compatibility with
                             2136 ; 373  |                                        //  older host drivers.
                             2137 ; 374  |    DWORD dwTotalNumberOfSectors;
                             2138 ; 375  |    DWORD dwTotalNumberOfBytes;
                             2139 ; 376  |    WORD wSectorSizeInBytes;
                             2140 ; 377  |} MEDIA_SIZE;
                             2141 ; 378  |
                             2142 ; 379  |typedef struct {
                             2143 ; 380  |    BOOL    bInstalled;
                             2144 ; 381  |    INT     iPbsSectorOffset;   // from the beginning of the data drive 
                             2145 ; 382  |    DWORD   dwSize;
                             2146 ; 383  |} DATA_DRIVE_PBS_LOC;
                             2147 ; 384  |extern  INT _reentrant FSFileOpen(_packed BYTE *fname,INT attribute, INT DeviceNumber);
                             2148 ; 385  |extern  INT _reentrant FSFastOpen(DWORD Key, INT attribute);
                             2149 ; 386  |extern  INT FSFileDelete(_packed BYTE *fname,INT DeviceNumber);
                             2150 ; 387  |extern  INT FSFileCreate(_packed BYTE *fname,INT DeviceNumber);
                             2151 ; 388  |extern  INT _reentrant FSChangeDir(_packed BYTE *dirname,INT DeviceNumber);
                             2152 ; 389  |extern  INT _reentrant FSCreateDir(_packed BYTE *dirname,INT DeviceNumber);
                             2153 ; 390  |extern  INT _reentrant FSDeleteDir(_packed BYTE *dirname,INT DeviceNumber);
                             2154 ; 391  |extern  INT _reentrant FSFileAppend(_packed BYTE *fname,INT DeviceNumber);
                             2155 ; 392  |extern  INT _reentrant FSFileRead(INT BytestoRead, INT Handle, INT memory_type, INT modulo, WORD *buffer);
                             2156 ; 393  |extern  INT _reentrant FSFileWrite(INT wNumberBytes, INT Handle, INT memory_type, INT iModulo, WORD *buffer);
                             2157 ; 394  |extern  INT _reentrant FSFileClose(INT Handle);
                             2158 ; 395  |extern  LONG _reentrant FSFileSize(INT HandleNumber);
                             2159 ; 396  |extern  LONG  FSSize(INT DeviceNum, INT TYPE);   
                             2160 ; 397  |extern  INT FSFreeClusters(INT Device);
                             2161 ; 398  |extern  INT BytesPerCluster(INT Device);
                             2162 ; 399  |
                             2163 ; 400  |
                             2164 ; 401  |
                             2165 ; 402  |//extern  INT FSFileCreate(_packed BYTE *pbFileName, BYTE bDevice);
                             2166 ; 403  |//extern  INT FSFileDelete(_packed BYTE *pbFileName, BYTE bDevice);
                             2167 ; 404  |extern  INT FSFileRename(_packed BYTE *pbCurFilename, _packed BYTE *pbNewFilename, BYTE bDevice);
                             2168 ; 405  |//extern  INT _reentrant FSFileAttribute(_packed BYTE *pbFilename, WORD wAttributes, BYTE bDevice);
                             2169 ; 406  |//extern  INT FSFileAppend(_packed BYTE *pbFileName, BYTE bDevice);
                             2170 ; 407  |//extern  INT FSFileOpen(_packed BYTE *pbFileName, WORD wAttributes, BYTE bDevice);
                             2171 ; 408  |//extern  INT FSFileClose(INT bHandle);
                             2172 ; 409  |//extern  INT FSFileRead(WORD wNumberBytes, BYTE bHandle, WORD wMemSpace, INT iModulo, WORD *pwBuffer);
                             2173 ; 410  |//extern  INT FSFileWrite(WORD wNumberBytes, BYTE bHandle, WORD wMemSpace, INT iModulo, WORD *pwBuffer);
                             2174 ; 411  |extern  INT _reentrant fseek( INT handle , LONG offset, INT iOrigin );
                             2175 ; 412  |extern  INT _reentrant FSFileEof(INT Handle);
                             2176 ; 413  |extern INT _reentrant FSFileAttribute(INT Attributes, _packed BYTE *fname, INT DeviceNumber);
                             2177 ; 414  |extern INT _reentrant FSFileAttributeClear(INT Attributes, _packed BYTE *fname, INT DeviceNumber);
                             2178 ; 415  |//extern  LONG FSFileSize(INT bHandle);
                             2179 ; 416  |extern _asmfunc INT FSPresent(BYTE bDevice);
                             2180 ; 417  |extern _asmfunc INT FSType(BYTE bDevice);
                             2181 ; 418  |//extern LONG FSSize(WORD wDevice, WORD wReturnType);
                             2182 ; 419  |//extern INT FSChangeDir(_packed BYTE *pbDirName, BYTE bDevice);
                             2183 ; 420  |//extern INT FSCreateDir(_packed BYTE *pbDirName, BYTE bDevice);
                             2184 ; 421  |//extern INT FSDeleteDir(_packed BYTE *pbDirName, BYTE bDevice);
                             2185 ; 422  |extern _asmfunc void SysLoadFATWrite(void);
                             2186 ; 423  |extern _asmfunc INT SysUnLoadFATWrite(void);
                             2187 ; 424  |extern LONG _reentrant ftell(INT iHandle);
                             2188 ; 425  |extern _asmfunc struct FCB * ReadDirectory(int iDevice, int iEntry);
                             2189 ; 426  |
                             2190 ; 427  |#endif
                             2191 
                             2193 
                             2194 ; 18   |#include "usb_api.h"
                             2195 
                             2197 
                             2198 ; 1    |////////////////////////////////////////////////////////////////////////////////
                             2199 ; 2    |// Copyright(C) SigmaTel, Inc. 2002 - 2003
                             2200 ; 3    |//
                             2201 ; 4    |// File : USB_API.H
                             2202 ; 5    |// Description : USB_API.H defines and structures definition for USB device
                             2203 ; 6    |//               driver API.
                             2204 ; 7    |//               This 
                             2205 ; 8    |////////////////////////////////////////////////////////////////////////////////
                             2206 ; 9    |
                             2207 ; 10   |#ifndef __usb_api_h__
                             2208 ; 11   |#define __usb_api_h__ 1
                             2209 ; 12   |
                             2210 ; 13   |#include "types.h"
                             2211 
                             2213 
                             2214 ; 1    |////////////////////////////////////////////////////////////////////////////////
                             2215 ; 2    |// Copyright(C) SigmaTel, Inc. 2000-2004
                             2216 ; 3    |//
                             2217 ; 4    |// Filename: types.h
TASKING DSP2410 assembler v1.5r1 Build 138 SN 00100122
                                                                                                                                                                                                                                                       Page   9

M:ADDR CODE           CYCLES LINE SOURCELINE
                             2218 ; 5    |// Description: Standard data types
                             2219 ; 6    |////////////////////////////////////////////////////////////////////////////////
                             2220 ; 7    |
                             2221 ; 8    |#ifndef _TYPES_H
                             2222 ; 9    |#define _TYPES_H
                             2223 ; 10   |
                             2224 ; 11   |// TODO:  move this outta here!
                             2225 ; 12   |#if !defined(NOERROR)
                             2226 ; 13   |#define NOERROR 0
                             2227 ; 14   |#define SUCCESS 0
                             2228 ; 15   |#endif 
                             2229 ; 16   |#if !defined(SUCCESS)
                             2230 ; 17   |#define SUCCESS  0
                             2231 ; 18   |#endif
                             2232 ; 19   |#if !defined(ERROR)
                             2233 ; 20   |#define ERROR   -1
                             2234 ; 21   |#endif
                             2235 ; 22   |#if !defined(FALSE)
                             2236 ; 23   |#define FALSE 0
                             2237 ; 24   |#endif
                             2238 ; 25   |#if !defined(TRUE)
                             2239 ; 26   |#define TRUE  1
                             2240 ; 27   |#endif
                             2241 ; 28   |
                             2242 ; 29   |#if !defined(NULL)
                             2243 ; 30   |#define NULL 0
                             2244 ; 31   |#endif
                             2245 ; 32   |
                             2246 ; 33   |#define MAX_INT     0x7FFFFF
                             2247 ; 34   |#define MAX_LONG    0x7FFFFFffffff
                             2248 ; 35   |        // max positive unsigned long value: -1 == 0xFFFFFFffffff
                             2249 ; 36   |#define MAX_ULONG   (-1) 
                             2250 ; 37   |
                             2251 ; 38   |#define WORD_SIZE   24              // word size in bits
                             2252 ; 39   |#define BYTES_PER_WORD 3            // 8 bit bytes
                             2253 ; 40   |
                             2254 ; 41   |
                             2255 ; 42   |#define BYTE    unsigned char       // btVarName
                             2256 ; 43   |#define CHAR    signed char         // cVarName
                             2257 ; 44   |#define USHORT  unsigned short      // usVarName
                             2258 ; 45   |#define SHORT   unsigned short      // sVarName
                             2259 ; 46   |#define WORD    unsigned int        // wVarName
                             2260 ; 47   |#define INT     signed int          // iVarName
                             2261 ; 48   |#define DWORD   unsigned long       // dwVarName
                             2262 ; 49   |#define LONG    signed long         // lVarName
                             2263 ; 50   |#define BOOL    unsigned int        // bVarName
                             2264 ; 51   |#define FRACT   _fract              // frVarName
                             2265 ; 52   |#define LFRACT  long _fract         // lfrVarName
                             2266 ; 53   |#define CIRC    _circ               // cp<type prefix>VarName (see below)
                             2267 ; 54   |#define FLOAT   float               // fVarName
                             2268 ; 55   |#define DBL     double              // dVarName
                             2269 ; 56   |#define ENUM    enum                // eVarName
                             2270 ; 57   |#define CMX     _complex            // cmxVarName
                             2271 ; 58   |typedef WORD UCS3;                   // 
                             2272 ; 59   |
                             2273 ; 60   |#define UINT16  unsigned short
                             2274 ; 61   |#define UINT8   unsigned char   
                             2275 ; 62   |#define UINT32  unsigned long
                             2276 ; 63   |#define UINT64  unsigned long   // need to figure out how to do 64 bit values.  Or port exisiting code to only use 48 bit
                             2277 ; 64   |#define INT64   unsigned long   // need to figure out how to do 64 bit values.  Or port exisiting code to only use 48 bit
                             2278 ; 65   |#define WCHAR   UINT16
                             2279 ; 66   |
                             2280 ; 67   |//UINT128 is 16 bytes or 6 words
                             2281 ; 68   |typedef struct UINT128_3500 {   
                             2282 ; 69   |    int val[6];     
                             2283 ; 70   |} UINT128_3500;
                             2284 ; 71   |
                             2285 ; 72   |#define UINT128   UINT128_3500
                             2286 ; 73   |
                             2287 ; 74   |// Little endian word packed byte strings:   
                             2288 ; 75   |//      _packed BYTE bTextVarName[]="a string";  bText is a packed byte string prefix
                             2289 ; 76   |// Convert to big endian words by reordering bytes from high to low using swizzle.
                             2290 ; 77   |// Little endian word packed byte strings:   
                             2291 ; 78   |//      _packed BYTE bTextVarName[]="a string";  bText is a packed byte string prefix
                             2292 ; 79   |// Convert to big endian words by reordering bytes from high to low using swizzle.
                             2293 ; 80   |
                             2294 ; 81   |// Declare Memory Spaces To Use When Coding
                             2295 ; 82   |// A. Sector Buffers
                             2296 ; 83   |#define SECTOR_BUFFER_MEM_X _X
                             2297 ; 84   |#define SECTOR_BUFFER_MEM_Y _Y
                             2298 ; 85   |#define SECTOR_BUFFER_MEM SECTOR_BUFFER_MEM_X
                             2299 ; 86   |typedef WORD SECTOR_BUFFER_MEM SECTOR_BUFFER;
                             2300 ; 87   |typedef SECTOR_BUFFER * P_SECTOR_BUFFER;
                             2301 ; 88   |// B. Media DDI Memory
                             2302 ; 89   |#define MEDIA_DDI_MEM _Y
                             2303 ; 90   |
                             2304 ; 91   |
                             2305 ; 92   |
                             2306 ; 93   |// Pointers to linear structures are labeled as: p<type prefix>VarName
                             2307 ; 94   |// Examples of circular pointers:
                             2308 ; 95   |//    INT CIRC cpiVarName
                             2309 ; 96   |//    DWORD CIRC cpdwVarName
                             2310 ; 97   |
                             2311 ; 98   |#define RETCODE INT                 // rcVarName
                             2312 ; 99   |
                             2313 ; 100  |// generic bitfield structure
                             2314 ; 101  |struct Bitfield {
                             2315 ; 102  |    unsigned int B0  :1;
                             2316 ; 103  |    unsigned int B1  :1;
                             2317 ; 104  |    unsigned int B2  :1;
                             2318 ; 105  |    unsigned int B3  :1;
                             2319 ; 106  |    unsigned int B4  :1;
                             2320 ; 107  |    unsigned int B5  :1;
                             2321 ; 108  |    unsigned int B6  :1;
                             2322 ; 109  |    unsigned int B7  :1;
                             2323 ; 110  |    unsigned int B8  :1;
                             2324 ; 111  |    unsigned int B9  :1;
                             2325 ; 112  |    unsigned int B10 :1;
                             2326 ; 113  |    unsigned int B11 :1;
                             2327 ; 114  |    unsigned int B12 :1;
                             2328 ; 115  |    unsigned int B13 :1;
                             2329 ; 116  |    unsigned int B14 :1;
                             2330 ; 117  |    unsigned int B15 :1;
                             2331 ; 118  |    unsigned int B16 :1;
                             2332 ; 119  |    unsigned int B17 :1;
                             2333 ; 120  |    unsigned int B18 :1;
                             2334 ; 121  |    unsigned int B19 :1;
                             2335 ; 122  |    unsigned int B20 :1;
                             2336 ; 123  |    unsigned int B21 :1;
                             2337 ; 124  |    unsigned int B22 :1;
                             2338 ; 125  |    unsigned int B23 :1;
                             2339 ; 126  |};
                             2340 ; 127  |
                             2341 ; 128  |union BitInt {
                             2342 ; 129  |        struct Bitfield B;
                             2343 ; 130  |        int        I;
                             2344 ; 131  |};
                             2345 ; 132  |
                             2346 ; 133  |#define MAX_MSG_LENGTH 10
                             2347 ; 134  |struct CMessage
                             2348 ; 135  |{
                             2349 ; 136  |        unsigned int m_uLength;
                             2350 ; 137  |        unsigned int m_uMsg[MAX_MSG_LENGTH];
                             2351 ; 138  |};
                             2352 ; 139  |
                             2353 ; 140  |typedef struct {
                             2354 ; 141  |    WORD m_wLength;
                             2355 ; 142  |    WORD m_wMessage;
                             2356 ; 143  |    WORD m_wParams[MAX_MSG_LENGTH];
                             2357 ; 144  |} Message;
                             2358 ; 145  |
                             2359 ; 146  |struct MessageQueueDescriptor
                             2360 ; 147  |{
                             2361 ; 148  |        int *m_pBase;
                             2362 ; 149  |        int m_iModulo;
                             2363 ; 150  |        int m_iSize;
                             2364 ; 151  |        int *m_pHead;
                             2365 ; 152  |        int *m_pTail;
                             2366 ; 153  |};
                             2367 ; 154  |
                             2368 ; 155  |struct ModuleEntry
                             2369 ; 156  |{
                             2370 ; 157  |    int m_iSignaledEventMask;
                             2371 ; 158  |    int m_iWaitEventMask;
                             2372 ; 159  |    int m_iResourceOfCode;
                             2373 ; 160  |    struct MessageQueueDescriptor *m_pMessageQueue;
                             2374 ; 161  |    int _asmfunc (*m_pProcessEntryPoint)(union WaitMask Signals,struct MessageQueueDescriptor *);
                             2375 ; 162  |    int _asmfunc (*m_pInitFunction)(struct MessageQueueDescriptor *);
                             2376 ; 163  |    int m_uTimeOutHigh;
                             2377 ; 164  |    int m_uTimeOutLow;
                             2378 ; 165  |    int _asmfunc (*m_pBackgroundFunction)(struct MessageQueueDescriptor *);
                             2379 ; 166  |};
                             2380 ; 167  |
                             2381 ; 168  |union WaitMask{
                             2382 ; 169  |    struct B{
                             2383 ; 170  |        unsigned int m_bNone     :1;
                             2384 ; 171  |        unsigned int m_bMessage  :1;
                             2385 ; 172  |        unsigned int m_bTimer    :1;
                             2386 ; 173  |        unsigned int m_bButton   :1;
                             2387 ; 174  |    } B;
                             2388 ; 175  |    int I;
                             2389 ; 176  |} ;
                             2390 ; 177  |
                             2391 ; 178  |
                             2392 ; 179  |struct Button {
                             2393 ; 180  |        WORD wButtonEvent;
                             2394 ; 181  |        WORD wUnused[MAX_MSG_LENGTH];   
                             2395 ; 182  |};
                             2396 ; 183  |
                             2397 ; 184  |struct Message {
                             2398 ; 185  |        WORD wMsgLength;
                             2399 ; 186  |        WORD wMsgCommand;
                             2400 ; 187  |        WORD wMsgParms[MAX_MSG_LENGTH-1];
                             2401 ; 188  |};
                             2402 ; 189  |
                             2403 ; 190  |union EventTypes {
                             2404 ; 191  |        struct CMessage msg;
                             2405 ; 192  |        struct Button Button ;
                             2406 ; 193  |        struct Message Message;
                             2407 ; 194  |};
                             2408 ; 195  |
                             2409 ; 196  |// next 2 used to get updater build to return correct protocol ver in scsi response.
                             2410 ; 197  |#define BUILD_TYPE_UPDATER  0x100
                             2411 ; 198  |#define BUILD_TYPE_HOSTLINK 0x101
                             2412 ; 199  |#define BUILD_TYPE_PLAYER   0x102
                             2413 ; 200  |
                             2414 ; 201  |// Resets part if RETAIL build. DEBUG build executes debug instruction to halt.
                             2415 ; 202  |#define SystemHalt() __asm(" include 'sysmacro.asm' \n error") 
                             2416 ; 203  |#define assert(x)    if(!(x)) __asm(" include 'sysmacro.asm' \n error")
                             2417 ; 204  |
                             2418 ; 205  |#if DEBUG
                             2419 ; 206  |// For DEBUG builds, DebugBuildAssert(condition) halts if condition evaluates to FALSE. 
                             2420 ; 207  |#define DebugBuildAssert(x)    if(!(x)) __asm(" debug ")
                             2421 ; 208  |#else 
                             2422 ; 209  |// For RETAIL builds, DebugBuildAssert(condition) does nothing & execution continues rather than halt or reset. 
                             2423 ; 210  |#define DebugBuildAssert(x)    
                             2424 ; 211  |#endif
                             2425 ; 212  |
                             2426 ; 213  |// Do this in your C files to make a reminder that's displayed during the build.
                             2427 ; 214  |//  #pragma asm
                             2428 ; 215  |//  WARN 'Note to builder: reminder to do this after verifying that'
                             2429 ; 216  |//  #pragma endasm
                             2430 ; 217  |
                             2431 ; 218  |
                             2432 ; 219  |#ifdef COLOR_262K
                             2433 ; 220  |#define RGB(r,g,b)    ((0x0000FC & (r)) << 10) | ((0x0000FC & (g)) << 4) | ((0x0000FC & (b)) >> 2)    //262k
                             2434 ; 221  |#elif defined(COLOR_65K)
                             2435 ; 222  |#define RGB(r,g,b)    ((0x0000F8 & (r)) << 8) | ((0x0000FC & (g)) << 3) | ((0x0000F8 & (b)) >> 3)  //65k
                             2436 ; 223  |#else
                             2437 ; 224  |#define RGB(r,g,b)       ((0x0000F0 & (r)) << 4) | (0x0000F0 & (g)) | ((0x0000F0 & (b)) >> 4)
                             2438 ; 225  |#endif
                             2439 ; 226  |    
                             2440 ; 227  |#endif // #ifndef _TYPES_H
                             2441 
                             2443 
                             2444 ; 14   |#include "project.h"
                             2445 
                             2447 
                             2448 ; 1    |/////////////////////////////////////////////////////////////////////////////////
                             2449 ; 2    |//  Copyright(C) SigmaTel, Inc. 2000-2004
                             2450 ; 3    |//  Filename: project.inc
                             2451 ; 4    |//  Description: 
                             2452 ; 5    |/////////////////////////////////////////////////////////////////////////////////
                             2453 ; 6    |
                             2454 ; 7    |#if (!defined(_PROJECT_INC))
                             2455 ; 8    |#define _PROJECT_INC 1
                             2456 ; 9    |
                             2457 ; 10   |#if defined(STMP_BUILD_PLAYER)
                             2458 ; 11   |#include "hwequ.h"
                             2459 ; 12   |#else 
                             2460 ; 13   |//include "regscodec.inc"
                             2461 ; 14   |#endif
                             2462 ; 15   |
                             2463 ; 16   |//////////////////////////////////////////////////////////////////////////////////
                             2464 ; 17   |// Uncomment next define to allow player boot if you have stfm1000 macro enabled (defaults ON) & 
                             2465 ; 18   |// your board crystal is not able to output nominal voltage range. Used in player main.asm. STMP00012148
                             2466 ; 19   |// Defining this will result in lower battery life (price of using a lower quality crystal). 
                             2467 ; 20   |// Those that want to save battery life and have good crystals that meet our HW team's specs can 
                             2468 ; 21   |// comment out this line to reduce crystal bias current and so battery current in player mode.  
                             2469 ; 22   |#define SUPPORT_MARGINAL_XTALS 1
                             2470 ; 23   |
TASKING DSP2410 assembler v1.5r1 Build 138 SN 00100122
                                                                                                                                                                                                                                                       Page  10

M:ADDR CODE           CYCLES LINE SOURCELINE
                             2471 ; 24   |/////////////////////////////////////////////////////////////////////////////////
                             2472 ; 25   |// BOOT SPEED CONFIG & ASSOCIATED BATTERY VOLTAGE CHECK ENABLE
                             2473 ; 26   |/////////////////////////////////////////////////////////////////////////////////
                             2474 ; 27   |// Users can enable one of ATTEMPT_FAST_BOOT or FASTEST boot or neither project define below by defining
                             2475 ; 28   |// values as 0 or 1, else it defaults to the boot speed used in previous SDKs.
                             2476 ; 29   |#define ATTEMPT_FAST_BOOT 1
                             2477 ; 30   |#define ATTEMPT_FASTEST_BOOT 0   
                             2478 ; 31   |// Changing this define to 0 removes Vbat threshholding & unconditionally gives fast boot config above- 
                             2479 ; 32   |// disabling this check is suggested for profiling if you want to try to tweak down threshholds by maybe 50mV.
                             2480 ; 33   |// Also the tests should clear the fast boot config defines to link & boot at normal speed.
                             2481 ; 34   |#define SPEED_BOOT_BATTERY_CHECK 1
                             2482 ; 35   |
                             2483 ; 36   |/////////////////////////////////////////////////////////////////////////////////
                             2484 ; 37   |// MEDIA DEFINITIONS
                             2485 ; 38   |/////////////////////////////////////////////////////////////////////////////////
                             2486 ; 39   |
                             2487 ; 40   |/////////////////////////////////////////////////////////////////////////////////
                             2488 ; 41   |// MNAND - Number of chips forming the internal physical device (i.e. # of NANDs)
                             2489 ; 42   |#if defined(NAND1)
                             2490 ; 43   |#define SM_INTERNAL_CHIPS 1
                             2491 ; 44   |#else 
                             2492 ; 45   |#if defined(NAND2)
                             2493 ; 46   |#define SM_INTERNAL_CHIPS 2
                             2494 ; 47   |#else 
                             2495 ; 48   |#if defined(NAND3)
                             2496 ; 49   |#define SM_INTERNAL_CHIPS 3
                             2497 ; 50   |#else 
                             2498 ; 51   |#if defined(NAND4)
                             2499 ; 52   |#define SM_INTERNAL_CHIPS 4
                             2500 ; 53   |#else 
                             2501 ; 54   |#define SM_INTERNAL_CHIPS 1
                             2502 ; 55   |#endif
                             2503 ; 56   |#endif
                             2504 ; 57   |#endif
                             2505 ; 58   |#endif
                             2506 ; 59   |
                             2507 ; 60   |/////////////////////////////////////////////////////////////////////////////////
                             2508 ; 61   |// If SMARTMEDIA_DETECT_ACTIVE_HIGH is defined:
                             2509 ; 62   |//   SmartMedia will be detected as inserted if the GPIO pin reads 1 and removed if it reads 0.  
                             2510 ; 63   |// If SMARTMEDIA_DETECT_ACTIVE_HIGH is not defined ** comment out next line **
                             2511 ; 64   |//   SmartMedia will be detected as inserted if the GPIO pin reads 0 and removed if it reads 1.
                             2512 ; 65   |//*** comment out if active high ****
                             2513 ; 66   |//SMARTMEDIA_DETECT_ACTIVE_HIGH  equ     1
                             2514 ; 67   |
                             2515 ; 68   |#if defined(SMEDIA)
                             2516 ; 69   |#define NUM_REMOVABLE_MEDIA 1
                             2517 ; 70   |#define NUM_SM_EXTERNAL 1
                             2518 ; 71   |#define MMC_MAX_PHYSICAL_DEVICES 0
                             2519 ; 72   |#define SM_MAX_LOGICAL_DEVICES 2
                             2520 ; 73   |#else 
                             2521 ; 74   |#if defined(MMC)
                             2522 ; 75   |#define NUM_REMOVABLE_MEDIA 1
                             2523 ; 76   |#define NUM_SM_EXTERNAL 0
                             2524 ; 77   |#define MMC_MAX_PHYSICAL_DEVICES 1
                             2525 ; 78   |#define SM_MAX_LOGICAL_DEVICES 1
                             2526 ; 79   |#else 
                             2527 ; 80   |#define NUM_REMOVABLE_MEDIA 0
                             2528 ; 81   |#define NUM_SM_EXTERNAL 0
                             2529 ; 82   |#define MMC_MAX_PHYSICAL_DEVICES 0
                             2530 ; 83   |#define SM_MAX_LOGICAL_DEVICES 1
                             2531 ; 84   |#endif
                             2532 ; 85   |#endif
                             2533 ; 86   |
                             2534 ; 87   |/////////////////////////////////////////////////////////////////////////////////
                             2535 ; 88   |// Mass Storage Class definitions
                             2536 ; 89   |/////////////////////////////////////////////////////////////////////////////////
                             2537 ; 90   |// Set to 0 if Composite Device build is desired.    
                             2538 ; 91   |#define MULTI_LUN_BUILD 1   
                             2539 ; 92   |
                             2540 ; 93   |////////////////////////////////////////////////////////////////////////////////
                             2541 ; 94   |//  SCSI
                             2542 ; 95   |#if (MULTI_LUN_BUILD==0)
                             2543 ; 96   |  #if (NUM_REMOVABLE_MEDIA == 1)
                             2544 ; 97   |    #define SCSI_NUM_TARGETS                        2
                             2545 ; 98   |    #define SCSI_DEVICE_NUM_LUNS_DEV_0              1
                             2546 ; 99   |    #define SCSI_DEVICE_NUM_LUNS_DEV_1              1
                             2547 ; 100  |  #else
                             2548 ; 101  |    #define SCSI_NUM_TARGETS                        1
                             2549 ; 102  |    #define SCSI_DEVICE_NUM_LUNS_DEV_0              1
                             2550 ; 103  |  #endif
                             2551 ; 104  |#else
                             2552 ; 105  |    #define SCSI_NUM_TARGETS                        1
                             2553 ; 106  |  #if (NUM_REMOVABLE_MEDIA == 1)
                             2554 ; 107  |    #define SCSI_DEVICE_NUM_LUNS_DEV_0              2
                             2555 ; 108  |  #else
                             2556 ; 109  |    #define SCSI_DEVICE_NUM_LUNS_DEV_0              1  
                             2557 ; 110  |  #endif
                             2558 ; 111  |#endif
                             2559 ; 112  |
                             2560 ; 113  |
                             2561 ; 114  |#define USBMSC_NUM_DEVICES                      SCSI_NUM_TARGETS
                             2562 ; 115  |
                             2563 ; 116  |
                             2564 ; 117  |////////////////////////////////////////////////////////////////////////////////
                             2565 ; 118  |// Define number of logical medias and drives for three builds (MTP, USBMSC, and Player)
                             2566 ; 119  |////////////////////////////////////////////////////////////////////////////////
                             2567 ; 120  |#ifdef MMC
                             2568 ; 121  |#ifdef MTP_BUILD
                             2569 ; 122  |// --------------------
                             2570 ; 123  |// MTP and MMC
                             2571 ; 124  |// --------------------
                             2572 ; 125  |#define NUM_LOGICAL_MEDIA       2
                             2573 ; 126  |#define NUM_LOGICAL_DRIVES      8
                             2574 ; 127  |#else  // ifndef MTP_BUILD
                             2575 ; 128  |#ifdef STMP_BUILD_PLAYER
                             2576 ; 129  |// --------------------
                             2577 ; 130  |// Player and MMC
                             2578 ; 131  |// --------------------
                             2579 ; 132  |#else
                             2580 ; 133  |// --------------------
                             2581 ; 134  |// USBMSC and MMC
                             2582 ; 135  |// --------------------
                             2583 ; 136  |#define NUM_LOGICAL_MEDIA       3
                             2584 ; 137  |#define NUM_LOGICAL_DRIVES      8
                             2585 ; 138  |#endif // ifdef STMP_BUILD_PLAYER
                             2586 ; 139  |#endif // ifdef MTP_BUILD
                             2587 ; 140  |#else  // ifndef MMC
                             2588 ; 141  |#ifdef MTP_BUILD
                             2589 ; 142  |// --------------------
                             2590 ; 143  |// MTP and NAND only
                             2591 ; 144  |// --------------------
                             2592 ; 145  |#define NUM_LOGICAL_MEDIA       1
                             2593 ; 146  |#define NUM_LOGICAL_DRIVES      7
                             2594 ; 147  |#else  // ifndef MTP_BUILD
                             2595 ; 148  |#ifdef STMP_BUILD_PLAYER
                             2596 ; 149  |// --------------------
                             2597 ; 150  |// Player and NAND only
                             2598 ; 151  |// --------------------
                             2599 ; 152  |#else
                             2600 ; 153  |// --------------------
                             2601 ; 154  |// USBMSC and NAND only
                             2602 ; 155  |// --------------------
                             2603 ; 156  |#define NUM_LOGICAL_MEDIA       2
                             2604 ; 157  |#define NUM_LOGICAL_DRIVES      7
                             2605 ; 158  |#endif // ifdef STMP_BUILD_PLAYER
                             2606 ; 159  |#endif // ifdef MTP_BUILD
                             2607 ; 160  |#endif // ifdef MMC 
                             2608 ; 161  |
                             2609 ; 162  |// If we are in an MTP build then we don't use as many transfers buffers.
                             2610 ; 163  |#if (defined(MTP_BUILD))
                             2611 ; 164  |#define MAX_USB_TRANSFERS_QUEUED 16
                             2612 ; 165  |
                             2613 ; 166  |////!
                             2614 ; 167  |////! This varible holds the watchdog count for the store flush.
                             2615 ; 168  |////!
                             2616 ; 169  |///
                             2617 ; 170  |#include <types.h>
                             2618 ; 171  |extern volatile INT g_StoreWatchDogCount;
                             2619 ; 172  |extern const INT g_StoreWatchDogTimeout;
                             2620 ; 173  |#endif
                             2621 ; 174  |
                             2622 ; 175  |////////////////////////////////////////////////////////////////////////////////
                             2623 ; 176  |// These are needed here for Mass Storage Class
                             2624 ; 177  |// Needs to be cleaned up
                             2625 ; 178  |////////////////////////////////////////////////////////////////////////////////
                             2626 ; 179  |#if (!defined(STMP_BUILD_PLAYER))
                             2627 ; 180  |#define SCRATCH_USER_Y_SIZE 512
                             2628 ; 181  |#define SCRATCH_USER_X_SIZE 512
                             2629 ; 182  |
                             2630 ; 183  |#define BROWNOUT_LEVEL1_DETECTED                0x000001
                             2631 ; 184  |
                             2632 ; 185  |#endif
                             2633 ; 186  |
                             2634 ; 187  |
                             2635 ; 188  |/////////////////////////////////////////////////////////////////////////////////
                             2636 ; 189  |// SmartMedia/NAND defs
                             2637 ; 190  |#define SM_MAX_PHYSICAL_DEVICES SM_INTERNAL_CHIPS+NUM_SM_EXTERNAL
                             2638 ; 191  |#define SM_REMOVABLE_DEVICE_NUM SM_INTERNAL_CHIPS
                             2639 ; 192  |
                             2640 ; 193  |/////////////////////////////////////////////////////////////////////////////////
                             2641 ; 194  |// Sysloadresources defs
                             2642 ; 195  |#define SM_MAX_RESOURCE_DEVICES SM_INTERNAL_CHIPS+NUM_SM_EXTERNAL
                             2643 ; 196  |
                             2644 ; 197  |/////////////////////////////////////////////////////////////////////////////////
                             2645 ; 198  |// MMC defs
                             2646 ; 199  |#define MMC_MAX_PARTITIONS 1
                             2647 ; 200  |#define MMC_MAX_LOGICAL_DEVICES MMC_MAX_PHYSICAL_DEVICES*MMC_MAX_PARTITIONS
                             2648 ; 201  |
                             2649 ; 202  |/////////////////////////////////////////////////////////////////////////////////
                             2650 ; 203  |// SPI defs
                             2651 ; 204  |#define SPI_MAX_DEVICES MMC_MAX_PHYSICAL_DEVICES
                             2652 ; 205  |
                             2653 ; 206  |/////////////////////////////////////////////////////////////////////////////////
                             2654 ; 207  |// Global media defs
                             2655 ; 208  |#define MAX_PHYSICAL_DEVICES SM_MAX_PHYSICAL_DEVICES+MMC_MAX_PHYSICAL_DEVICES
                             2656 ; 209  |#define MAX_LOGICAL_DEVICES SM_MAX_LOGICAL_DEVICES+MMC_MAX_LOGICAL_DEVICES
                             2657 ; 210  |
                             2658 ; 211  |/////////////////////////////////////////////////////////////////////////////////
                             2659 ; 212  |// DO NOT CHANGE THESE!!!
                             2660 ; 213  |#define SM_MAX_PARTITIONS 4
                             2661 ; 214  |#define MAX_HANDLES 2
                             2662 ; 215  |/////////////////////////////////////////////////////////////////////////////////
                             2663 ; 216  |
                             2664 ; 217  |
                             2665 ; 218  |/////////////////////////////////////////////////////////////////////////////////
                             2666 ; 219  |// Battery LRADC Values 
                             2667 ; 220  |/////////////////////////////////////////////////////////////////////////////////
                             2668 ; 221  |// brownout trip point in mV (moved by RS)
                             2669 ; 222  |// BATT_SAFETY_MARGIN:  percentage value used by:
                             2670 ; 223  |//   * SysSaveSettings to determine if enough power is left to attempt a settings save. 
                             2671 ; 224  |//   * Recorder to conditionally prevent the start or continuation of 
                             2672 ; 225  |//     audio recording to media.
                             2673 ; 226  |#define BATT_SAFETY_MARGIN 10
                             2674 ; 227  |
                             2675 ; 228  |//; player resource drive refresh allowed only when battery usable % is above this value. 
                             2676 ; 229  |//; 50% of usable range [0.9V to 1.5V] is around 1.2V This is the safe target alkaline voltage to do a refresh.
                             2677 ; 230  |//; LIION will also require 50% which will work but that could be changed in the future. 
                             2678 ; 231  |//RESOURCE_REFRESH_MIN_BATT_PCT equ 50
                             2679 ; 232  |
                             2680 ; 233  |// stmp00005071 adds these for mp3 encode stability at low battery per battery type & mmc presence.
                             2681 ; 234  |
                             2682 ; 235  |//// Vbat threshholds empirically tuned by profiling max bat current for 3 HW cases: 
                             2683 ; 236  |//// 1 GigaByte MMC, NAND flash only, & LiIon Buck mode. See voicemenu pre-encode Vbat check.
                             2684 ; 237  |#if (!defined(CLCD))
                             2685 ; 238  |#define MP3_ENC_MMC_MIN_V_BAT_MV 1100
                             2686 ; 239  |#define MP3_ENC_NANDONLY_MIN_V_BAT_MV 1000
                             2687 ; 240  |#else 
                             2688 ; 241  |#define MP3_ENC_MMC_MIN_V_BAT_MV 1250
                             2689 ; 242  |#define MP3_ENC_NANDONLY_MIN_V_BAT_MV 1150
                             2690 ; 243  |#endif
                             2691 ; 244  |#define MP3_ENC_BUCKMODE_MIN_V_BAT_MV 3300
                             2692 ; 245  |
                             2693 ; 246  |// These Vbat use-range-percentages are derived to correspond with target battery 
                             2694 ; 247  |// voltages of 1.10V for MMC, 1.0V for nand only (alkaline or nimh), and 3.3V for any LiIon.
                             2695 ; 248  |// See mp3 encoder overlay.
                             2696 ; 249  |#define MP3_ENC_MMC_MIN_V_BAT_RANGE_PCT 33
                             2697 ; 250  |#define MP3_ENC_NANDONLY_MIN_V_BAT_RANGE_PCT 17
                             2698 ; 251  |#define MP3_ENC_BUCKMODE_MIN_V_BAT_RANGE_PCT 25
                             2699 ; 252  |
                             2700 ; 253  |/////////////////////////////////////////////////////////////////////////////////
                             2701 ; 254  |// Voice recording filenames
                             2702 ; 255  |// number of digits in filename Vxxx.wav
                             2703 ; 256  |/////////////////////////////////////////////////////////////////////////////////
                             2704 ; 257  |#define DIGITS_IN_VOICE_FILENAME 3   
                             2705 ; 258  |
                             2706 ; 259  |/////////////////////////////////////////////////////////////////////////////////
                             2707 ; 260  |// Mic Bias: Set this enable to 1 to internally generate mic bias voltage. 
                             2708 ; 261  |// Also below, must configure internal resistor value and pin to use for DC bias. 
                             2709 ; 262  |// Can set to 0 to disable internally generated mic bias voltage at pin lradc1/2.
                             2710 ; 263  |#if defined(DEVICE_3500)
                             2711 ; 264  |#define ENABLE_INTERNALLY_GENERATED_MICBIAS 1 
                             2712 ; 265  |// MIC BIAS circuit source selection: use Low Resolution ADC pin 2 or 1 to bias mic. 
                             2713 ; 266  |// Per your layout: select LRADC 2 or 1 below 
                             2714 ; 267  |//   (pin LRADC 2 for 35xx cpu card revB, LRADC 1 for 35xx cpu card revC, ref schematics, & demo player)
                             2715 ; 268  |#define LRADC_NUM_FOR_MIC_BIAS 1 
                             2716 ; 269  |// Sets internal mic bias R to value 2, 4, or 8 (in kOhms).
                             2717 ; 270  |#define MICBIAS_CONFIGURED_RESISTOR_KOHMS 8
                             2718 ; 271  |
                             2719 ; 272  |// Allows mic bias to settle before sampling. This delay currently unused. For rec btn when bias not yet ready.
                             2720 ; 273  |#define REC_BTN_INTERNAL_MIC_BIAS_SETTLING_DELAY_MS 400 
                             2721 ; 274  |// Option always keeps bias enabled after mainmenu init. This allows for start pop prevention if you use rec button from outside voice menu.
TASKING DSP2410 assembler v1.5r1 Build 138 SN 00100122
                                                                                                                                                                                                                                                       Page  11

M:ADDR CODE           CYCLES LINE SOURCELINE
                             2722 ; 275  |// This selection costs 1 mWatt but gains the desired low record button to sampling latency in the record-from-music-menu use-case.
                             2723 ; 276  |#define KEEP_MIC_BIAS_ENABLED 0
                             2724 ; 277  |
                             2725 ; 278  |#else 
                             2726 ; 279  |// STMP3410
                             2727 ; 280  |#define ENABLE_INTERNALLY_GENERATED_MICBIAS 0
                             2728 ; 281  |#define LRADC_NUM_FOR_MIC_BIAS 1 
                             2729 ; 282  |#define MICBIAS_CONFIGURED_RESISTOR_KOHMS 2
                             2730 ; 283  |#endif
                             2731 ; 284  |
                             2732 ; 285  |/////////////////////////////////////////////////////////////////////////////////
                             2733 ; 286  |// Number of available soft timers
                             2734 ; 287  |/////////////////////////////////////////////////////////////////////////////////
                             2735 ; 288  |#if defined(SYNC_LYRICS)
                             2736 ; 289  |#define SOFT_TIMERS 10
                             2737 ; 290  |#else 
                             2738 ; 291  |#if defined(JPEG_DECODER)
                             2739 ; 292  |#define SOFT_TIMERS 10
                             2740 ; 293  |#else 
                             2741 ; 294  |#define SOFT_TIMERS 9
                             2742 ; 295  |#endif
                             2743 ; 296  |#endif
                             2744 ; 297  |
                             2745 ; 298  |/////////////////////////////////////////////////////////////////////////////////
                             2746 ; 299  |//  sizes
                             2747 ; 300  |/////////////////////////////////////////////////////////////////////////////////
                             2748 ; 301  |#if defined(MMC)
                             2749 ; 302  |#if defined(USE_PLAYLIST5)
                             2750 ; 303  |#define MENU_STACK_SIZE 1500
                             2751 ; 304  |#else 
                             2752 ; 305  |#define MENU_STACK_SIZE 1250
                             2753 ; 306  |#endif //if @def('USE_PLAYLIST5')
                             2754 ; 307  |#else 
                             2755 ; 308  |#if defined(USE_PLAYLIST5)
                             2756 ; 309  |#define MENU_STACK_SIZE 1500
                             2757 ; 310  |#else 
                             2758 ; 311  |#define MENU_STACK_SIZE 1250
                             2759 ; 312  |#endif //if @def('USE_PLAYLIST5')
                             2760 ; 313  |#endif //if @def('MMC')
                             2761 ; 314  |
                             2762 ; 315  |// NOTE: SDK2.6 USED 550 FOR NEXT LINE, BUT SDK3.0BETA USED 750. Should it be ifdef MTP 750 else 550 for other builds? TOVERIFY. MYALLOC
                             2763 ; 316  |// 
                             2764 ; 317  |#define STACK_L1_SIZE 750
                             2765 ; 318  |#define STACK_L2_SIZE 100
                             2766 ; 319  |#define STACK_L3_SIZE 160
                             2767 ; 320  |
                             2768 ; 321  |// If we are in MTP mode the overlay task stack can shrink.
                             2769 ; 322  |// TODO shrink this stack for MTP, I will leave it at 500 until we verify that it 
                             2770 ; 323  |// is ok with switching code.
                             2771 ; 324  |#if defined(MTP_BUILD)
                             2772 ; 325  |#define OVERLAY_MANAGER_STACK_SIZE 300
                             2773 ; 326  |#endif
                             2774 ; 327  |
                             2775 ; 328  |/////////////////////////////////////////////////////////////////////////////////
                             2776 ; 329  |// maximum number of nested funclets 
                             2777 ; 330  |/////////////////////////////////////////////////////////////////////////////////
                             2778 ; 331  |#define MAX_NESTED_FUNCLET 6 
                             2779 ; 332  |
                             2780 ; 333  |/////////////////////////////////////////////////////////////////////////////////
                             2781 ; 334  |//    LCD DEFINITIONS
                             2782 ; 335  |/////////////////////////////////////////////////////////////////////////////////
                             2783 ; 336  |
                             2784 ; 337  |#define SPACE_CHAR 0x000020          
                             2785 ; 338  |#define ZERO_CHAR 0x000030
                             2786 ; 339  |#define COLON_CHAR 0x00003A
                             2787 ; 340  |#define PERIOD_CHAR 0x00002E
                             2788 ; 341  |
                             2789 ; 342  |#if (defined(S6B33B0A_LCD))
                             2790 ; 343  |#define LCD_X_SIZE 128
                             2791 ; 344  |#define LCD_Y_SIZE 159
                             2792 ; 345  |#endif
                             2793 ; 346  |
                             2794 ; 347  |#if (defined(SED15XX_LCD))
                             2795 ; 348  |#define LCD_X_SIZE 128
                             2796 ; 349  |#define LCD_Y_SIZE 64
                             2797 ; 350  |#endif
                             2798 ; 351  |
                             2799 ; 352  |
                             2800 ; 353  |//////////////////////////////////////////////////////////////////////////////////
                             2801 ; 354  |//   Details on Customizing Contrast
                             2802 ; 355  |/////////////////////////////////////////////////////////////////////////////////
                             2803 ; 356  |//   Max supported LCD range is 0 - 3F; however due to hardware/voltage differences
                             2804 ; 357  |//   the range of visibility is usually smaller than this.  It is important to 
                             2805 ; 358  |//   calibrate the visible range, because the contrast setting is saved.
                             2806 ; 359  |//   If the user shuts off the player while lcd is not visible, the player is useless
                             2807 ; 360  |//   unless the ezact sequence is remembered.
                             2808 ; 361  |//   To find out what range your player supports: 
                             2809 ; 362  |//   change these equs to full range or comment out (full range is default)
                             2810 ; 363  |//;;;;;;
                             2811 ; 364  |// uncomment the line below to build code that will provide raw contrast value
                             2812 ; 365  |// recommended calibration using player -- uncomment 
                             2813 ; 366  |//;;;;;;
                             2814 ; 367  |//CONTRAST_CALIBRATION    equ  1
                             2815 ; 368  |////////////////////////////
                             2816 ; 369  |#if (defined(DEMO_HW))
                             2817 ; 370  |// this is the setting for ET301 demos; Next 2 line have not been updated for new Shingyi LCD (June6'05)
                             2818 ; 371  |#define LCD_MAX_CONTRAST 0x32 
                             2819 ; 372  |#define LCD_MIN_CONTRAST 0x1E
                             2820 ; 373  |#else 
                             2821 ; 374  |
                             2822 ; 375  |#if (defined(S6B33B0A_LCD))
                             2823 ; 376  |#define LCD_MAX_CONTRAST 210
                             2824 ; 377  |#define LCD_MIN_CONTRAST 160    
                             2825 ; 378  |#endif
                             2826 ; 379  |
                             2827 ; 380  |#if (defined(SED15XX_LCD))
                             2828 ; 381  |// Next 3 line comment was for OLD shingyi LCD: (default LCD before sdk2.6)
                             2829 ; 382  |// Engineering board regs support range [17-37].
                             2830 ; 383  |//   Engineering board DC/DC support range [24-46]. 
                             2831 ; 384  |//   One default contrast range [24-42] works for both.
                             2832 ; 385  |// The 3 sets of contrast ranges below are updated for SDK2.6 to support either 
                             2833 ; 386  |// new or old ShingYih LCDs. "File" refers to \resource\shingyih\system_lcd_init_seq.src
                             2834 ; 387  |// 3/10/05 - Use one of the 2 next contrast ranges depending on which
                             2835 ; 388  |// ShingYih LCD you have.  See \resources\shingyi\readme.txt 
                             2836 ; 389  |// Optimal for NEW LCD with NEW file (SDK2.6 default)  
                             2837 ; 390  |// G098064-41 LCD module (present on engr board revH LCD card)
                             2838 ; 391  |
                             2839 ; 392  |#if (defined(NEWSHINGYIH))
                             2840 ; 393  |#define LCD_MAX_CONTRAST 250
                             2841 ; 394  |#define LCD_MIN_CONTRAST 0
                             2842 ; 395  |#else 
                             2843 ; 396  |//-----
                             2844 ; 397  |// Near optimal for OLD LCD with NEW file. 
                             2845 ; 398  |// NOT optimal for the new lcd but pretty good. So u may use this if u want 1 build for both LCDs.
                             2846 ; 399  |#define LCD_MAX_CONTRAST 250
                             2847 ; 400  |#define LCD_MIN_CONTRAST 0
                             2848 ; 401  |
                             2849 ; 402  |//=====
                             2850 ; 403  |// Optimal for OLD ShingYih LCD with OLD file (as sdk2.521)
                             2851 ; 404  |// Suggest going with default new init file & values above for your LCD instead of this historic ver.
                             2852 ; 405  |//LCD_MAX_CONTRAST equ 42
                             2853 ; 406  |//LCD_MIN_CONTRAST equ 24 
                             2854 ; 407  |
                             2855 ; 408  |#endif
                             2856 ; 409  |#endif
                             2857 ; 410  |
                             2858 ; 411  |#endif
                             2859 ; 412  |
                             2860 ; 413  |//////////////////////////////////////////////////////////////////////////////////
                             2861 ; 414  |// The default value of the lcd contrast in % of range
                             2862 ; 415  |//   the default value is used when no settings.dat is available
                             2863 ; 416  |//////////////////////////////////////////////////////////////////////////////////
                             2864 ; 417  |
                             2865 ; 418  |#if (defined(S6B33B0A_LCD))
                             2866 ; 419  |// 60% of range is default value
                             2867 ; 420  |#define DEFAULT_CONTRAST 50 
                             2868 ; 421  |#endif
                             2869 ; 422  |
                             2870 ; 423  |#if (defined(SED15XX_LCD))
                             2871 ; 424  |// % of range is default value (was 60%)
                             2872 ; 425  |#define DEFAULT_CONTRAST 50 
                             2873 ; 426  |#endif
                             2874 ; 427  |
                             2875 ; 428  |
                             2876 ; 429  |// percentage change per increment/decrement message (LCD_DEC_CONTRAST/LCD_INC_CONTRAST)
                             2877 ; 430  |// make lower when doing calibration
                             2878 ; 431  |#define LCD_STEPSIZE_CONTRAST 10  
                             2879 ; 432  |
                             2880 ; 433  |
                             2881 ; 434  |/////////////////////////////////////////////////////////////////////////////////
                             2882 ; 435  |// For FFWD and RWND
                             2883 ; 436  |/////////////////////////////////////////////////////////////////////////////////
                             2884 ; 437  |#define SECONDS_TO_SKIP 1
                             2885 ; 438  |#define SECONDS_TO_SKIP1 3
                             2886 ; 439  |#define SECONDS_TO_SKIP2 6
                             2887 ; 440  |// number of seconds to cause reset to begin of song for PREV push
                             2888 ; 441  |#define PREV_SONG_THRESHOLD 5  
                             2889 ; 442  |// number of 300 mSec periods before the numbers of seconds to skip increases
                             2890 ; 443  |#define FIRST_TIME_BOUNDARY 15 
                             2891 ; 444  |// number of 300 mSec periods before the numbers of seconds to skip increases
                             2892 ; 445  |#define SECOND_TIME_BOUNDARY 30 
                             2893 ; 446  |
                             2894 ; 447  |// For audible FFW/RWD
                             2895 ; 448  |#define SECONDS_TO_SKIP_FOR_3X_RATE 1
                             2896 ; 449  |#define SECONDS_TO_SKIP_FOR_60X_RATE 18
                             2897 ; 450  |#define SECONDS_TO_SKIP_FOR_600X_RATE 180
                             2898 ; 451  |#define SECONDS_TO_SKIP_FOR_1800X_RATE 540
                             2899 ; 452  |// number of 300 mSec periods before the numbers of seconds to skip increases
                             2900 ; 453  |#define LEVEL1_BOUNDARY 17 
                             2901 ; 454  |// number of 300 mSec periods before the numbers of seconds to skip increases
                             2902 ; 455  |#define LEVEL2_BOUNDARY 33 
                             2903 ; 456  |// number of 300 mSec periods before the numbers of seconds to skip increases
                             2904 ; 457  |#define LEVEL3_BOUNDARY 50 
                             2905 ; 458  |// Stmp00010296 Ticket #71685:  for song shorter than the min. skip size
                             2906 ; 459  |// if song_time < skip_size, bCurrentSongShort=>TRUE (ignore FWD/RWD commands)
                             2907 ; 460  |// Short Song Time, songs too short to play.
                             2908 ; 461  |#define SHORT_SONG_TIME SECONDS_TO_SKIP         
                             2909 ; 462  |
                             2910 ; 463  |/////////////////////////////////////////////////////////////////////////////////
                             2911 ; 464  |// MP3 Sync Values
                             2912 ; 465  |/////////////////////////////////////////////////////////////////////////////////
                             2913 ; 466  |// # bytes to look for sync before marking it bad
                             2914 ; 467  |#define MP3_SYNC_THRESHOLD 70000 
                             2915 ; 468  |// # bytes to look for sync before slowing decoder isr frequency (to let menus run)
                             2916 ; 469  |#define MP3_SYNC_THRESHOLD1 10000 
                             2917 ; 470  |// once we have sync'd, the isr should be called this frequently
                             2918 ; 471  |#define MP3_DECODERISR_FAST 7500  
                             2919 ; 472  |// if decoder is having difficulty syncing, switch isr to be called less frequently
                             2920 ; 473  |#define MP3_DECODERISR_SLOW 50000 
                             2921 ; 474  |
                             2922 ; 475  |
                             2923 ; 476  |/////////////////////////////////////////////////////////////////////////////////
                             2924 ; 477  |//// Multi-Stage Volume Control Definitions
                             2925 ; 478  |/////////////////////////////////////////////////////////////////////////////////
                             2926 ; 479  |//// Use Multi-Stage Volume
                             2927 ; 480  |#define MULTI_STAGE_VOLUME 0x1                  
                             2928 ; 481  |
                             2929 ; 482  |//// Master Volume definitions
                             2930 ; 483  |#define MIX_MSTR_MAX_VOL 0x0
                             2931 ; 484  |#define NUM_MSTR_ATT_STEPS (0x1F-MIX_MSTR_MAX_VOL)
                             2932 ; 485  |
                             2933 ; 486  |//// DAC-Mode definitions
                             2934 ; 487  |//// Adjusts 0dB point
                             2935 ; 488  |#define MIX_DAC_NOM_VOL 0x6                  
                             2936 ; 489  |#define MIX_DAC_MIN_VOL 0x1F
                             2937 ; 490  |// For minimum clipping: Set MIX_DAC_MAX_VOL below to match MIX_DAC_NOM_VOL value 2 lines above.
                             2938 ; 491  |// For additional gain (with possible clipping): Set MIX_DAC_MAX_VOL in range below. 
                             2939 ; 492  |//                                               Each integer below MIX_DAC_NOM_VOL provides 1.5 dB gain on Stmp34x0; 
                             2940 ; 493  |//                                               Max gain possible: 8 step diff would provide +12dB gain.   
                             2941 ; 494  |// range: [0 to MIX_DAC_NOM_VOL] (0 for loudest volume)
                             2942 ; 495  |#define MIX_DAC_MAX_VOL 0x0  
                             2943 ; 496  |
                             2944 ; 497  |#define NUM_DAC_ATT_STEPS (MIX_DAC_MIN_VOL-MIX_DAC_NOM_VOL+1)
                             2945 ; 498  |#define NUM_DAC_GAIN_STEPS (MIX_DAC_NOM_VOL-MIX_DAC_MAX_VOL)
                             2946 ; 499  |#define NUM_DAC_MODE_VOL_STEPS (NUM_DAC_ATT_STEPS+NUM_MSTR_ATT_STEPS+NUM_DAC_GAIN_STEPS+1)
                             2947 ; 500  |
                             2948 ; 501  |//// If there is no stored volume, set to 50% of DAC-Mode max; change if DAC Mode is not the default
                             2949 ; 502  |//// STMP35xx has 2dB attenuation per step so default needs a few more steps above midpoint.
                             2950 ; 503  |#define DEFAULT_VOLUME ((NUM_DAC_MODE_VOL_STEPS/2)+6)         
                             2951 ; 504  |
                             2952 ; 505  |//// Set maximum restored volume to 75% of DAC-Mode max; change if DAC Mode is not the default
                             2953 ; 506  |#define MAX_RESTORED_VOLUME ((3*NUM_DAC_MODE_VOL_STEPS)/4)   
                             2954 ; 507  |
                             2955 ; 508  |
                             2956 ; 509  |//// Line In definitions (used for Line-In 1)
                             2957 ; 510  |//// 0dB point of the Line In
                             2958 ; 511  |#define MIX_LINE_NOM_VOL 0x8                  
                             2959 ; 512  |//// Minimum volume of Line In
                             2960 ; 513  |#define MIX_LINE_MIN_VOL 0x1F                 
                             2961 ; 514  |//// Maximum volume of Line In (can adjust extra gain)
                             2962 ; 515  |#define MIX_LINE_MAX_VOL 0x6                  
                             2963 ; 516  |#define NUM_LINE_ATT_STEPS (MIX_LINE_MIN_VOL-MIX_LINE_NOM_VOL+1)
                             2964 ; 517  |#define NUM_LINE_GAIN_STEPS (MIX_LINE_NOM_VOL-MIX_LINE_MAX_VOL)
                             2965 ; 518  |#define NUM_LINE_MODE_VOL_STEPS (NUM_LINE_ATT_STEPS+NUM_MSTR_ATT_STEPS+NUM_LINE_GAIN_STEPS+1)
                             2966 ; 519  |
                             2967 ; 520  |//// Line In definitions (used for FM tuner with 144 pin package)
                             2968 ; 521  |//// 0dB point of the Line In
                             2969 ; 522  |#define MIX_FM_NOM_VOL 0x8                  
                             2970 ; 523  |//// Minimum volume of Line In
                             2971 ; 524  |#define MIX_FM_MIN_VOL 0x1F                 
                             2972 ; 525  |//// Maximum volume of Line In (can adjust extra gain)
TASKING DSP2410 assembler v1.5r1 Build 138 SN 00100122
                                                                                                                                                                                                                                                       Page  12

M:ADDR CODE           CYCLES LINE SOURCELINE
                             2973 ; 526  |#define MIX_FM_MAX_VOL 0x6                  
                             2974 ; 527  |#define NUM_FM_ATT_STEPS (MIX_FM_MIN_VOL-MIX_FM_NOM_VOL+1)
                             2975 ; 528  |#define NUM_FM_GAIN_STEPS (MIX_FM_NOM_VOL-MIX_FM_MAX_VOL)
                             2976 ; 529  |#define NUM_FM_MODE_VOL_STEPS (NUM_FM_ATT_STEPS+NUM_MSTR_ATT_STEPS+NUM_FM_GAIN_STEPS+1)
                             2977 ; 530  |
                             2978 ; 531  |/////////////////////////////////////////////////////////////////////////////////
                             2979 ; 532  |//// When enabled (1), periodically checks for one of several FM state machine invalid deadlock states & recovers. 
                             2980 ; 533  |//// Define as 0 to disable FM-deadlock-state checking and recovery.
                             2981 ; 534  |#define FM_WATCHDOG_ENABLE 1
                             2982 ; 535  |
                             2983 ; 536  |#if !defined(STMP_BUILD_PLAYER)
                             2984 ; 537  |////
                             2985 ; 538  |////! This varible holds the lcd display state for the mtp project.
                             2986 ; 539  |////
                             2987 ; 540  |///
                             2988 ; 541  |#include <types.h>
                             2989 ; 542  |extern volatile WORD g_wActivityState;
                             2990 ; 543  |#endif // if !@def('STMP_BUILD_PLAYER')
                             2991 ; 544  |
                             2992 ; 545  |void _reentrant Init5VSense(void);
                             2993 ; 546  |void _reentrant ServiceDCDC(void);
                             2994 ; 547  |
                             2995 ; 548  |////////////////////////////////////////////////////////////////////////////
                             2996 ; 549  |//// JPEG Thumbnail Mode Setting
                             2997 ; 550  |//// number of column in thumbnail mode
                             2998 ; 551  |#define THUMBNAIL_X 2           
                             2999 ; 552  |//// number of row in  thumbnail mode
                             3000 ; 553  |#define THUMBNAIL_Y 2           
                             3001 ; 554  |//// thumbnail boundary offset x
                             3002 ; 555  |#define THUMBNAIL_X_OFFSET 4            
                             3003 ; 556  |//// thumbnail boundary offset y
                             3004 ; 557  |#define THUMBNAIL_Y_OFFSET 4            
                             3005 ; 558  |
                             3006 ; 559  |#endif // if (!@def(_PROJECT_INC))
                             3007 ; 560  |
                             3008 
                             3010 
                             3011 ; 15   |
                             3012 ; 16   |#ifndef _USB_MEM
                             3013 ; 17   |//if not overwridden, default to the compiler default memory space
                             3014 ; 18   |#define _USB_MEM
                             3015 ; 19   |#endif
                             3016 ; 20   |
                             3017 ; 21   |#define USB_LANGUAGE_ENGLISH 0x0409
                             3018 ; 22   |#define USB_LANGUAGE_CHINESE_PRC 0x0804
                             3019 ; 23   |#define USB_LANGUAGE_CHINESE_TAIWAN 0x0404
                             3020 ; 24   |#define USB_LANGUAGE_JAPANESE 0x0411
                             3021 ; 25   |
                             3022 ; 26   |#define MAX_STRING 30
                             3023 ; 27   |
                             3024 ; 28   |#define  USB_SPEED_FULL                      (0)
                             3025 ; 29   |#define  USB_SPEED_LOW                       (1)
                             3026 ; 30   |#define  USB_SPEED_HIGH                      (2)
                             3027 ; 31   |
                             3028 ; 32   |#define EP_FS_MAX_PACKET_SIZE               (64)    
                             3029 ; 33   |
                             3030 ; 34   |#define EP_HS_MAX_PACKET_SIZE               (512)   
                             3031 ; 35   |
                             3032 ; 36   |// Data transferred to devices based on Sigmatel 3500 chip may sometimes be 
                             3033 ; 37   |// corrupted. The corruption occurs when device is connected in USB High Speed 
                             3034 ; 38   |// mode, and size of the transfer in bytes is divisible by 128, but not 
                             3035 ; 39   |// divisible by the packet size. The workaround is implemented in Microsoft MTP 
                             3036 ; 40   |// driver to allow support for those devices.
                             3037 ; 41   |
                             3038 ; 42   |// the bug can corrupt the end of data buffer. It occurs when host sends out a 
                             3039 ; 43   |// short packet that is multiple of 128 bytes. During this scenario the USB core
                             3040 ; 44   |// does writes that are voided (byte enable == all zero), which was an undefined 
                             3041 ; 45   |// capability and thus the gasket did not apply a proper response. This should 
                             3042 ; 46   |// not affect Mass Storage applications because data transfers are 512 bytes and 
                             3043 ; 47   |// scsi commands are < 16 bytes. Other applications with their own driver will
                             3044 ; 48   |// need to pad the packets if they fall into the error case. "What this basically 
                             3045 ; 49   |// boils down to is that any time the host sends a short packet of 128, 256 or
                             3046 ; 50   |// 384 bytes to a high-speed connected player a number of bytes will be corrupted.
                             3047 ; 51   |// This is easiest to reproduce in SendObject commands but can strike any of the 
                             3048 ; 52   |// commands that take an arbitrary amount of data.
                             3049 ; 53   |#define ARC_HS_128_MODULO_BUG               (128)
                             3050 ; 54   |
                             3051 ; 55   |
                             3052 ; 56   |/* Error codes */
                             3053 ; 57   |#define USB_OK                              (0x00)
                             3054 ; 58   |#define USBERR_REGISTER_SERVICE             (0x01)  // Failed to register a service
                             3055 ; 59   |#define USBERR_NO_SERVICE                   (0x02)  // No registered service found 
                             3056 ; 60   |#define USBERR_TX_FAILED                    (0x03)  // Fail to prepare XD descriptor
                             3057 ; 61   |#define USBERR_SIZE_TOO_LARGE               (0x04)  // Number of bytes to transfer is too large
                             3058 ; 62   |#define USBERR_EP_INIT_FAILED               (0x05)  // Endpoint init fail
                             3059 ; 63   |#define USBERR_CONFIG_FAILED                (0x06)  // Error reported by the application
                             3060 ; 64   |                                                    // if the new config failed or not supported
                             3061 ; 65   |#define USBERR_DEVICE_NOT_CONFIGURED        (0x07)  // Error reported by the transfer function
                             3062 ; 66   |                                                    // if attempting to transfer while the device
                             3063 ; 67   |                                                    // is not configured
                             3064 ; 68   |#define USBERR_INIT_FAILED                  (0x08)  // Fail to initialize the USB API
                             3065 ; 69   |
                             3066 ; 70   |
                             3067 ; 71   |/* Endpoint types */
                             3068 ; 72   |#define  USB_CONTROL_ENDPOINT             (0)
                             3069 ; 73   |#define  USB_ISOCHRONOUS_ENDPOINT         (1)
                             3070 ; 74   |#define  USB_BULK_ENDPOINT                (2)
                             3071 ; 75   |#define  USB_INTERRUPT_ENDPOINT           (3)
                             3072 ; 76   |
                             3073 ; 77   |/* End point direction */
                             3074 ; 78   |#define  USB_OUT                         (0)
                             3075 ; 79   |#define  USB_IN                          (1)
                             3076 ; 80   |
                             3077 ; 81   |/* End point packed size */
                             3078 ; 82   |#define  USB_FS_MAX_PACKET_SIZE           (64)
                             3079 ; 83   |#define  USB_HS_BULK_OUT_MAX_PACKET_SIZE  (256)
                             3080 ; 84   |#define  USB_HS_BULK_IN_MAX_PACKET_SIZE   (128)
                             3081 ; 85   |
                             3082 ; 86   |
                             3083 ; 87   |#define  USB_TEST_MODE_TEST_J             (0x01)
                             3084 ; 88   |#define  USB_TEST_MODE_TEST_K             (0x02)
                             3085 ; 89   |#define  USB_TEST_MODE_TEST_SE0_NAK       (0x03)
                             3086 ; 90   |#define  USB_TEST_MODE_TEST_PACKET        (0x04)
                             3087 ; 91   |
                             3088 ; 92   |/* Available service types */
                             3089 ; 93   |/* Services 0 through 15 are reserved for endpoints */
                             3090 ; 94   |#define  USB_SERVICE_EP0                  (0x00)
                             3091 ; 95   |#define  USB_SERVICE_EP1                  (0x01)
                             3092 ; 96   |#define  USB_SERVICE_EP2                  (0x02)
                             3093 ; 97   |#define  USB_SERVICE_EP3                  (0x03)
                             3094 ; 98   |#define  USB_SERVICE_EP4                  (0x04)
                             3095 ; 99   |#define  USB_SERVICE_EP5                  (0x05)
                             3096 ; 100  |#define  USB_SERVICE_EP6                  (0x06)
                             3097 ; 101  |#define  USB_SERVICE_EP7                  (0x07)
                             3098 ; 102  |#define  USB_SERVICE_EP8                  (0x08)
                             3099 ; 103  |#define  USB_SERVICE_EP9                  (0x09)
                             3100 ; 104  |#define  USB_SERVICE_EP10                 (0x0a)
                             3101 ; 105  |#define  USB_SERVICE_EP11                 (0x0b)
                             3102 ; 106  |#define  USB_SERVICE_EP12                 (0x0c)
                             3103 ; 107  |#define  USB_SERVICE_EP13                 (0x0d)
                             3104 ; 108  |#define  USB_SERVICE_EP14                 (0x0e)
                             3105 ; 109  |#define  USB_SERVICE_EP15                 (0x0f)
                             3106 ; 110  |#define  USB_SERVICE_BUS_RESET            (0x10)
                             3107 ; 111  |#define  USB_SERVICE_SUSPEND              (0x11)
                             3108 ; 112  |#define  USB_SERVICE_SOF                  (0x12)
                             3109 ; 113  |#define  USB_SERVICE_RESUME               (0x13)
                             3110 ; 114  |#define  USB_SERVICE_SLEEP                (0x14)
                             3111 ; 115  |#define  USB_SERVICE_SPEED_DETECTION      (0x15)
                             3112 ; 116  |#define  USB_SERVICE_TEST                 (0x16)
                             3113 ; 117  |#define  USB_SERVICE_CHANGE_CONFIG        (0x17)
                             3114 ; 118  |#define  USB_SERVICE_CHANGE_IFACE         (0x18)   
                             3115 ; 119  |#define  NON_EP_SERVICES                  (USB_SERVICE_SPEED_DETECTION - USB_SERVICE_EP15)
                             3116 ; 120  |
                             3117 ; 121  |// This is the maximum service structures allocated 
                             3118 ; 122  |// One for each End point + the common services (non endpoint services) 
                             3119 ; 123  |#define MAX_NUMBER_SERVICES               (MAX_NUM_EP + NON_EP_SERVICES)  
                             3120 ; 124  |
                             3121 ; 125  |#define NUMBER_BYTES_IN_SETUP               (8)
                             3122 ; 126  |
                             3123 ; 127  |// possible values of btStatus on the xd_struct
                             3124 ; 128  |#define  USB_STATUS_TRANSFER_IDLE           (0)
                             3125 ; 129  |#define  USB_STATUS_TRANSFER_SUCCESS        (1)            
                             3126 ; 130  |#define  USB_STATUS_TRANSFER_ACCEPTED       (2)
                             3127 ; 131  |#define  USB_STATUS_TRANSFER_IN_PROGRESS    (3)
                             3128 ; 132  |#define  USB_STATUS_TRANSFER_ERROR          (4)
                             3129 ; 133  |
                             3130 ; 134  |// types of status set/returned by set_status() and get_status()
                             3131 ; 135  |#define  USB_STATUS_DEVICE_STATE          (0x01)
                             3132 ; 136  |#define  USB_STATUS_INTERFACE             (0x02)
                             3133 ; 137  |#define  USB_STATUS_ADDRESS               (0x03)
                             3134 ; 138  |#define  USB_STATUS_CURRENT_CONFIG        (0x04)
                             3135 ; 139  |#define  USB_STATUS_SOF_COUNT             (0x05)
                             3136 ; 140  |#define  USB_STATUS                       (0x06)
                             3137 ; 141  |#define  USB_STATUS_TEST_MODE             (0x07)
                             3138 ; 142  |#define  USB_STATUS_DEVICE_SPEED          (0x08)  
                             3139 ; 143  |#define  USB_STATUS_DEVICE_TEST           (0x09)  
                             3140 ; 144  |#define  USB_STATUS_CURRENT_IFACE         (0x0a)
                             3141 ; 145  |#define  USB_STATUS_CONNECTION            (0x0b)  
                             3142 ; 146  |// For status endpoint, the endpoint number is coded in the less significant nibble
                             3143 ; 147  |#define  USB_STATUS_ENDPOINT              (0x10)
                             3144 ; 148  |#define  USB_STATUS_ENDPOINT_NUMBER_MASK  (0x0F)
                             3145 ; 149  |
                             3146 ; 150  |#define USB_MAX_SIZE_PER_TRANSFER       (0x4000)    // This is the maximum size that
                             3147 ; 151  |                                                    // we allow per transfer
                             3148 ; 152  |
                             3149 ; 153  |//Possible states the device can be in
                             3150 ; 154  |#define  USB_STATE_UNKNOWN                   (0xff)
                             3151 ; 155  |#define  USB_STATE_UNPLUGGED                 (0x05) // USB Cable unplugged
                             3152 ; 156  |#define  USB_STATE_PLUGGED                   (0x04) // USB Cable inserted
                             3153 ; 157  |#define  USB_STATE_POWERED                   (0x03)
                             3154 ; 158  |#define  USB_STATE_DEFAULT                   (0x02)
                             3155 ; 159  |#define  USB_STATE_ADDRESSED                 (0x01)
                             3156 ; 160  |#define  USB_STATE_CONFIGURED                (0x00)
                             3157 ; 161  |#define  USB_STATE_SUSPENDED                 (0x80)
                             3158 ; 162  |
                             3159 ; 163  |// Possible states the connection can be in
                             3160 ; 164  |//#define USB_STATE_UNKNOWN                 (0xff)
                             3161 ; 165  |#define USB_CONNECTED                       (0x00)
                             3162 ; 166  |#define USB_DISCONNECTED                    (0x01)
                             3163 ; 167  |
                             3164 ; 168  |
                             3165 ; 169  |
                             3166 ; 170  |typedef union
                             3167 ; 171  |{
                             3168 ; 172  |    struct
                             3169 ; 173  |    {
                             3170 ; 174  |        int Recipient               : 5;
                             3171 ; 175  |        int Type                    : 2;
                             3172 ; 176  |        int DataTransferDirection   : 1;
                             3173 ; 177  |        int Request                 : 8;
                             3174 ; 178  |        int                         : 8;
                             3175 ; 179  |    } B;
                             3176 ; 180  |    
                             3177 ; 181  |    int I;
                             3178 ; 182  |} USBRequestType ;
                             3179 
                             3193 
                             3194 ; 183  |
                             3195 ; 184  |typedef struct {
                             3196 ; 185  |   BYTE     bValid;
                             3197 ; 186  |   USBRequestType RequestType;
                             3198 ; 187  |   BYTE     btRequest;
                             3199 ; 188  |   WORD     wValue;
                             3200 ; 189  |   WORD     wIndex;
                             3201 ; 190  |   WORD     wLength;
                             3202 ; 191  |    } USB_SetupData;
                             3203 ; 192  |
                             3204 ; 193  |// Descriptor sizes in bytes
                             3205 ; 194  |#define SIZE_DEVICE_DESCRIPTOR_IN_BYTES     (18)
                             3206 ; 195  |#define SIZE_DEVICE_DESCRIPTOR_IN_WORDS     (6)
                             3207 ; 196  |#define SIZE_DEVICE_QUALIFIER_DESCRIPTOR_IN_BYTES   (10)
                             3208 ; 197  |#define SIZE_DEVICE_QUALIFIER_DESCRIPTOR_IN_WORDS   (4)
                             3209 ; 198  |#define SIZE_CONFIG_DESCRIPTOR_IN_BYTES     (9)
                             3210 ; 199  |#define SIZE_CONFIG_DESCRIPTOR_IN_WORDS     (3)
                             3211 ; 200  |#define SIZE_INTERFACE_DESCRIPTOR_IN_BYTES  (9)
                             3212 ; 201  |#define SIZE_INTERFACE_DESCRIPTOR_IN_WORDS  (3)
                             3213 ; 202  |#define SIZE_ENDPOINT_DESCRIPTOR_IN_BYTES   (7)
                             3214 ; 203  |
                             3215 ; 204  |
                             3216 ; 205  |// Descriptor types
                             3217 ; 206  |#define DESCRIPTOR_TYPE_DEVICE              (0x01)
                             3218 ; 207  |#define DESCRIPTOR_TYPE_CONFIG              (0x02)
                             3219 ; 208  |#define DESCRIPTOR_TYPE_STRING              (0x03)
                             3220 ; 209  |#define DESCRIPTOR_TYPE_INTERFACE           (0x04)
                             3221 ; 210  |#define DESCRIPTOR_TYPE_ENDPOINT            (0x05)
                             3222 ; 211  |#define DESCRIPTOR_TYPE_DEVICE_QUALIFIER    (0x06)
                             3223 ; 212  |#define DESCRIPTOR_TYPE_OTHER_SPEED_CONFIG  (0x07)
                             3224 ; 213  |#define DESCRIPTOR_TYPE_INTERFACE_POWER     (0x08)
                             3225 ; 214  |
                             3226 ; 215  |
                             3227 ; 216  |#define USB_REQUEST_DIRECTION_HOST_TO_DEVICE    ((WORD)0x000000)
                             3228 ; 217  |#define USB_REQUEST_DIRECTION_DEVICE_TO_HOST    ((WORD)0x000001)
                             3229 ; 218  |
                             3230 ; 219  |#define USB_REQUEST_TYPE_STANDARD               ((WORD)0x000000)
                             3231 ; 220  |#define USB_REQUEST_TYPE_CLASS                  ((WORD)0x000001)
                             3232 ; 221  |#define USB_REQUEST_TYPE_VENDOR                 ((WORD)0x000002)
                             3233 ; 222  |#define USB_REQUEST_TYPE_RESERVED               ((WORD)0x000003)
                             3234 ; 223  |
                             3235 ; 224  |#define USB_REQUEST_RECIPIENT_DEVICE            ((WORD)0x000000)
                             3236 ; 225  |#define USB_REQUEST_RECIPIENT_INTERFACE         ((WORD)0x000001)
                             3237 ; 226  |#define USB_REQUEST_RECIPIENT_ENDPOINT          ((WORD)0x000002)
TASKING DSP2410 assembler v1.5r1 Build 138 SN 00100122
                                                                                                                                                                                                                                                       Page  13

M:ADDR CODE           CYCLES LINE SOURCELINE
                             3238 ; 227  |#define USB_REQUEST_RECIPIENT_OTHER             ((WORD)0x000003)
                             3239 ; 228  |
                             3240 ; 229  |#define USB_REQUEST_STANDARD_GET_STATUS         ((WORD)0x000000)
                             3241 ; 230  |#define USB_REQUEST_STANDARD_CLEAR_FEATURE      ((WORD)0x000001)
                             3242 ; 231  |#define USB_REQUEST_STANDARD_RESERVED_1         ((WORD)0x000002)
                             3243 ; 232  |#define USB_REQUEST_STANDARD_SET_FEATURE        ((WORD)0x000003)
                             3244 ; 233  |#define USB_REQUEST_STANDARD_RESERVED_2         ((WORD)0x000004)
                             3245 ; 234  |#define USB_REQUEST_STANDARD_SET_ADDRESS        ((WORD)0x000005)
                             3246 ; 235  |#define USB_REQUEST_STANDARD_GET_DESCRIPTOR     ((WORD)0x000006)
                             3247 ; 236  |#define USB_REQUEST_STANDARD_SET_DESCRIPTOR     ((WORD)0x000007)
                             3248 ; 237  |#define USB_REQUEST_STANDARD_GET_CONFIGURATION  ((WORD)0x000008)
                             3249 ; 238  |#define USB_REQUEST_STANDARD_SET_CONFIGURATION  ((WORD)0x000009)
                             3250 ; 239  |#define USB_REQUEST_STANDARD_GET_INTERFACE      ((WORD)0x00000A)
                             3251 ; 240  |#define USB_REQUEST_STANDARD_SET_INTERFACE      ((WORD)0x00000B)
                             3252 ; 241  |#define USB_REQUEST_STANDARD_SYNCH_FRAME        ((WORD)0x00000C)
                             3253 ; 242  |
                             3254 ; 243  |#define USB_CLEAR_FEATURE_ENDPOINT_HALT         (0)
                             3255 ; 244  |#define USB_CLEAR_FEATURE_REMOTE_WAKEUP         (1)
                             3256 ; 245  |
                             3257 ; 246  |
                             3258 ; 247  |// Struct Device Descriptor
                             3259 ; 248  |typedef struct {
                             3260 ; 249  |    BYTE    bLength;                // (0) Size of this descriptor in bytes (18)
                             3261 ; 250  |    BYTE    btDescriptorType;       // (1) Device descriptor type (1)
                             3262 ; 251  |    BYTE    btBcdUsbLsb;            // (2) USB specification release number (for version 2.00 0x00)
                             3263 ; 252  |    BYTE    btBcdUsbMsb;            // (3)                                  (for version 2.00 0x02)     
                             3264 ; 253  |    BYTE    btDeviceClass;          // (4) Class code
                             3265 ; 254  |    BYTE    btDeviceSubclass;       // (5) Subclass code
                             3266 ; 255  |    BYTE    btDeviceProtocol;       // (6) Protocol code
                             3267 ; 256  |    BYTE    btMaxPacketSize0;       // (7) Maximum packet size for endpoint 0 (8, 16, 32 or 64)
                             3268 ; 257  |    BYTE    btIdVendorLsb;          // (8) Vendor Id
                             3269 ; 258  |    BYTE    btIdVendorMsb;          // (9)
                             3270 ; 259  |    BYTE    btIdProductLsb;         // (10) Product Id
                             3271 ; 260  |    BYTE    btIdProductMsb;         // (11)
                             3272 ; 261  |    BYTE    btBcdReleaseLsb;        // (12) Device release number in BCD
                             3273 ; 262  |    BYTE    btBcdReleaseMsb;        // (13)
                             3274 ; 263  |    BYTE    btIndexManufacturer;    // (14) Index of string descriptor describing Manufacturer
                             3275 ; 264  |    BYTE    btIndexProduct;         // (15) Index of string descriptor describing Product
                             3276 ; 265  |    BYTE    btIndexSerialNumber;    // (16) Index of string descriptor describing Device Serial Number
                             3277 ; 266  |    BYTE    btNumConfigurations;    // (17) Number of possible configurations
                             3278 ; 267  |} Struct_Standard_Dev_Desc;
                             3279 ; 268  |
                             3280 ; 269  |// Struct Device Qualifier Descriptor
                             3281 ; 270  |typedef struct {
                             3282 ; 271  |    BYTE    bLength;                // (0) Size of this descriptor in bytes (10)
                             3283 ; 272  |    BYTE    btDescriptorType;       // (1) Device descriptor type (6)
                             3284 ; 273  |    BYTE    btBcdUsbLsb;            // (2) USB specification release number (for version 2.00 0x00)
                             3285 ; 274  |    BYTE    btBcdUsbMsb;            // (3)                                  (for version 2.00 0x02)     
                             3286 ; 275  |    BYTE    btDeviceClass;          // (4) Class code
                             3287 ; 276  |    BYTE    btDeviceSubclass;       // (5) Subclass code
                             3288 ; 277  |    BYTE    btDeviceProtocol;       // (6) Protocol code
                             3289 ; 278  |    BYTE    btMaxPacketSize0;       // (7) Maximum packet size for endpoint 0 other speed (8, 16, 32 or 64)
                             3290 ; 279  |    BYTE    btNumConfigurations;    // (8) Number of other-speed possible configurations
                             3291 ; 280  |    BYTE    btReserved;             // (9) Reserved for future use, must be 0
                             3292 ; 281  |} Struct_Dev_Qualifier_Desc;
                             3293 ; 282  |
                             3294 ; 283  |// Struct Configuration Descriptor
                             3295 ; 284  |typedef struct {
                             3296 ; 285  |    BYTE    bLength;                // (0) Size of this descriptor in bytes (9)
                             3297 ; 286  |    BYTE    btDescriptorType;       // (1) Device descriptor type (2 or 7)
                             3298 ; 287  |    BYTE    btTotalLengthLsb;       // (2) Total length of data returned for this config.
                             3299 ; 288  |    BYTE    btTotalLengthMsb;       // (3)                                  
                             3300 ; 289  |    BYTE    btNumInterfaces;        // (4) Number of Interfaces supported by this configuration
                             3301 ; 290  |    BYTE    btConfigurationValue;   // (5) Value to use as an argument to the SetConfiguration() request
                             3302 ; 291  |    BYTE    btIndexConfiguration;   // (6) Index of string descriptor describing this configuration
                             3303 ; 292  |    BYTE    btBitMapAttributes;     // (7) Configuration Characteristics
                             3304 ; 293  |                                    //     D7:      Reserved (set to one)
                             3305 ; 294  |                                    //     D6:      Self-powered
                             3306 ; 295  |                                    //     D5:      Remote Wakeup
                             3307 ; 296  |                                    //     D4..0:   Reserved (reset to zero)        
                             3308 ; 297  |    BYTE    btMaxPower;             // (8) Maximum power consumption expressed in 2mA units.
                             3309 ; 298  |} Struct_Standard_Config_Desc, Struct_Other_Speed_Config_Desc;
                             3310 ; 299  |
                             3311 ; 300  |// Struct Interface Descriptor
                             3312 ; 301  |typedef struct {
                             3313 ; 302  |    BYTE    bLength;                // (0) Size of this descriptor in bytes (9)
                             3314 ; 303  |    BYTE    btDescriptorType;       // (1) Device descriptor type (4)
                             3315 ; 304  |    BYTE    btInterfaceNum;         // (2) Number of this interface. Zero-based value.
                             3316 ; 305  |    BYTE    btAlternateSetting;     // (3)                                  
                             3317 ; 306  |    BYTE    btNumEndpoints;         // (4) Number of endpointsused by this interface (excluding endpoint 0).
                             3318 ; 307  |    BYTE    btInterfaceClass;       // (5) Class code
                             3319 ; 308  |    BYTE    btInterfaceSubClass;    // (6) Sub Class code
                             3320 ; 309  |    BYTE    btInterfaceProtocol;    // (7) Protocol Code
                             3321 ; 310  |    BYTE    btIndexInterface;       // (8) Index of string descriptor describing this interface
                             3322 ; 311  |} Struct_Standard_Interface_Desc;
                             3323 ; 312  |
                             3324 ; 313  |// Struct Endpoint Descriptor
                             3325 ; 314  |typedef struct {
                             3326 ; 315  |    BYTE    bLength;                // (0) Size of this descriptor in bytes (7)
                             3327 ; 316  |    BYTE    btDescriptorType;       // (1) Device descriptor type (5)
                             3328 ; 317  |    BYTE    btEndpointAddress;      // (2) Address of the endpoint on the USB device described by this descriptor
                             3329 ; 318  |                                    //      Bit 3..0: Endpoint number
                             3330 ; 319  |                                    //      Bit 6..4: Reserved, reset to zero
                             3331 ; 320  |                                    //      Bit 7:    Direction. Ignored for control endpoints (0 OUT, 1 IN)
                             3332 ; 321  |    BYTE    btBitMapAttributes;     // (3) Endpoint attributes
                             3333 ; 322  |                                    //      bits 1..0: Transfer Type (00 Control, 01 Iso, 10 Bulk, 11 Int)
                             3334 ; 323  |                                    //      bits 5..2: If not an iso endpoints, they are reserved and must be reset to zero.
                             3335 ; 324  |                                    //      bits 7..6: Reserved bits, must be reset to zero.                                    
                             3336 ; 325  |    BYTE    btMaxPacketSizeLsb;     // (4) Maximum packet size. Refer to standard for bits specification
                             3337 ; 326  |    BYTE    btMaxPacketSizeMsb;     // (5)
                             3338 ; 327  |    BYTE    btInterval;             // (6) Interval for polling endpoint for data transfers (refer to standard)
                             3339 ; 328  |} Struct_Standard_Endpoint_Desc;
                             3340 ; 329  |
                             3341 ; 330  |typedef struct {
                             3342 ; 331  |    BYTE    btLength;                   // (0) Size of this descriptor in bytes (2*MAX_USB_LANG + 2)
                             3343 ; 332  |    BYTE    btDescriptorType;           // (1) String descriptor type (3)
                             3344 ; 333  |    BYTE    btString[MAX_STRING*2];       
                             3345 ; 334  |} Struct_String_Desc;
                             3346 ; 335  |
                             3347 ; 336  |//
                             3348 ; 337  |// Externals
                             3349 ; 338  |//
                             3350 ; 339  |extern void _reentrant usb_dci_chip_enable (void);
                             3351 ; 340  |extern void _reentrant usb_dci_shutdown(void);
                             3352 ; 341  |
                             3353 ; 342  |BYTE _reentrant usb_device_init(void);
                             3354 ; 343  |void _inline usb_device_shutdown(void)
                             3355 ; 344  |{
                             3356 ; 345  |    usb_dci_shutdown();
                             3357 ; 346  |}
                             3358 ; 347  |
                             3359 ; 348  |BYTE _reentrant usb_device_register_service(BYTE btType, void (* Service)(BOOL bSetup, BYTE btDirection, BYTE _USB_MEM * pbtBuffer, WORD wLength,WORD wPrivateData)); 
                             3360 ; 349  |//Remove unused function usb_device_get_service() to reclain _P memroy.
                             3361 ; 350  |//BYTE _reentrant usb_device_get_service(BYTE btType, void (* Service)(BOOL bSetup, BYTE btDirection, BYTE _USB_MEM * pbtBuffer, WORD wLength)); 
                             3362 ; 351  |
                             3363 ; 352  |BYTE _reentrant usb_device_init_endpoint(BYTE btEndpoint, USHORT usMaxPacketSize, BYTE btDirection, BYTE btType, BOOL bFlag);
                             3364 ; 353  |
                             3365 ; 354  |extern USB_SetupData *_reentrant usb_dci_get_setup_data(BYTE btEndpoint);
                             3366 
                             3375 
                             3376 ; 355  |#define usb_device_read_setup_data(btEndpoint) usb_dci_get_setup_data(btEndpoint)
                             3377 ; 356  |
                             3378 ; 357  |void _reentrant usb_device_get_status(BYTE btType, USHORT * pusStatus);
                             3379 ; 358  |void _reentrant usb_device_set_status(BYTE btType, USHORT usStatus);
                             3380 ; 359  |BYTE _reentrant usb_device_get_transfer_status(BYTE btEndpoint, BYTE btDirection);
                             3381 ; 360  |
                             3382 ; 361  |extern void _reentrant usb_dci_stall_endpoint(BYTE btEndpoint, BYTE btDirection);
                             3383 ; 362  |#define usb_device_stall_endpoint(btEndpoint, btDirection) usb_dci_stall_endpoint((btEndpoint), (btDirection))
                             3384 ; 363  |
                             3385 ; 364  |extern void _reentrant usb_dci_unstall_endpoint(BYTE btEndpoint, BYTE btDirection);
                             3386 ; 365  |#define usb_device_unstall_endpoint(btEndpoint, btDirection) usb_dci_unstall_endpoint((btEndpoint), (btDirection))
                             3387 ; 366  |
                             3388 ; 367  |extern void _reentrant usb_dci_finish_transaction(BYTE btEndpoint);
                             3389 ; 368  |#define usb_device_finish_transaction(btEndpoint) usb_dci_finish_transaction(btEndpoint);
                             3390 ; 369  |
                             3391 ; 370  |////////////////////////////////////////////////////////////////////////////////
                             3392 ; 371  |//
                             3393 ; 372  |//>  Name:          usb_device_enable
                             3394 ; 373  |//
                             3395 ; 374  |//   Type:          Function
                             3396 ; 375  |//
                             3397 ; 376  |//   Description:   Enables the USB device for transfers
                             3398 ; 377  |//
                             3399 ; 378  |//   Inputs:        none
                             3400 ; 379  |//
                             3401 ; 380  |//   Outputs:       USB_OK or error code
                             3402 ; 381  |//
                             3403 ; 382  |//   Notes:         none
                             3404 ; 383  |//<
                             3405 ; 384  |////////////////////////////////////////////////////////////////////////////////
                             3406 ; 385  |void _inline usb_device_enable(void)
                             3407 ; 386  |{
                             3408 ; 387  |    usb_dci_chip_enable();
                             3409 ; 388  |}
                             3410 ; 389  |
                             3411 ; 390  |void _reentrant usb_device_release(void);
                             3412 ; 391  |void _reentrant usb_device_hold(void);
                             3413 ; 392  |BYTE _reentrant usb_device_is_hold(void);
                             3414 ; 393  |void _reentrant usb_device_data_phase_required(void);
                             3415 ; 394  |
                             3416 ; 395  |BOOL _reentrant usb_device_is_first_init(void);
                             3417 ; 396  |void _reentrant usb_device_set_first_init(void);
                             3418 ; 397  |void _reentrant usb_device_clear_first_init(void);
                             3419 ; 398  |
                             3420 ; 399  |WORD _reentrant usb_get_current_limit(void);
                             3421 ; 400  |RETCODE _reentrant usb_set_current_limit(WORD);
                             3422 ; 401  |
                             3423 ; 402  |////////////////////////////////////////////////////////////////////
                             3424 ; 403  |extern BYTE _reentrant usb_dci_get_endpoint_status(BYTE btEndpoint);
                             3425 ; 404  |#define usb_device_get_endpoint_status(btEndpoint) usb_dci_get_endpoint_status(btEndpoint)
                             3426 ; 405  |
                             3427 ; 406  |#define USB_ENDPOINT_STATUS_OK                          0
                             3428 ; 407  |#define USB_ENDPOINT_STATUS_STALLED                     1
                             3429 ; 408  |#define USB_ENDPOINT_STATUS_RECIEVED_UNSTALL_REQUEST    2
                             3430 ; 409  |// WHQL
                             3431 ; 410  |#define USB_ENDPOINT_STATUS_HOST_STALLED                3
                             3432 ; 411  |////////////////////////////////////////////////////////////////////
                             3433 ; 412  |
                             3434 ; 413  |
                             3435 ; 414  |BYTE _reentrant usb_device_send_data(BYTE btEndpoint, WORD _X * pbtStmpWordAdd, BYTE btByteOffset, USHORT usSize, WORD wPrivateData, BOOL bIsDataPhase);
                             3436 ; 415  |BYTE _reentrant usb_device_recv_data(BYTE btEndpoint, WORD _X * pbtStmpWordAdd, BYTE btByteOffset, USHORT usSize, WORD wPrivateData, BOOL bIsDataPhase);
                             3437 ; 416  |void _reentrant ch9ServiceEp0(BOOL bSetup, BYTE btDirection, WORD _X *pbtBuffer, WORD wLength,WORD wPrivateData);
                             3438 ; 417  |BYTE _reentrant usb_device_transfer_data(BYTE btEndpoint, WORD _X* pbtStmpWordAdd, 
                             3439 ; 418  |                                         BYTE btByteOffset, USHORT usSize, WORD wPrivateData, 
                             3440 ; 419  |                                         BOOL bIsDataPhase, WORD wDirection);
                             3441 ; 420  |
                             3442 ; 421  |#ifndef CUSTOMIZE_UNICODE
                             3443 ; 422  |extern const BYTE g_Manufacturer[];
                             3444 ; 423  |extern const BYTE g_ProductName[];
                             3445 ; 424  |extern const BYTE g_ConfigString[];
                             3446 ; 425  |extern const BYTE g_Interface0String[];
                             3447 ; 426  |extern const BYTE g_Interface1String[];
                             3448 ; 427  |extern const BYTE g_MSOSDescriptorString[];
                             3449 ; 428  |#else   // CUSTOMIZE_UNICODE
                             3450 ; 429  |extern const WORD g_Manufacturer[];
                             3451 ; 430  |extern const WORD g_ProductName[];
                             3452 ; 431  |extern const WORD g_ConfigString[];
                             3453 ; 432  |extern const WORD g_Interface0String[];
                             3454 ; 433  |extern const WORD g_Interface1String[];
                             3455 ; 434  |extern const WORD g_MSOSDescriptorString[];
                             3456 ; 435  |#endif
                             3457 ; 436  |extern WORD g_LanguageList[];
                             3458 ; 437  |
                             3459 ; 438  |extern const BYTE g_SCSIVendorID[];
                             3460 ; 439  |extern const BYTE g_SCSIProductID[];
                             3461 ; 440  |extern void *g_pStrings[];
                             3462 ; 441  |
                             3463 ; 442  |extern WORD g_wUSBVendorID;
                             3464 ; 443  |extern WORD g_wUSBProductID;
                             3465 ; 444  |extern WORD g_wUSBReleaseID;
                             3466 ; 445  |
                             3467 ; 446  |#endif
                             3468 ; 447  |/* EOF */
                             3469 ; 448  |
                             3470 
                             3472 
                             3473 ; 19   |#include "usbmsc.h"
                             3474 
                             3476 
                             3477 ; 1    |////////////////////////////////////////////////////////////////////////////////
                             3478 ; 2    |// Copyright(C) SigmaTel, Inc. 2000-2001
                             3479 ; 3    |//
                             3480 ; 4    |// Filename: usbmsc.h
                             3481 ; 5    |// Description: 
                             3482 ; 6    |////////////////////////////////////////////////////////////////////////////////
                             3483 ; 7    |
                             3484 ; 8    |#ifndef _USBMSC_H
                             3485 ; 9    |#define _USBMSC_H
                             3486 ; 10   |
                             3487 ; 11   |////////////////////////////////////////////////////////////////////////////////
                             3488 ; 12   |// Includes
                             3489 ; 13   |////////////////////////////////////////////////////////////////////////////////
                             3490 ; 14   |
                             3491 ; 15   |#include "kernel.h"
                             3492 
                             3494 
                             3495 ; 1    |///////////////////////////////////////////////////////////////////////////////
                             3496 ; 2    |///
                             3497 ; 3    |/// Filename: kernel.h
                             3498 ; 4    |/// Description: 
                             3499 ; 5    |///
TASKING DSP2410 assembler v1.5r1 Build 138 SN 00100122
                                                                                                                                                                                                                                                       Page  14

M:ADDR CODE           CYCLES LINE SOURCELINE
                             3500 ; 6    |///
                             3501 ; 7    |/// Copyright (c) SigmaTel, Inc. Unpublished
                             3502 ; 8    |///
                             3503 ; 9    |/// SigmaTel, Inc.
                             3504 ; 10   |/// Proprietary  Confidential
                             3505 ; 11   |///
                             3506 ; 12   |/// This source code and the algorithms implemented therein constitute
                             3507 ; 13   |/// confidential information and may comprise trade secrets of SigmaTel, Inc.
                             3508 ; 14   |/// or its associates, and any use thereof is subject to the terms and
                             3509 ; 15   |/// conditions of the Confidential Disclosure Agreement pursuant to which this
                             3510 ; 16   |/// source code was originally received.
                             3511 ; 17   |///
                             3512 ; 18   |///////////////////////////////////////////////////////////////////////////////
                             3513 ; 19   |#ifndef __KERNEL_H
                             3514 ; 20   |#define __KERNEL_H
                             3515 ; 21   |
                             3516 ; 22   |
                             3517 ; 23   |#include "types.h"
                             3518 
                             3520 
                             3521 ; 1    |////////////////////////////////////////////////////////////////////////////////
                             3522 ; 2    |// Copyright(C) SigmaTel, Inc. 2000-2004
                             3523 ; 3    |//
                             3524 ; 4    |// Filename: types.h
                             3525 ; 5    |// Description: Standard data types
                             3526 ; 6    |////////////////////////////////////////////////////////////////////////////////
                             3527 ; 7    |
                             3528 ; 8    |#ifndef _TYPES_H
                             3529 ; 9    |#define _TYPES_H
                             3530 ; 10   |
                             3531 ; 11   |// TODO:  move this outta here!
                             3532 ; 12   |#if !defined(NOERROR)
                             3533 ; 13   |#define NOERROR 0
                             3534 ; 14   |#define SUCCESS 0
                             3535 ; 15   |#endif 
                             3536 ; 16   |#if !defined(SUCCESS)
                             3537 ; 17   |#define SUCCESS  0
                             3538 ; 18   |#endif
                             3539 ; 19   |#if !defined(ERROR)
                             3540 ; 20   |#define ERROR   -1
                             3541 ; 21   |#endif
                             3542 ; 22   |#if !defined(FALSE)
                             3543 ; 23   |#define FALSE 0
                             3544 ; 24   |#endif
                             3545 ; 25   |#if !defined(TRUE)
                             3546 ; 26   |#define TRUE  1
                             3547 ; 27   |#endif
                             3548 ; 28   |
                             3549 ; 29   |#if !defined(NULL)
                             3550 ; 30   |#define NULL 0
                             3551 ; 31   |#endif
                             3552 ; 32   |
                             3553 ; 33   |#define MAX_INT     0x7FFFFF
                             3554 ; 34   |#define MAX_LONG    0x7FFFFFffffff
                             3555 ; 35   |        // max positive unsigned long value: -1 == 0xFFFFFFffffff
                             3556 ; 36   |#define MAX_ULONG   (-1) 
                             3557 ; 37   |
                             3558 ; 38   |#define WORD_SIZE   24              // word size in bits
                             3559 ; 39   |#define BYTES_PER_WORD 3            // 8 bit bytes
                             3560 ; 40   |
                             3561 ; 41   |
                             3562 ; 42   |#define BYTE    unsigned char       // btVarName
                             3563 ; 43   |#define CHAR    signed char         // cVarName
                             3564 ; 44   |#define USHORT  unsigned short      // usVarName
                             3565 ; 45   |#define SHORT   unsigned short      // sVarName
                             3566 ; 46   |#define WORD    unsigned int        // wVarName
                             3567 ; 47   |#define INT     signed int          // iVarName
                             3568 ; 48   |#define DWORD   unsigned long       // dwVarName
                             3569 ; 49   |#define LONG    signed long         // lVarName
                             3570 ; 50   |#define BOOL    unsigned int        // bVarName
                             3571 ; 51   |#define FRACT   _fract              // frVarName
                             3572 ; 52   |#define LFRACT  long _fract         // lfrVarName
                             3573 ; 53   |#define CIRC    _circ               // cp<type prefix>VarName (see below)
                             3574 ; 54   |#define FLOAT   float               // fVarName
                             3575 ; 55   |#define DBL     double              // dVarName
                             3576 ; 56   |#define ENUM    enum                // eVarName
                             3577 ; 57   |#define CMX     _complex            // cmxVarName
                             3578 ; 58   |typedef WORD UCS3;                   // 
                             3579 ; 59   |
                             3580 ; 60   |#define UINT16  unsigned short
                             3581 ; 61   |#define UINT8   unsigned char   
                             3582 ; 62   |#define UINT32  unsigned long
                             3583 ; 63   |#define UINT64  unsigned long   // need to figure out how to do 64 bit values.  Or port exisiting code to only use 48 bit
                             3584 ; 64   |#define INT64   unsigned long   // need to figure out how to do 64 bit values.  Or port exisiting code to only use 48 bit
                             3585 ; 65   |#define WCHAR   UINT16
                             3586 ; 66   |
                             3587 ; 67   |//UINT128 is 16 bytes or 6 words
                             3588 ; 68   |typedef struct UINT128_3500 {   
                             3589 ; 69   |    int val[6];     
                             3590 ; 70   |} UINT128_3500;
                             3591 ; 71   |
                             3592 ; 72   |#define UINT128   UINT128_3500
                             3593 ; 73   |
                             3594 ; 74   |// Little endian word packed byte strings:   
                             3595 ; 75   |//      _packed BYTE bTextVarName[]="a string";  bText is a packed byte string prefix
                             3596 ; 76   |// Convert to big endian words by reordering bytes from high to low using swizzle.
                             3597 ; 77   |// Little endian word packed byte strings:   
                             3598 ; 78   |//      _packed BYTE bTextVarName[]="a string";  bText is a packed byte string prefix
                             3599 ; 79   |// Convert to big endian words by reordering bytes from high to low using swizzle.
                             3600 ; 80   |
                             3601 ; 81   |// Declare Memory Spaces To Use When Coding
                             3602 ; 82   |// A. Sector Buffers
                             3603 ; 83   |#define SECTOR_BUFFER_MEM_X _X
                             3604 ; 84   |#define SECTOR_BUFFER_MEM_Y _Y
                             3605 ; 85   |#define SECTOR_BUFFER_MEM SECTOR_BUFFER_MEM_X
                             3606 ; 86   |typedef WORD SECTOR_BUFFER_MEM SECTOR_BUFFER;
                             3607 ; 87   |typedef SECTOR_BUFFER * P_SECTOR_BUFFER;
                             3608 ; 88   |// B. Media DDI Memory
                             3609 ; 89   |#define MEDIA_DDI_MEM _Y
                             3610 ; 90   |
                             3611 ; 91   |
                             3612 ; 92   |
                             3613 ; 93   |// Pointers to linear structures are labeled as: p<type prefix>VarName
                             3614 ; 94   |// Examples of circular pointers:
                             3615 ; 95   |//    INT CIRC cpiVarName
                             3616 ; 96   |//    DWORD CIRC cpdwVarName
                             3617 ; 97   |
                             3618 ; 98   |#define RETCODE INT                 // rcVarName
                             3619 ; 99   |
                             3620 ; 100  |// generic bitfield structure
                             3621 ; 101  |struct Bitfield {
                             3622 ; 102  |    unsigned int B0  :1;
                             3623 ; 103  |    unsigned int B1  :1;
                             3624 ; 104  |    unsigned int B2  :1;
                             3625 ; 105  |    unsigned int B3  :1;
                             3626 ; 106  |    unsigned int B4  :1;
                             3627 ; 107  |    unsigned int B5  :1;
                             3628 ; 108  |    unsigned int B6  :1;
                             3629 ; 109  |    unsigned int B7  :1;
                             3630 ; 110  |    unsigned int B8  :1;
                             3631 ; 111  |    unsigned int B9  :1;
                             3632 ; 112  |    unsigned int B10 :1;
                             3633 ; 113  |    unsigned int B11 :1;
                             3634 ; 114  |    unsigned int B12 :1;
                             3635 ; 115  |    unsigned int B13 :1;
                             3636 ; 116  |    unsigned int B14 :1;
                             3637 ; 117  |    unsigned int B15 :1;
                             3638 ; 118  |    unsigned int B16 :1;
                             3639 ; 119  |    unsigned int B17 :1;
                             3640 ; 120  |    unsigned int B18 :1;
                             3641 ; 121  |    unsigned int B19 :1;
                             3642 ; 122  |    unsigned int B20 :1;
                             3643 ; 123  |    unsigned int B21 :1;
                             3644 ; 124  |    unsigned int B22 :1;
                             3645 ; 125  |    unsigned int B23 :1;
                             3646 ; 126  |};
                             3647 ; 127  |
                             3648 ; 128  |union BitInt {
                             3649 ; 129  |        struct Bitfield B;
                             3650 ; 130  |        int        I;
                             3651 ; 131  |};
                             3652 ; 132  |
                             3653 ; 133  |#define MAX_MSG_LENGTH 10
                             3654 ; 134  |struct CMessage
                             3655 ; 135  |{
                             3656 ; 136  |        unsigned int m_uLength;
                             3657 ; 137  |        unsigned int m_uMsg[MAX_MSG_LENGTH];
                             3658 ; 138  |};
                             3659 ; 139  |
                             3660 ; 140  |typedef struct {
                             3661 ; 141  |    WORD m_wLength;
                             3662 ; 142  |    WORD m_wMessage;
                             3663 ; 143  |    WORD m_wParams[MAX_MSG_LENGTH];
                             3664 ; 144  |} Message;
                             3665 ; 145  |
                             3666 ; 146  |struct MessageQueueDescriptor
                             3667 ; 147  |{
                             3668 ; 148  |        int *m_pBase;
                             3669 ; 149  |        int m_iModulo;
                             3670 ; 150  |        int m_iSize;
                             3671 ; 151  |        int *m_pHead;
                             3672 ; 152  |        int *m_pTail;
                             3673 ; 153  |};
                             3674 ; 154  |
                             3675 ; 155  |struct ModuleEntry
                             3676 ; 156  |{
                             3677 ; 157  |    int m_iSignaledEventMask;
                             3678 ; 158  |    int m_iWaitEventMask;
                             3679 ; 159  |    int m_iResourceOfCode;
                             3680 ; 160  |    struct MessageQueueDescriptor *m_pMessageQueue;
                             3681 ; 161  |    int _asmfunc (*m_pProcessEntryPoint)(union WaitMask Signals,struct MessageQueueDescriptor *);
                             3682 ; 162  |    int _asmfunc (*m_pInitFunction)(struct MessageQueueDescriptor *);
                             3683 ; 163  |    int m_uTimeOutHigh;
                             3684 ; 164  |    int m_uTimeOutLow;
                             3685 ; 165  |    int _asmfunc (*m_pBackgroundFunction)(struct MessageQueueDescriptor *);
                             3686 ; 166  |};
                             3687 ; 167  |
                             3688 ; 168  |union WaitMask{
                             3689 ; 169  |    struct B{
                             3690 ; 170  |        unsigned int m_bNone     :1;
                             3691 ; 171  |        unsigned int m_bMessage  :1;
                             3692 ; 172  |        unsigned int m_bTimer    :1;
                             3693 ; 173  |        unsigned int m_bButton   :1;
                             3694 ; 174  |    } B;
                             3695 ; 175  |    int I;
                             3696 ; 176  |} ;
                             3697 ; 177  |
                             3698 ; 178  |
                             3699 ; 179  |struct Button {
                             3700 ; 180  |        WORD wButtonEvent;
                             3701 ; 181  |        WORD wUnused[MAX_MSG_LENGTH];   
                             3702 ; 182  |};
                             3703 ; 183  |
                             3704 ; 184  |struct Message {
                             3705 ; 185  |        WORD wMsgLength;
                             3706 ; 186  |        WORD wMsgCommand;
                             3707 ; 187  |        WORD wMsgParms[MAX_MSG_LENGTH-1];
                             3708 ; 188  |};
                             3709 ; 189  |
                             3710 ; 190  |union EventTypes {
                             3711 ; 191  |        struct CMessage msg;
                             3712 ; 192  |        struct Button Button ;
                             3713 ; 193  |        struct Message Message;
                             3714 ; 194  |};
                             3715 ; 195  |
                             3716 ; 196  |// next 2 used to get updater build to return correct protocol ver in scsi response.
                             3717 ; 197  |#define BUILD_TYPE_UPDATER  0x100
                             3718 ; 198  |#define BUILD_TYPE_HOSTLINK 0x101
                             3719 ; 199  |#define BUILD_TYPE_PLAYER   0x102
                             3720 ; 200  |
                             3721 ; 201  |// Resets part if RETAIL build. DEBUG build executes debug instruction to halt.
                             3722 ; 202  |#define SystemHalt() __asm(" include 'sysmacro.asm' \n error") 
                             3723 ; 203  |#define assert(x)    if(!(x)) __asm(" include 'sysmacro.asm' \n error")
                             3724 ; 204  |
                             3725 ; 205  |#if DEBUG
                             3726 ; 206  |// For DEBUG builds, DebugBuildAssert(condition) halts if condition evaluates to FALSE. 
                             3727 ; 207  |#define DebugBuildAssert(x)    if(!(x)) __asm(" debug ")
                             3728 ; 208  |#else 
                             3729 ; 209  |// For RETAIL builds, DebugBuildAssert(condition) does nothing & execution continues rather than halt or reset. 
                             3730 ; 210  |#define DebugBuildAssert(x)    
                             3731 ; 211  |#endif
                             3732 ; 212  |
                             3733 ; 213  |// Do this in your C files to make a reminder that's displayed during the build.
                             3734 ; 214  |//  #pragma asm
                             3735 ; 215  |//  WARN 'Note to builder: reminder to do this after verifying that'
                             3736 ; 216  |//  #pragma endasm
                             3737 ; 217  |
                             3738 ; 218  |
                             3739 ; 219  |#ifdef COLOR_262K
                             3740 ; 220  |#define RGB(r,g,b)    ((0x0000FC & (r)) << 10) | ((0x0000FC & (g)) << 4) | ((0x0000FC & (b)) >> 2)    //262k
                             3741 ; 221  |#elif defined(COLOR_65K)
                             3742 ; 222  |#define RGB(r,g,b)    ((0x0000F8 & (r)) << 8) | ((0x0000FC & (g)) << 3) | ((0x0000F8 & (b)) >> 3)  //65k
                             3743 ; 223  |#else
                             3744 ; 224  |#define RGB(r,g,b)       ((0x0000F0 & (r)) << 4) | (0x0000F0 & (g)) | ((0x0000F0 & (b)) >> 4)
                             3745 ; 225  |#endif
                             3746 ; 226  |    
                             3747 ; 227  |#endif // #ifndef _TYPES_H
                             3748 
                             3750 
                             3751 ; 24   |#include "gettime.h"
                             3752 
TASKING DSP2410 assembler v1.5r1 Build 138 SN 00100122
                                                                                                                                                                                                                                                       Page  15

M:ADDR CODE           CYCLES LINE SOURCELINE
                             3754 
                             3755 ; 1    |#ifndef __TIME_H
                             3756 ; 2    |#define __TIME_H
                             3757 ; 3    |
                             3758 ; 4    |_callee_save LONG GetTime(void);
                             3759 ; 5    |
                             3760 ; 6    |#endif
                             3761 
                             3763 
                             3764 ; 25   |#include "sysirq.h"
                             3765 
                             3767 
                             3768 ; 1    |////////////////////////////////////////////////////////////////////////////////
                             3769 ; 2    |// Copyright(C) SigmaTel, Inc. 2000-2001
                             3770 ; 3    |//
                             3771 ; 4    |// Filename: sysirq.h
                             3772 ; 5    |// Description: 
                             3773 ; 6    |////////////////////////////////////////////////////////////////////////////////
                             3774 ; 7    |
                             3775 ; 8    |#ifndef _SYSIRQ_H
                             3776 ; 9    |#define _SYSIRQ_H
                             3777 ; 10   |
                             3778 ; 11   |///////////////////////////////////////////////////////////////////////////////
                             3779 ; 12   |// Defs
                             3780 ; 13   |///////////////////////////////////////////////////////////////////////////////
                             3781 ; 14   |
                             3782 ; 15   |#define     INTERRUPTS_UNMASK_ALL   0x000000
                             3783 ; 16   |
                             3784 ; 17   |///////////////////////////////////////////////////////////////////////////////
                             3785 ; 18   |// Structure definitions
                             3786 ; 19   |///////////////////////////////////////////////////////////////////////////////
                             3787 ; 20   |
                             3788 ; 21   |///////////////////////////////////////////////////////////////////////////////
                             3789 ; 22   |// Prototypes
                             3790 ; 23   |///////////////////////////////////////////////////////////////////////////////
                             3791 ; 24   |
                             3792 ; 25   |WORD _reentrant SysMaskAllInterrupts(void);
                             3793 ; 26   |void _reentrant SysUnMaskAllInterrupts(WORD wLevel);
                             3794 ; 27   |WORD _reentrant SysGetIrqLevel(void);
                             3795 ; 28   |RETCODE _reentrant SysSetIrqLevel(WORD wIrqLevel);
                             3796 ; 29   |
                             3797 ; 30   |#endif // #ifndef _SYSIRQ_H
                             3798 
                             3800 
                             3801 ; 26   |#include "icoll.h"
                             3802 
                             3804 
                             3805 ; 1    |////////////////////////////////////////////////////////////////////////////////
                             3806 ; 2    |// Copyright(C) SigmaTel, Inc. 2002
                             3807 ; 3    |//
                             3808 ; 4    |// Filename: icoll.h
                             3809 ; 5    |// Description: 
                             3810 ; 6    |////////////////////////////////////////////////////////////////////////////////
                             3811 ; 7    |
                             3812 ; 8    |#ifndef _ICOLL_H
                             3813 ; 9    |#define _ICOLL_H
                             3814 ; 10   |
                             3815 ; 11   |///////////////////////////////////////////////////////////////////////////////
                             3816 ; 12   |// Defs
                             3817 ; 13   |///////////////////////////////////////////////////////////////////////////////
                             3818 ; 14   |                                                                                          
                             3819 ; 15   |#define ICOLL_SOURCE_DAC_REFILL                                 (DWORD)0             
                             3820 ; 16   |#define ICOLL_SOURCE_DAC_UNDERFLOW                              (DWORD)1             
                             3821 ; 17   |#define ICOLL_SOURCE_ADC_REFILL                                 (DWORD)2             
                             3822 ; 18   |#define ICOLL_SOURCE_ADC_OVERFLOW                               (DWORD)3             
                             3823 ; 19   |#define ICOLL_SOURCE_FLASH_DONE                                 (DWORD)4              
                             3824 ; 20   |#define ICOLL_SOURCE_COMPACTFLASH_CARD_IRQ                      (DWORD)5              
                             3825 ; 21   |#define ICOLL_SOURCE_SMARTMEDIA_TIMEOUT                         (DWORD)6              
                             3826 ; 22   |#define ICOLL_SOURCE_SMARTMEDIA_INTERFACE_INVALID_PROGRAMMING   (DWORD)7              
                             3827 ; 23   |#define ICOLL_SOURCE_COMPACTFLASH_NO_CARD                       (DWORD)8               
                             3828 ; 24   |#define ICOLL_SOURCE_COMPACTFLASH_STATUS_CHANGE                 (DWORD)9               
                             3829 ; 25   |#define ICOLL_SOURCE_GPIO_0                                     (DWORD)10               
                             3830 ; 26   |#define ICOLL_SOURCE_GPIO_1                                     (DWORD)11               
                             3831 ; 27   |#define ICOLL_SOURCE_GPIO_2                                     (DWORD)12                
                             3832 ; 28   |#define ICOLL_SOURCE_TIMER_0                                    (DWORD)13                
                             3833 ; 29   |#define ICOLL_SOURCE_TIMER_1                                    (DWORD)14                
                             3834 ; 30   |#define ICOLL_SOURCE_TIMER_2                                    (DWORD)15                
                             3835 ; 31   |#define ICOLL_SOURCE_TIMER_3                                    (DWORD)16                 
                             3836 ; 32   |#define ICOLL_SOURCE_GPIO_3                                     (DWORD)17                 
                             3837 ; 33   |#define ICOLL_SOURCE_SDRAM                                      (DWORD)18                 
                             3838 ; 34   |#define ICOLL_SOURCE_CDI                                        (DWORD)19                 
                             3839 ; 35   |
                             3840 ; 36   |#if (defined(DEVICE_3410) || defined(DEVICE_3310))
                             3841 ; 37   |
                             3842 ; 38   |#define ICOLL_SOURCE_USB_SOF                                    (DWORD)20                  
                             3843 ; 39   |#define ICOLL_SOURCE_USB_SET_INTERFACE_REQUEST                  (DWORD)21                  
                             3844 ; 40   |#define ICOLL_SOURCE_USB_HOST_RESET                             (DWORD)22                  
                             3845 ; 41   |#define ICOLL_SOURCE_USB_ENDPOINT_START                         (DWORD)23
                             3846 ; 42   |#define ICOLL_SOURCE_USB_ENDPOINT_0                             (DWORD)23                  
                             3847 ; 43   |#define ICOLL_SOURCE_USB_ENDPOINT_1                             (DWORD)24                  
                             3848 ; 44   |#define ICOLL_SOURCE_USB_ENDPOINT_2                             (DWORD)25                  
                             3849 ; 45   |#define ICOLL_SOURCE_USB_ENDPOINT_3                             (DWORD)26                  
                             3850 ; 46   |#define ICOLL_SOURCE_USB_ENDPOINT_4                             (DWORD)27                  
                             3851 ; 47   |#define ICOLL_SOURCE_USB_ENDPOINT_5                             (DWORD)28                    
                             3852 ; 48   |#define ICOLL_SOURCE_USB_ENDPOINT_6                             (DWORD)29                    
                             3853 ; 49   |#define ICOLL_SOURCE_USB_ENDPOINT_7                             (DWORD)30                    
                             3854 ; 50   |
                             3855 ; 51   |#else
                             3856 ; 52   |
                             3857 ; 53   |#define ICOLL_SOURCE_VDD_5V_CONNECTED                           (DWORD)20                  
                             3858 ; 54   |#define ICOLL_SOURCE_USB_CONTROLLER                             (DWORD)21                  
                             3859 ; 55   |#define ICOLL_SOURCE_USB_WAKEUP                                 (DWORD)22                  
                             3860 ; 56   |#define ICOLL_SOURCE_VDD_5V_DISCONNECTED                        (DWORD)23
                             3861 ; 57   |#define ICOLL_SOURCE_ESPI                                       (DWORD)24                  
                             3862 ; 58   |#define ICOLL_SOURCE_FILCO                                      (DWORD)25                  
                             3863 ; 59   |#define ICOLL_SOURCE_LRADC1                                     (DWORD)26                  
                             3864 ; 60   |#define ICOLL_SOURCE_RTC_ALARM                                  (DWORD)27                  
                             3865 ; 61   |#define ICOLL_SOURCE_LRADC2                                     (DWORD)28                  
                             3866 ; 62   |#define ICOLL_SOURCE_FLASH_ECC                                  (DWORD)29                    
                             3867 ; 63   |
                             3868 ; 64   |#endif
                             3869 ; 65   |
                             3870 ; 66   |#define ICOLL_SOURCE_CDSYNC                                     (DWORD)31                    
                             3871 ; 67   |#define ICOLL_SOURCE_CDSYNC_EXCEPTION                           (DWORD)32                     
                             3872 ; 68   |#define ICOLL_SOURCE_REED_SOLOMON                               (DWORD)33
                             3873 ; 69   |#define ICOLL_END_OF_TRUE_SOURCES                                ICOLL_SOURCE_REED_SOLOMON
                             3874 ; 70   |// The rest of these "sources" are not really ICOLL sources.  They are not
                             3875 ; 71   |//  routed through the ICOLL but are included here to make interrupt abstraction
                             3876 ; 72   |//  as simple as possible.  The ICOLL functions special-case these.
                             3877 ; 73   |#define ICOLL_SOURCE_I2C_RX_READY                               (DWORD)34
                             3878 ; 74   |#define ICOLL_SOURCE_I2C_RX_OVERFLOW                            (DWORD)35
                             3879 ; 75   |#define ICOLL_SOURCE_I2C_TX_EMPTY                               (DWORD)36
                             3880 ; 76   |#define ICOLL_SOURCE_I2C_TX_UNDERFLOW                           (DWORD)37
                             3881 ; 77   |#define ICOLL_SOURCE_SPI_COMPLETE                               (DWORD)38
                             3882 ; 78   |#define ICOLL_SOURCE_I2S_RX_OVERFLOW                            (DWORD)39
                             3883 ; 79   |#define ICOLL_SOURCE_I2S_TX_UNDERFLOW                           (DWORD)40
                             3884 ; 80   |#define ICOLL_SOURCE_I2S_RX_READY                               (DWORD)41
                             3885 ; 81   |#define ICOLL_SOURCE_I2S_TX_EMPTY                               (DWORD)42
                             3886 ; 82   |#define ICOLL_SOURCE_HARDWARE_RESET                             (DWORD)43
                             3887 ; 83   |#define ICOLL_SOURCE_STACK_ERROR                                (DWORD)44
                             3888 ; 84   |#define ICOLL_SOURCE_TRACE                                      (DWORD)45
                             3889 ; 85   |#define ICOLL_SOURCE_SWI                                        (DWORD)46
                             3890 ; 86   |#define ICOLL_SOURCE_IRQA                                       (DWORD)47
                             3891 ; 87   |#define ICOLL_SOURCE_BROWNOUT                                   (DWORD)48
                             3892 ; 88   |#define ICOLL_SOURCE_ILLEGAL_INSTRUCTION                        (DWORD)49
                             3893 ; 89   |#define ICOLL_SOURCE_END                                        ICOLL_SOURCE_ILLEGAL_INSTRUCTION
                             3894 ; 90   |#define ICOLL_NUM_SOURCES                                       ICOLL_SOURCE_END+1
                             3895 ; 91   |
                             3896 ; 92   |#define ICOLL_ICLENABLE_REG_0_LAST_SRC                          (DWORD)23
                             3897 ; 93   |
                             3898 ; 94   |#define ICOLL_PRIORITY_000              0x000000
                             3899 ; 95   |#define ICOLL_PRIORITY_001              0x000001
                             3900 ; 96   |#define ICOLL_PRIORITY_010              0x000002
                             3901 ; 97   |#define ICOLL_PRIORITY_011              0x000003
                             3902 ; 98   |#define ICOLL_PRIORITY_100              0x000004
                             3903 ; 99   |#define ICOLL_PRIORITY_101              0x000005
                             3904 ; 100  |#define ICOLL_PRIORITY_110              0x000006
                             3905 ; 101  |#define ICOLL_PRIORITY_111              0x000007
                             3906 ; 102  |
                             3907 ; 103  |#define ICOLL_STEERING_IVL1             0x000000
                             3908 ; 104  |#define ICOLL_STEERING_IVL2             0x000001
                             3909 ; 105  |#define ICOLL_STEERING_IVL3             0x000002
                             3910 ; 106  |#define ICOLL_STEERING_IVL6             0x000003
                             3911 ; 107  |
                             3912 ; 108  |///////////////////////////////////////////////////////////////////////////////
                             3913 ; 109  |// ERRORS
                             3914 ; 110  |///////////////////////////////////////////////////////////////////////////////
                             3915 ; 111  |                                                                                          
                             3916 ; 112  |#define ICOLL_ERROR_INVALID_SOURCE              (RETCODE)0x000001
                             3917 ; 113  |
                             3918 ; 114  |///////////////////////////////////////////////////////////////////////////////
                             3919 ; 115  |// Structure definitions
                             3920 ; 116  |///////////////////////////////////////////////////////////////////////////////
                             3921 ; 117  |
                             3922 ; 118  |typedef void (*ISR_VECTOR)(void);
                             3923 ; 119  |
                             3924 ; 120  |typedef struct
                             3925 ; 121  |{
                             3926 ; 122  |    WORD wSource;
                             3927 ; 123  |    WORD wPriority;
                             3928 ; 124  |    WORD wSteering;
                             3929 ; 125  |} ICOLL_ELEMENT;
                             3930 ; 126  |
                             3931 ; 127  |///////////////////////////////////////////////////////////////////////////////
                             3932 ; 128  |// Prototypes
                             3933 ; 129  |///////////////////////////////////////////////////////////////////////////////
                             3934 ; 130  |
                             3935 ; 131  |void _reentrant IcollShutDown(void);
                             3936 ; 132  |RETCODE _reentrant IcollEnable(DWORD dwSource);
                             3937 ; 133  |RETCODE _reentrant IcollDisable(DWORD dwSource);
                             3938 ; 134  |BOOL _reentrant IcollGetStatus(DWORD dwSource);
                             3939 ; 135  |RETCODE _reentrant IcollSetPriority(DWORD dwSource, WORD wPriority);
                             3940 ; 136  |RETCODE _reentrant IcollSetSteering(DWORD dwSource, WORD wSteering);
                             3941 ; 137  |RETCODE _reentrant IcollInstallIsrVector(ISR_VECTOR pISR, WORD wSource);
                             3942 ; 138  |void _asmfunc IcollResetVectorTable(void);
                             3943 ; 139  |#endif // #ifndef _ICOLL_H
                             3944 
                             3946 
                             3947 ; 27   |
                             3948 ; 28   |#ifndef SYS_MAX_MSG_PARAMS
                             3949 ; 29   |#define SYS_MAX_MSG_PARAMS 10
                             3950 ; 30   |#endif
                             3951 ; 31   |
                             3952 ; 32   |#ifndef MAX_REGIONS
                             3953 ; 33   |#define MAX_REGIONS 5
                             3954 ; 34   |#endif 
                             3955 ; 35   |
                             3956 ; 36   |#define TIMEOUT_IMMEDIATE 0
                             3957 ; 37   |
                             3958 ; 38   |struct TaskEntryStruct;
                             3959 ; 39   |
                             3960 ; 40   |union SyncObjectStruct;
                             3961 ; 41   |
                             3962 ; 42   |
                             3963 ; 43   |// JCP - Already defined in types.h
                             3964 ; 44   |
                             3965 ; 45   |//typedef struct {
                             3966 ; 46   |//    WORD m_wLength;
                             3967 ; 47   |//    WORD m_wMessage;
                             3968 ; 48   |//    WORD m_wParams[SYS_MAX_MSG_PARAMS];
                             3969 ; 49   |//} Message;
                             3970 ; 50   |
                             3971 ; 51   |typedef struct {
                             3972 ; 52   |    _circ WORD    *m_pHead;
                             3973 ; 53   |    _circ WORD    *m_pTail;
                             3974 ; 54   |} CircularBufferDescriptor;
                             3975 ; 55   |
                             3976 ; 56   |typedef struct MemoryRegionStruct {
                             3977 ; 57   |    WORD m_wResourceLoaded;
                             3978 ; 58   |    _P INT *m_StartAddress;
                             3979 ; 59   |    _P INT *m_EndAddress;
                             3980 ; 60   |} MemoryRegion;
                             3981 
                             3988 
                             3989 ; 61   |
                             3990 ; 62   |
                             3991 ; 63   |typedef struct TaskEntryStruct{
                             3992 ; 64   |    CircularBufferDescriptor *m_pMessageQueue;
                             3993 ; 65   |    void   *m_pWaitingOnPtr;                                //points to either an object or a queue we're waiting on.
                             3994 ; 66   |    WORD    m_wWaitingOnWord;
                             3995 ; 67   |    WORD    m_wState;                                       //The state is used to indicate what the task is waiting on.
                             3996 ; 68   |    WORD   *m_pStackPointer;
                             3997 ; 69   |    WORD    m_wTaskID;                                      //The kernel does not use this for any purpose.   This is set by the developer
                             3998 ; 70   |                                                            //  and returned by SysGetTaskID() for use by functions that are required to 
                             3999 ; 71   |                                                            //  be task aware.
                             4000 ; 72   |    long    m_lTimeout;                                     //This is in absolute time (can compare directly to the current system time
                             4001 ; 73   |    WORD    m_wRegionResources[MAX_REGIONS];                //a snapshot of the requirements of the task in terms of which resources are loaded
                             4002 ; 74   |    WORD    m_wPriority;                                    
                             4003 ; 75   |    WORD   *m_pInitialStackPointer;                         //only used at init time
                             4004 ; 76   |    WORD    m_wStackSize;
                             4005 ; 77   |    _reentrant void   (*m_pEntryPoint)(void);               //only used at init time
                             4006 ; 78   |} TaskEntry;
                             4007 
                             4030 
                             4031 ; 79   |
                             4032 ; 80   |typedef union SyncObjectStruct {
                             4033 ; 81   |    TaskEntry   *m_pOwner;
                             4034 ; 82   |    struct
                             4035 ; 83   |    {
                             4036 ; 84   |    int          m_iOwner :16;
                             4037 ; 85   |    int          m_iCount : 8;
TASKING DSP2410 assembler v1.5r1 Build 138 SN 00100122
                                                                                                                                                                                                                                                       Page  16

M:ADDR CODE           CYCLES LINE SOURCELINE
                             4038 ; 86   |    } counter;
                             4039 ; 87   |} SyncObject;
                             4040 ; 88   |
                             4041 ; 89   |typedef WORD SignalGroup;
                             4042 ; 90   |
                             4043 ; 91   |
                             4044 ; 92   |typedef struct {
                             4045 ; 93   |    WORD    m_wMessageType;
                             4046 ; 94   |    CircularBufferDescriptor    *m_pDestination;
                             4047 ; 95   |}  RoutingEntry;
                             4048 
                             4053 
                             4054 ; 96   |
                             4055 ; 97   |extern RoutingEntry g_RoutingTable[];
                             4056 ; 98   |extern TaskEntry *g_TaskList[];
                             4057 
                             4065 
                             4066 ; 99   |extern MemoryRegion *g_RegionTable[];
                             4067 ; 100  |
                             4068 ; 101  |//Time Releated Functions
                             4069 ; 102  |_reentrant WORD SysWait(INT wTimeout);
                             4070 ; 103  |
                             4071 ; 104  |//Task Related Functions
                             4072 ; 105  |_reentrant WORD SysGetTaskID(void);
                             4073 ; 106  |
                             4074 ; 107  |//Message related functions
                             4075 ; 108  |_asmfunc WORD SysWaitOnMessage(INT wTimeout, Message *pMsg);
                             4076 
                             4083 
                             4084 ; 109  |_asmfunc WORD SysPeekMessage(CircularBufferDescriptor *pQueue, Message *pMsg);
                             4085 ; 110  |_reentrant WORD SysPostMessage(WORD wLength, ...);
                             4086 ; 111  |_reentrant WORD SysPostMessageWait(INT wTimeout, WORD wLength, ...);
                             4087 ; 112  |
                             4088 ; 113  |//maybe this is too much functionality?
                             4089 ; 114  |_asmfunc WORD SysWaitOnBoth(WORD wTimeout, SyncObject *pObject, Message *pMsg);
                             4090 
                             4102 
                             4103 ; 115  |
                             4104 ; 116  |//SyncObject Related functions
                             4105 ; 117  |_asmfunc WORD SysWaitOnObject(INT wTimeout, SyncObject *pObject);
                             4106 ; 118  |_asmfunc WORD SysAssignObject(SyncObject *pObject, TaskEntry *pTaskID);
                             4107 ; 119  |_reentrant void SysReleaseObject(SyncObject *pObject);
                             4108 ; 120  |_reentrant void ISRReleaseObject(SyncObject *pObject);
                             4109 ; 121  |
                             4110 ; 122  |//Queue Related Functions
                             4111 ; 123  |_asmfunc WORD SysWaitOnQueue(INT wTimeout,CircularBufferDescriptor *pQueue, INT wSizeToBeFree);
                             4112 ; 124  |
                             4113 ; 125  |//Event Related Functions
                             4114 ; 126  |_asmfunc WORD SysWaitOnSignal(INT wTimeout, void * pSignalGroup, int iSignal);
                             4115 
                             4117 
                             4118 ; 127  |_asmfunc void SysSignal(SignalGroup *pSignalGroup, int iSignal);
                             4119 ; 128  |
                             4120 ; 129  |//ISR function
                             4121 ; 130  |
                             4122 ; 131  |//SysCallFunctions
                             4123 ; 132  |int _asmfunc exSysCallFunction_v(void);
                             4124 ; 133  |int _asmfunc exSysCallFunction_i(int);
                             4125 ; 134  |int _asmfunc exSysCallFunction_ii(int, int);
                             4126 ; 135  |int _asmfunc exSysCallFunction_iii(int, int, int);
                             4127 ; 136  |int _asmfunc SysCallFunction(WORD * RESOURCE,int _reentrant (int,int,int*),  int, int, int *);
                             4128 ; 137  |#define SysCallFunction(rsrc,func,a,b,p) SysCallFunction((void*)rsrc,(func),(a),(b),(p))
                             4129 ; 138  |
                             4130 ; 139  |void _asmfunc v_SysCallFunction_v(WORD * RESOURCE,void _reentrant (void));
                             4131 ; 140  |#define v_SysCallFunction_v(rsrc,func) v_SysCallFunction_v((void*)rsrc,(func))
                             4132 ; 141  |
                             4133 ; 142  |void _asmfunc SysCallFunction_i(WORD * RESOURCE,void _reentrant (int),int);
                             4134 ; 143  |#define SysCallFunction_i(rsrc,func,a,b,p) SysCallFunction_i((void*)rsrc,(func),(a),(b),(p))
                             4135 ; 144  |
                             4136 ; 145  |int _asmfunc SysCallFunction_L(void* RESOURCE,int _reentrant (long,long,int*),  long, long, int *);
                             4137 ; 146  |
                             4138 ; 147  |int _asmfunc i_SysCallFunction_i(WORD * RESOURCE,int _reentrant (int), int);
                             4139 ; 148  |
                             4140 ; 149  |int _asmfunc i_SysCallFunction_iipp(WORD * RESOURCE,int _reentrant (int,int,int*,int*),  int, int, int *, int *);
                             4141 ; 150  |
                             4142 ; 151  |int _asmfunc i_SysCallFunction_iiip(WORD * RESOURCE,int _reentrant (int,int,int,int*),  int, int, int, int *);
                             4143 ; 152  |
                             4144 ; 153  |int _asmfunc fSysCallFunction(WORD * RESOURCE,int _reentrant (int,int,int*),  int, int, int *);
                             4145 ; 154  |
                             4146 ; 155  |
                             4147 ; 156  |//These values are return values, and also values that are set in the TaskEntry.m_wState to indicate what the task
                             4148 ; 157  |//is waiting on.
                             4149 ; 158  |#define EVENT_TIMEOUT   0
                             4150 ; 159  |#define EVENT_MESSAGE   1
                             4151 ; 160  |#define EVENT_OBJECT    2
                             4152 ; 161  |#define EVENT_QUEUE     4
                             4153 ; 162  |#define EVENT_SIGNAL    5
                             4154 ; 163  |#define EVENT_RELEASING_OBJECT2 6
                             4155 ; 164  |#define EVENT_RELEASING_OBJECT1 7
                             4156 ; 165  |
                             4157 ; 166  |
                             4158 ; 167  |//this is the owner that a SyncObject should be assigned to if a task it going to wait on a completion of the interrupt. 
                             4159 ; 168  |#define ISR_OWNER  ((TaskEntry*)(0xffff))
                             4160 ; 169  |#define KERNEL_OWNER  ((TaskEntry*)(0))
                             4161 ; 170  |
                             4162 ; 171  |
                             4163 ; 172  |#ifdef INSTRUMENT_ENABLE
                             4164 ; 173  |#include <regsgpio.h>
                             4165 ; 174  |
                             4166 ; 175  |//
                             4167 ; 176  |// Define the bit positions in the GPIO registers used for signalling.
                             4168 ; 177  |//
                             4169 ; 178  |#define GPIO_24     B0
                             4170 ; 179  |#define GPIO_36     B12
                             4171 ; 180  |#define GPIO_37     B13
                             4172 ; 181  |#define GPIO_38     B14
                             4173 ; 182  |#define GPIO_39     B15
                             4174 ; 183  |#define GPIO_42     B18
                             4175 ; 184  |#define GPIO_46     B22
                             4176 ; 185  |#define GPIO_47     B23
                             4177 ; 186  |
                             4178 ; 187  |//=============================================================================
                             4179 ; 188  |// SysSignalEvent
                             4180 ; 189  |//-----------------------------------------------------------------------------
                             4181 ; 190  |//! This macro allows code to set a gpio event that can be measured outside the
                             4182 ; 191  |//! part.
                             4183 ; 192  |//! \param wGPIONumber 
                             4184 ; 193  |//!     This should be one of the Macros defined above, and indicates which 
                             4185 ; 194  |//!     GPIO will be set.
                             4186 ; 195  |//!
                             4187 ; 196  |//! \return
                             4188 ; 197  |//!     None. 
                             4189 ; 198  |//!
                             4190 ; 199  |//=============================================================================
                             4191 ; 200  |#define SysSignalEvent(wGPIONumber)         \ 
                             4192 ; 201  |{                                           \ 
                             4193 ; 202  |    HW_GP1DOR.B.##wGPIONumber = 1;          \ 
                             4194 ; 203  |}
                             4195 ; 204  |
                             4196 ; 205  |//=============================================================================
                             4197 ; 206  |// SysClearEvent
                             4198 ; 207  |//-----------------------------------------------------------------------------
                             4199 ; 208  |//! This macro allows code to clear a gpio event that can be measured outside 
                             4200 ; 209  |//! the part.
                             4201 ; 210  |//! \param wGPIONumber 
                             4202 ; 211  |//!     This should be one of the Macros defined above, and indicates which 
                             4203 ; 212  |//!     GPIO will be set.
                             4204 ; 213  |//!
                             4205 ; 214  |//! \return
                             4206 ; 215  |//!     None. 
                             4207 ; 216  |//!
                             4208 ; 217  |//=============================================================================
                             4209 ; 218  |#define SysClearEvent(wGPIONumber)          \ 
                             4210 ; 219  |{                                           \ 
                             4211 ; 220  |    HW_GP1DOR.B.##wGPIONumber = 0;          \ 
                             4212 ; 221  |}
                             4213 ; 222  |
                             4214 ; 223  |//=============================================================================
                             4215 ; 224  |// SysEnableEvent
                             4216 ; 225  |//-----------------------------------------------------------------------------
                             4217 ; 226  |//! This macro must be called by code before using the SysSetEvent or 
                             4218 ; 227  |//! SysClearEvent so that the GPIOs are set up correctly.
                             4219 ; 228  |//!
                             4220 ; 229  |//! \param wGPIONumber 
                             4221 ; 230  |//!     This should be one of the Macros defined above, and indicates which 
                             4222 ; 231  |//!     GPIO will be set.
                             4223 ; 232  |//!
                             4224 ; 233  |//! \return
                             4225 ; 234  |//!     None. 
                             4226 ; 235  |//!
                             4227 ; 236  |//=============================================================================
                             4228 ; 237  |#define SysEnableEvent(wGPIONumber)         \ 
                             4229 ; 238  |{                                           \ 
                             4230 ; 239  |    HW_GP1DOER.B.##wGPIONumber=1;           \ 
                             4231 ; 240  |    HW_GP1DOR.B.##wGPIONumber=0;            \ 
                             4232 ; 241  |    HW_GP1ENR.B.##wGPIONumber=1;            \ 
                             4233 ; 242  |    HW_GP1PWR.B.##wGPIONumber=1;            \ 
                             4234 ; 243  |}
                             4235 ; 244  |#else // INSTRUMENT_ENABLE
                             4236 ; 245  |#define SysSignalEvent(wGPIONumber)
                             4237 ; 246  |#define SysClearEvent(wGPIONumber)
                             4238 ; 247  |#define SysEnableEvent(wGPIONumber)
                             4239 ; 248  |#endif // INSTRUMENT_ENABLE
                             4240 ; 249  |    
                             4241 ; 250  |#endif
                             4242 
                             4244 
                             4245 ; 16   |#include "usb_api.h"
                             4246 
                             4248 
                             4249 ; 1    |////////////////////////////////////////////////////////////////////////////////
                             4250 ; 2    |// Copyright(C) SigmaTel, Inc. 2002 - 2003
                             4251 ; 3    |//
                             4252 ; 4    |// File : USB_API.H
                             4253 ; 5    |// Description : USB_API.H defines and structures definition for USB device
                             4254 ; 6    |//               driver API.
                             4255 ; 7    |//               This 
                             4256 ; 8    |////////////////////////////////////////////////////////////////////////////////
                             4257 ; 9    |
                             4258 ; 10   |#ifndef __usb_api_h__
                             4259 ; 11   |#define __usb_api_h__ 1
                             4260 ; 12   |
                             4261 ; 13   |#include "types.h"
                             4262 ; 14   |#include "project.h"
                             4263 ; 15   |
                             4264 ; 16   |#ifndef _USB_MEM
                             4265 ; 17   |//if not overwridden, default to the compiler default memory space
                             4266 ; 18   |#define _USB_MEM
                             4267 ; 19   |#endif
                             4268 ; 20   |
                             4269 ; 21   |#define USB_LANGUAGE_ENGLISH 0x0409
                             4270 ; 22   |#define USB_LANGUAGE_CHINESE_PRC 0x0804
                             4271 ; 23   |#define USB_LANGUAGE_CHINESE_TAIWAN 0x0404
                             4272 ; 24   |#define USB_LANGUAGE_JAPANESE 0x0411
                             4273 ; 25   |
                             4274 ; 26   |#define MAX_STRING 30
                             4275 ; 27   |
                             4276 ; 28   |#define  USB_SPEED_FULL                      (0)
                             4277 ; 29   |#define  USB_SPEED_LOW                       (1)
                             4278 ; 30   |#define  USB_SPEED_HIGH                      (2)
                             4279 ; 31   |
                             4280 ; 32   |#define EP_FS_MAX_PACKET_SIZE               (64)    
                             4281 ; 33   |
                             4282 ; 34   |#define EP_HS_MAX_PACKET_SIZE               (512)   
                             4283 ; 35   |
                             4284 ; 36   |// Data transferred to devices based on Sigmatel 3500 chip may sometimes be 
                             4285 ; 37   |// corrupted. The corruption occurs when device is connected in USB High Speed 
                             4286 ; 38   |// mode, and size of the transfer in bytes is divisible by 128, but not 
                             4287 ; 39   |// divisible by the packet size. The workaround is implemented in Microsoft MTP 
                             4288 ; 40   |// driver to allow support for those devices.
                             4289 ; 41   |
                             4290 ; 42   |// the bug can corrupt the end of data buffer. It occurs when host sends out a 
                             4291 ; 43   |// short packet that is multiple of 128 bytes. During this scenario the USB core
                             4292 ; 44   |// does writes that are voided (byte enable == all zero), which was an undefined 
                             4293 ; 45   |// capability and thus the gasket did not apply a proper response. This should 
                             4294 ; 46   |// not affect Mass Storage applications because data transfers are 512 bytes and 
                             4295 ; 47   |// scsi commands are < 16 bytes. Other applications with their own driver will
                             4296 ; 48   |// need to pad the packets if they fall into the error case. "What this basically 
                             4297 ; 49   |// boils down to is that any time the host sends a short packet of 128, 256 or
                             4298 ; 50   |// 384 bytes to a high-speed connected player a number of bytes will be corrupted.
                             4299 ; 51   |// This is easiest to reproduce in SendObject commands but can strike any of the 
                             4300 ; 52   |// commands that take an arbitrary amount of data.
                             4301 ; 53   |#define ARC_HS_128_MODULO_BUG               (128)
                             4302 ; 54   |
                             4303 ; 55   |
                             4304 ; 56   |/* Error codes */
                             4305 ; 57   |#define USB_OK                              (0x00)
                             4306 ; 58   |#define USBERR_REGISTER_SERVICE             (0x01)  // Failed to register a service
                             4307 ; 59   |#define USBERR_NO_SERVICE                   (0x02)  // No registered service found 
                             4308 ; 60   |#define USBERR_TX_FAILED                    (0x03)  // Fail to prepare XD descriptor
                             4309 ; 61   |#define USBERR_SIZE_TOO_LARGE               (0x04)  // Number of bytes to transfer is too large
                             4310 ; 62   |#define USBERR_EP_INIT_FAILED               (0x05)  // Endpoint init fail
                             4311 ; 63   |#define USBERR_CONFIG_FAILED                (0x06)  // Error reported by the application
                             4312 ; 64   |                                                    // if the new config failed or not supported
                             4313 ; 65   |#define USBERR_DEVICE_NOT_CONFIGURED        (0x07)  // Error reported by the transfer function
                             4314 ; 66   |                                                    // if attempting to transfer while the device
                             4315 ; 67   |                                                    // is not configured
                             4316 ; 68   |#define USBERR_INIT_FAILED                  (0x08)  // Fail to initialize the USB API
                             4317 ; 69   |
                             4318 ; 70   |
                             4319 ; 71   |/* Endpoint types */
TASKING DSP2410 assembler v1.5r1 Build 138 SN 00100122
                                                                                                                                                                                                                                                       Page  17

M:ADDR CODE           CYCLES LINE SOURCELINE
                             4320 ; 72   |#define  USB_CONTROL_ENDPOINT             (0)
                             4321 ; 73   |#define  USB_ISOCHRONOUS_ENDPOINT         (1)
                             4322 ; 74   |#define  USB_BULK_ENDPOINT                (2)
                             4323 ; 75   |#define  USB_INTERRUPT_ENDPOINT           (3)
                             4324 ; 76   |
                             4325 ; 77   |/* End point direction */
                             4326 ; 78   |#define  USB_OUT                         (0)
                             4327 ; 79   |#define  USB_IN                          (1)
                             4328 ; 80   |
                             4329 ; 81   |/* End point packed size */
                             4330 ; 82   |#define  USB_FS_MAX_PACKET_SIZE           (64)
                             4331 ; 83   |#define  USB_HS_BULK_OUT_MAX_PACKET_SIZE  (256)
                             4332 ; 84   |#define  USB_HS_BULK_IN_MAX_PACKET_SIZE   (128)
                             4333 ; 85   |
                             4334 ; 86   |
                             4335 ; 87   |#define  USB_TEST_MODE_TEST_J             (0x01)
                             4336 ; 88   |#define  USB_TEST_MODE_TEST_K             (0x02)
                             4337 ; 89   |#define  USB_TEST_MODE_TEST_SE0_NAK       (0x03)
                             4338 ; 90   |#define  USB_TEST_MODE_TEST_PACKET        (0x04)
                             4339 ; 91   |
                             4340 ; 92   |/* Available service types */
                             4341 ; 93   |/* Services 0 through 15 are reserved for endpoints */
                             4342 ; 94   |#define  USB_SERVICE_EP0                  (0x00)
                             4343 ; 95   |#define  USB_SERVICE_EP1                  (0x01)
                             4344 ; 96   |#define  USB_SERVICE_EP2                  (0x02)
                             4345 ; 97   |#define  USB_SERVICE_EP3                  (0x03)
                             4346 ; 98   |#define  USB_SERVICE_EP4                  (0x04)
                             4347 ; 99   |#define  USB_SERVICE_EP5                  (0x05)
                             4348 ; 100  |#define  USB_SERVICE_EP6                  (0x06)
                             4349 ; 101  |#define  USB_SERVICE_EP7                  (0x07)
                             4350 ; 102  |#define  USB_SERVICE_EP8                  (0x08)
                             4351 ; 103  |#define  USB_SERVICE_EP9                  (0x09)
                             4352 ; 104  |#define  USB_SERVICE_EP10                 (0x0a)
                             4353 ; 105  |#define  USB_SERVICE_EP11                 (0x0b)
                             4354 ; 106  |#define  USB_SERVICE_EP12                 (0x0c)
                             4355 ; 107  |#define  USB_SERVICE_EP13                 (0x0d)
                             4356 ; 108  |#define  USB_SERVICE_EP14                 (0x0e)
                             4357 ; 109  |#define  USB_SERVICE_EP15                 (0x0f)
                             4358 ; 110  |#define  USB_SERVICE_BUS_RESET            (0x10)
                             4359 ; 111  |#define  USB_SERVICE_SUSPEND              (0x11)
                             4360 ; 112  |#define  USB_SERVICE_SOF                  (0x12)
                             4361 ; 113  |#define  USB_SERVICE_RESUME               (0x13)
                             4362 ; 114  |#define  USB_SERVICE_SLEEP                (0x14)
                             4363 ; 115  |#define  USB_SERVICE_SPEED_DETECTION      (0x15)
                             4364 ; 116  |#define  USB_SERVICE_TEST                 (0x16)
                             4365 ; 117  |#define  USB_SERVICE_CHANGE_CONFIG        (0x17)
                             4366 ; 118  |#define  USB_SERVICE_CHANGE_IFACE         (0x18)   
                             4367 ; 119  |#define  NON_EP_SERVICES                  (USB_SERVICE_SPEED_DETECTION - USB_SERVICE_EP15)
                             4368 ; 120  |
                             4369 ; 121  |// This is the maximum service structures allocated 
                             4370 ; 122  |// One for each End point + the common services (non endpoint services) 
                             4371 ; 123  |#define MAX_NUMBER_SERVICES               (MAX_NUM_EP + NON_EP_SERVICES)  
                             4372 ; 124  |
                             4373 ; 125  |#define NUMBER_BYTES_IN_SETUP               (8)
                             4374 ; 126  |
                             4375 ; 127  |// possible values of btStatus on the xd_struct
                             4376 ; 128  |#define  USB_STATUS_TRANSFER_IDLE           (0)
                             4377 ; 129  |#define  USB_STATUS_TRANSFER_SUCCESS        (1)            
                             4378 ; 130  |#define  USB_STATUS_TRANSFER_ACCEPTED       (2)
                             4379 ; 131  |#define  USB_STATUS_TRANSFER_IN_PROGRESS    (3)
                             4380 ; 132  |#define  USB_STATUS_TRANSFER_ERROR          (4)
                             4381 ; 133  |
                             4382 ; 134  |// types of status set/returned by set_status() and get_status()
                             4383 ; 135  |#define  USB_STATUS_DEVICE_STATE          (0x01)
                             4384 ; 136  |#define  USB_STATUS_INTERFACE             (0x02)
                             4385 ; 137  |#define  USB_STATUS_ADDRESS               (0x03)
                             4386 ; 138  |#define  USB_STATUS_CURRENT_CONFIG        (0x04)
                             4387 ; 139  |#define  USB_STATUS_SOF_COUNT             (0x05)
                             4388 ; 140  |#define  USB_STATUS                       (0x06)
                             4389 ; 141  |#define  USB_STATUS_TEST_MODE             (0x07)
                             4390 ; 142  |#define  USB_STATUS_DEVICE_SPEED          (0x08)  
                             4391 ; 143  |#define  USB_STATUS_DEVICE_TEST           (0x09)  
                             4392 ; 144  |#define  USB_STATUS_CURRENT_IFACE         (0x0a)
                             4393 ; 145  |#define  USB_STATUS_CONNECTION            (0x0b)  
                             4394 ; 146  |// For status endpoint, the endpoint number is coded in the less significant nibble
                             4395 ; 147  |#define  USB_STATUS_ENDPOINT              (0x10)
                             4396 ; 148  |#define  USB_STATUS_ENDPOINT_NUMBER_MASK  (0x0F)
                             4397 ; 149  |
                             4398 ; 150  |#define USB_MAX_SIZE_PER_TRANSFER       (0x4000)    // This is the maximum size that
                             4399 ; 151  |                                                    // we allow per transfer
                             4400 ; 152  |
                             4401 ; 153  |//Possible states the device can be in
                             4402 ; 154  |#define  USB_STATE_UNKNOWN                   (0xff)
                             4403 ; 155  |#define  USB_STATE_UNPLUGGED                 (0x05) // USB Cable unplugged
                             4404 ; 156  |#define  USB_STATE_PLUGGED                   (0x04) // USB Cable inserted
                             4405 ; 157  |#define  USB_STATE_POWERED                   (0x03)
                             4406 ; 158  |#define  USB_STATE_DEFAULT                   (0x02)
                             4407 ; 159  |#define  USB_STATE_ADDRESSED                 (0x01)
                             4408 ; 160  |#define  USB_STATE_CONFIGURED                (0x00)
                             4409 ; 161  |#define  USB_STATE_SUSPENDED                 (0x80)
                             4410 ; 162  |
                             4411 ; 163  |// Possible states the connection can be in
                             4412 ; 164  |//#define USB_STATE_UNKNOWN                 (0xff)
                             4413 ; 165  |#define USB_CONNECTED                       (0x00)
                             4414 ; 166  |#define USB_DISCONNECTED                    (0x01)
                             4415 ; 167  |
                             4416 ; 168  |
                             4417 ; 169  |
                             4418 ; 170  |typedef union
                             4419 ; 171  |{
                             4420 ; 172  |    struct
                             4421 ; 173  |    {
                             4422 ; 174  |        int Recipient               : 5;
                             4423 ; 175  |        int Type                    : 2;
                             4424 ; 176  |        int DataTransferDirection   : 1;
                             4425 ; 177  |        int Request                 : 8;
                             4426 ; 178  |        int                         : 8;
                             4427 ; 179  |    } B;
                             4428 ; 180  |    
                             4429 ; 181  |    int I;
                             4430 ; 182  |} USBRequestType ;
                             4431 ; 183  |
                             4432 ; 184  |typedef struct {
                             4433 ; 185  |   BYTE     bValid;
                             4434 ; 186  |   USBRequestType RequestType;
                             4435 ; 187  |   BYTE     btRequest;
                             4436 ; 188  |   WORD     wValue;
                             4437 ; 189  |   WORD     wIndex;
                             4438 ; 190  |   WORD     wLength;
                             4439 ; 191  |    } USB_SetupData;
                             4440 ; 192  |
                             4441 ; 193  |// Descriptor sizes in bytes
                             4442 ; 194  |#define SIZE_DEVICE_DESCRIPTOR_IN_BYTES     (18)
                             4443 ; 195  |#define SIZE_DEVICE_DESCRIPTOR_IN_WORDS     (6)
                             4444 ; 196  |#define SIZE_DEVICE_QUALIFIER_DESCRIPTOR_IN_BYTES   (10)
                             4445 ; 197  |#define SIZE_DEVICE_QUALIFIER_DESCRIPTOR_IN_WORDS   (4)
                             4446 ; 198  |#define SIZE_CONFIG_DESCRIPTOR_IN_BYTES     (9)
                             4447 ; 199  |#define SIZE_CONFIG_DESCRIPTOR_IN_WORDS     (3)
                             4448 ; 200  |#define SIZE_INTERFACE_DESCRIPTOR_IN_BYTES  (9)
                             4449 ; 201  |#define SIZE_INTERFACE_DESCRIPTOR_IN_WORDS  (3)
                             4450 ; 202  |#define SIZE_ENDPOINT_DESCRIPTOR_IN_BYTES   (7)
                             4451 ; 203  |
                             4452 ; 204  |
                             4453 ; 205  |// Descriptor types
                             4454 ; 206  |#define DESCRIPTOR_TYPE_DEVICE              (0x01)
                             4455 ; 207  |#define DESCRIPTOR_TYPE_CONFIG              (0x02)
                             4456 ; 208  |#define DESCRIPTOR_TYPE_STRING              (0x03)
                             4457 ; 209  |#define DESCRIPTOR_TYPE_INTERFACE           (0x04)
                             4458 ; 210  |#define DESCRIPTOR_TYPE_ENDPOINT            (0x05)
                             4459 ; 211  |#define DESCRIPTOR_TYPE_DEVICE_QUALIFIER    (0x06)
                             4460 ; 212  |#define DESCRIPTOR_TYPE_OTHER_SPEED_CONFIG  (0x07)
                             4461 ; 213  |#define DESCRIPTOR_TYPE_INTERFACE_POWER     (0x08)
                             4462 ; 214  |
                             4463 ; 215  |
                             4464 ; 216  |#define USB_REQUEST_DIRECTION_HOST_TO_DEVICE    ((WORD)0x000000)
                             4465 ; 217  |#define USB_REQUEST_DIRECTION_DEVICE_TO_HOST    ((WORD)0x000001)
                             4466 ; 218  |
                             4467 ; 219  |#define USB_REQUEST_TYPE_STANDARD               ((WORD)0x000000)
                             4468 ; 220  |#define USB_REQUEST_TYPE_CLASS                  ((WORD)0x000001)
                             4469 ; 221  |#define USB_REQUEST_TYPE_VENDOR                 ((WORD)0x000002)
                             4470 ; 222  |#define USB_REQUEST_TYPE_RESERVED               ((WORD)0x000003)
                             4471 ; 223  |
                             4472 ; 224  |#define USB_REQUEST_RECIPIENT_DEVICE            ((WORD)0x000000)
                             4473 ; 225  |#define USB_REQUEST_RECIPIENT_INTERFACE         ((WORD)0x000001)
                             4474 ; 226  |#define USB_REQUEST_RECIPIENT_ENDPOINT          ((WORD)0x000002)
                             4475 ; 227  |#define USB_REQUEST_RECIPIENT_OTHER             ((WORD)0x000003)
                             4476 ; 228  |
                             4477 ; 229  |#define USB_REQUEST_STANDARD_GET_STATUS         ((WORD)0x000000)
                             4478 ; 230  |#define USB_REQUEST_STANDARD_CLEAR_FEATURE      ((WORD)0x000001)
                             4479 ; 231  |#define USB_REQUEST_STANDARD_RESERVED_1         ((WORD)0x000002)
                             4480 ; 232  |#define USB_REQUEST_STANDARD_SET_FEATURE        ((WORD)0x000003)
                             4481 ; 233  |#define USB_REQUEST_STANDARD_RESERVED_2         ((WORD)0x000004)
                             4482 ; 234  |#define USB_REQUEST_STANDARD_SET_ADDRESS        ((WORD)0x000005)
                             4483 ; 235  |#define USB_REQUEST_STANDARD_GET_DESCRIPTOR     ((WORD)0x000006)
                             4484 ; 236  |#define USB_REQUEST_STANDARD_SET_DESCRIPTOR     ((WORD)0x000007)
                             4485 ; 237  |#define USB_REQUEST_STANDARD_GET_CONFIGURATION  ((WORD)0x000008)
                             4486 ; 238  |#define USB_REQUEST_STANDARD_SET_CONFIGURATION  ((WORD)0x000009)
                             4487 ; 239  |#define USB_REQUEST_STANDARD_GET_INTERFACE      ((WORD)0x00000A)
                             4488 ; 240  |#define USB_REQUEST_STANDARD_SET_INTERFACE      ((WORD)0x00000B)
                             4489 ; 241  |#define USB_REQUEST_STANDARD_SYNCH_FRAME        ((WORD)0x00000C)
                             4490 ; 242  |
                             4491 ; 243  |#define USB_CLEAR_FEATURE_ENDPOINT_HALT         (0)
                             4492 ; 244  |#define USB_CLEAR_FEATURE_REMOTE_WAKEUP         (1)
                             4493 ; 245  |
                             4494 ; 246  |
                             4495 ; 247  |// Struct Device Descriptor
                             4496 ; 248  |typedef struct {
                             4497 ; 249  |    BYTE    bLength;                // (0) Size of this descriptor in bytes (18)
                             4498 ; 250  |    BYTE    btDescriptorType;       // (1) Device descriptor type (1)
                             4499 ; 251  |    BYTE    btBcdUsbLsb;            // (2) USB specification release number (for version 2.00 0x00)
                             4500 ; 252  |    BYTE    btBcdUsbMsb;            // (3)                                  (for version 2.00 0x02)     
                             4501 ; 253  |    BYTE    btDeviceClass;          // (4) Class code
                             4502 ; 254  |    BYTE    btDeviceSubclass;       // (5) Subclass code
                             4503 ; 255  |    BYTE    btDeviceProtocol;       // (6) Protocol code
                             4504 ; 256  |    BYTE    btMaxPacketSize0;       // (7) Maximum packet size for endpoint 0 (8, 16, 32 or 64)
                             4505 ; 257  |    BYTE    btIdVendorLsb;          // (8) Vendor Id
                             4506 ; 258  |    BYTE    btIdVendorMsb;          // (9)
                             4507 ; 259  |    BYTE    btIdProductLsb;         // (10) Product Id
                             4508 ; 260  |    BYTE    btIdProductMsb;         // (11)
                             4509 ; 261  |    BYTE    btBcdReleaseLsb;        // (12) Device release number in BCD
                             4510 ; 262  |    BYTE    btBcdReleaseMsb;        // (13)
                             4511 ; 263  |    BYTE    btIndexManufacturer;    // (14) Index of string descriptor describing Manufacturer
                             4512 ; 264  |    BYTE    btIndexProduct;         // (15) Index of string descriptor describing Product
                             4513 ; 265  |    BYTE    btIndexSerialNumber;    // (16) Index of string descriptor describing Device Serial Number
                             4514 ; 266  |    BYTE    btNumConfigurations;    // (17) Number of possible configurations
                             4515 ; 267  |} Struct_Standard_Dev_Desc;
                             4516 ; 268  |
                             4517 ; 269  |// Struct Device Qualifier Descriptor
                             4518 ; 270  |typedef struct {
                             4519 ; 271  |    BYTE    bLength;                // (0) Size of this descriptor in bytes (10)
                             4520 ; 272  |    BYTE    btDescriptorType;       // (1) Device descriptor type (6)
                             4521 ; 273  |    BYTE    btBcdUsbLsb;            // (2) USB specification release number (for version 2.00 0x00)
                             4522 ; 274  |    BYTE    btBcdUsbMsb;            // (3)                                  (for version 2.00 0x02)     
                             4523 ; 275  |    BYTE    btDeviceClass;          // (4) Class code
                             4524 ; 276  |    BYTE    btDeviceSubclass;       // (5) Subclass code
                             4525 ; 277  |    BYTE    btDeviceProtocol;       // (6) Protocol code
                             4526 ; 278  |    BYTE    btMaxPacketSize0;       // (7) Maximum packet size for endpoint 0 other speed (8, 16, 32 or 64)
                             4527 ; 279  |    BYTE    btNumConfigurations;    // (8) Number of other-speed possible configurations
                             4528 ; 280  |    BYTE    btReserved;             // (9) Reserved for future use, must be 0
                             4529 ; 281  |} Struct_Dev_Qualifier_Desc;
                             4530 ; 282  |
                             4531 ; 283  |// Struct Configuration Descriptor
                             4532 ; 284  |typedef struct {
                             4533 ; 285  |    BYTE    bLength;                // (0) Size of this descriptor in bytes (9)
                             4534 ; 286  |    BYTE    btDescriptorType;       // (1) Device descriptor type (2 or 7)
                             4535 ; 287  |    BYTE    btTotalLengthLsb;       // (2) Total length of data returned for this config.
                             4536 ; 288  |    BYTE    btTotalLengthMsb;       // (3)                                  
                             4537 ; 289  |    BYTE    btNumInterfaces;        // (4) Number of Interfaces supported by this configuration
                             4538 ; 290  |    BYTE    btConfigurationValue;   // (5) Value to use as an argument to the SetConfiguration() request
                             4539 ; 291  |    BYTE    btIndexConfiguration;   // (6) Index of string descriptor describing this configuration
                             4540 ; 292  |    BYTE    btBitMapAttributes;     // (7) Configuration Characteristics
                             4541 ; 293  |                                    //     D7:      Reserved (set to one)
                             4542 ; 294  |                                    //     D6:      Self-powered
                             4543 ; 295  |                                    //     D5:      Remote Wakeup
                             4544 ; 296  |                                    //     D4..0:   Reserved (reset to zero)        
                             4545 ; 297  |    BYTE    btMaxPower;             // (8) Maximum power consumption expressed in 2mA units.
                             4546 ; 298  |} Struct_Standard_Config_Desc, Struct_Other_Speed_Config_Desc;
                             4547 ; 299  |
                             4548 ; 300  |// Struct Interface Descriptor
                             4549 ; 301  |typedef struct {
                             4550 ; 302  |    BYTE    bLength;                // (0) Size of this descriptor in bytes (9)
                             4551 ; 303  |    BYTE    btDescriptorType;       // (1) Device descriptor type (4)
                             4552 ; 304  |    BYTE    btInterfaceNum;         // (2) Number of this interface. Zero-based value.
                             4553 ; 305  |    BYTE    btAlternateSetting;     // (3)                                  
                             4554 ; 306  |    BYTE    btNumEndpoints;         // (4) Number of endpointsused by this interface (excluding endpoint 0).
                             4555 ; 307  |    BYTE    btInterfaceClass;       // (5) Class code
                             4556 ; 308  |    BYTE    btInterfaceSubClass;    // (6) Sub Class code
                             4557 ; 309  |    BYTE    btInterfaceProtocol;    // (7) Protocol Code
                             4558 ; 310  |    BYTE    btIndexInterface;       // (8) Index of string descriptor describing this interface
                             4559 ; 311  |} Struct_Standard_Interface_Desc;
                             4560 ; 312  |
                             4561 ; 313  |// Struct Endpoint Descriptor
                             4562 ; 314  |typedef struct {
                             4563 ; 315  |    BYTE    bLength;                // (0) Size of this descriptor in bytes (7)
                             4564 ; 316  |    BYTE    btDescriptorType;       // (1) Device descriptor type (5)
                             4565 ; 317  |    BYTE    btEndpointAddress;      // (2) Address of the endpoint on the USB device described by this descriptor
                             4566 ; 318  |                                    //      Bit 3..0: Endpoint number
                             4567 ; 319  |                                    //      Bit 6..4: Reserved, reset to zero
                             4568 ; 320  |                                    //      Bit 7:    Direction. Ignored for control endpoints (0 OUT, 1 IN)
                             4569 ; 321  |    BYTE    btBitMapAttributes;     // (3) Endpoint attributes
                             4570 ; 322  |                                    //      bits 1..0: Transfer Type (00 Control, 01 Iso, 10 Bulk, 11 Int)
TASKING DSP2410 assembler v1.5r1 Build 138 SN 00100122
                                                                                                                                                                                                                                                       Page  18

M:ADDR CODE           CYCLES LINE SOURCELINE
                             4571 ; 323  |                                    //      bits 5..2: If not an iso endpoints, they are reserved and must be reset to zero.
                             4572 ; 324  |                                    //      bits 7..6: Reserved bits, must be reset to zero.                                    
                             4573 ; 325  |    BYTE    btMaxPacketSizeLsb;     // (4) Maximum packet size. Refer to standard for bits specification
                             4574 ; 326  |    BYTE    btMaxPacketSizeMsb;     // (5)
                             4575 ; 327  |    BYTE    btInterval;             // (6) Interval for polling endpoint for data transfers (refer to standard)
                             4576 ; 328  |} Struct_Standard_Endpoint_Desc;
                             4577 ; 329  |
                             4578 ; 330  |typedef struct {
                             4579 ; 331  |    BYTE    btLength;                   // (0) Size of this descriptor in bytes (2*MAX_USB_LANG + 2)
                             4580 ; 332  |    BYTE    btDescriptorType;           // (1) String descriptor type (3)
                             4581 ; 333  |    BYTE    btString[MAX_STRING*2];       
                             4582 ; 334  |} Struct_String_Desc;
                             4583 ; 335  |
                             4584 ; 336  |//
                             4585 ; 337  |// Externals
                             4586 ; 338  |//
                             4587 ; 339  |extern void _reentrant usb_dci_chip_enable (void);
                             4588 ; 340  |extern void _reentrant usb_dci_shutdown(void);
                             4589 ; 341  |
                             4590 ; 342  |BYTE _reentrant usb_device_init(void);
                             4591 ; 343  |void _inline usb_device_shutdown(void)
                             4592 ; 344  |{
                             4593 ; 345  |    usb_dci_shutdown();
                             4594 ; 346  |}
                             4595 ; 347  |
                             4596 ; 348  |BYTE _reentrant usb_device_register_service(BYTE btType, void (* Service)(BOOL bSetup, BYTE btDirection, BYTE _USB_MEM * pbtBuffer, WORD wLength,WORD wPrivateData)); 
                             4597 ; 349  |//Remove unused function usb_device_get_service() to reclain _P memroy.
                             4598 ; 350  |//BYTE _reentrant usb_device_get_service(BYTE btType, void (* Service)(BOOL bSetup, BYTE btDirection, BYTE _USB_MEM * pbtBuffer, WORD wLength)); 
                             4599 ; 351  |
                             4600 ; 352  |BYTE _reentrant usb_device_init_endpoint(BYTE btEndpoint, USHORT usMaxPacketSize, BYTE btDirection, BYTE btType, BOOL bFlag);
                             4601 ; 353  |
                             4602 ; 354  |extern USB_SetupData *_reentrant usb_dci_get_setup_data(BYTE btEndpoint);
                             4603 ; 355  |#define usb_device_read_setup_data(btEndpoint) usb_dci_get_setup_data(btEndpoint)
                             4604 ; 356  |
                             4605 ; 357  |void _reentrant usb_device_get_status(BYTE btType, USHORT * pusStatus);
                             4606 ; 358  |void _reentrant usb_device_set_status(BYTE btType, USHORT usStatus);
                             4607 ; 359  |BYTE _reentrant usb_device_get_transfer_status(BYTE btEndpoint, BYTE btDirection);
                             4608 ; 360  |
                             4609 ; 361  |extern void _reentrant usb_dci_stall_endpoint(BYTE btEndpoint, BYTE btDirection);
                             4610 ; 362  |#define usb_device_stall_endpoint(btEndpoint, btDirection) usb_dci_stall_endpoint((btEndpoint), (btDirection))
                             4611 ; 363  |
                             4612 ; 364  |extern void _reentrant usb_dci_unstall_endpoint(BYTE btEndpoint, BYTE btDirection);
                             4613 ; 365  |#define usb_device_unstall_endpoint(btEndpoint, btDirection) usb_dci_unstall_endpoint((btEndpoint), (btDirection))
                             4614 ; 366  |
                             4615 ; 367  |extern void _reentrant usb_dci_finish_transaction(BYTE btEndpoint);
                             4616 ; 368  |#define usb_device_finish_transaction(btEndpoint) usb_dci_finish_transaction(btEndpoint);
                             4617 ; 369  |
                             4618 ; 370  |////////////////////////////////////////////////////////////////////////////////
                             4619 ; 371  |//
                             4620 ; 372  |//>  Name:          usb_device_enable
                             4621 ; 373  |//
                             4622 ; 374  |//   Type:          Function
                             4623 ; 375  |//
                             4624 ; 376  |//   Description:   Enables the USB device for transfers
                             4625 ; 377  |//
                             4626 ; 378  |//   Inputs:        none
                             4627 ; 379  |//
                             4628 ; 380  |//   Outputs:       USB_OK or error code
                             4629 ; 381  |//
                             4630 ; 382  |//   Notes:         none
                             4631 ; 383  |//<
                             4632 ; 384  |////////////////////////////////////////////////////////////////////////////////
                             4633 ; 385  |void _inline usb_device_enable(void)
                             4634 ; 386  |{
                             4635 ; 387  |    usb_dci_chip_enable();
                             4636 ; 388  |}
                             4637 ; 389  |
                             4638 ; 390  |void _reentrant usb_device_release(void);
                             4639 ; 391  |void _reentrant usb_device_hold(void);
                             4640 ; 392  |BYTE _reentrant usb_device_is_hold(void);
                             4641 ; 393  |void _reentrant usb_device_data_phase_required(void);
                             4642 ; 394  |
                             4643 ; 395  |BOOL _reentrant usb_device_is_first_init(void);
                             4644 ; 396  |void _reentrant usb_device_set_first_init(void);
                             4645 ; 397  |void _reentrant usb_device_clear_first_init(void);
                             4646 ; 398  |
                             4647 ; 399  |WORD _reentrant usb_get_current_limit(void);
                             4648 ; 400  |RETCODE _reentrant usb_set_current_limit(WORD);
                             4649 ; 401  |
                             4650 ; 402  |////////////////////////////////////////////////////////////////////
                             4651 ; 403  |extern BYTE _reentrant usb_dci_get_endpoint_status(BYTE btEndpoint);
                             4652 ; 404  |#define usb_device_get_endpoint_status(btEndpoint) usb_dci_get_endpoint_status(btEndpoint)
                             4653 ; 405  |
                             4654 ; 406  |#define USB_ENDPOINT_STATUS_OK                          0
                             4655 ; 407  |#define USB_ENDPOINT_STATUS_STALLED                     1
                             4656 ; 408  |#define USB_ENDPOINT_STATUS_RECIEVED_UNSTALL_REQUEST    2
                             4657 ; 409  |// WHQL
                             4658 ; 410  |#define USB_ENDPOINT_STATUS_HOST_STALLED                3
                             4659 ; 411  |////////////////////////////////////////////////////////////////////
                             4660 ; 412  |
                             4661 ; 413  |
                             4662 ; 414  |BYTE _reentrant usb_device_send_data(BYTE btEndpoint, WORD _X * pbtStmpWordAdd, BYTE btByteOffset, USHORT usSize, WORD wPrivateData, BOOL bIsDataPhase);
                             4663 ; 415  |BYTE _reentrant usb_device_recv_data(BYTE btEndpoint, WORD _X * pbtStmpWordAdd, BYTE btByteOffset, USHORT usSize, WORD wPrivateData, BOOL bIsDataPhase);
                             4664 ; 416  |void _reentrant ch9ServiceEp0(BOOL bSetup, BYTE btDirection, WORD _X *pbtBuffer, WORD wLength,WORD wPrivateData);
                             4665 ; 417  |BYTE _reentrant usb_device_transfer_data(BYTE btEndpoint, WORD _X* pbtStmpWordAdd, 
                             4666 ; 418  |                                         BYTE btByteOffset, USHORT usSize, WORD wPrivateData, 
                             4667 ; 419  |                                         BOOL bIsDataPhase, WORD wDirection);
                             4668 ; 420  |
                             4669 ; 421  |#ifndef CUSTOMIZE_UNICODE
                             4670 ; 422  |extern const BYTE g_Manufacturer[];
                             4671 ; 423  |extern const BYTE g_ProductName[];
                             4672 ; 424  |extern const BYTE g_ConfigString[];
                             4673 ; 425  |extern const BYTE g_Interface0String[];
                             4674 ; 426  |extern const BYTE g_Interface1String[];
                             4675 ; 427  |extern const BYTE g_MSOSDescriptorString[];
                             4676 ; 428  |#else   // CUSTOMIZE_UNICODE
                             4677 ; 429  |extern const WORD g_Manufacturer[];
                             4678 ; 430  |extern const WORD g_ProductName[];
                             4679 ; 431  |extern const WORD g_ConfigString[];
                             4680 ; 432  |extern const WORD g_Interface0String[];
                             4681 ; 433  |extern const WORD g_Interface1String[];
                             4682 ; 434  |extern const WORD g_MSOSDescriptorString[];
                             4683 ; 435  |#endif
                             4684 ; 436  |extern WORD g_LanguageList[];
                             4685 ; 437  |
                             4686 ; 438  |extern const BYTE g_SCSIVendorID[];
                             4687 ; 439  |extern const BYTE g_SCSIProductID[];
                             4688 ; 440  |extern void *g_pStrings[];
                             4689 ; 441  |
                             4690 ; 442  |extern WORD g_wUSBVendorID;
                             4691 ; 443  |extern WORD g_wUSBProductID;
                             4692 ; 444  |extern WORD g_wUSBReleaseID;
                             4693 ; 445  |
                             4694 ; 446  |#endif
                             4695 ; 447  |/* EOF */
                             4696 ; 448  |
                             4697 
                             4699 
                             4700 ; 17   |#include "scsi.h"
                             4701 
                             4703 
                             4704 ; 1    |////////////////////////////////////////////////////////////////////////////////
                             4705 ; 2    |// Copyright(C) SigmaTel, Inc. 2000-2001
                             4706 ; 3    |//
                             4707 ; 4    |// Filename: scsi.h
                             4708 ; 5    |// Description: 
                             4709 ; 6    |////////////////////////////////////////////////////////////////////////////////
                             4710 ; 7    |
                             4711 ; 8    |#ifndef _SCSI_H
                             4712 ; 9    |#define _SCSI_H
                             4713 ; 10   |
                             4714 ; 11   |#include "types.h"
                             4715 
                             4717 
                             4718 ; 1    |////////////////////////////////////////////////////////////////////////////////
                             4719 ; 2    |// Copyright(C) SigmaTel, Inc. 2000-2004
                             4720 ; 3    |//
                             4721 ; 4    |// Filename: types.h
                             4722 ; 5    |// Description: Standard data types
                             4723 ; 6    |////////////////////////////////////////////////////////////////////////////////
                             4724 ; 7    |
                             4725 ; 8    |#ifndef _TYPES_H
                             4726 ; 9    |#define _TYPES_H
                             4727 ; 10   |
                             4728 ; 11   |// TODO:  move this outta here!
                             4729 ; 12   |#if !defined(NOERROR)
                             4730 ; 13   |#define NOERROR 0
                             4731 ; 14   |#define SUCCESS 0
                             4732 ; 15   |#endif 
                             4733 ; 16   |#if !defined(SUCCESS)
                             4734 ; 17   |#define SUCCESS  0
                             4735 ; 18   |#endif
                             4736 ; 19   |#if !defined(ERROR)
                             4737 ; 20   |#define ERROR   -1
                             4738 ; 21   |#endif
                             4739 ; 22   |#if !defined(FALSE)
                             4740 ; 23   |#define FALSE 0
                             4741 ; 24   |#endif
                             4742 ; 25   |#if !defined(TRUE)
                             4743 ; 26   |#define TRUE  1
                             4744 ; 27   |#endif
                             4745 ; 28   |
                             4746 ; 29   |#if !defined(NULL)
                             4747 ; 30   |#define NULL 0
                             4748 ; 31   |#endif
                             4749 ; 32   |
                             4750 ; 33   |#define MAX_INT     0x7FFFFF
                             4751 ; 34   |#define MAX_LONG    0x7FFFFFffffff
                             4752 ; 35   |        // max positive unsigned long value: -1 == 0xFFFFFFffffff
                             4753 ; 36   |#define MAX_ULONG   (-1) 
                             4754 ; 37   |
                             4755 ; 38   |#define WORD_SIZE   24              // word size in bits
                             4756 ; 39   |#define BYTES_PER_WORD 3            // 8 bit bytes
                             4757 ; 40   |
                             4758 ; 41   |
                             4759 ; 42   |#define BYTE    unsigned char       // btVarName
                             4760 ; 43   |#define CHAR    signed char         // cVarName
                             4761 ; 44   |#define USHORT  unsigned short      // usVarName
                             4762 ; 45   |#define SHORT   unsigned short      // sVarName
                             4763 ; 46   |#define WORD    unsigned int        // wVarName
                             4764 ; 47   |#define INT     signed int          // iVarName
                             4765 ; 48   |#define DWORD   unsigned long       // dwVarName
                             4766 ; 49   |#define LONG    signed long         // lVarName
                             4767 ; 50   |#define BOOL    unsigned int        // bVarName
                             4768 ; 51   |#define FRACT   _fract              // frVarName
                             4769 ; 52   |#define LFRACT  long _fract         // lfrVarName
                             4770 ; 53   |#define CIRC    _circ               // cp<type prefix>VarName (see below)
                             4771 ; 54   |#define FLOAT   float               // fVarName
                             4772 ; 55   |#define DBL     double              // dVarName
                             4773 ; 56   |#define ENUM    enum                // eVarName
                             4774 ; 57   |#define CMX     _complex            // cmxVarName
                             4775 ; 58   |typedef WORD UCS3;                   // 
                             4776 ; 59   |
                             4777 ; 60   |#define UINT16  unsigned short
                             4778 ; 61   |#define UINT8   unsigned char   
                             4779 ; 62   |#define UINT32  unsigned long
                             4780 ; 63   |#define UINT64  unsigned long   // need to figure out how to do 64 bit values.  Or port exisiting code to only use 48 bit
                             4781 ; 64   |#define INT64   unsigned long   // need to figure out how to do 64 bit values.  Or port exisiting code to only use 48 bit
                             4782 ; 65   |#define WCHAR   UINT16
                             4783 ; 66   |
                             4784 ; 67   |//UINT128 is 16 bytes or 6 words
                             4785 ; 68   |typedef struct UINT128_3500 {   
                             4786 ; 69   |    int val[6];     
                             4787 ; 70   |} UINT128_3500;
                             4788 ; 71   |
                             4789 ; 72   |#define UINT128   UINT128_3500
                             4790 ; 73   |
                             4791 ; 74   |// Little endian word packed byte strings:   
                             4792 ; 75   |//      _packed BYTE bTextVarName[]="a string";  bText is a packed byte string prefix
                             4793 ; 76   |// Convert to big endian words by reordering bytes from high to low using swizzle.
                             4794 ; 77   |// Little endian word packed byte strings:   
                             4795 ; 78   |//      _packed BYTE bTextVarName[]="a string";  bText is a packed byte string prefix
                             4796 ; 79   |// Convert to big endian words by reordering bytes from high to low using swizzle.
                             4797 ; 80   |
                             4798 ; 81   |// Declare Memory Spaces To Use When Coding
                             4799 ; 82   |// A. Sector Buffers
                             4800 ; 83   |#define SECTOR_BUFFER_MEM_X _X
                             4801 ; 84   |#define SECTOR_BUFFER_MEM_Y _Y
                             4802 ; 85   |#define SECTOR_BUFFER_MEM SECTOR_BUFFER_MEM_X
                             4803 ; 86   |typedef WORD SECTOR_BUFFER_MEM SECTOR_BUFFER;
                             4804 ; 87   |typedef SECTOR_BUFFER * P_SECTOR_BUFFER;
                             4805 ; 88   |// B. Media DDI Memory
                             4806 ; 89   |#define MEDIA_DDI_MEM _Y
                             4807 ; 90   |
                             4808 ; 91   |
                             4809 ; 92   |
                             4810 ; 93   |// Pointers to linear structures are labeled as: p<type prefix>VarName
                             4811 ; 94   |// Examples of circular pointers:
                             4812 ; 95   |//    INT CIRC cpiVarName
                             4813 ; 96   |//    DWORD CIRC cpdwVarName
                             4814 ; 97   |
                             4815 ; 98   |#define RETCODE INT                 // rcVarName
                             4816 ; 99   |
                             4817 ; 100  |// generic bitfield structure
                             4818 ; 101  |struct Bitfield {
                             4819 ; 102  |    unsigned int B0  :1;
                             4820 ; 103  |    unsigned int B1  :1;
                             4821 ; 104  |    unsigned int B2  :1;
                             4822 ; 105  |    unsigned int B3  :1;
                             4823 ; 106  |    unsigned int B4  :1;
                             4824 ; 107  |    unsigned int B5  :1;
TASKING DSP2410 assembler v1.5r1 Build 138 SN 00100122
                                                                                                                                                                                                                                                       Page  19

M:ADDR CODE           CYCLES LINE SOURCELINE
                             4825 ; 108  |    unsigned int B6  :1;
                             4826 ; 109  |    unsigned int B7  :1;
                             4827 ; 110  |    unsigned int B8  :1;
                             4828 ; 111  |    unsigned int B9  :1;
                             4829 ; 112  |    unsigned int B10 :1;
                             4830 ; 113  |    unsigned int B11 :1;
                             4831 ; 114  |    unsigned int B12 :1;
                             4832 ; 115  |    unsigned int B13 :1;
                             4833 ; 116  |    unsigned int B14 :1;
                             4834 ; 117  |    unsigned int B15 :1;
                             4835 ; 118  |    unsigned int B16 :1;
                             4836 ; 119  |    unsigned int B17 :1;
                             4837 ; 120  |    unsigned int B18 :1;
                             4838 ; 121  |    unsigned int B19 :1;
                             4839 ; 122  |    unsigned int B20 :1;
                             4840 ; 123  |    unsigned int B21 :1;
                             4841 ; 124  |    unsigned int B22 :1;
                             4842 ; 125  |    unsigned int B23 :1;
                             4843 ; 126  |};
                             4844 ; 127  |
                             4845 ; 128  |union BitInt {
                             4846 ; 129  |        struct Bitfield B;
                             4847 ; 130  |        int        I;
                             4848 ; 131  |};
                             4849 ; 132  |
                             4850 ; 133  |#define MAX_MSG_LENGTH 10
                             4851 ; 134  |struct CMessage
                             4852 ; 135  |{
                             4853 ; 136  |        unsigned int m_uLength;
                             4854 ; 137  |        unsigned int m_uMsg[MAX_MSG_LENGTH];
                             4855 ; 138  |};
                             4856 ; 139  |
                             4857 ; 140  |typedef struct {
                             4858 ; 141  |    WORD m_wLength;
                             4859 ; 142  |    WORD m_wMessage;
                             4860 ; 143  |    WORD m_wParams[MAX_MSG_LENGTH];
                             4861 ; 144  |} Message;
                             4862 ; 145  |
                             4863 ; 146  |struct MessageQueueDescriptor
                             4864 ; 147  |{
                             4865 ; 148  |        int *m_pBase;
                             4866 ; 149  |        int m_iModulo;
                             4867 ; 150  |        int m_iSize;
                             4868 ; 151  |        int *m_pHead;
                             4869 ; 152  |        int *m_pTail;
                             4870 ; 153  |};
                             4871 ; 154  |
                             4872 ; 155  |struct ModuleEntry
                             4873 ; 156  |{
                             4874 ; 157  |    int m_iSignaledEventMask;
                             4875 ; 158  |    int m_iWaitEventMask;
                             4876 ; 159  |    int m_iResourceOfCode;
                             4877 ; 160  |    struct MessageQueueDescriptor *m_pMessageQueue;
                             4878 ; 161  |    int _asmfunc (*m_pProcessEntryPoint)(union WaitMask Signals,struct MessageQueueDescriptor *);
                             4879 ; 162  |    int _asmfunc (*m_pInitFunction)(struct MessageQueueDescriptor *);
                             4880 ; 163  |    int m_uTimeOutHigh;
                             4881 ; 164  |    int m_uTimeOutLow;
                             4882 ; 165  |    int _asmfunc (*m_pBackgroundFunction)(struct MessageQueueDescriptor *);
                             4883 ; 166  |};
                             4884 ; 167  |
                             4885 ; 168  |union WaitMask{
                             4886 ; 169  |    struct B{
                             4887 ; 170  |        unsigned int m_bNone     :1;
                             4888 ; 171  |        unsigned int m_bMessage  :1;
                             4889 ; 172  |        unsigned int m_bTimer    :1;
                             4890 ; 173  |        unsigned int m_bButton   :1;
                             4891 ; 174  |    } B;
                             4892 ; 175  |    int I;
                             4893 ; 176  |} ;
                             4894 ; 177  |
                             4895 ; 178  |
                             4896 ; 179  |struct Button {
                             4897 ; 180  |        WORD wButtonEvent;
                             4898 ; 181  |        WORD wUnused[MAX_MSG_LENGTH];   
                             4899 ; 182  |};
                             4900 ; 183  |
                             4901 ; 184  |struct Message {
                             4902 ; 185  |        WORD wMsgLength;
                             4903 ; 186  |        WORD wMsgCommand;
                             4904 ; 187  |        WORD wMsgParms[MAX_MSG_LENGTH-1];
                             4905 ; 188  |};
                             4906 ; 189  |
                             4907 ; 190  |union EventTypes {
                             4908 ; 191  |        struct CMessage msg;
                             4909 ; 192  |        struct Button Button ;
                             4910 ; 193  |        struct Message Message;
                             4911 ; 194  |};
                             4912 ; 195  |
                             4913 ; 196  |// next 2 used to get updater build to return correct protocol ver in scsi response.
                             4914 ; 197  |#define BUILD_TYPE_UPDATER  0x100
                             4915 ; 198  |#define BUILD_TYPE_HOSTLINK 0x101
                             4916 ; 199  |#define BUILD_TYPE_PLAYER   0x102
                             4917 ; 200  |
                             4918 ; 201  |// Resets part if RETAIL build. DEBUG build executes debug instruction to halt.
                             4919 ; 202  |#define SystemHalt() __asm(" include 'sysmacro.asm' \n error") 
                             4920 ; 203  |#define assert(x)    if(!(x)) __asm(" include 'sysmacro.asm' \n error")
                             4921 ; 204  |
                             4922 ; 205  |#if DEBUG
                             4923 ; 206  |// For DEBUG builds, DebugBuildAssert(condition) halts if condition evaluates to FALSE. 
                             4924 ; 207  |#define DebugBuildAssert(x)    if(!(x)) __asm(" debug ")
                             4925 ; 208  |#else 
                             4926 ; 209  |// For RETAIL builds, DebugBuildAssert(condition) does nothing & execution continues rather than halt or reset. 
                             4927 ; 210  |#define DebugBuildAssert(x)    
                             4928 ; 211  |#endif
                             4929 ; 212  |
                             4930 ; 213  |// Do this in your C files to make a reminder that's displayed during the build.
                             4931 ; 214  |//  #pragma asm
                             4932 ; 215  |//  WARN 'Note to builder: reminder to do this after verifying that'
                             4933 ; 216  |//  #pragma endasm
                             4934 ; 217  |
                             4935 ; 218  |
                             4936 ; 219  |#ifdef COLOR_262K
                             4937 ; 220  |#define RGB(r,g,b)    ((0x0000FC & (r)) << 10) | ((0x0000FC & (g)) << 4) | ((0x0000FC & (b)) >> 2)    //262k
                             4938 ; 221  |#elif defined(COLOR_65K)
                             4939 ; 222  |#define RGB(r,g,b)    ((0x0000F8 & (r)) << 8) | ((0x0000FC & (g)) << 3) | ((0x0000F8 & (b)) >> 3)  //65k
                             4940 ; 223  |#else
                             4941 ; 224  |#define RGB(r,g,b)       ((0x0000F0 & (r)) << 4) | (0x0000F0 & (g)) | ((0x0000F0 & (b)) >> 4)
                             4942 ; 225  |#endif
                             4943 ; 226  |    
                             4944 ; 227  |#endif // #ifndef _TYPES_H
                             4945 
                             4947 
                             4948 ; 12   |#include "filesystem.h"
                             4949 
                             4951 
                             4952 ; 1    |////////////////////////////////////////////////////////////////////////////////
                             4953 ; 2    |//  Copyright(C) SigmaTel, Inc. 2001
                             4954 ; 3    |//
                             4955 ; 4    |//  File        : FileSystem.h
                             4956 ; 5    |//  Description : Header File for File System
                             4957 ; 6    |////////////////////////////////////////////////////////////////////////////////
                             4958 ; 7    |
                             4959 ; 8    |#ifndef _FILESYSTEM_H
                             4960 ; 9    |#define _FILESYSTEM_H
                             4961 ; 10   |
                             4962 ; 11   |#include "types.h"
                             4963 ; 12   |
                             4964 ; 13   |
                             4965 ; 14   |// File attributes
                             4966 ; 15   |#ifndef _FS_ATTRIBUTES
                             4967 ; 16   |#define _FS_ATTRIBUTES
                             4968 ; 17   |#define READ        1
                             4969 ; 18   |#define WRITE       2
                             4970 ; 19   |#define WRITE_PLUS  3
                             4971 ; 20   |#define APPEND      4
                             4972 ; 21   |#define TRUNCATE    8
                             4973 ; 22   |#define CREATE      16
                             4974 ; 23   |#endif
                             4975 ; 24   |
                             4976 ; 25   |//#ifndef FAT12
                             4977 ; 26   |//#define FAT12   1
                             4978 ; 27   |//#endif
                             4979 ; 28   |//
                             4980 ; 29   |#ifndef FAT16
                             4981 ; 30   |#define FAT16   2
                             4982 ; 31   |#endif
                             4983 ; 32   |
                             4984 ; 33   |#define MEM_SPACE_P 0x100000
                             4985 ; 34   |#define MEM_SPACE_Y 0x400000
                             4986 ; 35   |#define MEM_SPACE_X 0x800000
                             4987 ; 36   |
                             4988 ; 37   |#define FILE_SYS_MODE_READ  0
                             4989 ; 38   |#define FILE_SYS_MODE_WRITE 1
                             4990 ; 39   | 
                             4991 ; 40   |#define ATTR_READ_ONLY      0x01
                             4992 ; 41   |#define ATTR_HIDDEN         0x02
                             4993 ; 42   |#define ATTR_SYSTEM         0x04
                             4994 ; 43   |#define ATTR_VOLUME_ID      0x08
                             4995 ; 44   |#define ATTR_DIRECTORY      0x10
                             4996 ; 45   |#define ATTR_ARCHIVE        0x20
                             4997 ; 46   |#define ATTR_LONG_NAME      ATTR_READ_ONLY|ATTR_HIDDEN|ATTR_SYSTEM|ATTR_VOLUME_ID
                             4998 ; 47   |
                             4999 ; 48   |#define SEEK_SET           -1
                             5000 ; 49   |#define SEEK_CUR            0
                             5001 ; 50   |#define SEEK_END            1
                             5002 ; 51   |
                             5003 ; 52   |#define DEVICE_INSTALLED              (WORD)(0)
                             5004 ; 53   |#define DEVICE_NOT_FOUND              (WORD)(2)
                             5005 ; 54   |#define INVALID_FILESYSTEM                        (WORD)(3)
                             5006 ; 55   |#define DEVICE_INVALID                (WORD)(-1)
                             5007 ; 56   |#define DEVICE_ERROR_WRITE_PROTECTED  (WORD)(-2)
                             5008 ; 57   |
                             5009 ; 58   |#define MEDIA_SIZE_TOTAL_SECTORS    0
                             5010 ; 59   |#define MEDIA_SIZE_TOTAL_BYTES      1
                             5011 ; 60   |#define MEDIA_SIZE_BYTES_PER_SECTOR 2
                             5012 ; 61   |#define MEDIA_SIZE_IN_MEGABYTES     3     
                             5013 ; 62   |
                             5014 ; 63   |#define READ_TYPE_NORMAL            0
                             5015 ; 64   |#define READ_TYPE_FAT               1
                             5016 ; 65   |#define READ_TYPE_RAW               2
                             5017 ; 66   |
                             5018 ; 67   |
                             5019 ; 68   |#ifdef MEDIA_DDI_PARTIAL_SEQ_ENABLE
                             5020 ; 69   |    #define WRITE_TYPE_RANDOM                   0
                             5021 ; 70   |    #define WRITE_TYPE_SEQ_FIRST                1
                             5022 ; 71   |    #define WRITE_TYPE_SEQ_NEXT                 2
                             5023 ; 72   |    #define WRITE_TYPE_RESET_CLEAN_UP           3
                             5024 ; 73   |    #define WRITE_TYPE_PARTIAL_SEQ_FIRST        4
                             5025 ; 74   |    #define WRITE_TYPE_PARTIAL_SEQ_NEXT         5
                             5026 ; 75   |    #define WRITE_TYPE_PARTIAL_SEQ_LAST         6
                             5027 ; 76   |    #ifdef MEDIA_DDI_RAW_SECTOR_SERVER_ENABLE
                             5028 ; 77   |        #define WRITE_TYPE_RANDOM_RAW               7
                             5029 ; 78   |        #define WRITE_TYPE_SEQ_FIRST_RAW            8
                             5030 ; 79   |        #define WRITE_TYPE_SEQ_NEXT_RAW             9
                             5031 ; 80   |        #define WRITE_TYPE_PARTIAL_SEQ_FIRST_RAW    10
                             5032 ; 81   |        #define WRITE_TYPE_PARTIAL_SEQ_NEXT_RAW     11
                             5033 ; 82   |        #define WRITE_TYPE_PARTIAL_SEQ_LAST_RAW     12
                             5034 ; 83   |    #endif
                             5035 ; 84   |#else
                             5036 ; 85   |    #define WRITE_TYPE_RANDOM                   0
                             5037 ; 86   |    #define WRITE_TYPE_SEQ_FIRST                1
                             5038 ; 87   |    #define WRITE_TYPE_SEQ_NEXT                 2
                             5039 ; 88   |    #ifdef MEDIA_DDI_RAW_SECTOR_SERVER_ENABLE
                             5040 ; 89   |        #define WRITE_TYPE_RANDOM_RAW               3
                             5041 ; 90   |        #define WRITE_TYPE_SEQ_FIRST_RAW            4
                             5042 ; 91   |        #define WRITE_TYPE_SEQ_NEXT_RAW             5
                             5043 ; 92   |    #endif
                             5044 ; 93   |#endif
                             5045 ; 94   |    #define WRITE_TYPE_UNDEFINED 0xFFFFFF
                             5046 ; 95   |
                             5047 ; 96   |
                             5048 ; 97   |#ifndef MAX_FILENAME_LENGTH
                             5049 ; 98   |#define MAX_FILENAME_LENGTH 256
                             5050 ; 99   |#endif
                             5051 ; 100  |
                             5052 ; 101  |typedef struct {
                             5053 ; 102  |    WORD wNumberOfZones;
                             5054 ; 103  |    WORD wSizeInMegaBytes;
                             5055 ; 104  |} SMARTMEDIA_CHIP_INFO;
                             5056 ; 105  |
                             5057 ; 106  |typedef struct {
                             5058 ; 107  |    WORD wBootIdentification;
                             5059 ; 108  |    WORD wStartHeadNumber;
                             5060 ; 109  |    WORD wStartSectorNumber;
                             5061 ; 110  |    WORD wStartCylinderNumber;
                             5062 ; 111  |    WORD wSystemIdentification;
                             5063 ; 112  |    WORD wEndHeadNumber;
                             5064 ; 113  |    WORD wEndSectorNumber;
                             5065 ; 114  |    WORD wEndCylinderNumber;
                             5066 ; 115  |    WORD wStartLogicalSectorNumberHigh;
                             5067 ; 116  |    WORD wStartLogicalSectorNumberLow;
                             5068 ; 117  |    WORD wPartitionSizeHigh;
                             5069 ; 118  |    WORD wPartitionSizeLow;
                             5070 ; 119  |} SMARTMEDIA_PARTITION_TABLE;
                             5071 ; 120  |
                             5072 ; 121  |typedef struct {
                             5073 ; 122  |    WORD wWord0;
                             5074 ; 123  |    WORD wWord1;
                             5075 ; 124  |    WORD wWord2;
                             5076 ; 125  |} SMARTMEDIA_CIS_IDI_MANUFACTURER_NAME;
                             5077 ; 126  |
TASKING DSP2410 assembler v1.5r1 Build 138 SN 00100122
                                                                                                                                                                                                                                                       Page  20

M:ADDR CODE           CYCLES LINE SOURCELINE
                             5078 ; 127  |typedef struct {
                             5079 ; 128  |    WORD wWord0;
                             5080 ; 129  |    WORD wWord1;
                             5081 ; 130  |} SMARTMEDIA_CIS_IDI_PRODUCT_NAME;
                             5082 ; 131  |
                             5083 ; 132  |typedef struct {
                             5084 ; 133  |    WORD wWord0;
                             5085 ; 134  |    WORD wWord1;
                             5086 ; 135  |} SMARTMEDIA_CIS_IDI_PRODUCT_VERSION;
                             5087 ; 136  |
                             5088 ; 137  |typedef struct {
                             5089 ; 138  |    WORD wWord0;
                             5090 ; 139  |    WORD wWord1;
                             5091 ; 140  |    WORD wWord2;
                             5092 ; 141  |    WORD wWord3;
                             5093 ; 142  |} SMARTMEDIA_CIS_IDI_SERIAL_NUMBER;
                             5094 ; 143  |
                             5095 ; 144  |typedef struct {
                             5096 ; 145  |    WORD wWord0;
                             5097 ; 146  |} SMARTMEDIA_CIS_IDI_MODEL_NUMBER;
                             5098 ; 147  |
                             5099 ; 148  |typedef struct {
                             5100 ; 149  |    SMARTMEDIA_CIS_IDI_MANUFACTURER_NAME ManufacturerName;
                             5101 ; 150  |    SMARTMEDIA_CIS_IDI_PRODUCT_NAME ProductName;
                             5102 ; 151  |    SMARTMEDIA_CIS_IDI_PRODUCT_VERSION ProductVersion;
                             5103 ; 152  |    SMARTMEDIA_CIS_IDI_SERIAL_NUMBER SerialNumber;
                             5104 ; 153  |    SMARTMEDIA_CIS_IDI_MODEL_NUMBER ModelNumber;
                             5105 ; 154  |} SMARTMEDIA_CIS_IDI_TABLE;
                             5106 ; 155  |   
                             5107 ; 156  |typedef struct {
                             5108 ; 157  |    WORD wPageSizeInBytes;
                             5109 ; 158  |    WORD wRedundantAreaSizeInBytes;
                             5110 ; 159  |    WORD wNumberOfPagesPerBlock;
                             5111 ; 160  |    WORD wNumberOfBlocksPerZone;
                             5112 ; 161  |    WORD wNumberOfZonesInMedia;
                             5113 ; 162  |    WORD wMediaSizeInMBytes;
                             5114 ; 163  |    SMARTMEDIA_PARTITION_TABLE * pPartitionTable;
                             5115 ; 164  |    SMARTMEDIA_CIS_IDI_TABLE * pCisIdiTable;
                             5116 ; 165  |    WORD wMediaFlagStatus;
                             5117 ; 166  |    WORD wNumberOfBlocksToTheCisIdiBlock;
                             5118 ; 167  |    WORD wTotalNumberOfPhysicalBlocks;
                             5119 ; 168  |    WORD wNumberOfSystemBlocks;
                             5120 ; 169  |} SMARTMEDIA_ENTRY_TABLE;
                             5121 ; 170  |
                             5122 ; 171  |typedef struct {
                             5123 ; 172  |    WORD wDevice;        
                             5124 ; 173  |    WORD wDirtyBlockFlag;
                             5125 ; 174  |    WORD wCleanTailFlag; 
                             5126 ; 175  |    WORD wLogDOSPage;    
                             5127 ; 176  |    WORD wSrcLogBlock;   
                             5128 ; 177  |    WORD wSrcPhyBlock;   
                             5129 ; 178  |    WORD wDestPhyBlock;  
                             5130 ; 179  |    WORD wStartSrcPage;  
                             5131 ; 180  |    WORD wStartDestPage; 
                             5132 ; 181  |    WORD wPagesToCopy;   
                             5133 ; 182  |    WORD wReplaceBuff;   
                             5134 ; 183  |    WORD wReplaceRdnt;
                             5135 ; 184  |    #ifdef MEDIA_DDI_PARTIAL_SEQ_ENABLE
                             5136 ; 185  |        WORD wFirstCount;
                             5137 ; 186  |        WORD wNextCount;
                             5138 ; 187  |        WORD wLastCount;
                             5139 ; 188  |    #endif
                             5140 ; 189  |} SMARTMEDIA_FWPPS_TABLE;
                             5141 ; 190  |
                             5142 ; 191  |typedef struct {
                             5143 ; 192  |    WORD wWord0;
                             5144 ; 193  |    WORD wWord1;
                             5145 ; 194  |    WORD wWord2;
                             5146 ; 195  |    WORD wWord3;
                             5147 ; 196  |} DIRECTORY_NAME;
                             5148 ; 197  |
                             5149 ; 198  |typedef struct {
                             5150 ; 199  |    WORD wWord0;
                             5151 ; 200  |    WORD wWord1;
                             5152 ; 201  |} DIRECTORY_EXTENSION;
                             5153 ; 202  |
                             5154 ; 203  |typedef struct {
                             5155 ; 204  |    WORD wWord0;
                             5156 ; 205  |    WORD wWord1;
                             5157 ; 206  |} DIRECTORY_SIZE;
                             5158 ; 207  |
                             5159 ; 208  |typedef struct {
                             5160 ; 209  |    DIRECTORY_NAME Name;
                             5161 ; 210  |    DIRECTORY_EXTENSION Extension;
                             5162 ; 211  |    WORD wAttribute;
                             5163 ; 212  |    WORD wReserved[4];
                             5164 ; 213  |    WORD wCreationTime;
                             5165 ; 214  |    WORD wCreationData;
                             5166 ; 215  |    WORD wFirstCluster;
                             5167 ; 216  |    DIRECTORY_SIZE Size;
                             5168 ; 217  |    WORD wCurrentCluster;
                             5169 ; 218  |    WORD wPointer;
                             5170 ; 219  |    WORD wRecord;
                             5171 ; 220  |    WORD wRd;
                             5172 ; 221  |} DIRECTORY_FILE_CONTROL_BLOCK;
                             5173 ; 222  |
                             5174 ; 223  |// TODO:  clean this up.  There are two versions.
                             5175 ; 224  |struct FCB
                             5176 ; 225  |{
                             5177 ; 226  |    _packed BYTE m_szFileName[9];       //0-2
                             5178 ; 227  |    int     m_wReserved;                //3
                             5179 ; 228  |    _packed BYTE m_szExt[4];            //4-5
                             5180 ; 229  |    int     m_wAttributes;              //6
                             5181 ; 230  |    int     m_wReserved2[4];            //7,8,9,a
                             5182 ; 231  |    int     m_wTimeofCreation;          //b
                             5183 ; 232  |    int     m_wDateofCreation;          //c
                             5184 ; 233  |    int     m_wFirstCluster;            //d
                             5185 ; 234  |    int     m_wFileSizeHigh;            //e
                             5186 ; 235  |    int     m_wFileSizeLow;             //f
                             5187 ; 236  |};
                             5188 ; 237  |
                             5189 ; 238  |
                             5190 ; 239  |typedef struct {
                             5191 ; 240  |    WORD wFirstClusterCurrentDirectory;
                             5192 ; 241  |    WORD wFirstClusterParentDirectory;
                             5193 ; 242  |    WORD wAbsSectorCurrentlyCached;
                             5194 ; 243  |    WORD wCurrentRelativeSector;
                             5195 ; 244  |    WORD wNumberOfSectors;
                             5196 ; 245  |    WORD wCurrentRecordLoadedInDcb;
                             5197 ; 246  |    WORD wBufferedRecord;
                             5198 ; 247  |    WORD wMaxNumberRecordsCurrentDirectory;
                             5199 ; 248  |    WORD * pwPointerToBuffer;
                             5200 ; 249  |    WORD * pwPointerToPath;
                             5201 ; 250  |    DIRECTORY_FILE_CONTROL_BLOCK * pDirFcb;
                             5202 ; 251  |} DIRECTORY_CONTROL_BLOCK;
                             5203 ; 252  |
                             5204 ; 253  |typedef struct {
                             5205 ; 254  |    WORD wWord0;
                             5206 ; 255  |    WORD wWord1;
                             5207 ; 256  |    WORD wWord2;
                             5208 ; 257  |    WORD wWord3;
                             5209 ; 258  |} FILE_NAME;
                             5210 ; 259  |
                             5211 ; 260  |typedef struct {
                             5212 ; 261  |    WORD wWord0;
                             5213 ; 262  |    WORD wWord1;
                             5214 ; 263  |} FILE_EXTENSION;
                             5215 ; 264  |
                             5216 ; 265  |typedef struct {
                             5217 ; 266  |    WORD wWord0;
                             5218 ; 267  |    WORD wWord1;
                             5219 ; 268  |} FILE_SIZE;
                             5220 ; 269  |
                             5221 ; 270  |typedef union {
                             5222 ; 271  |    struct {
                             5223 ; 272  |        int Read        :1;
                             5224 ; 273  |        int Write       :1;
                             5225 ; 274  |        int Append      :1;
                             5226 ; 275  |        int Truncate    :1;
                             5227 ; 276  |        int Create      :1;
                             5228 ; 277  |        int Rsrv        :3;
                             5229 ; 278  |        int Mode        :8;
                             5230 ; 279  |        int Device      :8;
                             5231 ; 280  |    } B;
                             5232 ; 281  |    int I;
                             5233 ; 282  |} FILE_FLAGS;
                             5234 ; 283  |
                             5235 ; 284  |typedef struct {
                             5236 ; 285  |    WORD wWord0;
                             5237 ; 286  |    WORD wWord1;
                             5238 ; 287  |} FILE_BYTE_CURRENT;
                             5239 ; 288  |
                             5240 ; 289  |typedef struct {
                             5241 ; 290  |    FILE_NAME Name;
                             5242 ; 291  |    FILE_EXTENSION Extension;
                             5243 ; 292  |    WORD wAttributes;
                             5244 ; 293  |    WORD wReserved[4];
                             5245 ; 294  |    WORD wCreationTime;
                             5246 ; 295  |    WORD wCreationData;
                             5247 ; 296  |    WORD wFirstCluster;
                             5248 ; 297  |    FILE_SIZE Size;
                             5249 ; 298  |    WORD wCurrentCluster;
                             5250 ; 299  |    WORD wPointer;
                             5251 ; 300  |    WORD wRecord;
                             5252 ; 301  |    WORD wRd;
                             5253 ; 302  |    FILE_FLAGS Flags;
                             5254 ; 303  |    FILE_BYTE_CURRENT FcbByteCurrent;
                             5255 ; 304  |    WORD wFcbFlagEndOfCx;
                             5256 ; 305  |} FILE_CONTROL_BLOCK;    
                             5257 ; 306  |
                             5258 ; 307  |typedef struct {
                             5259 ; 308  |    WORD wWord0;
                             5260 ; 309  |    WORD wWord1;
                             5261 ; 310  |    WORD wWord2;
                             5262 ; 311  |    WORD wWord3;
                             5263 ; 312  |} VOLUME_LABEL;
                             5264 ; 313  |
                             5265 ; 314  |typedef struct {
                             5266 ; 315  |    WORD wFATPhysicalBlock1;
                             5267 ; 316  |    WORD wFATPhysicalBlock2;
                             5268 ; 317  |    WORD wFATPhysicalBlock3;
                             5269 ; 318  |    WORD wFATPhysicalBlock4;
                             5270 ; 319  |} FAT_PHYSICAL_BLOCK_LIST;
                             5271 ; 320  |
                             5272 ; 321  |typedef struct {
                             5273 ; 322  |    WORD wFATSectorInCache;
                             5274 ; 323  |    WORD wLastClusterFree;
                             5275 ; 324  |    WORD wNumberOfUsedClusters;
                             5276 ; 325  |    WORD wNumberOfFreeClusters;
                             5277 ; 326  |    WORD wNumberOfBadClusters;
                             5278 ; 327  |    WORD wNumberOfReservedClusters;
                             5279 ; 328  |    WORD wControl;
                             5280 ; 329  |    WORD * pwSectorCache;
                             5281 ; 330  |    FAT_PHYSICAL_BLOCK_LIST FATPhysicalLocationList;
                             5282 ; 331  |} FAT_TABLE;
                             5283 ; 332  |
                             5284 ; 333  |typedef struct {
                             5285 ; 334  |    WORD wStateMediaTable;
                             5286 ; 335  |    WORD wTypeFs;
                             5287 ; 336  |    WORD wBytesPerSector;
                             5288 ; 337  |    WORD wSectorsPerCluster;
                             5289 ; 338  |    WORD wNumberOfReservedSectors;
                             5290 ; 339  |    WORD wMaximumNumberOfFATs;
                             5291 ; 340  |    WORD wMaxRootDirectoryEntries;
                             5292 ; 341  |    WORD wTotalSectors;
                             5293 ; 342  |    WORD wNumberOfFATSectors;
                             5294 ; 343  |    WORD wNumberOfSectorsPerTrack;
                             5295 ; 344  |    WORD wNumberOfHeads;
                             5296 ; 345  |    WORD wNumberOfHiddenSectorsMSB;
                             5297 ; 346  |    WORD wNumberOfHiddenSectorsLSB;
                             5298 ; 347  |    WORD wTotalSectors32MSB;
                             5299 ; 348  |    WORD wTotalSectors32LSB;
                             5300 ; 349  |    WORD wDriverNumber;
                             5301 ; 350  |    WORD wExtendedBootSignature;
                             5302 ; 351  |    WORD wVolumeIDMSB;
                             5303 ; 352  |    WORD wVolumeIDLSB;
                             5304 ; 353  |    VOLUME_LABEL VolumeLabel;
                             5305 ; 354  |    WORD * pwWriteBuffer;
                             5306 ; 355  |    WORD wPrimaryFATRelativeSector;
                             5307 ; 356  |    WORD wSecondaryFATRelativeSector;
                             5308 ; 357  |    WORD wRootDirectoryRelativeSector;
                             5309 ; 358  |    WORD wFirstSectorNumberDataZone;
                             5310 ; 359  |    WORD wMaxNumberOfFATEntries;
                             5311 ; 360  |    WORD wRootDirectorySizeInSectors;
                             5312 ; 361  |    WORD wDataAreaSizeInSectors;
                             5313 ; 362  |} MEDIA_TABLE;
                             5314 ; 363  |
                             5315 ; 364  |typedef struct {
                             5316 ; 365  |    MEDIA_TABLE * pMediaTable;
                             5317 ; 366  |    DIRECTORY_CONTROL_BLOCK * pDirectoryControlBlock;
                             5318 ; 367  |    FAT_TABLE * pFATTable;
                             5319 ; 368  |} DEVICE_CONTROL_TABLE;
                             5320 ; 369  |    
                             5321 ; 370  |typedef struct {
                             5322 ; 371  |    WORD dwTotalSizeInMegaBytes;        // dwTotalSizeInMegaBytes is limited
                             5323 ; 372  |                                        //  to 2-bytes for compatibility with
                             5324 ; 373  |                                        //  older host drivers.
                             5325 ; 374  |    DWORD dwTotalNumberOfSectors;
                             5326 ; 375  |    DWORD dwTotalNumberOfBytes;
                             5327 ; 376  |    WORD wSectorSizeInBytes;
                             5328 ; 377  |} MEDIA_SIZE;
TASKING DSP2410 assembler v1.5r1 Build 138 SN 00100122
                                                                                                                                                                                                                                                       Page  21

M:ADDR CODE           CYCLES LINE SOURCELINE
                             5329 ; 378  |
                             5330 ; 379  |typedef struct {
                             5331 ; 380  |    BOOL    bInstalled;
                             5332 ; 381  |    INT     iPbsSectorOffset;   // from the beginning of the data drive 
                             5333 ; 382  |    DWORD   dwSize;
                             5334 ; 383  |} DATA_DRIVE_PBS_LOC;
                             5335 ; 384  |extern  INT _reentrant FSFileOpen(_packed BYTE *fname,INT attribute, INT DeviceNumber);
                             5336 ; 385  |extern  INT _reentrant FSFastOpen(DWORD Key, INT attribute);
                             5337 ; 386  |extern  INT FSFileDelete(_packed BYTE *fname,INT DeviceNumber);
                             5338 ; 387  |extern  INT FSFileCreate(_packed BYTE *fname,INT DeviceNumber);
                             5339 ; 388  |extern  INT _reentrant FSChangeDir(_packed BYTE *dirname,INT DeviceNumber);
                             5340 ; 389  |extern  INT _reentrant FSCreateDir(_packed BYTE *dirname,INT DeviceNumber);
                             5341 ; 390  |extern  INT _reentrant FSDeleteDir(_packed BYTE *dirname,INT DeviceNumber);
                             5342 ; 391  |extern  INT _reentrant FSFileAppend(_packed BYTE *fname,INT DeviceNumber);
                             5343 ; 392  |extern  INT _reentrant FSFileRead(INT BytestoRead, INT Handle, INT memory_type, INT modulo, WORD *buffer);
                             5344 ; 393  |extern  INT _reentrant FSFileWrite(INT wNumberBytes, INT Handle, INT memory_type, INT iModulo, WORD *buffer);
                             5345 ; 394  |extern  INT _reentrant FSFileClose(INT Handle);
                             5346 ; 395  |extern  LONG _reentrant FSFileSize(INT HandleNumber);
                             5347 ; 396  |extern  LONG  FSSize(INT DeviceNum, INT TYPE);   
                             5348 ; 397  |extern  INT FSFreeClusters(INT Device);
                             5349 ; 398  |extern  INT BytesPerCluster(INT Device);
                             5350 ; 399  |
                             5351 ; 400  |
                             5352 ; 401  |
                             5353 ; 402  |//extern  INT FSFileCreate(_packed BYTE *pbFileName, BYTE bDevice);
                             5354 ; 403  |//extern  INT FSFileDelete(_packed BYTE *pbFileName, BYTE bDevice);
                             5355 ; 404  |extern  INT FSFileRename(_packed BYTE *pbCurFilename, _packed BYTE *pbNewFilename, BYTE bDevice);
                             5356 ; 405  |//extern  INT _reentrant FSFileAttribute(_packed BYTE *pbFilename, WORD wAttributes, BYTE bDevice);
                             5357 ; 406  |//extern  INT FSFileAppend(_packed BYTE *pbFileName, BYTE bDevice);
                             5358 ; 407  |//extern  INT FSFileOpen(_packed BYTE *pbFileName, WORD wAttributes, BYTE bDevice);
                             5359 ; 408  |//extern  INT FSFileClose(INT bHandle);
                             5360 ; 409  |//extern  INT FSFileRead(WORD wNumberBytes, BYTE bHandle, WORD wMemSpace, INT iModulo, WORD *pwBuffer);
                             5361 ; 410  |//extern  INT FSFileWrite(WORD wNumberBytes, BYTE bHandle, WORD wMemSpace, INT iModulo, WORD *pwBuffer);
                             5362 ; 411  |extern  INT _reentrant fseek( INT handle , LONG offset, INT iOrigin );
                             5363 ; 412  |extern  INT _reentrant FSFileEof(INT Handle);
                             5364 ; 413  |extern INT _reentrant FSFileAttribute(INT Attributes, _packed BYTE *fname, INT DeviceNumber);
                             5365 ; 414  |extern INT _reentrant FSFileAttributeClear(INT Attributes, _packed BYTE *fname, INT DeviceNumber);
                             5366 ; 415  |//extern  LONG FSFileSize(INT bHandle);
                             5367 ; 416  |extern _asmfunc INT FSPresent(BYTE bDevice);
                             5368 ; 417  |extern _asmfunc INT FSType(BYTE bDevice);
                             5369 ; 418  |//extern LONG FSSize(WORD wDevice, WORD wReturnType);
                             5370 ; 419  |//extern INT FSChangeDir(_packed BYTE *pbDirName, BYTE bDevice);
                             5371 ; 420  |//extern INT FSCreateDir(_packed BYTE *pbDirName, BYTE bDevice);
                             5372 ; 421  |//extern INT FSDeleteDir(_packed BYTE *pbDirName, BYTE bDevice);
                             5373 ; 422  |extern _asmfunc void SysLoadFATWrite(void);
                             5374 ; 423  |extern _asmfunc INT SysUnLoadFATWrite(void);
                             5375 ; 424  |extern LONG _reentrant ftell(INT iHandle);
                             5376 ; 425  |extern _asmfunc struct FCB * ReadDirectory(int iDevice, int iEntry);
                             5377 ; 426  |
                             5378 ; 427  |#endif
                             5379 
                             5381 
                             5382 ; 13   |#include "sectorarrayhandler.h"
                             5383 
                             5385 
                             5386 ; 1    |#ifndef __SECTOR_ARRAY_HANDLER_H
                             5387 ; 2    |#define __SECTOR_ARRAY_HANDLER_H
                             5388 ; 3    |
                             5389 ; 4    |#define SECTOR_STATE_FREE 0
                             5390 ; 5    |#define SECTOR_STATE_FILLING 1
                             5391 ; 6    |#define SECTOR_STATE_FILLED 2
                             5392 ; 7    |
                             5393 ; 8    |typedef struct
                             5394 ; 9    |{
                             5395 ; 10   |    int iState;
                             5396 ; 11   |    WORD _X *pwData;
                             5397 ; 12   |} SECTOR_TYPE;
                             5398 
                             5405 
                             5406 ; 13   |
                             5407 ; 14   |
                             5408 ; 15   |
                             5409 ; 16   |typedef struct SectorArray
                             5410 ; 17   |{
                             5411 ; 18   |    SECTOR_TYPE*pSectors;
                             5412 ; 19   |    INT iNumSectorBuffers;
                             5413 ; 20   |    WORD wHeadIndex;
                             5414 ; 21   |    WORD wFillingIndex;
                             5415 ; 22   |    WORD wTailIndex;
                             5416 ; 23   |    WORD wSectorsInFlight;
                             5417 ; 24   |}  SECTOR_ARRAY;
                             5418 
                             5429 
                             5430 ; 25   |
                             5431 ; 26   |
                             5432 ; 27   |
                             5433 ; 28   |_reentrant SECTOR_TYPE*ReadSectorArrayHandlerGetFreeSector(SECTOR_ARRAY*);
                             5434 ; 29   |_reentrant void ReadSectorArrayHandlerFreeSector(SECTOR_ARRAY*);
                             5435 ; 30   |_reentrant void ReadSectorArrayHandlerFreeAllSectors(SECTOR_ARRAY*);
                             5436 ; 31   |
                             5437 ; 32   |_reentrant SECTOR_TYPE*WriteSectorArrayHandlerGetFreeSector(SECTOR_ARRAY*);
                             5438 ; 33   |_reentrant SECTOR_TYPE*WriteSectorArrayHandlerGetFilledSector(SECTOR_ARRAY*);
                             5439 ; 34   |_reentrant void WriteSectorArrayHandlerFillSector(SECTOR_ARRAY*);
                             5440 ; 35   |_reentrant void WriteSectorArrayHandlerFreeSector(SECTOR_ARRAY*,SECTOR_TYPE*);
                             5441 ; 36   |
                             5442 ; 37   |_reentrant void SectorArrayInitialize(SECTOR_ARRAY *, WORD wSectorCount,WORD wSectorSize, SECTOR_TYPE *pSectorTypeArray,WORD _X *pSectorDataBuffer);
                             5443 ; 38   |
                             5444 ; 39   |
                             5445 ; 40   |#endif 
                             5446 
                             5448 
                             5449 ; 14   |////////////////////////////////////////////////////////////////////////////////
                             5450 ; 15   |// Debug stuff
                             5451 ; 16   |////////////////////////////////////////////////////////////////////////////////
                             5452 ; 17   |
                             5453 ; 18   |    #ifdef SCSI_COMMAND_HISTORY
                             5454 ; 19   |#define SCSI_COMMAND_HISTORY_SIZE       500
                             5455 ; 20   |#define SCSI_CDB_SIZE_IN_WORDS          6
                             5456 ; 21   |    #endif
                             5457 ; 22   |    
                             5458 ; 23   |////////////////////////////////////////////////////////////////////////////////
                             5459 ; 24   |// Defs
                             5460 ; 25   |////////////////////////////////////////////////////////////////////////////////
                             5461 ; 26   |
                             5462 ; 27   |#define SCSI_CDB_BUFFER_OP_CODE_MASK    (WORD)0x0000FF
                             5463 ; 28   |
                             5464 ; 29   |////////////////////////////////////////////////////////////////////////////////
                             5465 ; 30   |// Supported SCSI commands
                             5466 ; 31   |#define SCSI_OPCODE_INQUIRY                         0x12
                             5467 ; 32   |#define SCSI_OPCODE_READ_CAPACITY                   0x25
                             5468 ; 33   |#define SCSI_OPCODE_READ_FORMAT_CAPACITIES          0x23
                             5469 ; 34   |#define SCSI_OPCODE_READ_6                          0x08
                             5470 ; 35   |#define SCSI_OPCODE_READ_10                         0x28
                             5471 ; 36   |#define SCSI_OPCODE_READ_12                         0xA8
                             5472 ; 37   |#define SCSI_OPCODE_READ_16                         0x88
                             5473 ; 38   |#define SCSI_OPCODE_WRITE_6                         0x0A
                             5474 ; 39   |#define SCSI_OPCODE_WRITE_10                        0x2A
                             5475 ; 40   |#define SCSI_OPCODE_WRITE_12                        0xAA
                             5476 ; 41   |#define SCSI_OPCODE_WRITE_16                        0x8A
                             5477 ; 42   |#define SCSI_OPCODE_REQUEST_SENSE                   0x03
                             5478 ; 43   |#define SCSI_OPCODE_TEST_UNIT_READY                 0x00
                             5479 ; 44   |#define SCSI_OPCODE_START_STOP_UNIT                 0x1B
                             5480 ; 45   |#define SCSI_OPCODE_FORMAT_UNIT                     0x04
                             5481 ; 46   |#define SCSI_OPCODE_RESERVE_10                      0x56
                             5482 ; 47   |#define SCSI_OPCODE_RELEASE_10                      0x57
                             5483 ; 48   |#define SCSI_OPCODE_SEND_DIAGNOSTIC                 0x1D
                             5484 ; 49   |#define SCSI_OPCODE_MODE_SENSE_6                    0x1A
                             5485 ; 50   |#define SCSI_OPCODE_MODE_SENSE_10                   0x5A
                             5486 ; 51   |#define SCSI_OPCODE_PREVENT_ALLOW_MEDIUM_REMOVAL    0x1E
                             5487 ; 52   |#define SCSI_OPCODE_START_STOP_UNIT                 0x1B // Start Stop Unit from the SBC-2 spec
                             5488 ; 53   |#define SCSI_OPCODE_READ_BUFFER                     0x3C
                             5489 ; 54   |
                             5490 ; 55   |#define SCSI_CDB_SIZE_INQUIRY                       6
                             5491 ; 56   |#define SCSI_CDB_SIZE_READ_CAPACITY                 10
                             5492 ; 57   |#define SCSI_CDB_SIZE_READ_6                        6
                             5493 ; 58   |#define SCSI_CDB_SIZE_READ_10                       10
                             5494 ; 59   |#define SCSI_CDB_SIZE_READ_12                       12
                             5495 ; 60   |#define SCSI_CDB_SIZE_READ_16                       16
                             5496 ; 61   |#define SCSI_CDB_SIZE_WRITE_6                       6
                             5497 ; 62   |#define SCSI_CDB_SIZE_WRITE_10                      10
                             5498 ; 63   |#define SCSI_CDB_SIZE_WRITE_12                      12
                             5499 ; 64   |#define SCSI_CDB_SIZE_WRITE_16                      16
                             5500 ; 65   |#define SCSI_CDB_SIZE_REQUEST_SENSE                 6
                             5501 ; 66   |#define SCSI_CDB_SIZE_TEST_UNIT_READY               6
                             5502 ; 67   |#define SCSI_CDB_SIZE_START_STOP_UNIT               6
                             5503 ; 68   |#define SCSI_CDB_SIZE_FORMAT_UNIT                   6
                             5504 ; 69   |#define SCSI_CDB_SIZE_RESERVE_10                    10
                             5505 ; 70   |#define SCSI_CDB_SIZE_RELEASE_10                    10
                             5506 ; 71   |#define SCSI_CDB_SIZE_SEND_DIAGNOSTIC               6
                             5507 ; 72   |#define SCSI_CDB_SIZE_MODE_SENSE_6                  6
                             5508 ; 73   |#define SCSI_CDB_SIZE_MODE_SENSE_10                 10
                             5509 ; 74   |#define SCSI_CDB_SIZE_PREVENT_ALLOW_MEDIUM_REMOVAL  6
                             5510 ; 75   |#define SCSI_CDB_SIZE_START_STOP_UNIT               6
                             5511 ; 76   |
                             5512 ; 77   |////////////////////////////////////////////////////////////////////////////////
                             5513 ; 78   |// Unsupported SCSI commands known to have been received.  Unknown SCSI commands
                             5514 ; 79   |//  not in this list are only trapped in development builds.  Release builds
                             5515 ; 80   |//  simply fail all commands not in this list.  Use the
                             5516 ; 81   |//  SCSI_TRAP_UNKNOWN_OPCODES build option in the make file to trap.
                             5517 ; 82   |#define SCSI_OPCODE_READ_FORMAT_CAPACITIES          0x23 // Read Format Capacities from the
                             5518 ; 83   |                                                         //  SFF-8070i spec
                             5519 ; 84   |#define SCSI_OPCODE_VERIFY_10                       0x2F // Verify(10) from the SBC-2 spec
                             5520 ; 85   |
                             5521 ; 86   |////////////////////////////////////////////////////////////////////////////////
                             5522 ; 87   |// Data direction defs
                             5523 ; 88   |#define SCSI_DATA_TO_HOST               0
                             5524 ; 89   |#define SCSI_DATA_FROM_HOST             1
                             5525 ; 90   |
                             5526 ; 91   |////////////////////////////////////////////////////////////////////////////////
                             5527 ; 92   |// Sense Data defs
                             5528 ; 93   |#define SENSE_DATA_RESPONSE_CODE_CURRENT_ERRORS     0x70
                             5529 ; 94   |#define SENSE_DATA_RESPONSE_CODE_DEFERRED_ERRORS    0x71
                             5530 ; 95   |#define SENSE_DATA_INFORMATION_VALID                1<<7
                             5531 ; 96   |#define SENSE_DATA_INFORMATION_INVALID              0
                             5532 ; 97   |#define SENSE_DATA_ILI_CORRECT                      0<<4
                             5533 ; 98   |#define SENSE_DATA_ILI_INCORRECT                    1<<4
                             5534 ; 99   |
                             5535 ; 100  |////////////////////////////////////////////////////////////////////////////////
                             5536 ; 101  |// Sense Key defs
                             5537 ; 102  |#define SCSI_SENSE_KEY_NO_SENSE             0<<16
                             5538 ; 103  |#define SCSI_SENSE_KEY_RECOVERED_ERROR      1<<16
                             5539 ; 104  |#define SCSI_SENSE_KEY_NOT_READY            2<<16
                             5540 ; 105  |#define SCSI_SENSE_KEY_MEDIUM_ERROR         3<<16
                             5541 ; 106  |#define SCSI_SENSE_KEY_HARDWARE_ERROR       4<<16
                             5542 ; 107  |#define SCSI_SENSE_KEY_ILLEGAL_REQUEST      5<<16
                             5543 ; 108  |#define SCSI_SENSE_KEY_UNIT_ATTENTION       6<<16
                             5544 ; 109  |#define SCSI_SENSE_KEY_DATA_PROTECT         7<<16
                             5545 ; 110  |#define SCSI_SENSE_KEY_BLANK_CHECK          8<<16
                             5546 ; 111  |#define SCSI_SENSE_KEY_VENDOR_SPECIFIC      9<<16
                             5547 ; 112  |#define SCSI_SENSE_KEY_COPY_ABORTED         10<<16
                             5548 ; 113  |#define SCSI_SENSE_KEY_ABORTED_COMMAND      11<<16
                             5549 ; 114  |#define SCSI_SENSE_KEY_OBSOLETE             12<<16
                             5550 ; 115  |#define SCSI_SENSE_KEY_VOLUME_OVERFLOW      13<<16
                             5551 ; 116  |#define SCSI_SENSE_KEY_MISCOMPARE           14<<16
                             5552 ; 117  |#define SCSI_SENSE_KEY_RESERVED             15<<16
                             5553 ; 118  |
                             5554 ; 119  |////////////////////////////////////////////////////////////////////////////////
                             5555 ; 120  |// Additional Sense Code & Qualifier defs.  Asc is the LSB.
                             5556 ; 121  |#define SCSI_ASC_NO_ADDITIONAL_SENSE_INFO                               0x0000
                             5557 ; 122  |
                             5558 ; 123  |#define SCSI_ASC_LOGICAL_UNIT_NOT_READY_MANUAL_INTERVENTION_REQUIRED    0x0304
                             5559 ; 124  |
                             5560 ; 125  |#define SCSI_ASC_LOGICAL_UNIT_DOES_NOT_RESPOND_TO_SELECTION             0x0005
                             5561 ; 126  |
                             5562 ; 127  |#define SCSI_ASC_INVALID_COMMAND_OPERATION_CODE                         0x0020
                             5563 ; 128  |
                             5564 ; 129  |#define SCSI_ASC_LOGICAL_UNIT_NOT_SUPPORTED                             0x0025
                             5565 ; 130  |
                             5566 ; 131  |#define SCSI_ASC_LOGICAL_BLOCK_ADDRESS_OUT_OF_RANGE                     0x0021 
                             5567 ; 132  |
                             5568 ; 133  |#define SCSI_ASC_WRITE_PROTECTED                                        0x0027
                             5569 ; 134  |
                             5570 ; 135  |#define SCSI_ASC_NOT_READY_TO_READY_CHANGE_MEDIUM_MAY_HAVE_CHANGED      0x0028
                             5571 ; 136  |
                             5572 ; 137  |#define SCSI_ASC_DEVICE_INTERNAL_RESET                                  0x0429
                             5573 ; 138  |
                             5574 ; 139  |#define SCSI_ASC_INCOMPATIBLE_MEDIUM_INSTALLED                          0x0030
                             5575 ; 140  |#define SCSI_ASC_CANNOT_READ_MEDIUM_UNKNOWN_FORMAT                      0x0130
                             5576 ; 141  |#define SCSI_ASC_CANNOT_READ_MEDIUM_INCOMPATIBLE_FORMAT                 0x0230
                             5577 ; 142  |#define SCSI_ASC_CANNOT_WRITE_MEDIUM_UNKNOWN_FORMAT                     0x0430
                             5578 ; 143  |#define SCSI_ASC_CANNOT_WRITE_MEDIUM_INCOMPATIBLE_FORMAT                0x0530
                             5579 ; 144  |
                             5580 ; 145  |#define SCSI_ASC_MEDIUM_FORMAT_CORRUPTED                                0x0031
                             5581 ; 146  |
                             5582 ; 147  |#define SCSI_ASC_UNRECOVERED_READ_ERROR                                 0x0011
                             5583 ; 148  |
                             5584 ; 149  |#define SCSI_ASC_MEDIUM_NOT_PRESENT                                     0x003A
                             5585 ; 150  |#define SCSI_ASC_MEDIUM_DESTINATION_ELEMENT_FULL                        0x003B
                             5586 ; 151  |
                             5587 ; 152  |#define SCSI_ASC_INQUIRY_DATA_HAS_CHANGED                               0x033F
                             5588 ; 153  |#define SCSI_ASC_REPORTED_LUNS_DATA_HAS_CHANGED                         0x0E3F
                             5589 ; 154  |
                             5590 ; 155  |#define SCSI_ASC_LOGICIAL_UNIT_FAILED_SELF_CONFIGURATION                0x004C
                             5591 ; 156  |
                             5592 ; 157  |#define SCSI_ASC_INVALID_FIELD_IN_CDB                                   0x0024
                             5593 ; 158  |
                             5594 ; 159  |#define SCSI_ASC_LOGICAL_UNIT_FAILURE                                   0x013E
                             5595 ; 160  |#define SCSI_ASC_LOGICAL_UNIT_NOT_READY_INIT_CMD_REQUIRED               0x0204
                             5596 ; 161  |
                             5597 ; 162  |////////////////////////////////////////////////////////////////////////////////
                             5598 ; 163  |// Inquiry Peripheral Qualifier defs
TASKING DSP2410 assembler v1.5r1 Build 138 SN 00100122
                                                                                                                                                                                                                                                       Page  22

M:ADDR CODE           CYCLES LINE SOURCELINE
                             5599 ; 164  |#define SCSI_INQUIRY_PERIPHERAL_QUALIFIER_LUN_CONNECTED         0
                             5600 ; 165  |#define SCSI_INQUIRY_PERIPHERAL_QUALIFIER_LUN_NOT_CONNECTED     1
                             5601 ; 166  |#define SCSI_INQUIRY_PERIPHERAL_QUALIFIER_RESERVED              2
                             5602 ; 167  |#define SCSI_INQUIRY_PERIPHERAL_QUALIFIER_NO_SUPPORT            3
                             5603 ; 168  |
                             5604 ; 169  |////////////////////////////////////////////////////////////////////////////////
                             5605 ; 170  |// Inquiry Peripheral Qualifier defs
                             5606 ; 171  |#define SCSI_INQUIRY_PERIPHERAL_DEVICE_TYPE_DIRECT_ACCESS       0
                             5607 ; 172  |#define SCSI_INQUIRY_PERIPHERAL_DEVICE_TYPE_NO_SUPPORT          0x1F
                             5608 ; 173  |
                             5609 ; 174  |////////////////////////////////////////////////////////////////////////////////
                             5610 ; 175  |// Inquiry RMB defs
                             5611 ; 176  |#define SCSI_INQUIRY_RMB_DEVICE_IS_NOT_REMOVABLE                0
                             5612 ; 177  |#define SCSI_INQUIRY_RMB_DEVICE_IS_REMOVABLE                    1
                             5613 ; 178  |
                             5614 ; 179  |////////////////////////////////////////////////////////////////////////////////
                             5615 ; 180  |// Inquiry Vendor Specific SigmaTel struct defs
                             5616 ; 181  |#define SCSI_INQUIRY_VENDOR_SPECIFIC_STRUCT_MDS                 1
                             5617 ; 182  |
                             5618 ; 183  |#define SCSI_MDS_FLAGS_SYSTEM_MEDIA_FLAG_NON_SYSTEM             (WORD)0x00
                             5619 ; 184  |#define SCSI_MDS_FLAGS_SYSTEM_MEDIA_FLAG_SYSTEM                 (WORD)0x01
                             5620 ; 185  |                                                                
                             5621 ; 186  |#define SCSI_MDS_MEDIA_TYPE_NAND                                (WORD)0x00
                             5622 ; 187  |#define SCSI_MDS_MEDIA_TYPE_SMARTMEDIA                          (WORD)0x01
                             5623 ; 188  |#define SCSI_MDS_MEDIA_TYPE_MMC_1_4                             (WORD)0x10
                             5624 ; 189  |#define SCSI_MDS_MEDIA_TYPE_MMC_2_1_1                           (WORD)0x11
                             5625 ; 190  |#define SCSI_MDS_MEDIA_TYPE_MMC_3_1                             (WORD)0x12
                             5626 ; 191  |#define SCSI_MDS_MEDIA_TYPE_MMC_UNKNOWN_VERSION                 (WORD)0x13
                             5627 ; 192  |#define SCSI_MDS_MEDIA_TYPE_SD_1_0                              (WORD)0x20
                             5628 ; 193  |#define SCSI_MDS_MEDIA_TYPE_SD_UNKNOWN_VERSION                  (WORD)0x21
                             5629 ; 194  |
                             5630 ; 195  |////////////////////////////////////////////////////////////////////////////////
                             5631 ; 196  |// Error codes
                             5632 ; 197  |////////////////////////////////////////////////////////////////////////////////
                             5633 ; 198  |
                             5634 ; 199  |#define SCSI_PROJECT_SPECIFIC_INIT_FAILED                       (WORD)0x000001
                             5635 ; 200  |#define SCSI_DEVICE_INIT_ALL_FAILED                             (WORD)0x000002
                             5636 ; 201  |#define SCSI_ERROR_LUN_NOT_READY                                (WORD)0x000003
                             5637 ; 202  |#define SCSI_ERROR_INVALID_COMMAND                              (WORD)0x000004
                             5638 ; 203  |#define SCSI_ERROR_USB_MSC_RESET_DURING_SCSI_COMMAND            (WORD)0x000005
                             5639 ; 204  |#define SCSI_ERROR_READ_SECTOR_FAILURE                          (WORD)0x000006
                             5640 ; 205  |#define SCSI_ERROR_WRITE_SECTOR_FAILURE                         (WORD)0x000007
                             5641 ; 206  |#define SCSI_ERROR_WAIT_FOR_USB_TIMEOUT                         (WORD)0x000008
                             5642 ; 207  |#define SCSI_READ_FAILURE_TIMEOUT_USB_WILL_NOT_STOP             (WORD)0x000009
                             5643 ; 208  |#define SCSI_WRITE_FAILURE_TIMEOUT_USB_WILL_NOT_STOP            (WORD)0x00000A
                             5644 ; 209  |#define SCSI_ERROR_USB_DISCONNECT                               (WORD)0x00000B
                             5645 ; 210  |#define SCSI_ERROR_DDI_CALL_FAILED                              (WORD)0x00000C
                             5646 ; 211  |#define SCSI_ERROR_LBA_OUT_OF_RANGE                         (RETCODE)(0x000100)
                             5647 ; 212  |#define SCSI_WRITE_FAILURE_ZONE_FULL                        (RETCODE)(0x9AAAAA)
                             5648 ; 213  |
                             5649 ; 214  |////////////////////////////////////////////////////////////////////////////////
                             5650 ; 215  |// Typedefs
                             5651 ; 216  |////////////////////////////////////////////////////////////////////////////////
                             5652 ; 217  |
                             5653 ; 218  |typedef RETCODE (*SCSI_CH)(WORD wDeviceNum, WORD _X* pCdb);
                             5654 ; 219  |typedef RETCODE (*SCSI_PROJECT_INIT)(void);
                             5655 ; 220  |typedef RETCODE (*SCSI_LUN_FLAG_MEDIA_CHANGE_FUNCTION)(void);
                             5656 ; 221  |
                             5657 ; 222  |typedef struct
                             5658 ; 223  |{
                             5659 ; 224  |    WORD wValid;
                             5660 ; 225  |    WORD wSenseKey;
                             5661 ; 226  |    WORD wIli;
                             5662 ; 227  |    DWORD dwInformation;
                             5663 ; 228  |    WORD wAscqAsc; 
                             5664 ; 229  |    WORD wAddlData;
                             5665 ; 230  |} SCSI_SENSE_DATA;
                             5666 ; 231  |
                             5667 ; 232  |typedef enum
                             5668 ; 233  |{
                             5669 ; 234  |    ScsiMediaStateUnknown = 0,
                             5670 ; 235  |    ScsiMediaStateReady = 1,
                             5671 ; 236  |    ScsiMediaStateFormatRequired = 2,
                             5672 ; 237  |    ScsiMediaStateHardwareFailed = 3
                             5673 ; 238  |} SCSI_MEDIA_STATE;
                             5674 
                             5699 
                             5700 ; 239  |
                             5701 ; 240  |typedef struct
                             5702 ; 241  |{
                             5703 ; 242  |    DWORD dwNumBytesXferred;
                             5704 ; 243  |    WORD wCompletionStatus;
                             5705 ; 244  |    SCSI_SENSE_DATA SenseData;
                             5706 ; 245  |    BOOL bStopped;
                             5707 ; 246  |    BOOL bWriteProtected;
                             5708 ; 247  |    BOOL bMediaConnected;
                             5709 ; 248  |    BOOL bMediaIsRemovable;
                             5710 ; 249  |    WORD wRemovableType;
                             5711 ; 250  |    WORD wRemovableEntry;
                             5712 ; 251  |    WORD wRemovableMask;
                             5713 ; 252  |    BOOL bMediaEnumerated;
                             5714 ; 253  |    BOOL bMediaChanged;
                             5715 ; 254  |    BOOL bMediaInsertionDetected;
                             5716 ; 255  |    BOOL bMediaValid;
                             5717 ; 256  |    SCSI_MEDIA_STATE eMediaState;
                             5718 ; 257  |    WORD wFileSystemDriveNumber;
                             5719 ; 258  |    WORD wFileSystemMediaNumber;
                             5720 ; 259  |    BOOL bStartUnitAttention;
                             5721 ; 260  |    MEDIA_SIZE MediaSize;
                             5722 ; 261  |    WORD wInquiryVendorData[10];
                             5723 ; 262  |    WORD wInquiryVendorSpecific[7];
                             5724 ; 263  |    SCSI_LUN_FLAG_MEDIA_CHANGE_FUNCTION FlagMediaChange;
                             5725 ; 264  |    DWORD dwSequentialBoundaryMask;
                             5726 ; 265  |    DWORD dwSequentialBoundary;
                             5727 ; 266  |} SCSI_LUN;
                             5728 
                             5733 
                             5734 ; 267  |
                             5735 ; 268  |
                             5736 ; 269  |typedef struct SCSICommandEntryStruct
                             5737 ; 270  |{
                             5738 ; 271  |
                             5739 ; 272  |    WORD     wCommand;
                             5740 ; 273  |    SCSI_CH  pFunc;
                             5741 ; 274  |} SCSI_COMMAND_ENTRY;
                             5742 ; 275  |
                             5743 ; 276  |
                             5744 ; 277  |////////////////////////////////////////////////////////////////////////////////
                             5745 ; 278  |// Prototypes
                             5746 ; 279  |////////////////////////////////////////////////////////////////////////////////
                             5747 ; 280  |
                             5748 ; 281  |RETCODE _reentrant ScsiDeviceTaskRouter(WORD wDeviceNum, WORD _X * pCdb);
                             5749 ; 282  |RETCODE _reentrant ScsiDeviceTaskManager(WORD wDeviceNum, WORD wOpCode, WORD _X * pCdb, SCSI_CH pFunc);
                             5750 ; 283  |RETCODE _reentrant ScsiDeviceServer(WORD wDeviceNum, WORD _X* pCdb,    SCSI_CH pFunc);
                             5751 ; 284  |
                             5752 ; 285  |SCSI_CH _reentrant ScsiValidOperationCode(WORD wOpCode);
                             5753 
                             5758 
                             5759 ; 286  |SCSI_CH _reentrant SearchForSCSICommand(SCSI_COMMAND_ENTRY *pList, WORD wOpCode);
                             5760 ; 287  |
                             5761 ; 288  |RETCODE _reentrant ScsiInit(void);
                             5762 ; 289  |RETCODE _reentrant ScsiDeviceInitializeAll(void);
                             5763 ; 290  |RETCODE _reentrant ScsiDeviceInitialize(WORD wNum);
                             5764 ; 291  |RETCODE _reentrant ScsiLunInitialize(WORD wDevNum, WORD wLun);
                             5765 ; 292  |RETCODE ScsiLunSetupSize(WORD wDevNum, WORD wLun);
                             5766 ; 293  |RETCODE ScsiLunSetupInquiryVendorSpecificData(WORD wDevNum, WORD wLun);
                             5767 
                             5795 
                             5796 ; 294  |RETCODE _reentrant ScsiLunSetupDefaultSenseData(SCSI_LUN * pLun);
                             5797 ; 295  |RETCODE _reentrant ScsiDummyFlagMediaChange(void);
                             5798 ; 296  |
                             5799 ; 297  |#define SCSI_IDLE      0       // Not reading or writing
                             5800 ; 298  |#define SCSI_READING   1       // A read operation is in progress
                             5801 ; 299  |#define SCSI_WRITING   2       // A write operation is in progress
                             5802 ; 300  |
                             5803 ; 301  |extern WORD g_wSCSIActivityState;
                             5804 ; 302  |
                             5805 ; 303  |RETCODE _reentrant SCSIWriteSectorHelper(WORD wDevice, WORD wDrive, DWORD dwStartSector, WORD wSectorCount, BOOL bUseMultiwrite);
                             5806 ; 304  |RETCODE _reentrant SCSIReadSectorHelper(WORD wDevice, WORD wDrive, DWORD dwStartSector, WORD wSectorCount);
                             5807 ; 305  |
                             5808 ; 306  |SCSI_CH _reentrant GetVendorSpecificSCSIHandler(WORD wOpCode);
                             5809 ; 307  |SCSI_CH _reentrant GetCustomerExtentionSCSIHandler(WORD wOpCode);
                             5810 ; 308  |
                             5811 ; 309  |#endif // #ifndef _SCSI_H
                             5812 
                             5814 
                             5815 ; 18   |
                             5816 ; 19   |////////////////////////////////////////////////////////////////////////////////
                             5817 ; 20   |// Defs
                             5818 ; 21   |////////////////////////////////////////////////////////////////////////////////
                             5819 ; 22   |
                             5820 ; 23   |#define USB_INTERFACE_CLASS_MASS_STORAGE    0x08
                             5821 ; 24   |
                             5822 ; 25   |#define USB_INTERFACE_SUB_CLASS_RBC                             0x01
                             5823 ; 26   |#define USB_INTERFACE_SUB_CLASS_SFF_8020I                       0x02
                             5824 ; 27   |#define USB_INTERFACE_SUB_CLASS_MMC_2                           0x02
                             5825 ; 28   |#define USB_INTERFACE_SUB_CLASS_QIC_157                         0x03
                             5826 ; 29   |#define USB_INTERFACE_SUB_CLASS_UFI                             0x04
                             5827 ; 30   |#define USB_INTERFACE_SUB_CLASS_SFF_8070I                       0x05
                             5828 ; 31   |#define USB_INTERFACE_SUB_CLASS_SCSI_TRANSPARENT_COMMAND_SET    0x06
                             5829 ; 32   |
                             5830 ; 33   |#define USB_INTERFACE_PROTOCOL_CBI_CCI                          0x01
                             5831 ; 34   |#define USB_INTERFACE_PROTOCOL_CBI_NO_CCI                       0x02
                             5832 ; 35   |#define USB_INTERFACE_PROTOCOL_BULK_ONLY                        0x50
                             5833 ; 36   |
                             5834 ; 37   |#define USBMSC_CBW_SIGNATURE            (DWORD)0x43425355
                             5835 ; 38   |#define USBMSC_CBW_BULK_OUT_SIZE        (WORD)0x00001F
                             5836 ; 39   |
                             5837 ; 40   |#define USBMSC_BULK_OUT_SCSI_CDB_START  5
                             5838 ; 41   |
                             5839 ; 42   |// This is the number of sector buffers if the data area is interpreted as the smallest sector buffer size
                             5840 ; 43   |#define USBMSC_MAX_NUM_SECTOR_BUFFERS       (16)
                             5841 ; 44   |// We add one to pad at the beginning of the buffer and end of each entry to avoid the USB DMA defect
                             5842 ; 45   |#define USBMSC_TOTAL_BUFFER_SIZE            ((SECTOR_BUFFER_ALLOC_SIZE(SSFDC_SECTOR_TOTAL_SIZE)*USBMSC_MAX_NUM_SECTOR_BUFFERS)+1)
                             5843 ; 46   |
                             5844 ; 47   |#define USBMSC_CSW_SIGNATURE_LOW        (WORD)0x425355
                             5845 ; 48   |#define USBMSC_CSW_SIGNATURE_HIGH       (WORD)0x000053
                             5846 ; 49   |#define USBMSC_CSW_COMMAND_PASSED       (WORD)0x000000
                             5847 ; 50   |#define USBMSC_CSW_COMMAND_FAILED       (WORD)0x000001
                             5848 ; 51   |#define USBMSC_CSW_PHASE_ERROR          (WORD)0x000002
                             5849 ; 52   |
                             5850 ; 53   |#define GET_MAX_LUN_STAGE_DATA_0        (WORD)0x000000
                             5851 ; 54   |#define GET_MAX_LUN_STAGE_DATA_1        (WORD)0x000001
                             5852 ; 55   |
                             5853 ; 56   |#define USBMSC_MAX_LUNS                 4
                             5854 ; 57   |
                             5855 ; 58   |#define USBMSC_DEVICE_0                 0
                             5856 ; 59   |#define USBMSC_DEVICE_1                 1
                             5857 ; 60   |#define USBMSC_DEVICE_2                 2
                             5858 ; 61   |#define USBMSC_DEVICE_3                 3
                             5859 ; 62   |
                             5860 ; 63   |////////////////////////////////////////////////////////////////////////////////
                             5861 ; 64   |// Errors
                             5862 ; 65   |
                             5863 ; 66   |#define USBMSC_ERROR_INVALID_DEVICE                             (WORD)0xFFFFFF
                             5864 ; 67   |#define USBMSC_ERROR_INVALID_LUN                                (WORD)0xFFFFFE
                             5865 ; 68   |#define USBMSC_DEVICE_INIT_ALL_FAILED                           (WORD)0x000001
                             5866 ; 69   |#define USBMSC_DEVICE_INIT_FAILED                               (WORD)0x000002
                             5867 ; 70   |
                             5868 ; 71   |////////////////////////////////////////////////////////////////////////////////
                             5869 ; 72   |// Typedefs
                             5870 ; 73   |////////////////////////////////////////////////////////////////////////////////
                             5871 ; 74   |
                             5872 ; 75   |typedef RETCODE (*USBMSC_DEVICE_INIT_FUNCTION)(void);
                             5873 ; 76   |typedef RETCODE (*USBMSC_DEVICE_RESET_FUNCTION)(void);
                             5874 ; 77   |
                             5875 ; 78   |typedef union
                             5876 ; 79   |{
                             5877 ; 80   |    struct
                             5878 ; 81   |    {
                             5879 ; 82   |        int Reserved    : 6;
                             5880 ; 83   |        int Obsolete    : 1;
                             5881 ; 84   |        int Direction   : 1;
                             5882 ; 85   |    } B;
                             5883 ; 86   |    int I;
                             5884 ; 87   |} USBMSC_CBW_FLAGS;
                             5885 
                             5897 
                             5898 ; 88   |
                             5899 ; 89   |typedef struct
                             5900 ; 90   |{
                             5901 ; 91   |    DWORD dwCBWSignature;
                             5902 ; 92   |    DWORD dwCBWTag;
                             5903 ; 93   |    DWORD dwCBWDataTransferLength;
                             5904 ; 94   |    USBMSC_CBW_FLAGS CBWFlags;
                             5905 ; 95   |    WORD wCBWLUN;
                             5906 ; 96   |    WORD wReserved0;
                             5907 ; 97   |    WORD wCBWCBLength;
                             5908 ; 98   |    WORD wReserved1;
                             5909 ; 99   |} USBMSC_CBW;
                             5910 
                             5929 
                             5930 ; 100  |
                             5931 ; 101  |
                             5932 ; 102  |
                             5933 ; 103  |
                             5934 ; 104  |typedef struct
                             5935 ; 105  |{
                             5936 ; 106  |    SyncObject  TransferObject;
                             5937 ; 107  |    WORD wDeviceNumber;
                             5938 ; 108  |    WORD wBulkInEndpointNum;
TASKING DSP2410 assembler v1.5r1 Build 138 SN 00100122
                                                                                                                                                                                                                                                       Page  23

M:ADDR CODE           CYCLES LINE SOURCELINE
                             5939 ; 109  |    WORD _X *CommandOutBuffer;
                             5940 ; 110  |    WORD _X *CommandInBuffer;
                             5941 ; 111  |    WORD wTransferSize;
                             5942 ; 112  |    WORD wBulkOutEndpointNum;
                             5943 ; 113  |    WORD wInterface;
                             5944 ; 114  |    WORD wNumLunsSupported;
                             5945 ; 115  |    USBMSC_CBW CBW;
                             5946 ; 116  |    SCSI_LUN Lun[USBMSC_MAX_LUNS];
                             5947 ; 117  |    BOOL bCommandActive;
                             5948 ; 118  |    BOOL bMSCReset;
                             5949 ; 119  |    USBMSC_DEVICE_INIT_FUNCTION InitializeFunction;
                             5950 ; 120  |    USBMSC_DEVICE_RESET_FUNCTION ResetFunction;
                             5951 ; 121  |    SECTOR_ARRAY  SectorArray;
                             5952 ; 122  |} USBMSC_DEVICE;
                             5953 ; 123  |
                             5954 ; 124  |
                             5955 ; 125  |extern long int g_lUSBMSCBulkInBytes;
                             5956 ; 126  |extern long int g_lUSBMSCLastBulkInTime;
                             5957 ; 127  |extern long int g_lUSBMSCFirstBulkInTime;
                             5958 ; 128  |extern long int g_lUSBMSCBulkOutBytes;
                             5959 ; 129  |extern long int g_lUSBMSCLastBulkOutTime;
                             5960 ; 130  |extern long int g_lUSBMSCFirstBulkOutTime;
                             5961 
                             5981 
                             5982 ; 131  |
                             5983 ; 132  |extern USBMSC_DEVICE UsbMscDevice[];
                             5984 ; 133  |extern WORD g_wUsbMscNumDevices;
                             5985 ; 134  |
                             5986 ; 135  |
                             5987 ; 136  |////////////////////////////////////////////////////////////////////////////////
                             5988 ; 137  |// Prototypes
                             5989 ; 138  |////////////////////////////////////////////////////////////////////////////////
                             5990 ; 139  |
                             5991 ; 140  |void _reentrant UsbMscHandler0(void);
                             5992 ; 141  |void _reentrant UsbMscHandler1(void);
                             5993 ; 142  |RETCODE _reentrant UsbMscCbwProcessor(WORD wNum);
                             5994 ; 143  |RETCODE _reentrant UsbMscSendCsw(WORD wNum);
                             5995 ; 144  |RETCODE _reentrant UsbMscDriverInitialize(void);
                             5996 ; 145  |RETCODE _reentrant UsbMscDeviceInitializeAll(void);
                             5997 ; 146  |RETCODE _reentrant UsbMscDeviceInitialize(WORD wNum);
                             5998 ; 147  |RETCODE _reentrant UsbMscDeviceReset(WORD wNum);
                             5999 ; 148  |
                             6000 ; 149  |
                             6001 ; 150  |#define SECTOR_HANDLER  0x800000
                             6002 ; 151  |#define COMMAND_HANDLER 0x400000
                             6003 ; 152  |
                             6004 ; 153  |void _reentrant UsbMscBulkOutService(BOOL bSetup, BYTE btDirection, _packed BYTE _USB_MEM *pBuffer, WORD wLength,WORD wPrivateData);
                             6005 ; 154  |void _reentrant UsbMscBulkInService(BOOL bSetup, BYTE btDirection, _packed BYTE _USB_MEM *pBuffer, WORD wLength,WORD wPrivateData);
                             6006 ; 155  |void _reentrant UsbMscResetService(BOOL bSetup, BYTE btDirection, BYTE _USB_MEM * pbtBuffer, WORD wLength,WORD wPrivateData);
                             6007 ; 156  |void _reentrant UsbMscResumeService(BOOL bSetup, BYTE btDirection, BYTE _USB_MEM * pbtBuffer, WORD wLength,WORD wPrivateData);
                             6008 ; 157  |void _reentrant UsbMscSuspendService(BOOL bSetup, BYTE btDirection, BYTE _USB_MEM * pbtBuffer, WORD wLength,WORD wPrivateData);
                             6009 ; 158  |
                             6010 ; 159  |RETCODE _reentrant UsbMscCheckDiskAll(void);
                             6011 ; 160  |
                             6012 ; 161  |#define DISPLAY_USB_ACTIVE  0       // Currently reading or writing
                             6013 ; 162  |#define USB_BLINK_RATE_ON       50      // 50msec
                             6014 ; 163  |#define USB_BLINK_RATE_OFF      300     // 450mse
                             6015 ; 164  |
                             6016 ; 165  |#define PERSISTANT_BIT_FOR_LOW_POWER_MODE (HW_RTC_PERSISTANT1.B.b0)
                             6017 ; 166  |
                             6018 ; 167  |
                             6019 ; 168  |#endif // #ifndef _USBMSC_H
                             6020 
                             6022 
                             6023 ; 20   |#include "usbmscrequests.h"
                             6024 
                             6026 
                             6027 ; 1    |////////////////////////////////////////////////////////////////////////////////
                             6028 ; 2    |// Copyright(C) SigmaTel, Inc. 2002
                             6029 ; 3    |//
                             6030 ; 4    |// Filename: usbmscrequests.h
                             6031 ; 5    |// Description: 
                             6032 ; 6    |////////////////////////////////////////////////////////////////////////////////
                             6033 ; 7    |
                             6034 ; 8    |#ifndef _USBMSCREQUESTS_H
                             6035 ; 9    |#define _USBMSCREQUESTS_H
                             6036 ; 10   |
                             6037 ; 11   |////////////////////////////////////////////////////////////////////////////////
                             6038 ; 12   |// Defs
                             6039 ; 13   |////////////////////////////////////////////////////////////////////////////////
                             6040 ; 14   |
                             6041 ; 15   |////////////////////////////////////////////////////////////////////////////////
                             6042 ; 16   |// Errors
                             6043 ; 17   |////////////////////////////////////////////////////////////////////////////////
                             6044 ; 18   |
                             6045 ; 19   |////////////////////////////////////////////////////////////////////////////////
                             6046 ; 20   |// Typedefs
                             6047 ; 21   |////////////////////////////////////////////////////////////////////////////////
                             6048 ; 22   |
                             6049 ; 23   |////////////////////////////////////////////////////////////////////////////////
                             6050 ; 24   |// Prototypes
                             6051 ; 25   |////////////////////////////////////////////////////////////////////////////////
                             6052 ; 26   |void _reentrant USBMSCRequestHandler(BOOL bSetup, BYTE btDirection, WORD  _X *pbtBuffer, WORD wLength,WORD wPrivateData);
                             6053 ; 27   |
                             6054 ; 28   |#endif // #ifndef _USBMSCREQUESTS_H
                             6055 
                             6057 
                             6058 ; 21   |#include "scsi.h"
                             6059 
                             6061 
                             6062 ; 1    |////////////////////////////////////////////////////////////////////////////////
                             6063 ; 2    |// Copyright(C) SigmaTel, Inc. 2000-2001
                             6064 ; 3    |//
                             6065 ; 4    |// Filename: scsi.h
                             6066 ; 5    |// Description: 
                             6067 ; 6    |////////////////////////////////////////////////////////////////////////////////
                             6068 ; 7    |
                             6069 ; 8    |#ifndef _SCSI_H
                             6070 ; 9    |#define _SCSI_H
                             6071 ; 10   |
                             6072 ; 11   |#include "types.h"
                             6073 ; 12   |#include "filesystem.h"
                             6074 ; 13   |#include "sectorarrayhandler.h"
                             6075 ; 14   |////////////////////////////////////////////////////////////////////////////////
                             6076 ; 15   |// Debug stuff
                             6077 ; 16   |////////////////////////////////////////////////////////////////////////////////
                             6078 ; 17   |
                             6079 ; 18   |    #ifdef SCSI_COMMAND_HISTORY
                             6080 ; 19   |#define SCSI_COMMAND_HISTORY_SIZE       500
                             6081 ; 20   |#define SCSI_CDB_SIZE_IN_WORDS          6
                             6082 ; 21   |    #endif
                             6083 ; 22   |    
                             6084 ; 23   |////////////////////////////////////////////////////////////////////////////////
                             6085 ; 24   |// Defs
                             6086 ; 25   |////////////////////////////////////////////////////////////////////////////////
                             6087 ; 26   |
                             6088 ; 27   |#define SCSI_CDB_BUFFER_OP_CODE_MASK    (WORD)0x0000FF
                             6089 ; 28   |
                             6090 ; 29   |////////////////////////////////////////////////////////////////////////////////
                             6091 ; 30   |// Supported SCSI commands
                             6092 ; 31   |#define SCSI_OPCODE_INQUIRY                         0x12
                             6093 ; 32   |#define SCSI_OPCODE_READ_CAPACITY                   0x25
                             6094 ; 33   |#define SCSI_OPCODE_READ_FORMAT_CAPACITIES          0x23
                             6095 ; 34   |#define SCSI_OPCODE_READ_6                          0x08
                             6096 ; 35   |#define SCSI_OPCODE_READ_10                         0x28
                             6097 ; 36   |#define SCSI_OPCODE_READ_12                         0xA8
                             6098 ; 37   |#define SCSI_OPCODE_READ_16                         0x88
                             6099 ; 38   |#define SCSI_OPCODE_WRITE_6                         0x0A
                             6100 ; 39   |#define SCSI_OPCODE_WRITE_10                        0x2A
                             6101 ; 40   |#define SCSI_OPCODE_WRITE_12                        0xAA
                             6102 ; 41   |#define SCSI_OPCODE_WRITE_16                        0x8A
                             6103 ; 42   |#define SCSI_OPCODE_REQUEST_SENSE                   0x03
                             6104 ; 43   |#define SCSI_OPCODE_TEST_UNIT_READY                 0x00
                             6105 ; 44   |#define SCSI_OPCODE_START_STOP_UNIT                 0x1B
                             6106 ; 45   |#define SCSI_OPCODE_FORMAT_UNIT                     0x04
                             6107 ; 46   |#define SCSI_OPCODE_RESERVE_10                      0x56
                             6108 ; 47   |#define SCSI_OPCODE_RELEASE_10                      0x57
                             6109 ; 48   |#define SCSI_OPCODE_SEND_DIAGNOSTIC                 0x1D
                             6110 ; 49   |#define SCSI_OPCODE_MODE_SENSE_6                    0x1A
                             6111 ; 50   |#define SCSI_OPCODE_MODE_SENSE_10                   0x5A
                             6112 ; 51   |#define SCSI_OPCODE_PREVENT_ALLOW_MEDIUM_REMOVAL    0x1E
                             6113 ; 52   |#define SCSI_OPCODE_START_STOP_UNIT                 0x1B // Start Stop Unit from the SBC-2 spec
                             6114 ; 53   |#define SCSI_OPCODE_READ_BUFFER                     0x3C
                             6115 ; 54   |
                             6116 ; 55   |#define SCSI_CDB_SIZE_INQUIRY                       6
                             6117 ; 56   |#define SCSI_CDB_SIZE_READ_CAPACITY                 10
                             6118 ; 57   |#define SCSI_CDB_SIZE_READ_6                        6
                             6119 ; 58   |#define SCSI_CDB_SIZE_READ_10                       10
                             6120 ; 59   |#define SCSI_CDB_SIZE_READ_12                       12
                             6121 ; 60   |#define SCSI_CDB_SIZE_READ_16                       16
                             6122 ; 61   |#define SCSI_CDB_SIZE_WRITE_6                       6
                             6123 ; 62   |#define SCSI_CDB_SIZE_WRITE_10                      10
                             6124 ; 63   |#define SCSI_CDB_SIZE_WRITE_12                      12
                             6125 ; 64   |#define SCSI_CDB_SIZE_WRITE_16                      16
                             6126 ; 65   |#define SCSI_CDB_SIZE_REQUEST_SENSE                 6
                             6127 ; 66   |#define SCSI_CDB_SIZE_TEST_UNIT_READY               6
                             6128 ; 67   |#define SCSI_CDB_SIZE_START_STOP_UNIT               6
                             6129 ; 68   |#define SCSI_CDB_SIZE_FORMAT_UNIT                   6
                             6130 ; 69   |#define SCSI_CDB_SIZE_RESERVE_10                    10
                             6131 ; 70   |#define SCSI_CDB_SIZE_RELEASE_10                    10
                             6132 ; 71   |#define SCSI_CDB_SIZE_SEND_DIAGNOSTIC               6
                             6133 ; 72   |#define SCSI_CDB_SIZE_MODE_SENSE_6                  6
                             6134 ; 73   |#define SCSI_CDB_SIZE_MODE_SENSE_10                 10
                             6135 ; 74   |#define SCSI_CDB_SIZE_PREVENT_ALLOW_MEDIUM_REMOVAL  6
                             6136 ; 75   |#define SCSI_CDB_SIZE_START_STOP_UNIT               6
                             6137 ; 76   |
                             6138 ; 77   |////////////////////////////////////////////////////////////////////////////////
                             6139 ; 78   |// Unsupported SCSI commands known to have been received.  Unknown SCSI commands
                             6140 ; 79   |//  not in this list are only trapped in development builds.  Release builds
                             6141 ; 80   |//  simply fail all commands not in this list.  Use the
                             6142 ; 81   |//  SCSI_TRAP_UNKNOWN_OPCODES build option in the make file to trap.
                             6143 ; 82   |#define SCSI_OPCODE_READ_FORMAT_CAPACITIES          0x23 // Read Format Capacities from the
                             6144 ; 83   |                                                         //  SFF-8070i spec
                             6145 ; 84   |#define SCSI_OPCODE_VERIFY_10                       0x2F // Verify(10) from the SBC-2 spec
                             6146 ; 85   |
                             6147 ; 86   |////////////////////////////////////////////////////////////////////////////////
                             6148 ; 87   |// Data direction defs
                             6149 ; 88   |#define SCSI_DATA_TO_HOST               0
                             6150 ; 89   |#define SCSI_DATA_FROM_HOST             1
                             6151 ; 90   |
                             6152 ; 91   |////////////////////////////////////////////////////////////////////////////////
                             6153 ; 92   |// Sense Data defs
                             6154 ; 93   |#define SENSE_DATA_RESPONSE_CODE_CURRENT_ERRORS     0x70
                             6155 ; 94   |#define SENSE_DATA_RESPONSE_CODE_DEFERRED_ERRORS    0x71
                             6156 ; 95   |#define SENSE_DATA_INFORMATION_VALID                1<<7
                             6157 ; 96   |#define SENSE_DATA_INFORMATION_INVALID              0
                             6158 ; 97   |#define SENSE_DATA_ILI_CORRECT                      0<<4
                             6159 ; 98   |#define SENSE_DATA_ILI_INCORRECT                    1<<4
                             6160 ; 99   |
                             6161 ; 100  |////////////////////////////////////////////////////////////////////////////////
                             6162 ; 101  |// Sense Key defs
                             6163 ; 102  |#define SCSI_SENSE_KEY_NO_SENSE             0<<16
                             6164 ; 103  |#define SCSI_SENSE_KEY_RECOVERED_ERROR      1<<16
                             6165 ; 104  |#define SCSI_SENSE_KEY_NOT_READY            2<<16
                             6166 ; 105  |#define SCSI_SENSE_KEY_MEDIUM_ERROR         3<<16
                             6167 ; 106  |#define SCSI_SENSE_KEY_HARDWARE_ERROR       4<<16
                             6168 ; 107  |#define SCSI_SENSE_KEY_ILLEGAL_REQUEST      5<<16
                             6169 ; 108  |#define SCSI_SENSE_KEY_UNIT_ATTENTION       6<<16
                             6170 ; 109  |#define SCSI_SENSE_KEY_DATA_PROTECT         7<<16
                             6171 ; 110  |#define SCSI_SENSE_KEY_BLANK_CHECK          8<<16
                             6172 ; 111  |#define SCSI_SENSE_KEY_VENDOR_SPECIFIC      9<<16
                             6173 ; 112  |#define SCSI_SENSE_KEY_COPY_ABORTED         10<<16
                             6174 ; 113  |#define SCSI_SENSE_KEY_ABORTED_COMMAND      11<<16
                             6175 ; 114  |#define SCSI_SENSE_KEY_OBSOLETE             12<<16
                             6176 ; 115  |#define SCSI_SENSE_KEY_VOLUME_OVERFLOW      13<<16
                             6177 ; 116  |#define SCSI_SENSE_KEY_MISCOMPARE           14<<16
                             6178 ; 117  |#define SCSI_SENSE_KEY_RESERVED             15<<16
                             6179 ; 118  |
                             6180 ; 119  |////////////////////////////////////////////////////////////////////////////////
                             6181 ; 120  |// Additional Sense Code & Qualifier defs.  Asc is the LSB.
                             6182 ; 121  |#define SCSI_ASC_NO_ADDITIONAL_SENSE_INFO                               0x0000
                             6183 ; 122  |
                             6184 ; 123  |#define SCSI_ASC_LOGICAL_UNIT_NOT_READY_MANUAL_INTERVENTION_REQUIRED    0x0304
                             6185 ; 124  |
                             6186 ; 125  |#define SCSI_ASC_LOGICAL_UNIT_DOES_NOT_RESPOND_TO_SELECTION             0x0005
                             6187 ; 126  |
                             6188 ; 127  |#define SCSI_ASC_INVALID_COMMAND_OPERATION_CODE                         0x0020
                             6189 ; 128  |
                             6190 ; 129  |#define SCSI_ASC_LOGICAL_UNIT_NOT_SUPPORTED                             0x0025
                             6191 ; 130  |
                             6192 ; 131  |#define SCSI_ASC_LOGICAL_BLOCK_ADDRESS_OUT_OF_RANGE                     0x0021 
                             6193 ; 132  |
                             6194 ; 133  |#define SCSI_ASC_WRITE_PROTECTED                                        0x0027
                             6195 ; 134  |
                             6196 ; 135  |#define SCSI_ASC_NOT_READY_TO_READY_CHANGE_MEDIUM_MAY_HAVE_CHANGED      0x0028
                             6197 ; 136  |
                             6198 ; 137  |#define SCSI_ASC_DEVICE_INTERNAL_RESET                                  0x0429
                             6199 ; 138  |
                             6200 ; 139  |#define SCSI_ASC_INCOMPATIBLE_MEDIUM_INSTALLED                          0x0030
                             6201 ; 140  |#define SCSI_ASC_CANNOT_READ_MEDIUM_UNKNOWN_FORMAT                      0x0130
                             6202 ; 141  |#define SCSI_ASC_CANNOT_READ_MEDIUM_INCOMPATIBLE_FORMAT                 0x0230
                             6203 ; 142  |#define SCSI_ASC_CANNOT_WRITE_MEDIUM_UNKNOWN_FORMAT                     0x0430
                             6204 ; 143  |#define SCSI_ASC_CANNOT_WRITE_MEDIUM_INCOMPATIBLE_FORMAT                0x0530
                             6205 ; 144  |
                             6206 ; 145  |#define SCSI_ASC_MEDIUM_FORMAT_CORRUPTED                                0x0031
                             6207 ; 146  |
                             6208 ; 147  |#define SCSI_ASC_UNRECOVERED_READ_ERROR                                 0x0011
                             6209 ; 148  |
                             6210 ; 149  |#define SCSI_ASC_MEDIUM_NOT_PRESENT                                     0x003A
                             6211 ; 150  |#define SCSI_ASC_MEDIUM_DESTINATION_ELEMENT_FULL                        0x003B
                             6212 ; 151  |
TASKING DSP2410 assembler v1.5r1 Build 138 SN 00100122
                                                                                                                                                                                                                                                       Page  24

M:ADDR CODE           CYCLES LINE SOURCELINE
                             6213 ; 152  |#define SCSI_ASC_INQUIRY_DATA_HAS_CHANGED                               0x033F
                             6214 ; 153  |#define SCSI_ASC_REPORTED_LUNS_DATA_HAS_CHANGED                         0x0E3F
                             6215 ; 154  |
                             6216 ; 155  |#define SCSI_ASC_LOGICIAL_UNIT_FAILED_SELF_CONFIGURATION                0x004C
                             6217 ; 156  |
                             6218 ; 157  |#define SCSI_ASC_INVALID_FIELD_IN_CDB                                   0x0024
                             6219 ; 158  |
                             6220 ; 159  |#define SCSI_ASC_LOGICAL_UNIT_FAILURE                                   0x013E
                             6221 ; 160  |#define SCSI_ASC_LOGICAL_UNIT_NOT_READY_INIT_CMD_REQUIRED               0x0204
                             6222 ; 161  |
                             6223 ; 162  |////////////////////////////////////////////////////////////////////////////////
                             6224 ; 163  |// Inquiry Peripheral Qualifier defs
                             6225 ; 164  |#define SCSI_INQUIRY_PERIPHERAL_QUALIFIER_LUN_CONNECTED         0
                             6226 ; 165  |#define SCSI_INQUIRY_PERIPHERAL_QUALIFIER_LUN_NOT_CONNECTED     1
                             6227 ; 166  |#define SCSI_INQUIRY_PERIPHERAL_QUALIFIER_RESERVED              2
                             6228 ; 167  |#define SCSI_INQUIRY_PERIPHERAL_QUALIFIER_NO_SUPPORT            3
                             6229 ; 168  |
                             6230 ; 169  |////////////////////////////////////////////////////////////////////////////////
                             6231 ; 170  |// Inquiry Peripheral Qualifier defs
                             6232 ; 171  |#define SCSI_INQUIRY_PERIPHERAL_DEVICE_TYPE_DIRECT_ACCESS       0
                             6233 ; 172  |#define SCSI_INQUIRY_PERIPHERAL_DEVICE_TYPE_NO_SUPPORT          0x1F
                             6234 ; 173  |
                             6235 ; 174  |////////////////////////////////////////////////////////////////////////////////
                             6236 ; 175  |// Inquiry RMB defs
                             6237 ; 176  |#define SCSI_INQUIRY_RMB_DEVICE_IS_NOT_REMOVABLE                0
                             6238 ; 177  |#define SCSI_INQUIRY_RMB_DEVICE_IS_REMOVABLE                    1
                             6239 ; 178  |
                             6240 ; 179  |////////////////////////////////////////////////////////////////////////////////
                             6241 ; 180  |// Inquiry Vendor Specific SigmaTel struct defs
                             6242 ; 181  |#define SCSI_INQUIRY_VENDOR_SPECIFIC_STRUCT_MDS                 1
                             6243 ; 182  |
                             6244 ; 183  |#define SCSI_MDS_FLAGS_SYSTEM_MEDIA_FLAG_NON_SYSTEM             (WORD)0x00
                             6245 ; 184  |#define SCSI_MDS_FLAGS_SYSTEM_MEDIA_FLAG_SYSTEM                 (WORD)0x01
                             6246 ; 185  |                                                                
                             6247 ; 186  |#define SCSI_MDS_MEDIA_TYPE_NAND                                (WORD)0x00
                             6248 ; 187  |#define SCSI_MDS_MEDIA_TYPE_SMARTMEDIA                          (WORD)0x01
                             6249 ; 188  |#define SCSI_MDS_MEDIA_TYPE_MMC_1_4                             (WORD)0x10
                             6250 ; 189  |#define SCSI_MDS_MEDIA_TYPE_MMC_2_1_1                           (WORD)0x11
                             6251 ; 190  |#define SCSI_MDS_MEDIA_TYPE_MMC_3_1                             (WORD)0x12
                             6252 ; 191  |#define SCSI_MDS_MEDIA_TYPE_MMC_UNKNOWN_VERSION                 (WORD)0x13
                             6253 ; 192  |#define SCSI_MDS_MEDIA_TYPE_SD_1_0                              (WORD)0x20
                             6254 ; 193  |#define SCSI_MDS_MEDIA_TYPE_SD_UNKNOWN_VERSION                  (WORD)0x21
                             6255 ; 194  |
                             6256 ; 195  |////////////////////////////////////////////////////////////////////////////////
                             6257 ; 196  |// Error codes
                             6258 ; 197  |////////////////////////////////////////////////////////////////////////////////
                             6259 ; 198  |
                             6260 ; 199  |#define SCSI_PROJECT_SPECIFIC_INIT_FAILED                       (WORD)0x000001
                             6261 ; 200  |#define SCSI_DEVICE_INIT_ALL_FAILED                             (WORD)0x000002
                             6262 ; 201  |#define SCSI_ERROR_LUN_NOT_READY                                (WORD)0x000003
                             6263 ; 202  |#define SCSI_ERROR_INVALID_COMMAND                              (WORD)0x000004
                             6264 ; 203  |#define SCSI_ERROR_USB_MSC_RESET_DURING_SCSI_COMMAND            (WORD)0x000005
                             6265 ; 204  |#define SCSI_ERROR_READ_SECTOR_FAILURE                          (WORD)0x000006
                             6266 ; 205  |#define SCSI_ERROR_WRITE_SECTOR_FAILURE                         (WORD)0x000007
                             6267 ; 206  |#define SCSI_ERROR_WAIT_FOR_USB_TIMEOUT                         (WORD)0x000008
                             6268 ; 207  |#define SCSI_READ_FAILURE_TIMEOUT_USB_WILL_NOT_STOP             (WORD)0x000009
                             6269 ; 208  |#define SCSI_WRITE_FAILURE_TIMEOUT_USB_WILL_NOT_STOP            (WORD)0x00000A
                             6270 ; 209  |#define SCSI_ERROR_USB_DISCONNECT                               (WORD)0x00000B
                             6271 ; 210  |#define SCSI_ERROR_DDI_CALL_FAILED                              (WORD)0x00000C
                             6272 ; 211  |#define SCSI_ERROR_LBA_OUT_OF_RANGE                         (RETCODE)(0x000100)
                             6273 ; 212  |#define SCSI_WRITE_FAILURE_ZONE_FULL                        (RETCODE)(0x9AAAAA)
                             6274 ; 213  |
                             6275 ; 214  |////////////////////////////////////////////////////////////////////////////////
                             6276 ; 215  |// Typedefs
                             6277 ; 216  |////////////////////////////////////////////////////////////////////////////////
                             6278 ; 217  |
                             6279 ; 218  |typedef RETCODE (*SCSI_CH)(WORD wDeviceNum, WORD _X* pCdb);
                             6280 ; 219  |typedef RETCODE (*SCSI_PROJECT_INIT)(void);
                             6281 ; 220  |typedef RETCODE (*SCSI_LUN_FLAG_MEDIA_CHANGE_FUNCTION)(void);
                             6282 ; 221  |
                             6283 ; 222  |typedef struct
                             6284 ; 223  |{
                             6285 ; 224  |    WORD wValid;
                             6286 ; 225  |    WORD wSenseKey;
                             6287 ; 226  |    WORD wIli;
                             6288 ; 227  |    DWORD dwInformation;
                             6289 ; 228  |    WORD wAscqAsc; 
                             6290 ; 229  |    WORD wAddlData;
                             6291 ; 230  |} SCSI_SENSE_DATA;
                             6292 ; 231  |
                             6293 ; 232  |typedef enum
                             6294 ; 233  |{
                             6295 ; 234  |    ScsiMediaStateUnknown = 0,
                             6296 ; 235  |    ScsiMediaStateReady = 1,
                             6297 ; 236  |    ScsiMediaStateFormatRequired = 2,
                             6298 ; 237  |    ScsiMediaStateHardwareFailed = 3
                             6299 ; 238  |} SCSI_MEDIA_STATE;
                             6300 ; 239  |
                             6301 ; 240  |typedef struct
                             6302 ; 241  |{
                             6303 ; 242  |    DWORD dwNumBytesXferred;
                             6304 ; 243  |    WORD wCompletionStatus;
                             6305 ; 244  |    SCSI_SENSE_DATA SenseData;
                             6306 ; 245  |    BOOL bStopped;
                             6307 ; 246  |    BOOL bWriteProtected;
                             6308 ; 247  |    BOOL bMediaConnected;
                             6309 ; 248  |    BOOL bMediaIsRemovable;
                             6310 ; 249  |    WORD wRemovableType;
                             6311 ; 250  |    WORD wRemovableEntry;
                             6312 ; 251  |    WORD wRemovableMask;
                             6313 ; 252  |    BOOL bMediaEnumerated;
                             6314 ; 253  |    BOOL bMediaChanged;
                             6315 ; 254  |    BOOL bMediaInsertionDetected;
                             6316 ; 255  |    BOOL bMediaValid;
                             6317 ; 256  |    SCSI_MEDIA_STATE eMediaState;
                             6318 ; 257  |    WORD wFileSystemDriveNumber;
                             6319 ; 258  |    WORD wFileSystemMediaNumber;
                             6320 ; 259  |    BOOL bStartUnitAttention;
                             6321 ; 260  |    MEDIA_SIZE MediaSize;
                             6322 ; 261  |    WORD wInquiryVendorData[10];
                             6323 ; 262  |    WORD wInquiryVendorSpecific[7];
                             6324 ; 263  |    SCSI_LUN_FLAG_MEDIA_CHANGE_FUNCTION FlagMediaChange;
                             6325 ; 264  |    DWORD dwSequentialBoundaryMask;
                             6326 ; 265  |    DWORD dwSequentialBoundary;
                             6327 ; 266  |} SCSI_LUN;
                             6328 ; 267  |
                             6329 ; 268  |
                             6330 ; 269  |typedef struct SCSICommandEntryStruct
                             6331 ; 270  |{
                             6332 ; 271  |
                             6333 ; 272  |    WORD     wCommand;
                             6334 ; 273  |    SCSI_CH  pFunc;
                             6335 ; 274  |} SCSI_COMMAND_ENTRY;
                             6336 ; 275  |
                             6337 ; 276  |
                             6338 ; 277  |////////////////////////////////////////////////////////////////////////////////
                             6339 ; 278  |// Prototypes
                             6340 ; 279  |////////////////////////////////////////////////////////////////////////////////
                             6341 ; 280  |
                             6342 ; 281  |RETCODE _reentrant ScsiDeviceTaskRouter(WORD wDeviceNum, WORD _X * pCdb);
                             6343 ; 282  |RETCODE _reentrant ScsiDeviceTaskManager(WORD wDeviceNum, WORD wOpCode, WORD _X * pCdb, SCSI_CH pFunc);
                             6344 ; 283  |RETCODE _reentrant ScsiDeviceServer(WORD wDeviceNum, WORD _X* pCdb,    SCSI_CH pFunc);
                             6345 ; 284  |
                             6346 ; 285  |SCSI_CH _reentrant ScsiValidOperationCode(WORD wOpCode);
                             6347 ; 286  |SCSI_CH _reentrant SearchForSCSICommand(SCSI_COMMAND_ENTRY *pList, WORD wOpCode);
                             6348 ; 287  |
                             6349 ; 288  |RETCODE _reentrant ScsiInit(void);
                             6350 ; 289  |RETCODE _reentrant ScsiDeviceInitializeAll(void);
                             6351 ; 290  |RETCODE _reentrant ScsiDeviceInitialize(WORD wNum);
                             6352 ; 291  |RETCODE _reentrant ScsiLunInitialize(WORD wDevNum, WORD wLun);
                             6353 ; 292  |RETCODE ScsiLunSetupSize(WORD wDevNum, WORD wLun);
                             6354 ; 293  |RETCODE ScsiLunSetupInquiryVendorSpecificData(WORD wDevNum, WORD wLun);
                             6355 ; 294  |RETCODE _reentrant ScsiLunSetupDefaultSenseData(SCSI_LUN * pLun);
                             6356 ; 295  |RETCODE _reentrant ScsiDummyFlagMediaChange(void);
                             6357 ; 296  |
                             6358 ; 297  |#define SCSI_IDLE      0       // Not reading or writing
                             6359 ; 298  |#define SCSI_READING   1       // A read operation is in progress
                             6360 ; 299  |#define SCSI_WRITING   2       // A write operation is in progress
                             6361 ; 300  |
                             6362 ; 301  |extern WORD g_wSCSIActivityState;
                             6363 ; 302  |
                             6364 ; 303  |RETCODE _reentrant SCSIWriteSectorHelper(WORD wDevice, WORD wDrive, DWORD dwStartSector, WORD wSectorCount, BOOL bUseMultiwrite);
                             6365 ; 304  |RETCODE _reentrant SCSIReadSectorHelper(WORD wDevice, WORD wDrive, DWORD dwStartSector, WORD wSectorCount);
                             6366 ; 305  |
                             6367 ; 306  |SCSI_CH _reentrant GetVendorSpecificSCSIHandler(WORD wOpCode);
                             6368 ; 307  |SCSI_CH _reentrant GetCustomerExtentionSCSIHandler(WORD wOpCode);
                             6369 ; 308  |
                             6370 ; 309  |#endif // #ifndef _SCSI_H
                             6371 
                             6373 
                             6374 ; 22   |#include "bootmanager.h"
                             6375 
                             6377 
                             6378 ; 1    |////////////////////////////////////////////////////////////////////////////////
                             6379 ; 2    |// Copyright(C) SigmaTel, Inc. 2000-2001
                             6380 ; 3    |//
                             6381 ; 4    |// Filename: bootmanager.h
                             6382 ; 5    |// Description: 
                             6383 ; 6    |////////////////////////////////////////////////////////////////////////////////
                             6384 ; 7    |
                             6385 ; 8    |#ifndef _BOOTMANAGER_H
                             6386 ; 9    |#define _BOOTMANAGER_H
                             6387 ; 10   |
                             6388 ; 11   |////////////////////////////////////////////////////////////////////////////////
                             6389 ; 12   |// Defs
                             6390 ; 13   |////////////////////////////////////////////////////////////////////////////////
                             6391 ; 14   |
                             6392 ; 15   |#define BOOT_MANAGER_IS_RESIDENT        0x000001
                             6393 ; 16   |#define BOOT_MANAGER_IS_NOT_RESIDENT    0x000000
                             6394 ; 17   |
                             6395 ; 18   |////////////////////////////////////////////////////////////////////////////////
                             6396 ; 19   |// Typedefs
                             6397 ; 20   |////////////////////////////////////////////////////////////////////////////////
                             6398 ; 21   |
                             6399 ; 22   |////////////////////////////////////////////////////////////////////////////////
                             6400 ; 23   |// Prototypes
                             6401 ; 24   |////////////////////////////////////////////////////////////////////////////////
                             6402 ; 25   |
                             6403 ; 26   |//_asmfunc BootManager(WORD wBlockTag);
                             6404 ; 27   |void _reentrant BootManager(WORD wBootTag, BOOL bIsResident);
                             6405 ; 28   |
                             6406 ; 29   |#endif // #ifndef _SCSI_H
                             6407 
                             6409 
                             6410 ; 23   |#include "misc.h"
                             6411 
                             6413 
                             6414 ; 1    |////////////////////////////////////////////////////////////////////////////////
                             6415 ; 2    |// Copyright(C) SigmaTel, Inc. 2002
                             6416 ; 3    |//
                             6417 ; 4    |// Filename: misc.h
                             6418 ; 5    |// Description: 
                             6419 ; 6    |////////////////////////////////////////////////////////////////////////////////
                             6420 ; 7    |
                             6421 ; 8    |#ifndef _MISC_H
                             6422 ; 9    |#define _MISC_H
                             6423 ; 10   |
                             6424 ; 11   |////////////////////////////////////////////////////////////////////////////////
                             6425 ; 12   |// Defs
                             6426 ; 13   |////////////////////////////////////////////////////////////////////////////////
                             6427 ; 14   |
                             6428 ; 15   |////////////////////////////////////////////////////////////////////////////////
                             6429 ; 16   |// Error codes
                             6430 ; 17   |////////////////////////////////////////////////////////////////////////////////
                             6431 ; 18   |
                             6432 ; 19   |////////////////////////////////////////////////////////////////////////////////
                             6433 ; 20   |// Typedefs
                             6434 ; 21   |////////////////////////////////////////////////////////////////////////////////
                             6435 ; 22   |
                             6436 ; 23   |////////////////////////////////////////////////////////////////////////////////
                             6437 ; 24   |// Prototypes
                             6438 ; 25   |////////////////////////////////////////////////////////////////////////////////
                             6439 ; 26   |
                             6440 ; 27   |RETCODE PowerInit(void);
                             6441 ; 28   |RETCODE PllInit(void);
                             6442 ; 29   |RETCODE _reentrant SystemShutdown(void);
                             6443 ; 30   |RETCODE _reentrant SysGpioDisableAll(void);
                             6444 ; 31   |RETCODE _reentrant SysPadPowerDownAll(void);
                             6445 ; 32   |RETCODE _reentrant SysPllShutdown(void);
                             6446 ; 33   |RETCODE GoToSleep(void);
                             6447 ; 34   |void _reentrant SysDelayMs(WORD wDelay);
                             6448 ; 35   |DWORD GetDclkCount(void);
                             6449 ; 36   |#ifdef USE_PLAYLIST2
                             6450 ; 37   |DWORD GetDclkCount_PL2(void);
                             6451 ; 38   |#endif
                             6452 ; 39   |void SetDclkCount(DWORD dwCount);
                             6453 ; 40   |RETCODE SmartMediaSetPortTiming(WORD wTiming);
                             6454 ; 41   |RETCODE ProgramPll(INT iSpeed);
                             6455 ; 42   |void _reentrant SystemReset(void);
                             6456 ; 43   |void _reentrant SystemPowerOff(void);
                             6457 ; 44   |void _reentrant ReconfigureAsDcc(void);
                             6458 ; 45   |void _reentrant PowerDownFMTuners(void);
                             6459 ; 46   |#ifdef TUNER_5767
                             6460 ; 47   |void _reentrant  Philips5767_3WireWriteByte(INT data);
                             6461 ; 48   |void _reentrant Philips5767_3WireClockDelay(void);
                             6462 ; 49   |#endif
                             6463 ; 50   |extern BOOL g_bPowerOff;
                             6464 ; 51   |
                             6465 ; 52   |#ifndef DISABLE_USB_CURRENT_REQUIREMENT_FOR_MMC_DRIVER
                             6466 ; 53   |extern int g_iHighPwrPeriphInitMode; // def in usbmscmisc.c
                             6467 ; 54   | #define STRUCTURE_INIT_ONLY                            2
TASKING DSP2410 assembler v1.5r1 Build 138 SN 00100122
                                                                                                                                                                                                                                                       Page  25

M:ADDR CODE           CYCLES LINE SOURCELINE
                             6468 ; 55   | #define USB_HIGH_CURRENT_GRANTED                       3
                             6469 ; 56   |#endif
                             6470 ; 57   |
                             6471 ; 58   |#endif // #ifndef _MISC_H
                             6472 
                             6474 
                             6475 ; 24   |#include "mediadetection.h"
                             6476 
                             6478 
                             6479 ; 1    |#ifndef _MEDIADETECTION_H
                             6480 ; 2    |#define _MEDIADETECTION_H
                             6481 ; 3    |
                             6482 ; 4    |#define MEDIA_DETECT_POSITIVE_POLARITY  0
                             6483 ; 5    |#define MEDIA_DETECT_NEGATIVE_POLARITY  1
                             6484 ; 6    |
                             6485 ; 7    |#define MEDIA_TYPE_SMARTMEDIA   0
                             6486 ; 8    |#define MEDIA_TYPE_MMC          1
                             6487 ; 9    |
                             6488 ; 10   |//#ifndef NUM_REMOVABLE_MEDIA
                             6489 ; 11   |//#define NUM_REMOVABLE_MEDIA 1
                             6490 ; 12   |//#endif
                             6491 ; 13   |
                             6492 ; 14   |#endif // #ifndef _MEDIADETECTION_H
                             6493 
                             6495 
                             6496 ; 25   |#include "nandhal.h"
                             6497 
                             6499 
                             6500 ; 1    |////////////////////////////////////////////////////////////////////////////////
                             6501 ; 2    |// Copyright(C) SigmaTel, Inc. 2003-2005
                             6502 ; 3    |//
                             6503 ; 4    |// Filename:     NANDHal.h
                             6504 ; 5    |// Description:  Contains structs, prototypes, equates for the NAND Hal routines.
                             6505 ; 6    |////////////////////////////////////////////////////////////////////////////////
                             6506 ; 7    |
                             6507 ; 8    |#ifndef _NANDHAL_H
                             6508 ; 9    |#define _NANDHAL_H
                             6509 ; 10   |
                             6510 ; 11   |///////////////////////////////////////////////////////////////////////////////
                             6511 ; 12   |// Includes
                             6512 ; 13   |///////////////////////////////////////////////////////////////////////////////
                             6513 ; 14   |
                             6514 ; 15   |#include "errors.h"
                             6515 
                             6517 
                             6518 ; 1    |/////////////////////////////////////////////////////////////////////////////////
                             6519 ; 2    |//// Copyright(C) SigmaTel, Inc. 2003
                             6520 ; 3    |////
                             6521 ; 4    |//// Filename: errors.inc
                             6522 ; 5    |//// Description: 
                             6523 ; 6    |/////////////////////////////////////////////////////////////////////////////////
                             6524 ; 7    |
                             6525 ; 8    |#if (!defined(ERRORS_INC))
                             6526 ; 9    |#define ERRORS_INC 1
                             6527 ; 10   |
                             6528 ; 11   |#define LDRIVE_ERROR_INVALID_DRIVE_NUMBER 0x0101
                             6529 ; 12   |#define LDRIVE_ERROR_NOT_INITIALIZED 0x0102
                             6530 ; 13   |#define LDRIVE_ERROR_HARDWARE_FAILURE 0x0103
                             6531 ; 14   |#define LDRIVE_ERROR_INVALID_DRIVE_TYPE 0x0104
                             6532 ; 15   |#define LDRIVE_ERROR_INVALID_INFO_TYPE 0x0105
                             6533 ; 16   |#define LDRIVE_ERROR_SECTOR_OUT_OF_BOUNDS 0x0106
                             6534 ; 17   |#define LDRIVE_ERROR_WRITE_FAILURE 0x0107
                             6535 ; 18   |#define LDRIVE_ERROR_WRITE_PROTECTED 0x0108
                             6536 ; 19   |#define LDRIVE_ERROR_MULTI_WRITE_IN_PROGRESS 0x0109
                             6537 ; 20   |#define LDRIVE_ERROR_MUST_HAVE_MORE_THAN_ONE_SECTOR 0x010A
                             6538 ; 21   |#define LDRIVE_ERROR_MULTI_WRITE_NOT_SETUP 0x010B
                             6539 ; 22   |// The WRITE_ABORT Error is returned when the system drive detects a bad
                             6540 ; 23   |// block in the device. The block was marked bad and tables updated.
                             6541 ; 24   |// The application must start over.
                             6542 ; 25   |#define LDRIVE_ERROR_WRITE_ABORT 0x010C
                             6543 ; 26   |#define LDRIVE_ERROR_READ_FAILURE 0x010D
                             6544 ; 27   |#define LDRIVE_ERROR_MEDIA_NOT_ALLOCATED 0x010E
                             6545 ; 28   |#define LDRIVE_ERROR_LOW_LEVEL_MEDIA_FORMAT_REQUIRED 0x010F
                             6546 ; 29   |
                             6547 ; 30   |#define LMEDIA_ERROR_HARDWARE_FAILURE 0x0200
                             6548 ; 31   |#define LMEDIA_ERROR_INVALID_MEDIA_NUMBER 0x0201
                             6549 ; 32   |#define LMEDIA_ERROR_MEDIA_NOT_INITIALIZED 0x0202
                             6550 ; 33   |#define LMEDIA_ERROR_MEDIA_NOT_DISCOVERED 0x0203
                             6551 ; 34   |#define LMEDIA_ERROR_INVALID_MEDIA_INFO_TYPE 0x0204
                             6552 ; 35   |#define LMEDIA_ERROR_ALLOCATION_TO_LARGE 0x0205
                             6553 ; 36   |#define LMEDIA_ERROR_MEDIA_NOT_ERASED 0x0206
                             6554 ; 37   |#define LMEDIA_ERROR_MEDIA_ERASED 0x0207
                             6555 ; 38   |//Specific to NAND
                             6556 ; 39   |#define LMEDIA_ERROR_NO_REGIONS_IN_MEDIA 0x0208     
                             6557 ; 40   |#define LMEDIA_ERROR_DRIVES_MAX_OUT 0x0209 
                             6558 ; 41   |#define LMEDIA_ERROR_MEDIA_WRITE_PROTECTED 0x020A
                             6559 ; 42   |#define LMEDIA_ERROR_INVALID_INFO_TYPE 0x020B
                             6560 ; 43   |#define LMEDIA_ERROR_BAD_BLOCKS_MAX_OUT 0x020C
                             6561 ; 44   |#define LMEDIA_ERROR_NOT_ALLOCATED 0x020D
                             6562 ; 45   |
                             6563 ; 46   |#define LMEDIA_ERROR_DRIVE_TYPE_NOT_SUPPORTED 0x0210
                             6564 ; 47   |
                             6565 ; 48   |#define NAND_ERROR_WRITE_PHYS_SECTOR_PROGRAM_FAILED 0x0301
                             6566 ; 49   |#define ERROR_MULTI_WRITE_SECTOR_FIFO_OVERFLOW 0x0302
                             6567 ; 50   |#define ERROR_MULTI_WRITE_SECTOR_FIFO_UNDERFLOW 0x0303
                             6568 ; 51   |
                             6569 ; 52   |#define NAND_DATA_DRIVE_ERROR_LOGICAL_SECTOR_OUT_OF_BOUNDS 0x0401
                             6570 ; 53   |#define NAND_DATA_DRIVE_ERROR_RBLOCK_NOT_FOUND 0x0402
                             6571 ; 54   |#define NAND_DATA_DRIVE_ERROR_NO_FREE_RBLOCKS 0x0403
                             6572 ; 55   |#define NAND_DATA_DRIVE_ERROR_USECTOR_LOOKUP_INTERNAL_1 0x0404
                             6573 ; 56   |#define NAND_DATA_DRIVE_SECTOR_NOT_UPDATED 0x0405
                             6574 ; 57   |#define NAND_DATA_DRIVE_ERROR_CANT_RECYCLE_USECTOR_MAP 0x0406
                             6575 ; 58   |#define NAND_DATA_DRIVE_ERROR_UBLOCK_LBAS_INCONSISTENT 0x0407
                             6576 ; 59   |#define NAND_DATA_DRIVE_ERROR_HSECTORIDX_IN_UBLOCK_OUT_OF_RANGE 0x0408
                             6577 ; 60   |#define NAND_DATA_DRIVE_ERROR_CANT_RECYCLE_UBLOCK 0x0409
                             6578 ; 61   |#define NAND_DATA_DRIVE_ERROR_BBTABLE_FULL 0x040A
                             6579 ; 62   |#define NAND_DATA_DRIVE_ERROR_UPDATE_NOT_OPEN 0x040B
                             6580 ; 63   |#define NAND_DATA_DRIVE_ERROR_ADD_USECTOR_INTERNAL_1 0x040C
                             6581 ; 64   |#define NAND_DATA_DRIVE_ERROR_CANT_GET_ERASED_UBLOCK 0x040D
                             6582 ; 65   |#define NAND_DATA_DRIVE_ERROR_NO_ERASED_UBLOCKS 0x040E
                             6583 ; 66   |#define NAND_DATA_DRIVE_ERROR_CANT_ERASE_FREE_UBLOCK 0x040F
                             6584 ; 67   |#define NAND_DATA_DRIVE_ERROR_KILLUSECTOR_INTERNAL_1 0x0410
                             6585 ; 68   |#define NAND_DATA_DRIVE_ERROR_KILLUSECTOR_INTERNAL_2 0x0411
                             6586 ; 69   |#define NAND_DATA_DRIVE_RETURN_BLOCK_NOT_UPDATED 0x0412
                             6587 ; 70   |#define NAND_DATA_DRIVE_ERROR_UBLOCK_PROTECT_TABLE_FULL 0x0413
                             6588 ; 71   |#define NAND_DATA_DRIVE_ERROR_UBLOCK_ALREADY_PROTECTED 0x0414
                             6589 ; 72   |#define NAND_DATA_DRIVE_ERROR_UBLOCK_NOT_PROTECTED 0x0415
                             6590 ; 73   |#define NAND_DATA_DRIVE_ERROR_UBLOCKPROTECT_INTERNAL_1 0x0416
                             6591 ; 74   |#define NAND_DATA_DRIVE_ERROR_RECOVERUBLOCK_INTERNAL_1 0x0417
                             6592 ; 75   |#define NAND_DATA_DRIVE_ERROR_RECOVERUBLOCK_INTERNAL_2 0x0418
                             6593 ; 76   |#define NAND_DATA_DRIVE_ERROR_UBLOCK_NOT_IN_UTABLE 0x0419
                             6594 ; 77   |#define NAND_DATA_DRIVE_ERROR_CANT_ALLOCATE_USECTORS_MAPS 0x041A
                             6595 ; 78   |#define NAND_DATA_DRIVE_ERROR_CANT_INIT_DATA_REGIONS_LIST 0x041B
                             6596 ; 79   |#define NAND_DATA_DRIVE_ERROR_TOO_MANY_UBLOCKS_IN_CONFIG 0x041C
                             6597 ; 80   |#define NAND_DATA_DRIVE_ERROR_USECTOR_INDEX_IS_NOT_NEXT 0x041D
                             6598 ; 81   |#define NAND_DATA_DRIVE_ERROR_USECTOR_ALREADY_UPDATED 0x041E
                             6599 ; 82   |#define NAND_DATA_DRIVE_ERROR_BgGC_USECTOR_ERASE_TIMEDOUT 0x041F
                             6600 ; 83   |#define NAND_DATA_DRIVE_ERROR_BgGC_HSECTOR_COPY_TIMEDOUT 0x0420
                             6601 ; 84   |#define NAND_DATA_DRIVE_ERROR_BgGC_ALREADY_ENABLED 0x0421
                             6602 ; 85   |#define NAND_DATA_DRIVE_ERROR_BgGC_HSECTOR_ERASE_TIMEDOUT 0x0422
                             6603 ; 86   |#define NAND_DATA_DRIVE_ERROR_BgGC_SECTOR_NOT_UPDATED 0x0423
                             6604 ; 87   |#define NAND_DATA_DRIVE_ERROR_NO_STALE_UBLOCKS 0x0424
                             6605 ; 88   |#define NAND_DATA_DRIVE_ERROR_NAND_IS_READY_TIMEOUT 0x0425
                             6606 ; 89   |#define NAND_DATA_DRIVE_ERROR_CANT_CLOSE_UPDATE 0x0426
                             6607 ; 90   |
                             6608 ; 91   |#define NAND_DATA_DRIVE_ERROR_CMW_S0_FETCH_FAILED 0x042C
                             6609 ; 92   |#define NAND_DATA_DRIVE_ERROR_CMW_S1_FETCH_FAILED 0x042D
                             6610 ; 93   |#define NAND_DATA_DRIVE_ERROR_CMW_S2_1_FETCH_FAILED 0x042E
                             6611 ; 94   |#define NAND_DATA_DRIVE_ERROR_CMW_S2_2_FETCH_FAILED 0x042F
                             6612 ; 95   |#define NAND_DATA_DRIVE_ERROR_CMW_S3_1_FETCH_FAILED 0x0430
                             6613 ; 96   |#define NAND_DATA_DRIVE_ERROR_CMW_S3_2_FETCH_FAILED 0x0431
                             6614 ; 97   |#define NAND_DATA_DRIVE_ERROR_CMW_S4_1_FETCH_FAILED 0x0432
                             6615 ; 98   |#define NAND_DATA_DRIVE_ERROR_CMW_S4_2_FETCH_FAILED 0x0433
                             6616 ; 99   |#define NAND_DATA_DRIVE_ERROR_CMW_S5_FETCH_FAILED 0x0434
                             6617 ; 100  |#define NAND_DATA_DRIVE_ERROR_CMW_S0_ECC_TIMEOUT 0x0435
                             6618 ; 101  |#define NAND_DATA_DRIVE_ERROR_CMW_S2_ECC_TIMEOUT 0x0436
                             6619 ; 102  |#define NAND_DATA_DRIVE_ERROR_CMW_S3_ECC_TIMEOUT 0x0437
                             6620 ; 103  |#define NAND_DATA_DRIVE_ERROR_CMW_S4_ECC_TIMEOUT 0x0438
                             6621 ; 104  |#define NAND_DATA_DRIVE_ERROR_CMW_S5_ECC_TIMEOUT 0x0439
                             6622 ; 105  |#define NAND_DATA_DRIVE_ERROR_CMW_WRITE_FAILED 0x043A
                             6623 ; 106  |#define NAND_DATA_DRIVE_ERROR_CMW_RELEASE_FAILED 0x043B
                             6624 ; 107  |
                             6625 ; 108  |#define NAND_DATA_DRIVE_ERROR_INVALID_LOGICAL_SECTOR 0x0427
                             6626 ; 109  |#define NAND_DATA_DRIVE_ERROR_INVALID_RELATIVE_SECTOR 0x0428
                             6627 ; 110  |#define NAND_DATA_DRIVE_ERROR_UBLOCK_IS_EMPTY 0x0429
                             6628 ; 111  |#define NAND_DATA_DRIVE_ERROR_USECTOR_MAP_IS_BAD 0x042A
                             6629 ; 112  |#define NAND_DATA_DRIVE_ERROR_TOO_MANY_BLOCK_RECOVERIES 0x042B
                             6630 ; 113  |
                             6631 ; 114  |// indicates that during the NandHalInit, the NandType did not
                             6632 ; 115  |// match the previously initialized Nand chip type.
                             6633 ; 116  |#define NANDHAL_ERROR_NANDTYPE_MISMATCH 0x0500 
                             6634 ; 117  |#define NANDHAL_ERROR_LOOKUP_ID_FAILED 0x0501
                             6635 ; 118  |// Errors from calling HIL functions
                             6636 ; 119  |#define NANDHAL_ERROR_INIT_PORT 0x0502
                             6637 ; 120  |#define NANDHAL_ERROR_WRITE_PORT_CMD 0x0503
                             6638 ; 121  |#define NANDHAL_ERROR_WRITE_PORT_ADDR 0x0504
                             6639 ; 122  |#define NANDHAL_ERROR_READ_PORT_DATA 0x0505
                             6640 ; 123  |#define NANDHAL_ERROR_WAIT_FOR_READY_PORT 0x0506
                             6641 ; 124  |#define NANDHAL_ERROR_POWER_UP_FLASH_PADS 0x0507
                             6642 ; 125  |#define NANDHAL_ERROR_TERMINATE_PORT 0x0508
                             6643 ; 126  |#define NANDHAL_ERROR_LOCKPORT_TIMEOUT 0x0509
                             6644 ; 127  |#define NANDHAL_ERROR_LOCKNAND_TIMEOUT 0x050A
                             6645 ; 128  |// for 3410 build
                             6646 ; 129  |#define NANDHAL_ERROR_LOCKPORT_LOCKED 0x050B
                             6647 ; 130  |// for 3410 build
                             6648 ; 131  |#define NANDHAL_ERROR_LOCKNAND_LOCKED 0x050C
                             6649 ; 132  |#define NANDHAL_ERROR_WRITE_DATA_PORT 0x050D
                             6650 ; 133  |
                             6651 ; 134  |// indicates that the GetStatus returned a FAIL
                             6652 ; 135  |#define NANDHAL_ERROR_GETSTATUS_FAILED 0x050E
                             6653 ; 136  |#define NANDHAL_ERROR_WRITE_FAILED 0x050F
                             6654 ; 137  |#define NANDHAL_ERROR_READ_FAILED 0x0510
                             6655 ; 138  |#define NANDHAL_ERROR_READID1_FAILED 0x0511
                             6656 ; 139  |#define NANDHAL_ERROR_READID2_FAILED 0x0512
                             6657 ; 140  |#define NANDHAL_ERROR_READIDEXT_FAILED 0x0513
                             6658 ; 141  |// indicates the NAND was already BUSY
                             6659 ; 142  |#define NANDHAL_ERROR_SETNANDBUSY_FAILED 0x0514
                             6660 ; 143  |#define NANDHAL_ERROR_ASYNCWAIT_CALLBACK_ERR 0x0515
                             6661 ; 144  |// ECC Error Codes
                             6662 ; 145  |// ECC Computation has successfully completed
                             6663 ; 146  |#define COMPUTE_ECC_SUCCESS 0         
                             6664 ; 147  |// ECC computation still busy
                             6665 ; 148  |#define COMPUTE_ECC_NOT_DONE 0x0516
                             6666 ; 149  |// timed out while waiting on object
                             6667 ; 150  |#define NANDHAL_ERROR_LOCKECC_TIMEOUT 0x0517
                             6668 ; 151  |// flag already set for SDK2.4 lock
                             6669 ; 152  |#define NANDHAL_ERROR_LOCKECC_LOCKED 0x0518
                             6670 ; 153  |
                             6671 ; 154  |#define NANDHAL_ECC_NOERROR 0
                             6672 ; 155  |// SKIP 0519-051B for space optimization in ECC calculate functions
                             6673 ; 156  |#define NANDHAL_ECC_ERROR_FIXED 0x051C
                             6674 ; 157  |#define NANDHAL_ECC_ERROR_FIXED_REWRITE_SECTOR 0x051D
                             6675 ; 158  |#define NANDHAL_ECC_FIX_FAILED 0x051E
                             6676 ; 159  |#define NANDHAL_ECC_ERROR_FIXED_REWRITE_FAILED 0x051F
                             6677 ; 160  |
                             6678 ; 161  |// MMC Errors
                             6679 ; 162  |#define MMC_MEDIA_ERROR_DEVICE_NOT_INSERTED 0x0600
                             6680 ; 163  |#define MMC_MEDIA_ERROR_RESET_FAILED 0x0601
                             6681 ; 164  |#define MMC_MEDIA_APP_COMMAND_FAILED 0x0602
                             6682 ; 165  |#define MMC_MEDIA_ERROR_INIT_FAILED 0x0603
                             6683 ; 166  |#define MMC_MEDIA_ERROR_SEND_OP_TIMEOUT 0x0604
                             6684 ; 167  |#define MMC_MEDIA_READ_OCR_FAILED 0x0605
                             6685 ; 168  |#define MMC_MEDIA_UNSUPPORTED_OCR_VOLTAGES 0x0606
                             6686 ; 169  |#define MMC_MEDIA_READ_CSD_FAILED 0x0607
                             6687 ; 170  |#define MMC_MEDIA_INVALID_CSD_VERSION 0x0608
                             6688 ; 171  |#define MMC_MEDIA_READ_CID_FAILED 0x0609
                             6689 ; 172  |#define MMC_MEDIA_INVALID_CID 0x060A
                             6690 ; 173  |#define MMC_MEDIA_SPEC_VERSION_NOT_SUPPORTED 0x060B
                             6691 ; 174  |#define MMC_MEDIA_ERROR_NOT_FORMATTED 0x060C
                             6692 ; 175  |#define MMC_MEDIA_ERROR_NOT_ENUMERATED 0x060D
                             6693 ; 176  |
                             6694 ; 177  |#define MMC_DATA_DRIVE_ERROR_WRITE_SECTOR_FAIL 0x0700
                             6695 ; 178  |#define MMC_DATA_DRIVE_ERROR_INVALID_SECTOR 0x0701
                             6696 ; 179  |#define MMC_DATA_DRIVE_ERROR_READ_SECTOR_FAIL 0x0702
                             6697 ; 180  |#define MMC_DATA_DRIVE_ERROR_WRITE_PROTECTED 0x0703
                             6698 ; 181  |#define MMC_DATA_DRIVE_ERROR_ERASE_FAILED 0x0704
                             6699 ; 182  |#define MMC_DATA_DRIVE_ERROR_SEQUENTIAL_FIRST_FAIL 0x0705
                             6700 ; 183  |#define MMC_DATA_DRIVE_ERROR_SEQUENTIAL_NEXT_FAIL 0x0706
                             6701 ; 184  |#define MMC_DATA_DRIVE_ERROR_SEQUENTIAL_END_FAIL 0x0707
                             6702 ; 185  |#define MMC_DATA_DRIVE_ERROR_BLOCK_ALIGN_FAIL 0x0708
                             6703 ; 186  |
                             6704 ; 187  |/////////////////////////////////////////////////////////////////////////////////
                             6705 ; 188  |//// MMC HAL Error codes
                             6706 ; 189  |/////////////////////////////////////////////////////////////////////////////////
                             6707 ; 190  |#define MMC_HAL_ERROR_PHYSICAL_DEVICE_BLOCKED 0x0800
                             6708 ; 191  |#define MMC_HAL_ERROR_PHYSICAL_DEVICE_NOT_BLOCKED 0x0801
                             6709 ; 192  |#define MMC_HAL_ERROR_SPI_BUS_BLOCKED 0x0802
                             6710 ; 193  |#define MMC_HAL_ERROR_SPI_BUS_NOT_BLOCKED 0x0803
                             6711 ; 194  |#define MMC_HAL_ERROR_SPI_DRIVER_INIT_FAILED 0x0804
                             6712 ; 195  |#define MMC_HAL_ERROR_SPI_BUS_INIT_FAILED 0x0805
                             6713 ; 196  |
                             6714 ; 197  |#define MMC_HAL_ERROR_NO_COMMAND_RESPONSE 0x0810
                             6715 ; 198  |#define MMC_HAL_ERROR_BAD_START_BYTE 0x0811
                             6716 ; 199  |#define MMC_HAL_ERROR_BAD_WRITE_STATUS 0x0812
                             6717 ; 200  |#define MMC_HAL_ERROR_BAD_CSD_WRITE_STATUS 0x0813
                             6718 ; 201  |
                             6719 ; 202  |#define MMC_HAL_ERROR_START_BYTE_TIMEOUT 0x0820
                             6720 ; 203  |#define MMC_HAL_ERROR_WRITE_BUSY_TIMEOUT 0x0821
                             6721 ; 204  |#define MMC_HAL_ERROR_CSD_WRITE_BUSY_TIMEOUT 0x0822
                             6722 ; 205  |#define MMC_HAL_ERROR_ERASE_BUSY_TIMEOUT 0x0823
                             6723 ; 206  |#define MMC_HAL_ERROR_REGISTER_READ_TIMEOUT 0x0824
TASKING DSP2410 assembler v1.5r1 Build 138 SN 00100122
                                                                                                                                                                                                                                                       Page  26

M:ADDR CODE           CYCLES LINE SOURCELINE
                             6724 ; 207  |
                             6725 ; 208  |#define MMC_HAL_ERROR_CMD_FAIL_CMD0 0x0830
                             6726 ; 209  |#define MMC_HAL_ERROR_CMD_FAIL_CMD1 0x0831
                             6727 ; 210  |#define MMC_HAL_ERROR_CMD_FAIL_CMD9 0x0832
                             6728 ; 211  |#define MMC_HAL_ERROR_CMD_FAIL_CMD10 0x0833
                             6729 ; 212  |#define MMC_HAL_ERROR_CMD_FAIL_CMD12 0x0834
                             6730 ; 213  |#define MMC_HAL_ERROR_CMD_FAIL_CMD13 0x0835
                             6731 ; 214  |#define MMC_HAL_ERROR_CMD_FAIL_CMD16 0x0836
                             6732 ; 215  |#define MMC_HAL_ERROR_CMD_FAIL_CMD17 0x0837
                             6733 ; 216  |#define MMC_HAL_ERROR_CMD_FAIL_CMD18 0x0838
                             6734 ; 217  |#define MMC_HAL_ERROR_CMD_FAIL_CMD23 0x0839
                             6735 ; 218  |#define MMC_HAL_ERROR_CMD_FAIL_CMD24 0x083A
                             6736 ; 219  |#define MMC_HAL_ERROR_CMD_FAIL_CMD25 0x083B
                             6737 ; 220  |#define MMC_HAL_ERROR_CMD_FAIL_CMD27 0x083C
                             6738 ; 221  |#define MMC_HAL_ERROR_CMD_FAIL_CMD28 0x083D
                             6739 ; 222  |#define MMC_HAL_ERROR_CMD_FAIL_CMD29 0x083E
                             6740 ; 223  |#define MMC_HAL_ERROR_CMD_FAIL_CMD30 0x083F
                             6741 ; 224  |#define MMC_HAL_ERROR_CMD_FAIL_CMD32 0x0840
                             6742 ; 225  |#define MMC_HAL_ERROR_CMD_FAIL_CMD33 0x0841
                             6743 ; 226  |#define MMC_HAL_ERROR_CMD_FAIL_CMD35 0x0842
                             6744 ; 227  |#define MMC_HAL_ERROR_CMD_FAIL_CMD36 0x0843
                             6745 ; 228  |#define MMC_HAL_ERROR_CMD_FAIL_CMD38 0x0844
                             6746 ; 229  |#define MMC_HAL_ERROR_CMD_FAIL_CMD42 0x0845
                             6747 ; 230  |#define MMC_HAL_ERROR_CMD_FAIL_CMD55 0x0846
                             6748 ; 231  |#define MMC_HAL_ERROR_CMD_FAIL_CMD56 0x0847
                             6749 ; 232  |#define MMC_HAL_ERROR_CMD_FAIL_CMD58 0x0848
                             6750 ; 233  |#define MMC_HAL_ERROR_CMD_FAIL_CMD59 0x0849
                             6751 ; 234  |
                             6752 ; 235  |#define MMC_HAL_ERROR_SD_CMD_FAIL_ACMD13 0x0850
                             6753 ; 236  |#define MMC_HAL_ERROR_SD_CMD_FAIL_ACMD22 0x0851
                             6754 ; 237  |#define MMC_HAL_ERROR_SD_CMD_FAIL_ACMD23 0x0852
                             6755 ; 238  |#define MMC_HAL_ERROR_SD_CMD_FAIL_ACMD41 0x0853
                             6756 ; 239  |#define MMC_HAL_ERROR_SD_CMD_FAIL_ACMD42 0x0854
                             6757 ; 240  |#define MMC_HAL_ERROR_SD_CMD_FAIL_ACMD51 0x0855
                             6758 ; 241  |
                             6759 ; 242  |#define MMC_HAL_ERROR_BAD_CMD_RESPONSE_CMD0 0x0860
                             6760 ; 243  |#define MMC_HAL_ERROR_BAD_CMD_RESPONSE_CMD1 0x0861
                             6761 ; 244  |#define MMC_HAL_ERROR_BAD_CMD_RESPONSE_CMD9 0x0862
                             6762 ; 245  |#define MMC_HAL_ERROR_BAD_CMD_RESPONSE_CMD10 0x0863
                             6763 ; 246  |#define MMC_HAL_ERROR_BAD_CMD_RESPONSE_CMD12 0x0864
                             6764 ; 247  |#define MMC_HAL_ERROR_BAD_CMD_RESPONSE_CMD13 0x0865
                             6765 ; 248  |#define MMC_HAL_ERROR_BAD_CMD_RESPONSE_CMD16 0x0866
                             6766 ; 249  |#define MMC_HAL_ERROR_BAD_CMD_RESPONSE_CMD17 0x0867
                             6767 ; 250  |#define MMC_HAL_ERROR_BAD_CMD_RESPONSE_CMD18 0x0868
                             6768 ; 251  |#define MMC_HAL_ERROR_BAD_CMD_RESPONSE_CMD23 0x0869
                             6769 ; 252  |#define MMC_HAL_ERROR_BAD_CMD_RESPONSE_CMD24 0x086A
                             6770 ; 253  |#define MMC_HAL_ERROR_BAD_CMD_RESPONSE_CMD25 0x086B
                             6771 ; 254  |#define MMC_HAL_ERROR_BAD_CMD_RESPONSE_CMD27 0x086C
                             6772 ; 255  |#define MMC_HAL_ERROR_BAD_CMD_RESPONSE_CMD28 0x086D
                             6773 ; 256  |#define MMC_HAL_ERROR_BAD_CMD_RESPONSE_CMD29 0x086E
                             6774 ; 257  |#define MMC_HAL_ERROR_BAD_CMD_RESPONSE_CMD30 0x086F
                             6775 ; 258  |#define MMC_HAL_ERROR_BAD_CMD_RESPONSE_CMD32 0x0870
                             6776 ; 259  |#define MMC_HAL_ERROR_BAD_CMD_RESPONSE_CMD33 0x0871
                             6777 ; 260  |#define MMC_HAL_ERROR_BAD_CMD_RESPONSE_CMD35 0x0872
                             6778 ; 261  |#define MMC_HAL_ERROR_BAD_CMD_RESPONSE_CMD36 0x0873
                             6779 ; 262  |#define MMC_HAL_ERROR_BAD_CMD_RESPONSE_CMD38 0x0874
                             6780 ; 263  |#define MMC_HAL_ERROR_BAD_CMD_RESPONSE_CMD42 0x0875
                             6781 ; 264  |#define MMC_HAL_ERROR_BAD_CMD_RESPONSE_CMD55 0x0876
                             6782 ; 265  |#define MMC_HAL_ERROR_BAD_CMD_RESPONSE_CMD56 0x0877
                             6783 ; 266  |#define MMC_HAL_ERROR_BAD_CMD_RESPONSE_CMD58 0x0878
                             6784 ; 267  |#define MMC_HAL_ERROR_BAD_CMD_RESPONSE_CMD59 0x0879
                             6785 ; 268  |
                             6786 ; 269  |#define MMC_HAL_ERROR_SD_BAD_CMD_RESPONSE_ACMD13 0x0880
                             6787 ; 270  |#define MMC_HAL_ERROR_SD_BAD_CMD_RESPONSE_ACMD22 0x0881
                             6788 ; 271  |#define MMC_HAL_ERROR_SD_BAD_CMD_RESPONSE_ACMD23 0x0882
                             6789 ; 272  |#define MMC_HAL_ERROR_SD_BAD_CMD_RESPONSE_ACMD41 0x0883
                             6790 ; 273  |#define MMC_HAL_ERROR_SD_BAD_CMD_RESPONSE_ACMD42 0x0884
                             6791 ; 274  |#define MMC_HAL_ERROR_SD_BAD_CMD_RESPONSE_ACMD51 0x0885
                             6792 ; 275  |
                             6793 ; 276  |//;;;;;;; < Library Error Codes > ;;;;;;;;
                             6794 ; 277  |//MATH errors...
                             6795 ; 278  |#define ERRZeroDivide 0x7FFFFF
                             6796 ; 279  |
                             6797 ; 280  |//Memory Pointer errors...
                             6798 ; 281  |#define INVALID_MEMORY_SPACE 0x900000
                             6799 ; 282  |//****************************************************************/
                             6800 ; 283  |#if (!defined(NOERROR))
                             6801 ; 284  |#define NOERROR 0
                             6802 ; 285  |#endif
                             6803 ; 286  |
                             6804 ; 287  |////Added by RAKS
                             6805 ; 288  |
                             6806 ; 289  |#define ERRProgram 0x911111
                             6807 ; 290  |#define ERRNoMedia 0x922222
                             6808 ; 291  |#define ERRHwFail 0x933333   
                             6809 ; 292  |#define ERRInvMedia 0x944444
                             6810 ; 293  |#define ERRBlkFail 0x955555
                             6811 ; 294  |#define ERRInvDataStatus 0x966666
                             6812 ; 295  |#define ERRWriteFail 0x977777
                             6813 ; 296  |#define ERRECCCorr 0x988888
                             6814 ; 297  |#define ERRECCFail 0x999999
                             6815 ; 298  |#define ERRZoneFull 0x9aaaaa
                             6816 ; 299  |#define ERR_PAGE_UNASSIGNED 0x9aaaaB   
                             6817 ; 300  |// Partition Table Error Codes.                 Note 9AAAAA used above and below.
                             6818 ; 301  |//invalid partition table signature. 
                             6819 ; 302  |#define ERRPartTableSignature 0x9AAAAA   
                             6820 ; 303  |//boot ID bad
                             6821 ; 304  |#define ERRBootID 0x9BBBBB   
                             6822 ; 305  |#define ERRBootTableSignature 0x9CCCCC   
                             6823 ; 306  |////Nothing was here : RAKS
                             6824 ; 307  |//JUMP instruction bad
                             6825 ; 308  |#define ERRBootJump 0x9DDDDD  
                             6826 ; 309  |//ID Byte bad
                             6827 ; 310  |#define ERRIDByte 0x9EEEEE  
                             6828 ; 311  |
                             6829 ; 312  |
                             6830 ; 313  |//****************************************************************
                             6831 ; 314  |//        < < <  EMC5600 FAT12 FileSystem  > > >
                             6832 ; 315  |//****************************************************************
                             6833 ; 316  |// Master ERROR File
                             6834 ; 317  |//****************************************************************/
                             6835 ; 318  |// FAT File System Error Codes
                             6836 ; 319  |// corrupt FAT
                             6837 ; 320  |#define FATCorrupt -1        
                             6838 ; 321  |// invalid FAT sector
                             6839 ; 322  |#define DIRInvlaidSector -2        
                             6840 ; 323  |
                             6841 ; 324  |#define FATwarningFreeCx 0x0AFCFC
                             6842 ; 325  |#define FATwarningEndOfChain 0x0AECEC
                             6843 ; 326  |#define FATwarningReservedCx 0x0A1111
                             6844 ; 327  |#define FATwarningBadCx 0x0ABCBC       
                             6845 ; 328  |//FATcxsFree==0 
                             6846 ; 329  |#define FATwarningNoFreeCxs 0x0A0F0F   
                             6847 ; 330  |#define FATwarningBoundaryCx 0x0A2222
                             6848 ; 331  |#define FATwarningWriteBackAborted 0x0A3333
                             6849 ; 332  |
                             6850 ; 333  |#define FATfailedReadPrimaryFAT 0x7F0000
                             6851 ; 334  |#define FATfailedWritePrimaryFAT 0x7FFFFF   
                             6852 ; 335  |#define FATfailedWriteSecondaryFAT 0x7F8888
                             6853 ; 336  |
                             6854 ; 337  |#define FATerrorNoFreeBlocks 0x80A0A0
                             6855 ; 338  |#define FATerrorTableOverFlow 0x80CCCC
                             6856 ; 339  |#define FATerrorClusterUnderFlow 0x80DDDD
                             6857 ; 340  |#define FATerrorClusterOverFlow 0x80EEEE
                             6858 ; 341  |//No Free Cxs on FAT Scan!
                             6859 ; 342  |#define FATerrorNoFreeCxs 0x80FFFF   
                             6860 ; 343  |
                             6861 ; 344  |#define MATHerrorNotPowerOf2 0x802222
                             6862 ; 345  |
                             6863 ; 346  |#define MEDIAerrorFSNotSupported 0x810000
                             6864 ; 347  |#define MEDIAerrorMediaNotUsable 0x811111
                             6865 ; 348  |
                             6866 ; 349  |#define CXerrorValueOverFlow 0x82AAAA
                             6867 ; 350  |#define CXerrorValueUnderFlow 0x82BBBB
                             6868 ; 351  |
                             6869 ; 352  |#define HNDLerrorNoHandles 0x83AAAA
                             6870 ; 353  |#define HNDLerrorInvalidHandle 0x83BBBB
                             6871 ; 354  |#define HNDLerrorInvalidDevice 0x830D0D
                             6872 ; 355  |#define HNDLerrorIndexSect 0x83CCCC
                             6873 ; 356  |
                             6874 ; 357  |#define FCBwarningEndOfFile 0x84EFEF
                             6875 ; 358  |#define FCBerrorCXtoSect 0x84CCCC
                             6876 ; 359  |#define FCBerrorDiskFull 0x84DFDF
                             6877 ; 360  |
                             6878 ; 361  |#define SEEKprefix 0x85
                             6879 ; 362  |#define SEEKerrorAccessDenied 0x85ADAD
                             6880 ; 363  |#define SEEKerrorPassedBeginingOfFile 0x85BFBF
                             6881 ; 364  |#define SEEKerrorCurruptFCB 0x85CCCC
                             6882 ; 365  |#define SEEKerrorPassedEndOfFile 0x85EFEF
                             6883 ; 366  |
                             6884 ; 367  |#define READprefix 0x86
                             6885 ; 368  |#define READerrorMemoryOverFlow 0x860F0F
                             6886 ; 369  |#define READerrorInvalidBufferPntr 0x86BFBF
                             6887 ; 370  |#define READerrorInvalidByteCount 0x86BCBC
                             6888 ; 371  |#define READerrorAccessDenied 0x86ADAD
                             6889 ; 372  |#define READerrorFreeCx 0x860000
                             6890 ; 373  |#define READerrorEndOfChain 0x861111
                             6891 ; 374  |#define READerrorReservedCx 0x862222
                             6892 ; 375  |#define READerrorBadCx 0x863333
                             6893 ; 376  |
                             6894 ; 377  |#define WRITEprefix 0x87
                             6895 ; 378  |#define WRITEerrorMemoryOverFlow 0x870F0F
                             6896 ; 379  |#define WRITEerrorInvalidBufferPntr 0x87BFBF
                             6897 ; 380  |#define WRITEerrorInvalidByteCount 0x87BCBC
                             6898 ; 381  |#define WRITEerrorAccessDenied 0x87ADAD
                             6899 ; 382  |#define WRITEerrorFreeCx 0x870000
                             6900 ; 383  |#define WRITEerrorEndOfChain 0x871111
                             6901 ; 384  |#define WRITEerrorReservedCx 0x872222
                             6902 ; 385  |#define WRITEerrorBadCx 0x873333
                             6903 ; 386  |
                             6904 ; 387  |#define UTILprefix 0x88
                             6905 ; 388  |#define UTILerrorDeviceInvalid 0x88BDBD
                             6906 ; 389  |
                             6907 ; 390  |// Directory Error Codes
                             6908 ; 391  |
                             6909 ; 392  |// invalid DIR sector specified
                             6910 ; 393  |#define ERR_DIRInvalidSector 0xA00000  
                             6911 ; 394  |// PATH search string has invlaid directory
                             6912 ; 395  |#define ERR_DIRInvalidPath 0xA00001  
                             6913 ; 396  |#define ERR_DIR_ALREADY_EXISTS 0xA00002
                             6914 ; 397  |#define ERR_DIR_WRITE_FAILED 0xA00003
                             6915 ; 398  |#define ERR_DIR_NOT_EMPTY 0xA00003
                             6916 ; 399  |// Bad cluster number
                             6917 ; 400  |#define ERR_CLUSTER_OUT_OF_RANGE 0xA11111  
                             6918 ; 401  |// Can't open ROOT
                             6919 ; 402  |#define ERR_OPEN_ROOT 0xA22222  
                             6920 ; 403  |#define ERR_CLUSTER_FLAGGED_BAD 0xA33333 
                             6921 ; 404  |#define ERR_CLUSTER_UNREADABLE 0xA44444 
                             6922 ; 405  |#define ERR_SECTOR_UNREADABLE 0xA44441 
                             6923 ; 406  |// bad record number to read
                             6924 ; 407  |#define ERR_INVLAID_DIR_REQUEST 0xA55555  
                             6925 ; 408  |// record requeste not in range
                             6926 ; 409  |#define ERR_ReadRecordRangeError 0xA66666  
                             6927 ; 410  |// record requeste past end of ROOT
                             6928 ; 411  |#define ERR_ReadPastEndOfROOT 0xA66660  
                             6929 ; 412  |// device number invalid
                             6930 ; 413  |#define ERR_BadDeviceNumber 0xA77777  
                             6931 ; 414  |// FCB Does not popint to a sub-Directory entry
                             6932 ; 415  |#define ERR_FCB_Not_SubDir 0xA88888  
                             6933 ; 416  |// Path specified is invalid
                             6934 ; 417  |#define ERR_INVLAID_PATH 0xA99999  
                             6935 ; 418  |#define ERR_FILE_NOT_FOUND 0xAAAAAA
                             6936 ; 419  |#define ERR_FILE_EXISTS 0xABBBBB
                             6937 ; 420  |#define ERR_DISK_FULL 0xACCCCC
                             6938 ; 421  |#define ERR_DIR_DEVICE_NOT_READY 0xACCCC0
                             6939 ; 422  |#define ERR_CX_ALLOCATION 0xADDDDD
                             6940 ; 423  |#define ERR_INVALID_MODE 0xAEEEEE
                             6941 ; 424  |
                             6942 ; 425  |#define ERR_DUPLICATE_FILE_NAME 0xAFFFFC
                             6943 ; 426  |#define ERR_FAT_WRITE_FAILED 0xAFFFFD
                             6944 ; 427  |#define ERR_CANT_DELETE_CHAIN 0xAFFFFE
                             6945 ; 428  |#define ERR_FAT_CHAIN_CORRUPT 0xAFFFFF
                             6946 ; 429  |// String Manipulation Error Codes
                             6947 ; 430  |#define ERR_END_OF_STRING 0xABBBB0
                             6948 ; 431  |
                             6949 ; 432  |#endif //@DEF(ERRORS_INC)
                             6950 ; 433  |
                             6951 
                             6953 
                             6954 ; 16   |#include "sectordef.h"
                             6955 
                             6957 
                             6958 ; 1    |////////////////////////////////////////////////////////////////////////////////
                             6959 ; 2    |// Copyright(C) SigmaTel, Inc. 2003-2005
                             6960 ; 3    |//
                             6961 ; 4    |// Filename:     sectordef.h
                             6962 ; 5    |// Description:  Contains structs, prototypes, equates for the NAND Hal & other 
                             6963 ; 6    |//               routines.
                             6964 ; 7    |////////////////////////////////////////////////////////////////////////////////
                             6965 ; 8    |
                             6966 ; 9    |#ifndef _SECTORDEF_H
                             6967 ; 10   |#define _SECTORDEF_H
                             6968 ; 11   |
                             6969 ; 12   |    #define RAM_SECTOR_TOTAL_SIZE                 (528)
                             6970 ; 13   |    #define RAM_SECTOR_DATA_SIZE                  (512)
                             6971 ; 14   |    #define RAM_SECTOR_REDUNDANT_SIZE             (16)
                             6972 ; 15   |
                             6973 ; 16   |
                             6974 ; 17   |    #define MMC_SECTOR_TOTAL_SIZE                 (528)
                             6975 ; 18   |    #define MMC_SECTOR_DATA_SIZE                  (512)
                             6976 ; 19   |    #define MMC_SECTOR_REDUNDANT_SIZE             (16)
TASKING DSP2410 assembler v1.5r1 Build 138 SN 00100122
                                                                                                                                                                                                                                                       Page  27

M:ADDR CODE           CYCLES LINE SOURCELINE
                             6977 ; 20   |
                             6978 ; 21   |
                             6979 ; 22   |    #define SSFDC_SECTOR_TOTAL_SIZE                 (528)
                             6980 ; 23   |    #define SSFDC_SECTOR_DATA_SIZE                  (512)
                             6981 ; 24   |    #define SSFDC_SECTOR_REDUNDANT_SIZE             (16)
                             6982 ; 25   |
                             6983 ; 26   | // Define large sector macros as small ones so sdk3.x fits in ram and mtp with small 
                             6984 ; 27   | // sector flash gets the performance boosts from optimized nand timings, etc. 
                             6985 ; 28   | // TOVERIFY: Comment out the next macro def when you want large sector support as 
                             6986 ; 29   | // in sdk2.6 and you can find the free data RAM. Or uncomment if you want to save data ram
                             6987 ; 30   | // and only support 512 byte sectors and their associated flash types. 
                             6988 ; 31   |//#define LARGE_SECTOR_DEFS_AS_SMALL_SECTOR
                             6989 ; 32   |#ifdef LARGE_SECTOR_DEFS_AS_SMALL_SECTOR 
                             6990 ; 33   |    #define LARGE_SECTOR_TOTAL_SIZE                 (528)
                             6991 ; 34   |    #define LARGE_SECTOR_DATA_SIZE                  (512)
                             6992 ; 35   |    #define LARGE_SECTOR_REDUNDANT_SIZE             (16)
                             6993 ; 36   |#else
                             6994 ; 37   |    // Real large sector defines to use when large sector flash support is desired.
                             6995 ; 38   |    #define LARGE_SECTOR_TOTAL_SIZE                 (2112)
                             6996 ; 39   |    #define LARGE_SECTOR_DATA_SIZE                  (2048)
                             6997 ; 40   |    #define LARGE_SECTOR_REDUNDANT_SIZE             (64)
                             6998 ; 41   |#endif
                             6999 ; 42   |    
                             7000 ; 43   |    // round up to the nearest WORD, then add one to pad for the ECC DMA bug
                             7001 ; 44   |    #define SECTOR_BUFFER_ALLOC_SIZE(a)             (((a+2)/3)+1)
                             7002 ; 45   |
                             7003 ; 46   |
                             7004 ; 47   |    // These are moved here from chkdsk.h     TOVERIFY. 
                             7005 ; 48   |    #define SEC_512_BYTES_PER_SECTOR                        SSFDC_SECTOR_DATA_SIZE
                             7006 ; 49   |        #define SEC_512_BYTES_TOTAL_SIZE                                                SSFDC_SECTOR_TOTAL_SIZE
                             7007 ; 50   |        #define SEC_512_WORDS_TOTAL_SIZE                                                176
                             7008 ; 51   |    #define SEC_512_BYTES_CLUSTER_ENTRY_PER_SECTOR_SHIFT    12
                             7009 ; 52   |    #define SEC_512_BYTES_DIR_REC_PER_SECTOR                16
                             7010 ; 53   |    #define SEC_512_BYTES_WORDS_PER_SECTOR                  177
                             7011 ; 54   |    #define SEC_2K_BYTES_PER_SECTOR                         LARGE_SECTOR_DATA_SIZE
                             7012 ; 55   |        #define SEC_2K_BYTES_TOTAL_SIZE                                                 LARGE_SECTOR_TOTAL_SIZE
                             7013 ; 56   |    #define SEC_2K_BYTES_CLUSTER_ENTRY_PER_SECTOR_SHIFT     12
                             7014 ; 57   |    #define SEC_2K_BYTES_DIR_REC_PER_SECTOR                 64
                             7015 ; 58   |    #define SEC_2K_BYTES_WORDS_PER_SECTOR                   705
                             7016 ; 59   |    #define SEC_2K_BYTES_WORDS_PER_SECTOR_NO_RA             683
                             7017 ; 60   |
                             7018 ; 61   |    // Next 5 lines imported from nandsystemdrivewritesector.c
                             7019 ; 62   |    #define RA_ATTR_MEMORY_OFFSET           682
                             7020 ; 63   |    #define NUMBER_OF_WORDS_IN_512BYTES     171
                             7021 ; 64   |    #define NUM_ECC_DATA_IN_WORDS           3
                             7022 ; 65   |    #define SEC_512_WORD1_RA_SWAP           171
                             7023 ; 66   |    #define SEC_512_WORD2_RA_SWAP           173
                             7024 ; 67   |
                             7025 ; 68   |#endif  // _SECTORDEF_H
                             7026 ; 69   |
                             7027 
                             7029 
                             7030 ; 17   |
                             7031 ; 18   |///////////////////////////////////////////////////////////////////////////////
                             7032 ; 19   |// Definitions
                             7033 ; 20   |///////////////////////////////////////////////////////////////////////////////
                             7034 ; 21   |// Can disable ECC interrupt for testing
                             7035 ; 22   |#if 0 
                             7036 ; 23   |#define ECC_POLLING
                             7037 ; 24   |#endif
                             7038 ; 25   |
                             7039 ; 26   |#define RSECC_DELAY_COUNTER_VALUE 1000
                             7040 ; 27   |
                             7041 ; 28   |//-------------------------------
                             7042 ; 29   |// these byte values are also seen in device ID in nandtables.h and nanddesc.c for bootmgr.
                             7043 ; 30   |#define STMakerID    0x20
                             7044 ; 31   |#define HynixMakerID 0xAD
                             7045 ; 32   |
                             7046 ; 33   |#define SAMSUNG_MAKER_ID 0xEC
                             7047 ; 34   |#define MICRON_MAKER_ID   0x2c
                             7048 ; 35   |
                             7049 ; 36   |#define ToshibaMakerID        0x98
                             7050 ; 37   |#define RENESAS_MAKER_ID  0x07
                             7051 ; 38   |//#define SandiskMakerID 0x000045
                             7052 ; 39   |//-------------------------------
                             7053 ; 40   |// place the tables in X space.
                             7054 ; 41   |#define NAND_TABLES_MEMSPACE _X
                             7055 ; 42   |
                             7056 ; 43   |#define NANDHAL_MEM_X _X
                             7057 ; 44   |#define NANDHAL_MEM_Y _Y
                             7058 ; 45   |#define NANDHAL_MEM NANDHAL_MEM_Y    // ***** IF THIS CHANGES, YOU MUST UPDATE NANDHal.inc to MATCH!!!!
                             7059 ; 46   |
                             7060 ; 47   |#define LEAVE_CE_PIN_ASSERTED 0  // formerly FALSE
                             7061 ; 48   |#define DEASSERT_CE_PIN       1  // formerly TRUE
                             7062 ; 49   |
                             7063 ; 50   |// These are for readfunctions -- to ease readability
                             7064 ; 51   |#define wColumnByteZero 0
                             7065 ; 52   |#define wColumnAddrZero 0
                             7066 ; 53   |#define wRowByteZero    0
                             7067 ; 54   |#define wRowByteOne     1
                             7068 ; 55   |#define wRowAddrZero    0
                             7069 ; 56   |#define wReadZeroBytes  0
                             7070 ; 57   |#define wReadOneByte    1
                             7071 ; 58   |#define wReadTwoBytes   2
                             7072 ; 59   |#define wReadThreeBytes 3
                             7073 ; 60   |#define wReadSixBytes   6
                             7074 ; 61   |#define wByteOffsetZero 0
                             7075 ; 62   |
                             7076 ; 63   |// Timeouts -- TBD -- These either get replaced altogether, or go somewhere else.
                             7077 ; 64   |// WaitForREADY() timeout counts
                             7078 ; 65   |// These control how long we will wait for the NAND to finish some internal operation
                             7079 ; 66   |// (e.g. Read Page (to cache), Program Page (from cache), Erase Block, Reset).
                             7080 ; 67   |// NOTE: For timeouts, each "count" is on the order of 50 nsec.
                             7081 ; 68   |// (<10 instructions, at a few 10s of nanosecs each)
                             7082 ; 69   |// The settings below are probably very conservative, but still short in human time
                             7083 ; 70   |// (e.g. 2000000 counts is approx. 100 msec)
                             7084 ; 71   |#define NAND_READ_PAGE_TIMEOUT          (2000000)
                             7085 ; 72   |#define NAND_READ_REDUNDANT_TIMEOUT     (2000000)
                             7086 ; 73   |#define NAND_RESET_TIMEOUT              (2000000)
                             7087 ; 74   |#define NAND_WRITE_PAGE_TIMEOUT         (2000000)
                             7088 ; 75   |#define NAND_ERASE_BLOCK_TIMEOUT        (2000000)
                             7089 ; 76   |
                             7090 ; 77   |// Read Status Register Masks
                             7091 ; 78   |// commented out with definition of new API
                             7092 ; 79   |// #define NAND_SR_PASS_MASK           0x000001
                             7093 ; 80   |// #define NAND_SR_CACHEPASS_MASK      0x000002
                             7094 ; 81   |// #define NAND_SR_READY_MASK          0x000060
                             7095 ; 82   |// //#define NAND_SR_READY_MASK          0x000040
                             7096 ; 83   |// #define NAND_SR_WRITEPROTECT_MASK   0x000080
                             7097 ; 84   |
                             7098 ; 85   |// new definitions for standardized API
                             7099 ; 86   |#define NAND_STATUS_PASS_MASK                   0x000001
                             7100 ; 87   |#define NAND_STATUS_DISTRICT_0_PASS_MASK        0x000002
                             7101 ; 88   |#define NAND_STATUS_DISTRICT_1_PASS_MASK        0x000004
                             7102 ; 89   |#define NAND_STATUS_DISTRICT_2_PASS_MASK        0x000008
                             7103 ; 90   |#define NAND_STATUS_DISTRICT_3_PASS_MASK        0x000010
                             7104 ; 91   |#define NAND_STATUS_TRUE_READY_MASK             0x000020
                             7105 ; 92   |#define NAND_STATUS_CACHE_READY_MASK            0x000040
                             7106 ; 93   |#define NAND_STATUS_WRITE_PROTECT_MASK          0x000080
                             7107 ; 94   |#define NAND_STATUS_CACHE_PREVIOUS_PASS_MASK    0x000100
                             7108 ; 95   |// The next 3 are used for Renesas part.
                             7109 ; 96   |#define NAND_STATUS_PROGRAM_CHECK_PASS_MASK     0x000008
                             7110 ; 97   |#define NAND_STATUS_ERASE_CHECK_PASS_MASK       0x000010
                             7111 ; 98   |#define NAND_STATUS_ECC_CORRECTABLE_MASK        0x000020
                             7112 ; 99   |#define NAND_STATUS_INVALID_MASK                0x800000
                             7113 ; 100  |
                             7114 ; 101  |#define NAND_STATUS_PASS_VALUE                  0x000001
                             7115 ; 102  |#define NAND_STATUS_DISTRICT_0_PASS_VALUE       0x000002
                             7116 ; 103  |#define NAND_STATUS_DISTRICT_1_PASS_VALUE       0x000004
                             7117 ; 104  |#define NAND_STATUS_DISTRICT_2_PASS_VALUE       0x000008
                             7118 ; 105  |#define NAND_STATUS_DISTRICT_3_PASS_VALUE       0x000010
                             7119 ; 106  |#define NAND_STATUS_TRUE_READY_VALUE            0x000020
                             7120 ; 107  |#define NAND_STATUS_CACHE_READY_VALUE           0x000040
                             7121 ; 108  |#define NAND_STATUS_WRITE_PROTECT_VALUE         0x000080
                             7122 ; 109  |#define NAND_STATUS_CACHE_PREVIOUS_PASS_VALUE   0x000100
                             7123 ; 110  |
                             7124 ; 111  |#define NAND_STATUS_PROGRAM_CHECK_PASS_VALUE    0x000008
                             7125 ; 112  |#define NAND_STATUS_ERASE_CHECK_PASS_VALUE      0x000010
                             7126 ; 113  |#define NAND_STATUS_ECC_CORRECTABLE             0x000020
                             7127 ; 114  |
                             7128 ; 115  |#define WP_NAND_INTERNAL    0   // write protect line for internal
                             7129 ; 116  |#define WP_EXTERNAL         1   // write protect line for external
                             7130 ; 117  |
                             7131 ; 118  |#define MakerIDMask 0x0000ff
                             7132 ; 119  |#define INVALID_SECTOR_ADDRESS     (0xFFFFF0) // FFFFF0 is a dummy value intended to be an invalid sector address
                             7133 ; 120  |
                             7134 ; 121  |/////////////////////////////////////////////////////////////////////////////////
                             7135 ; 122  |//  Macros
                             7136 ; 123  |/////////////////////////////////////////////////////////////////////////////////
                             7137 ; 124  |
                             7138 ; 125  |//////////////////////////////////////////
                             7139 ; 126  |// NAND-Specific Physical Media structures
                             7140 ; 127  |//////////////////////////////////////////
                             7141 ; 128  |typedef enum {
                             7142 ; 129  |  // NOTE: NandHalInit checks for zero to see if initialization needed.
                             7143 ; 130  |  // Therefore, do not use a ZERO in the typedef.
                             7144 ; 131  |  eNandTypeUnknown = 0, // use for init
                             7145 ; 132  |  eNandType1 = 1,
                             7146 ; 133  |  eNandType2 = 2,
                             7147 ; 134  |  eNandType4 = 4,
                             7148 ; 135  |  eNandType5 = 5,
                             7149 ; 136  |  eNandType6 = 6,
                             7150 ; 137  |  eNandType7 = 7
                             7151 ; 138  |} NAND_TYPE;
                             7152 ; 139  |
                             7153 ; 140  |typedef enum {
                             7154 ; 141  |  eNandLockStateFree   = 0,
                             7155 ; 142  |  eNandLockStateLocked = 1
                             7156 ; 143  |} NAND_LOCK_STATE;
                             7157 ; 144  |
                             7158 ; 145  |typedef enum {
                             7159 ; 146  |    eNandProgCmdReadID                    = 0x000090,
                             7160 ; 147  |    eNandProgCmdReadID2                   = 0x000091,
                             7161 ; 148  |    eNandProgCmdReadStatus                = 0x000070,
                             7162 ; 149  |    eNandProgCmdReset                     = 0x0000ff,
                             7163 ; 150  |    eNandProgCmdSerialDataInput           = 0x000080,   // Page Program/Cache Program
                             7164 ; 151  |    eNandProgCmdRead1                     = 0x000000,   // Read or Read for CopyBack
                             7165 ; 152  |    eNandProgCmdRead1_2ndCycle            = 0x000030,   // Second Cycle for Read (Type 2 NANDs)
                             7166 ; 153  |    eNandProgCmdReadForCopyBack_2ndCycle  = 0x000035,   // Second Cycle for Read for Copy Back
                             7167 ; 154  |    eNandProgCmdReadForCacheCopyback_2nd  = 0x00003A,
                             7168 ; 155  |    eNandProgCmdRead2                     = 0x000001,
                             7169 ; 156  |    eNandProgCmdRead3                     = 0x000050,
                             7170 ; 157  |    eNandProgCmdPageProgram               = 0x000010,   // Second cycle for wSerialDataInput for Page Program
                             7171 ; 158  |    eNandProgCmdCacheProgram              = 0x000015,   // Second cycle for wSerialDataInput for Cache Program
                             7172 ; 159  |    eNandProgCmdCopyBackProgram           = 0x000085,
                             7173 ; 160  |    eNandProgCmdCopyBack2Program          = 0x00008C,
                             7174 ; 161  |    eNandProgCmdCopyBackProgram_2ndCycle  = 0x000010,   // Second cycle for Copy Back Program
                             7175 ; 162  |    eNandProgCmdBlockErase                = 0x000060,
                             7176 ; 163  |    eNandProgCmdBlockErase_2ndCycle       = 0x0000d0,
                             7177 ; 164  |    eNandProgCmdRandomDataIn              = 0x000085,
                             7178 ; 165  |    eNandProgCmdRandomDataOut             = 0x000005,
                             7179 ; 166  |    eNandProgCmdRandomDataOut_2ndCycle    = 0x0000E0,
                             7180 ; 167  |    eNandProgCmdReadMultiPlaneStatus      = 0x000071,   // MLC MultiPlane
                             7181 ; 168  |    eNandProgCmdReadErrorStatus           = 0x000072,   // MLC Single Plane Error Status
                             7182 ; 169  |    eNandProgCmdReadMultiPlaneErrorStatus = 0x000073,   // MLC MultiPlane Error Status.
                             7183 ; 170  |    eNandProgCmdMultiPlaneWrite           = 0x000011,
                             7184 ; 171  |    eNandProgCmdStatusModeReset           = 0x00007F,
                             7185 ; 172  |    eNandProgCmdMultiPlaneRead_2ndCycle   = 0x000031,
                             7186 ; 173  |    eNandProgCmdPageDataOutput            = 0x000006,
                             7187 ; 174  |    eNandProgCmdMultiPlaneVerifyErased    = 0x0000D3,
                             7188 ; 175  |    eNandProgCmdMultiPlaneBlockErase      = 0x00ffff,   // TBD !!! Need code for this.
                             7189 ; 176  |    eNandProgCmdNone                      = 0x7FFFFF,   // invalid entry
                             7190 ; 177  |    eNandProgCmdDummyProgram              = 0x6FFFFF    // invalid entry
                             7191 ; 178  |} NAND_PROGRAM_CODES;
                             7192 ; 179  |
                             7193 ; 180  |
                             7194 ; 181  |
                             7195 ; 182  |// NAND Physical Media API functions
                             7196 ; 183  |typedef RETCODE (*P_HAL_READ_SECTOR_FUNCTION)(struct NandPhysicalMediaTag *, WORD, P_SECTOR_BUFFER);
                             7197 
                             7201 
                             7202 ; 184  |typedef RETCODE (*P_HAL_READ_SECTOR_REDUNDANT_FUNCTION)(struct NandPhysicalMediaTag *, WORD, P_SECTOR_BUFFER, BOOL);
                             7203 ; 185  |typedef RETCODE (*P_HAL_ENABLE_WRITES_FUNCTION)(WORD);
                             7204 ; 186  |typedef RETCODE (*P_HAL_DISABLE_WRITES_FUNCTION)(WORD);
                             7205 ; 187  |typedef RETCODE (*P_HAL_WRITE_SECTOR_FUNCTION)(struct NandPhysicalMediaTag *, WORD, P_SECTOR_BUFFER);
                             7206 ; 188  |typedef RETCODE (*P_HAL_WRITE_SECTOR_REDUNDANT_FUNCTION)(struct NandPhysicalMediaTag *, WORD, P_SECTOR_BUFFER);
                             7207 ; 189  |typedef RETCODE (*P_HAL_ERASE_BLOCK_FUNCTION)(struct NandPhysicalMediaTag *, WORD);
                             7208 ; 190  |typedef RETCODE (*P_HAL_ERASE_BLOCK_ASYNC_FUNCTION)(struct NandPhysicalMediaTag *, WORD);
                             7209 ; 191  |typedef RETCODE (*P_HAL_COPY_SECTORS_FUNCTION)(struct NandPhysicalMediaTag *, WORD, WORD, WORD);
                             7210 ; 192  |typedef RETCODE (*P_HAL_GET_STATUS_FUNCTION)(struct NandPhysicalMediaTag *, WORD *, WORD);
                             7211 ; 193  |typedef RETCODE (*P_HAL_SETUP_WRITE_SECTOR_FUNCTION)(struct NandPhysicalMediaTag *, WORD);
                             7212 ; 194  |typedef RETCODE (*P_HAL_SETUP_WRITE_SECTOR_REDUNDANT_FUNCTION)(struct NandPhysicalMediaTag *, WORD);
                             7213 ; 195  |typedef RETCODE (*P_HAL_SEND_SECTOR_DATA_FUNCTION)(struct NandPhysicalMediaTag *, P_SECTOR_BUFFER);
                             7214 ; 196  |typedef RETCODE (*P_HAL_SEND_PROGRAM_COMMAND_FUNCTION)(struct NandPhysicalMediaTag *, NAND_PROGRAM_CODES);
                             7215 
                             7250 
                             7251 ; 197  |typedef RETCODE (*P_HAL_GET_DMA_STATUS_FUNCTION)(struct NandPhysicalMediaTag *);
                             7252 ; 198  |typedef RETCODE (*P_HAL_LOCK_INTERFACE_PORT_FUNCTION)(void);
                             7253 ; 199  |typedef RETCODE (*P_HAL_RELEASE_INTERFACE_PORT_FUNCTION)(void);
                             7254 ; 200  |typedef RETCODE (*P_HAL_LOCK_NAND_FUNCTION)(struct NandPhysicalMediaTag *);
                             7255 ; 201  |typedef RETCODE (*P_HAL_RELEASE_NAND_FUNCTION)(struct NandPhysicalMediaTag *);
                             7256 ; 202  |typedef RETCODE (*P_HAL_START_COMPUTE_ECC_FUNCTION)(P_SECTOR_BUFFER,WORD);
                             7257 ; 203  |typedef RETCODE (*P_HAL_COMPUTE_ECC_GET_STATUS_FUNCTION)(void);
                             7258 ; 204  |typedef RETCODE (*P_HAL_CORRECT_ECC_FUNCTION)(P_SECTOR_BUFFER);
                             7259 ; 205  |typedef BOOL    (*P_BUSYDONE_CALLBACK_FUNCTION)(int, void*);
                             7260 ; 206  |typedef RETCODE (*P_HAL_MSW_SECTOR_COMMIT)(struct NandPhysicalMediaTag *);
                             7261 ; 207  |typedef RETCODE (*P_HAL_MSW_PAGE_COMMIT)(struct NandPhysicalMediaTag *);
                             7262 
                             7341 
                             7342 ; 208  |
                             7343 ; 209  |
TASKING DSP2410 assembler v1.5r1 Build 138 SN 00100122
                                                                                                                                                                                                                                                       Page  28

M:ADDR CODE           CYCLES LINE SOURCELINE
                             7344 ; 210  |typedef struct {
                             7345 ; 211  |    WORD wReadSectorCodeBank;
                             7346 ; 212  |    P_HAL_READ_SECTOR_FUNCTION pReadSector;
                             7347 ; 213  |    WORD wReadSectorRedundantCodeBank;
                             7348 ; 214  |    P_HAL_READ_SECTOR_REDUNDANT_FUNCTION pReadSectorRedundant;
                             7349 ; 215  |    WORD wGetStatusCodeBank;
                             7350 ; 216  |    P_HAL_GET_STATUS_FUNCTION pGetStatus;
                             7351 ; 217  |    WORD wEnableWritesCodeBank;
                             7352 ; 218  |    P_HAL_ENABLE_WRITES_FUNCTION pEnableWrites;
                             7353 ; 219  |    WORD wDisableWritesCodeBank;
                             7354 ; 220  |    P_HAL_DISABLE_WRITES_FUNCTION pDisableWrites;
                             7355 ; 221  |    WORD wWriteSectorCodeBank;
                             7356 ; 222  |    P_HAL_WRITE_SECTOR_FUNCTION pWriteSector;
                             7357 ; 223  |    WORD wWriteSectorRedundantCodeBank;
                             7358 ; 224  |    P_HAL_WRITE_SECTOR_REDUNDANT_FUNCTION pWriteSectorRedundant;
                             7359 ; 225  |    WORD wEraseBlockCodeBank;
                             7360 ; 226  |    P_HAL_ERASE_BLOCK_FUNCTION pEraseBlock;
                             7361 ; 227  |    WORD wEraseBlockAsyncCodeBank;
                             7362 ; 228  |    P_HAL_ERASE_BLOCK_ASYNC_FUNCTION pEraseBlockAsync;
                             7363 ; 229  |    WORD wCopySectorsCodeBank;
                             7364 ; 230  |    P_HAL_COPY_SECTORS_FUNCTION pCopySectors;
                             7365 ; 231  |    WORD wSetupWriteSectorCodeBank;
                             7366 ; 232  |    P_HAL_SETUP_WRITE_SECTOR_FUNCTION pSetupWriteSector;
                             7367 ; 233  |    WORD wSetupWriteSectorRedundantCodeBank;
                             7368 ; 234  |    P_HAL_SETUP_WRITE_SECTOR_REDUNDANT_FUNCTION pSetupWriteSectorRedundant;
                             7369 ; 235  |    WORD wSendSectorDataCodeBank;
                             7370 ; 236  |    P_HAL_SEND_SECTOR_DATA_FUNCTION pSendSectorData;
                             7371 ; 237  |    WORD wSendProgramCommandCodeBank;
                             7372 ; 238  |    P_HAL_SEND_PROGRAM_COMMAND_FUNCTION pSendProgramCommand;
                             7373 ; 239  |    WORD wStartComputeECCCodeBank;
                             7374 ; 240  |    P_HAL_START_COMPUTE_ECC_FUNCTION pStartComputeECC;
                             7375 ; 241  |    WORD wComputeECCGetStatusCodeBank;
                             7376 ; 242  |    P_HAL_COMPUTE_ECC_GET_STATUS_FUNCTION pComputeECCGetStatus;
                             7377 ; 243  |    WORD wCorrectECCCodeBank;
                             7378 ; 244  |    P_HAL_CORRECT_ECC_FUNCTION pCorrectECC;
                             7379 ; 245  |    WORD wSectorCommitBank;
                             7380 ; 246  |    P_HAL_MSW_SECTOR_COMMIT pCommitSector;
                             7381 ; 247  |    WORD wPageCommitBank;
                             7382 ; 248  |    P_HAL_MSW_PAGE_COMMIT pCommitPage;
                             7383 ; 249  |
                             7384 ; 250  |} NANDHAL_API_DESCRIPTOR, * P_NANDHAL_API_DESCRIPTOR;
                             7385 
                             7437 
                             7438 ; 251  |
                             7439 ; 252  |typedef struct {
                             7440 ; 253  |    P_NANDHAL_API_DESCRIPTOR pNandHalApi;
                             7441 ; 254  |    NAND_TYPE                NandType;
                             7442 ; 255  |
                             7443 ; 256  |    // SECTOR PARAMETERS
                             7444 ; 257  |    WORD wSectorTotalSize;              // Total sector size (Data + Redundant Area)
                             7445 ; 258  |    WORD wSectorDataSize;               // Number of Data Bytes per Page
                             7446 ; 259  |    WORD wRedundantAreaSize;            // Number of Bytes per Redundant/Spare Area
                             7447 ; 260  |    // A physical Page may contain multiple Sectors.
                             7448 ; 261  |    // It is assumed that the number or Sectors per Page is always
                             7449 ; 262  |    // a power of 2 (i.e. 1,2,4...)
                             7450 ; 263  |    // The following elements are used to help address the Sectors within a Page
                             7451 ; 264  |    WORD wSectorToPageShift;            // Number of right shifts to compute Page Num from Sector Num
                             7452 ; 265  |    WORD wSectorInPageMask;             // Mask to extract "relative sector in Page" from absolute Sector Num
                             7453 ; 266  |
                             7454 ; 267  |    // BLOCK PARAMETERS
                             7455 ; 268  |    WORD wSectorsToBlockShift;
                             7456 ; 269  |    WORD wSectorsPerBlockMask;
                             7457 ; 270  |    WORD wNumberSectorsPerBlock;
                             7458 ; 271  |    WORD wPagesPerBlock;
                             7459 ; 272  |
                             7460 ; 273  |    // DEVICE ADDRESSING PARAMETERS
                             7461 ; 274  |    WORD wNumColumnBytes;
                             7462 ; 275  |    WORD wNumRowBytes;
                             7463 ; 276  |    BOOL bSendAddressForEachSector;
                             7464 ; 277  |} NAND_PARAMETERS_DESCRIPTOR, * P_NAND_PARAMETERS_DESCRIPTOR;
                             7465 
                             7492 
                             7493 ; 278  |
                             7494 ; 279  |typedef struct NandPhysicalMediaTag{
                             7495 ; 280  |    P_NAND_PARAMETERS_DESCRIPTOR pNANDParams;
                             7496 ; 281  |    WORD                         wChipNumber;
                             7497 ; 282  |    NAND_LOCK_STATE              Lock;
                             7498 ; 283  |    BOOL                         bNANDIsBusy;              // Used for SetNANDBusy and NANDIsReady
                             7499 ; 284  |    P_BUSYDONE_CALLBACK_FUNCTION pBusyDoneCallbackFunction;// Used for SetNANDBusy and NANDIsReady
                             7500 ; 285  |    void                      *  pBusyArg;                 // Used for SetNANDBusy and NANDIsReady
                             7501 ; 286  |    WORD                         wTotalSectors;
                             7502 ; 287  |    WORD                         wTotalBlocks;
                             7503 ; 288  |    WORD                         wTotalInternalDice;       // (1/2/4/...) - number of chips pretending to be a single chip
                             7504 ; 289  |    WORD                         wBlocksPerDie;            // (wTotalBlocks / wTotalInternalDice )
                             7505 ; 290  |} NAND_PHYSICAL_MEDIA_DESCRIPTOR, * P_NAND_PHYSICAL_MEDIA_DESCRIPTOR;
                             7506 
                             7518 
                             7519 ; 291  |
                             7520 ; 292  |
                             7521 ; 293  |// These are physical parameters that can be overruled in NAND_INIT_DESCRIPTOR
                             7522 ; 294  |// by analyzing the data read during read IDs command.
                             7523 ; 295  |typedef struct {
                             7524 ; 296  |    WORD                     wTotalInternalDice;       // (1/2/4/...) - number of chips pretending to be a single chip
                             7525 ; 297  |    WORD                     wBlocksPerDie;            // (wTotalBlocks / wTotalInternalDice)
                             7526 ; 298  |
                             7527 ; 299  |} NAND_OVER_RULED_PARAMTERS;
                             7528 ; 300  |
                             7529 ; 301  |// These are used by the TypeNDescriptor files -- use for copying.
                             7530 ; 302  |typedef struct {
                             7531 ; 303  |    WORD wSectorTotalSize;       // Total sector size (Data + Redundant Area)
                             7532 ; 304  |    // A physical Page may contain multiple Sectors.
                             7533 ; 305  |    // It is assumed that the number or Sectors per Page is always
                             7534 ; 306  |    // a power of 2 (i.e. 1,2,4...)
                             7535 ; 307  |    // The following elements are used to help address the Sectors within a Page
                             7536 ; 308  |    BOOL bSendAddressForEachSector; // FALSE if sectors in Page can be DMA'd without new setup
                             7537 ; 309  |} NAND_SECTOR_DESCRIPTOR, * P_NAND_SECTOR_DESCRIPTOR;
                             7538 ; 310  |
                             7539 ; 311  |typedef struct {
                             7540 ; 312  |    WORD wNumberSectorsPerBlock;
                             7541 ; 313  |    WORD wPagesPerBlock;
                             7542 ; 314  |} NAND_BLOCK_DESCRIPTOR, * P_NAND_BLOCK_DESCRIPTOR;
                             7543 ; 315  |
                             7544 ; 316  |typedef struct {
                             7545 ; 317  |    WORD wNumColumnBytes;
                             7546 ; 318  |    WORD wNumRowBytes;
                             7547 ; 319  |} NAND_DEVICE_ADDR_DESCRIPTOR, * P_NAND_DEVICE_ADDR_DESCRIPTOR;
                             7548 
                             7561 
                             7562 ; 320  |
                             7563 ; 321  |typedef struct {
                             7564 ; 322  |    // at init -- these are copied to NAND_PARAMETERS_DESCRIPTOR
                             7565 ; 323  |    NAND_SECTOR_DESCRIPTOR NAND_TABLES_MEMSPACE *         pSectorDescriptor;
                             7566 ; 324  |    NAND_BLOCK_DESCRIPTOR  NAND_TABLES_MEMSPACE *         pBlockDescriptor;
                             7567 ; 325  |    NAND_DEVICE_ADDR_DESCRIPTOR NAND_TABLES_MEMSPACE *    pDeviceAddressingDescriptor;
                             7568 ; 326  |    P_NANDHAL_API_DESCRIPTOR pNandHalApi;
                             7569 ; 327  |    NAND_TYPE                NandType;
                             7570 ; 328  |} NAND_DESCRIPTOR_SUB_STRUCT, * P_NAND_DESCRIPTOR_SUB_STRUCT;
                             7571 
                             7585 
                             7586 ; 329  |
                             7587 ; 330  |typedef struct {
                             7588 ; 331  |    // at init -- these are copied to NAND_PARAMETERS_DESCRIPTOR
                             7589 ; 332  |    NAND_DESCRIPTOR_SUB_STRUCT NAND_TABLES_MEMSPACE * pNandDescriptorSubStruct;
                             7590 ; 333  |    // at init -- these are copied to NAND_PHYSICAL_MEDIA_DESCRIPTOR
                             7591 ; 334  |    WORD                     wTotalBlocks;
                             7592 ; 335  |    WORD                     wTotalInternalDice;       // (1/2/4/...) - number of chips pretending to be a single chip
                             7593 ; 336  |} NAND_INIT_DESCRIPTOR, * P_NAND_INIT_DESCRIPTOR;
                             7594 ; 337  |
                             7595 ; 338  |typedef union {                     // All fields in nanoseconds
                             7596 ; 339  |
                             7597 ; 340  |    // By placing this word before the bitfield it allows structure copies to be done
                             7598 ; 341  |    //  safely by assignment rather than by memcpy.
                             7599 ; 342  |
                             7600 ; 343  |    WORD initializer;
                             7601 ; 344  |
                             7602 ; 345  |    // These field lengths are arbitrary... they only need to be large enough to hold
                             7603 ; 346  |    //  the values.  Possible optimization by using enumerations rather than the actual
                             7604 ; 347  |    //  values here and teaching NANDHalSetGPFlashTiming how to interpret them.
                             7605 ; 348  |
                             7606 ; 349  |    struct {
                             7607 ; 350  |        WORD TDH    :7;                         // tWH, tREH, tDH
                             7608 ; 351  |        WORD TDS    :7;                         // tWP, tDS
                             7609 ; 352  |        WORD THOLD  :5;                         // tCLH, tCH, tALH, tDH
                             7610 ; 353  |        WORD TSU    :5;                         // tCLS, tCS, tALS
                             7611 ; 354  |    } decode;
                             7612 ; 355  |} NAND_TIMINGS;
                             7613 ; 356  |
                             7614 ; 357  |// Special types to aid in absolute vs relative block address confusion  
                             7615 ; 358  |typedef WORD REGION_RELATIVE_BLK_ADDR;  
                             7616 ; 359  |typedef WORD ABSOLUTE_BLK_ADDR;  
                             7617 ; 360  |
                             7618 ; 361  |#define MK_NAND_TIMINGS_REAL( tsu, thold, tds, tdh )             ( ((tsu   & 0x1F) << 19)   \ 
                             7619 ; 362  |                                                                 | ((thold & 0x1F) << 14)   \ 
                             7620 ; 363  |                                                                 | ((tds   & 0x7F) << 7)    \ 
                             7621 ; 364  |                                                                 |  (tdh   & 0x7F) )
                             7622 ; 365  |
                             7623 ; 366  |//!! The max value for an unsigned 7 bit number is 2^7 - 1 = 127 so don't use any value >127 for tdh & tds (macro param 3&4), else overflow & crash occurs. 
                             7624 ; 367  |//!! The max value for an unsigned 5 bit number is 2^5 - 1 = 31  so don't use any value >31  for           (macro param 1&2), else overflow & crash can occur. 
                             7625 ; 368  |
                             7626 ; 369  |#if DEBUG
                             7627 ; 370  |    //  NAND1 and NAND2 get optimized timings.  NAND3 and NAND4 get failsafe timings.
                             7628 ; 371  |    #ifdef NAND1
                             7629 ; 372  |        #define NAND_FAILSAFE_TIMINGS                   MK_NAND_TIMINGS_REAL( 0, 10, 45, 30 )
                             7630 ; 373  |        #define MK_NAND_TIMINGS(a,b,c,d)        MK_NAND_TIMINGS_REAL(a,b,c,d)
                             7631 ; 374  |    #else
                             7632 ; 375  |        #ifdef NAND2
                             7633 ; 376  |            #define NAND_FAILSAFE_TIMINGS                       MK_NAND_TIMINGS_REAL( 0, 10, 61, 48 )
                             7634 ; 377  |            #define MK_NAND_TIMINGS(a,b,c,d)        MK_NAND_TIMINGS_REAL(a,b,c,d)
                             7635 ; 378  |        #else
                             7636 ; 379  |            #ifdef NAND3
                             7637 ; 380  |                #define NAND_FAILSAFE_TIMINGS                   MK_NAND_TIMINGS_REAL( 0, 10, 82, 48 )
                             7638 ; 381  |                #define MK_NAND_TIMINGS(a,b,c,d)        NAND_FAILSAFE_TIMINGS
                             7639 ; 382  |            #else
                             7640 ; 383  |                #ifdef NAND4
                             7641 ; 384  |                    #define NAND_FAILSAFE_TIMINGS                       MK_NAND_TIMINGS_REAL( 0, 10, 82, 48 )
                             7642 ; 385  |                    #define MK_NAND_TIMINGS(a,b,c,d)        NAND_FAILSAFE_TIMINGS
                             7643 ; 386  |                #else
                             7644 ; 387  |                    // DEBUG defined but not (NAND1 NAND2 NAND3 or NAND4)
                             7645 ; 388  |                    #define NAND_FAILSAFE_TIMINGS                       MK_NAND_TIMINGS_REAL( 0, 10, 45, 30 )
                             7646 ; 389  |                    #define MK_NAND_TIMINGS(a,b,c,d)        MK_NAND_TIMINGS_REAL(a,b,c,d)
                             7647 ; 390  |                #endif
                             7648 ; 391  |            #endif
                             7649 ; 392  |        #endif
                             7650 ; 393  |    #endif
                             7651 ; 394  |#else
                             7652 ; 395  |    // Retail builds get full speed timings
                             7653 ; 396  |    // non DEBUG (RETAIL) builds (non engr board layouts) get one best case timing set.
                             7654 ; 397  |    // You may be able to reduce these values per your flash datasheet to increase performance.
                             7655 ; 398  |    #define MK_NAND_TIMINGS(a,b,c,d)        MK_NAND_TIMINGS_REAL((a),(b),(c),(d))
                             7656 ; 399  |    #define NAND_FAILSAFE_TIMINGS                       MK_NAND_TIMINGS_REAL( 0, 10, 45, 30 )
                             7657 ; 400  |#endif
                             7658 
                             7679 
                             7680 ; 401  |
                             7681 ; 402  |typedef struct {
                             7682 ; 403  |  WORD                                        DeviceManufacturerCode;   // 00:Device:Manufacturer
                             7683 ; 404  |  NAND_TIMINGS                                NandTimings;
                             7684 ; 405  |  NAND_INIT_DESCRIPTOR NAND_TABLES_MEMSPACE * pNANDInitDescriptor;
                             7685 ; 406  |} NAND_DEVICECODE_MAP, * P_NAND_DEVICECODE_MAP;
                             7686 ; 407  |
                             7687 ; 408  |typedef union
                             7688 ; 409  |{
                             7689 ; 410  |   SECTOR_BUFFER singleLargeSector[SECTOR_BUFFER_ALLOC_SIZE(LARGE_SECTOR_TOTAL_SIZE)];
                             7690 ; 411  |   SECTOR_BUFFER singleSmallSector[SECTOR_BUFFER_ALLOC_SIZE(SSFDC_SECTOR_TOTAL_SIZE)];
                             7691 ; 412  |} _X NAND_COPY_BUFFER;
                             7692 ; 413  |
                             7693 ; 414  |typedef struct
                             7694 ; 415  |{
                             7695 ; 416  |    WORD SectorDataSizeInBytes;
                             7696 ; 417  |    WORD SectorDataSizeInWords;
                             7697 ; 418  |    WORD SectorRedundantSizeInBytes;
                             7698 ; 419  |    WORD SectorRedundantSizeInWords;
                             7699 ; 420  |    WORD SectorTotalSizeInBytes;
                             7700 ; 421  |    WORD SectorTotalSizeInWords;
                             7701 ; 422  |} NAND_OUT_OF_CONTEXT_DATA;
                             7702 ; 423  |
                             7703 ; 424  |
                             7704 ; 425  |typedef enum
                             7705 ; 426  |{
                             7706 ; 427  |    WRITE_MODE_NONE,
                             7707 ; 428  |    WRITE_MODE_SINGLE,
                             7708 ; 429  |    WRITE_MODE_MULTI
                             7709 ; 430  |} NAND_WRITE_MODE;
                             7710 ; 431  |
                             7711 ; 432  |typedef struct _id_decode
                             7712 ; 433  |{
                             7713 ; 434  |    // Read ID Byte 1
                             7714 ; 435  |    WORD MakerCode              : 8;
                             7715 ; 436  |    // Read ID Byte 2
                             7716 ; 437  |    WORD DeviceCode             : 8;
                             7717 ; 438  |    // Read ID Byte 3
                             7718 ; 439  |    WORD InternalChipNumber     : 2;        // Number of die = (1 << n)
                             7719 ; 440  |    WORD CellType               : 2;        // Number of bits per memory cell = ( 1 << (n+1) ) // may 2005: 2 bits per cell for today's mlc.
                             7720 ; 441  |    WORD VendorSpecific0        : 3;
                             7721 ; 442  |    WORD CacheProgram           : 1;        // 0 == Not supported
                             7722 ; 443  |    // Read ID Byte 4
                             7723 ; 444  |    WORD PageSize               : 2;        // Page size in bytes = (1 << n) * 1024
                             7724 ; 445  |    WORD RedundantAreaSize      : 1;        // Redundant area bytes per 512 data bytes = 8 * (1 << n)
                             7725 ; 446  |    WORD Reserved0              : 1;
                             7726 ; 447  |    WORD BlockSize              : 2;        // Block size in bytes = 64 * 1024 * (1 << n)
                             7727 ; 448  |    WORD Organization           : 1;        // 0 == x8, 1 == x16
TASKING DSP2410 assembler v1.5r1 Build 138 SN 00100122
                                                                                                                                                                                                                                                       Page  29

M:ADDR CODE           CYCLES LINE SOURCELINE
                             7728 ; 449  |    WORD SamsungHSSerialAccess  : 1;        // 0 == 50/30ns, 1 == 25ns
                             7729 ; 450  |    // Read ID Byte 5
                             7730 ; 451  |    WORD VendorSpecific1        : 2;
                             7731 ; 452  |    WORD PlaneNumber            : 2;        // # of planes total (see note below) = (1 << n)
                             7732 ; 453  |    WORD PlaneSize              : 3;        // # of bytes per plane = 64 * 1024 * 1024 * (1 << n)
                             7733 ; 454  |    WORD Reserved4              : 1;
                             7734 ; 455  |    // Read ID Byte 6
                             7735 ; 456  |    WORD Reserved5              : 3;
                             7736 ; 457  |    WORD ToshibaHighSpeedMode   : 1;        // 0 == Not supported
                             7737 ; 458  |    WORD Reserved6              : 4;
                             7738 ; 459  |}t_id_decode;
                             7739 
                             7741 
                             7742 ; 460  |
                             7743 ; 461  |// Note on # of planes for all Large Page Devices (SLC and MLC)
                             7744 ; 462  |//  This field will contain the number of planes per die * the number of die on a per chip enable basis.
                             7745 ; 463  |//    Examples;  1 plane, 1 die; value = 1
                             7746 ; 464  |//      2 plane, 1 die; value = 2
                             7747 ; 465  |//      2 plane, 2 die; value = 4
                             7748 ; 466  |//      2 plane, 2 die, 2 chip enable; value = 2
                             7749 ; 467  |
                             7750 ; 468  |//  In case of multi-stacked device, the "plane number" will show the total number of planes of the packaged
                             7751 ; 469  |//  device and not the number of planes per die. (e.g. If 2 pieces of device that has 2 planes were stacked
                             7752 ; 470  |//  in a package, the plane number will show "4")
                             7753 ; 471  |
                             7754 ; 472  |///////////////////////////////////////////////////////////////////////////////
                             7755 ; 473  |// Prototypes
                             7756 ; 474  |///////////////////////////////////////////////////////////////////////////////
                             7757 ; 475  |RETCODE _reentrant Type1_GetStatus(P_NAND_PHYSICAL_MEDIA_DESCRIPTOR pNANDDescriptor, WORD * pStatus, WORD Mask);
                             7758 ; 476  |RETCODE _reentrant Type1_CopySectors(P_NAND_PHYSICAL_MEDIA_DESCRIPTOR pNANDDescriptor,
                             7759 ; 477  |                                     WORD wSourceStartSectorNum, WORD wTargetStartSectorNum, WORD wNumSectors);
                             7760 ; 478  |RETCODE _reentrant Type1_CommitSector(P_NAND_PHYSICAL_MEDIA_DESCRIPTOR pNANDDescriptor);
                             7761 ; 479  |RETCODE _reentrant Type1_CommitPage(P_NAND_PHYSICAL_MEDIA_DESCRIPTOR pNANDDescriptor);
                             7762 ; 480  |
                             7763 ; 481  |
                             7764 ; 482  |RETCODE _reentrant Type2_CopySectors(P_NAND_PHYSICAL_MEDIA_DESCRIPTOR pNANDDescriptor,
                             7765 ; 483  |                                     WORD wSourceStartSectorNum, WORD wTargetStartSectorNum, WORD wNumSectors);
                             7766 ; 484  |RETCODE _reentrant Type2_GetStatus(P_NAND_PHYSICAL_MEDIA_DESCRIPTOR pNANDDescriptor, WORD * pStatus, WORD Mask);
                             7767 ; 485  |RETCODE _reentrant Type2_CommitSector(P_NAND_PHYSICAL_MEDIA_DESCRIPTOR pNANDDescriptor);
                             7768 ; 486  |RETCODE _reentrant Type2_CommitPage(P_NAND_PHYSICAL_MEDIA_DESCRIPTOR pNANDDescriptor);
                             7769 ; 487  |
                             7770 ; 488  |
                             7771 ; 489  |RETCODE _reentrant Type4_GetStatus(P_NAND_PHYSICAL_MEDIA_DESCRIPTOR pNANDDescriptor, WORD * pStatus, WORD Mask);
                             7772 ; 490  |RETCODE _reentrant Type4_EraseBlockAsync(P_NAND_PHYSICAL_MEDIA_DESCRIPTOR pNANDDescriptor,  WORD wBlockNum);
                             7773 ; 491  |RETCODE _reentrant Type4_CopySectors(P_NAND_PHYSICAL_MEDIA_DESCRIPTOR pNANDDescriptor,
                             7774 ; 492  |                                     WORD wSourceStartSectorNum, WORD wTargetStartSectorNum, WORD wNumSectors);
                             7775 ; 493  |RETCODE _reentrant Type4_CommitSector(P_NAND_PHYSICAL_MEDIA_DESCRIPTOR pNANDDescriptor);
                             7776 ; 494  |
                             7777 ; 495  |
                             7778 ; 496  |RETCODE _reentrant Type5_CopySectors(P_NAND_PHYSICAL_MEDIA_DESCRIPTOR pNANDDescriptor,
                             7779 ; 497  |                                     WORD wSourceStartSectorNum, WORD wTargetStartSectorNum, WORD wNumSectors);
                             7780 ; 498  |
                             7781 ; 499  |
                             7782 ; 500  |void _reentrant TypeX_FlushReadCache(short);
                             7783 ; 501  |void _reentrant TypeX_ReadForCopyback( P_NAND_PHYSICAL_MEDIA_DESCRIPTOR pNANDDescriptor, WORD wSourceStartSectorNum, WORD readCommand );
                             7784 ; 502  |void _reentrant TypeX_CopybackProgram( P_NAND_PHYSICAL_MEDIA_DESCRIPTOR pNANDDescriptor, WORD wTargetStartSectorNum, WORD firstProgCmd, WORD secondProgCmd, P_SECTOR_BUFFER pBuf );
                             7785 ; 503  |RETCODE _reentrant TypeX_SetupWriteSector(P_NAND_PHYSICAL_MEDIA_DESCRIPTOR pNANDDescriptor,  WORD wSectorNum);
                             7786 ; 504  |RETCODE _reentrant TypeX_SetupWriteSectorRedundant(P_NAND_PHYSICAL_MEDIA_DESCRIPTOR pNANDDescriptor,  WORD wSectorNum);
                             7787 ; 505  |WORD _reentrant TypeX_ComputeCol(P_NAND_PHYSICAL_MEDIA_DESCRIPTOR pNANDDescriptor, WORD wByteOffset);
                             7788 ; 506  |RETCODE _reentrant TypeX_ReadSectorData(P_NAND_PHYSICAL_MEDIA_DESCRIPTOR pNANDDescriptor,
                             7789 ; 507  |                        WORD iSectorNum, P_SECTOR_BUFFER pBuf);
                             7790 ; 508  |RETCODE _reentrant TypeX_ReadSectorRedundant(P_NAND_PHYSICAL_MEDIA_DESCRIPTOR pNANDDescriptor,
                             7791 ; 509  |                         WORD iSectorNum, P_SECTOR_BUFFER pSectorBuf, BOOL crcCorrect);
                             7792 ; 510  |RETCODE _reentrant TypeX_WaitForProgramDone(
                             7793 ; 511  |                  P_NAND_PHYSICAL_MEDIA_DESCRIPTOR pNANDDescriptor);
                             7794 ; 512  |RETCODE _reentrant TypeX_SendSectorData(
                             7795 ; 513  |                  P_NAND_PHYSICAL_MEDIA_DESCRIPTOR pNANDDescriptor,
                             7796 ; 514  |                  P_SECTOR_BUFFER pBuf);
                             7797 ; 515  |RETCODE _reentrant TypeX_SendSectorRedundantArea(
                             7798 ; 516  |                  P_NAND_PHYSICAL_MEDIA_DESCRIPTOR pNANDDescriptor,
                             7799 ; 517  |                  P_SECTOR_BUFFER pBuf);
                             7800 ; 518  |RETCODE _reentrant TypeX_SendProgramCommand(
                             7801 ; 519  |                  P_NAND_PHYSICAL_MEDIA_DESCRIPTOR pNANDDescriptor,
                             7802 ; 520  |                  NAND_PROGRAM_CODES eCommandCode);
                             7803 ; 521  |RETCODE _reentrant TypeX_WriteSector(P_NAND_PHYSICAL_MEDIA_DESCRIPTOR pNANDDescriptor,
                             7804 ; 522  |                                     WORD wSectorNum, P_SECTOR_BUFFER pBuf);
                             7805 ; 523  |RETCODE _reentrant TypeX_WriteSectorRedundant(
                             7806 ; 524  |                  P_NAND_PHYSICAL_MEDIA_DESCRIPTOR pNANDDescriptor,
                             7807 ; 525  |                  WORD wSectorNum, P_SECTOR_BUFFER pBuf);
                             7808 ; 526  |RETCODE _reentrant TypeX_EraseBlock(
                             7809 ; 527  |                  P_NAND_PHYSICAL_MEDIA_DESCRIPTOR pNANDDescriptor, WORD wBlockNum);
                             7810 ; 528  |RETCODE _reentrant TypeX_EraseBlockAsync(P_NAND_PHYSICAL_MEDIA_DESCRIPTOR pNANDDescriptor,
                             7811 ; 529  |                                         WORD wBlockNum);
                             7812 ; 530  |
                             7813 ; 531  |RETCODE _reentrant NANDHALCommon_EnableWrites(WORD wWPn);
                             7814 ; 532  |RETCODE _reentrant NANDHALCommon_DisableWrites(WORD wWPn);
                             7815 ; 533  |
                             7816 ; 534  |RETCODE _reentrant NANDHalStartComputeECC_1Bit(P_SECTOR_BUFFER pCompleteSectorBuf, WORD wWhichHalf);
                             7817 ; 535  |RETCODE _reentrant NANDHalStartComputeECC_4Bit(P_SECTOR_BUFFER pCompleteSectorBuf, WORD wWhichHalf);
                             7818 ; 536  |RETCODE _reentrant NANDHalCorrectECC_1Bit(P_SECTOR_BUFFER pCompleteSectorBuf);
                             7819 ; 537  |RETCODE _reentrant NANDHalCorrectECC_4Bit(P_SECTOR_BUFFER pCompleteSectorBuf);
                             7820 ; 538  |
                             7821 ; 539  |// These functions are all direct-callable. Do not need to go through struct de-referencing.
                             7822 ; 540  |RETCODE _reentrant NANDHalLockInterfacePort(void);
                             7823 ; 541  |RETCODE _reentrant NANDHalReleaseInterfacePort(void);
                             7824 ; 542  |RETCODE _reentrant NANDHalLockNand(P_NAND_PHYSICAL_MEDIA_DESCRIPTOR pNANDDescriptor);
                             7825 ; 543  |RETCODE _reentrant NANDHalReleaseNand(P_NAND_PHYSICAL_MEDIA_DESCRIPTOR pNANDDescriptor);
                             7826 ; 544  |RETCODE _reentrant NANDHalComputeECCGetStatus(void);
                             7827 ; 545  |WORD _reentrant CRC8(WORD _X * wData, WORD wOffset, WORD wBcount);
                             7828 ; 546  |void _reentrant NandReset(P_NAND_PHYSICAL_MEDIA_DESCRIPTOR pNANDDescriptor);
                             7829 ; 547  |RETCODE _reentrant NandHalInit(P_NAND_PHYSICAL_MEDIA_DESCRIPTOR pNANDDescriptor, NAND_TIMINGS * timings );
                             7830 ; 548  |RETCODE _reentrant NANDHalSetNandBusy(P_NAND_PHYSICAL_MEDIA_DESCRIPTOR pNANDDescriptor,
                             7831 ; 549  |                                      BOOL (* pCallbackFun)(int iStatus, void * pObj), void * pArg);
                             7832 ; 550  |BOOL _reentrant bNANDHalNandIsReady(P_NAND_PHYSICAL_MEDIA_DESCRIPTOR pNANDDescriptor);
                             7833 ; 551  |RETCODE _reentrant NANDHalWaitForAsync(P_NAND_PHYSICAL_MEDIA_DESCRIPTOR pNANDDescriptor);
                             7834 ; 552  |RETCODE _reentrant HALMarkBlockBadInRA(
                             7835 ; 553  |    P_NAND_PHYSICAL_MEDIA_DESCRIPTOR pNANDDescriptor,
                             7836 
                             7838 
                             7839 ; 554  |    ABSOLUTE_BLK_ADDR wBlockAddr);
                             7840 ; 555  |RETCODE _reentrant NANDHilInit(WORD wDeviceNum);
                             7841 ; 556  |RETCODE _reentrant NANDHalWaitForTrueReady(P_NAND_PHYSICAL_MEDIA_DESCRIPTOR pNANDDescriptor, WORD * pStatus);
                             7842 ; 557  |RETCODE _reentrant NANDHalWaitForCacheReady(P_NAND_PHYSICAL_MEDIA_DESCRIPTOR pNANDDescriptor, WORD * pStatus);
                             7843 ; 558  |void _reentrant NANDHalDblChkStatus(P_NAND_PHYSICAL_MEDIA_DESCRIPTOR pNANDDescriptor, WORD wMask, WORD *pwStatus);
                             7844 ; 559  |RETCODE _reentrant NANDHalSetGPFlashTiming( NAND_TIMINGS const * pNT );
                             7845 
                             7847 
                             7848 ; 560  |///////////////////////////////////////////////////////////////////////////////
                             7849 ; 561  |// Externs
                             7850 ; 562  |///////////////////////////////////////////////////////////////////////////////
                             7851 ; 563  |extern NANDHAL_MEM NANDHAL_API_DESCRIPTOR Type1_NANDHALApiDescriptor;
                             7852 ; 564  |extern NANDHAL_MEM NANDHAL_API_DESCRIPTOR Type2_NANDHALApiDescriptor;
                             7853 ; 565  |extern NANDHAL_MEM NANDHAL_API_DESCRIPTOR Type4_NANDHALApiDescriptor;
                             7854 ; 566  |extern NANDHAL_MEM NANDHAL_API_DESCRIPTOR Type5_NANDHALApiDescriptor;
                             7855 ; 567  |extern NANDHAL_MEM WORD g_iCachedPageNumInNAND[];
                             7856 ; 568  |#define INVALID_SECTOR_ADDRESS     (0xFFFFF0) // FFFFF0 is a dummy value intended to be an invalid sector address
                             7857 
                             7864 
                             7865 ; 569  |
                             7866 ; 570  |extern NAND_COPY_BUFFER wCopyBuffer;
                             7867 
                             7876 
                             7877 ; 571  |
                             7878 ; 572  |extern NAND_OUT_OF_CONTEXT_DATA g_NandAuxData;
                             7879 ; 573  |//extern NAND_WRITE_MODE g_WriteMode;  // can enable this line later. sdk 2.610 has it. 
                             7880 ; 574  |extern WORD g_maker_code;
                             7881 ; 575  |extern WORD g_CellType;
                             7882 ; 576  |extern WORD g_VendorSpecific1;
                             7883 ; 577  |extern WORD g_device_code;
                             7884 
                             7925 
                             7926 ; 578  |
                             7927 ; 579  |extern t_id_decode SECTOR_BUFFER_MEM * pReadIDDecode;
                             7928 ; 580  |#if 1 // TOVERIFY2: 
                             7929 ; 581  |///////////////////////////////////////////////////////////////////////////////
                             7930 ; 582  |// Macros
                             7931 ; 583  |///////////////////////////////////////////////////////////////////////////////
                             7932 ; 584  |//On NAND4 builds, if less than 4 Nands are used, then the ID structure gets overwritten with garbage
                             7933 ; 585  |//( zeros?),whenever the empty slots are probed. But we need to preserve the Maker code
                             7934 ; 586  |//for Hynix and ST Micro Nands.
                             7935 ; 587  |#define _nand_hal_preserve_data();\ 
                             7936 ; 588  |{                                          \ 
                             7937 ; 589  |  g_maker_code = pReadIDDecode->MakerCode; \ 
                             7938 ; 590  |  g_CellType = pReadIDDecode->CellType; \ 
                             7939 ; 591  |  g_device_code = pReadIDDecode->DeviceCode;\ 
                             7940 ; 592  |  g_VendorSpecific1 = pReadIDDecode->VendorSpecific1; \ 
                             7941 ; 593  |} // cell type backed up to glob so it's not lost during 2nd call to DetermineNandType in a multi CE present case. We call that > once only when >1 CE present.
                             7942 ; 594  |#else // old ver
                             7943 ; 595  |extern WORD NANDHAL_MEM wID1;
                             7944 ; 596  |//On NAND4 builds, if less than 4 Nands are used, then the ID structure gets overwritten with garbage 
                             7945 ; 597  |//( zeros?),whenever the empty slots are probed. But we need to preserve the Maker code and cell type
                             7946 ; 598  |//for Hynix and ST Micro and other Nands. 
                             7947 ; 599  |#define _nand_hal_preserve_data();\ 
                             7948 ; 600  |{                                          \ 
                             7949 ; 601  |  g_maker_code = (wID1 & MakerIDMask); \ 
                             7950 ; 602  |  //g_CellType = pReadIDDecode->CellType; \  /* should save this and uncomment this line too if you ever revert to this old way */
                             7951 ; 603  |  //g_VendorSpecific1 = pReadIDDecode->VendorSpecific1; \  /* should save this and uncomment this line too if you ever revert to this old way */
                             7952 ; 604  |}
                             7953 ; 605  |#endif
                             7954 ; 606  |
                             7955 ; 607  |#endif // #ifndef _NANDHAL_H
                             7956 ; 608  |
                             7957 ; 609  |
                             7958 
                             7960 
                             7961 ; 26   |#include "sectordef.h"
                             7962 
                             7964 
                             7965 ; 1    |////////////////////////////////////////////////////////////////////////////////
                             7966 ; 2    |// Copyright(C) SigmaTel, Inc. 2003-2005
                             7967 ; 3    |//
                             7968 ; 4    |// Filename:     sectordef.h
                             7969 ; 5    |// Description:  Contains structs, prototypes, equates for the NAND Hal & other 
                             7970 ; 6    |//               routines.
                             7971 ; 7    |////////////////////////////////////////////////////////////////////////////////
                             7972 ; 8    |
                             7973 ; 9    |#ifndef _SECTORDEF_H
                             7974 ; 10   |#define _SECTORDEF_H
                             7975 ; 11   |
                             7976 ; 12   |    #define RAM_SECTOR_TOTAL_SIZE                 (528)
                             7977 ; 13   |    #define RAM_SECTOR_DATA_SIZE                  (512)
                             7978 ; 14   |    #define RAM_SECTOR_REDUNDANT_SIZE             (16)
                             7979 ; 15   |
                             7980 ; 16   |
                             7981 ; 17   |    #define MMC_SECTOR_TOTAL_SIZE                 (528)
                             7982 ; 18   |    #define MMC_SECTOR_DATA_SIZE                  (512)
                             7983 ; 19   |    #define MMC_SECTOR_REDUNDANT_SIZE             (16)
                             7984 ; 20   |
                             7985 ; 21   |
                             7986 ; 22   |    #define SSFDC_SECTOR_TOTAL_SIZE                 (528)
                             7987 ; 23   |    #define SSFDC_SECTOR_DATA_SIZE                  (512)
                             7988 ; 24   |    #define SSFDC_SECTOR_REDUNDANT_SIZE             (16)
                             7989 ; 25   |
                             7990 ; 26   | // Define large sector macros as small ones so sdk3.x fits in ram and mtp with small 
                             7991 ; 27   | // sector flash gets the performance boosts from optimized nand timings, etc. 
                             7992 ; 28   | // TOVERIFY: Comment out the next macro def when you want large sector support as 
                             7993 ; 29   | // in sdk2.6 and you can find the free data RAM. Or uncomment if you want to save data ram
                             7994 ; 30   | // and only support 512 byte sectors and their associated flash types. 
                             7995 ; 31   |//#define LARGE_SECTOR_DEFS_AS_SMALL_SECTOR
                             7996 ; 32   |#ifdef LARGE_SECTOR_DEFS_AS_SMALL_SECTOR 
                             7997 ; 33   |    #define LARGE_SECTOR_TOTAL_SIZE                 (528)
                             7998 ; 34   |    #define LARGE_SECTOR_DATA_SIZE                  (512)
                             7999 ; 35   |    #define LARGE_SECTOR_REDUNDANT_SIZE             (16)
                             8000 ; 36   |#else
                             8001 ; 37   |    // Real large sector defines to use when large sector flash support is desired.
                             8002 ; 38   |    #define LARGE_SECTOR_TOTAL_SIZE                 (2112)
                             8003 ; 39   |    #define LARGE_SECTOR_DATA_SIZE                  (2048)
                             8004 ; 40   |    #define LARGE_SECTOR_REDUNDANT_SIZE             (64)
                             8005 ; 41   |#endif
                             8006 ; 42   |    
                             8007 ; 43   |    // round up to the nearest WORD, then add one to pad for the ECC DMA bug
                             8008 ; 44   |    #define SECTOR_BUFFER_ALLOC_SIZE(a)             (((a+2)/3)+1)
                             8009 ; 45   |
                             8010 ; 46   |
                             8011 ; 47   |    // These are moved here from chkdsk.h     TOVERIFY. 
                             8012 ; 48   |    #define SEC_512_BYTES_PER_SECTOR                        SSFDC_SECTOR_DATA_SIZE
                             8013 ; 49   |        #define SEC_512_BYTES_TOTAL_SIZE                                                SSFDC_SECTOR_TOTAL_SIZE
                             8014 ; 50   |        #define SEC_512_WORDS_TOTAL_SIZE                                                176
                             8015 ; 51   |    #define SEC_512_BYTES_CLUSTER_ENTRY_PER_SECTOR_SHIFT    12
                             8016 ; 52   |    #define SEC_512_BYTES_DIR_REC_PER_SECTOR                16
                             8017 ; 53   |    #define SEC_512_BYTES_WORDS_PER_SECTOR                  177
                             8018 ; 54   |    #define SEC_2K_BYTES_PER_SECTOR                         LARGE_SECTOR_DATA_SIZE
                             8019 ; 55   |        #define SEC_2K_BYTES_TOTAL_SIZE                                                 LARGE_SECTOR_TOTAL_SIZE
                             8020 ; 56   |    #define SEC_2K_BYTES_CLUSTER_ENTRY_PER_SECTOR_SHIFT     12
                             8021 ; 57   |    #define SEC_2K_BYTES_DIR_REC_PER_SECTOR                 64
                             8022 ; 58   |    #define SEC_2K_BYTES_WORDS_PER_SECTOR                   705
                             8023 ; 59   |    #define SEC_2K_BYTES_WORDS_PER_SECTOR_NO_RA             683
                             8024 ; 60   |
                             8025 ; 61   |    // Next 5 lines imported from nandsystemdrivewritesector.c
                             8026 ; 62   |    #define RA_ATTR_MEMORY_OFFSET           682
                             8027 ; 63   |    #define NUMBER_OF_WORDS_IN_512BYTES     171
                             8028 ; 64   |    #define NUM_ECC_DATA_IN_WORDS           3
                             8029 ; 65   |    #define SEC_512_WORD1_RA_SWAP           171
                             8030 ; 66   |    #define SEC_512_WORD2_RA_SWAP           173
                             8031 ; 67   |
                             8032 ; 68   |#endif  // _SECTORDEF_H
                             8033 ; 69   |
                             8034 
                             8036 
                             8037 ; 27   |
                             8038 ; 28   |#ifdef MTP_BUILD
TASKING DSP2410 assembler v1.5r1 Build 138 SN 00100122
                                                                                                                                                                                                                                                       Page  30

M:ADDR CODE           CYCLES LINE SOURCELINE
                             8039 ; 29   |#include "mtp.h"
                             8040 ; 30   |#include "usbmscMtpSwitch.h"
                             8041 ; 31   |#endif
                             8042 ; 32   |
                             8043 ; 33   |#ifdef MMC
                             8044 ; 34   |  #include "MMCddi.h"
                             8045 
                             8047 
                             8048 ; 1    |////////////////////////////////////////////////////////////////////////////////
                             8049 ; 2    |// Copyright(C) SigmaTel, Inc. 2003
                             8050 ; 3    |//
                             8051 ; 4    |// Filename: MMCDdi.h
                             8052 ; 5    |// Description: 
                             8053 ; 6    |////////////////////////////////////////////////////////////////////////////////
                             8054 ; 7    |
                             8055 ; 8    |#ifndef _MMCDDI_H
                             8056 ; 9    |#define _MMCDDI_H
                             8057 ; 10   |
                             8058 ; 11   |///////////////////////////////////////////////////////////////////////////////
                             8059 ; 12   |// Includes
                             8060 ; 13   |///////////////////////////////////////////////////////////////////////////////
                             8061 ; 14   |
                             8062 ; 15   |#include "ddildl_internal.h"
                             8063 
                             8065 
                             8066 ; 1    |////////////////////////////////////////////////////////////////////////////////
                             8067 ; 2    |// Copyright(C) SigmaTel, Inc. 2003
                             8068 ; 3    |//
                             8069 ; 4    |// Filename: ddildl_internal.h
                             8070 ; 5    |// Description: 
                             8071 ; 6    |////////////////////////////////////////////////////////////////////////////////
                             8072 ; 7    |#ifndef _DDILDL_INTERNAL_H
                             8073 ; 8    |#define _DDILDL_INTERNAL_H
                             8074 ; 9    |
                             8075 ; 10   |#include "ddildl.h"
                             8076 
                             8078 
                             8079 ; 1    |////////////////////////////////////////////////////////////////////////////////
                             8080 ; 2    |// Copyright(C) SigmaTel, Inc. 2003-2005
                             8081 ; 3    |//
                             8082 ; 4    |// Filename: ddildl.h
                             8083 ; 5    |// Description: 
                             8084 ; 6    |////////////////////////////////////////////////////////////////////////////////
                             8085 ; 7    |
                             8086 ; 8    |#ifndef _DDILDL_H
                             8087 ; 9    |#define _DDILDL_H
                             8088 ; 10   |
                             8089 ; 11   |///////////////////////////////////////////////////////////////////////////////
                             8090 ; 12   |// Includes
                             8091 ; 13   |///////////////////////////////////////////////////////////////////////////////
                             8092 ; 14   |
                             8093 ; 15   |///////////////////////////////////////////////////////////////////////////////
                             8094 ; 16   |// Definitions
                             8095 ; 17   |///////////////////////////////////////////////////////////////////////////////
                             8096 ; 18   |// version before march 11 2005 
                             8097 ; 19   |//#ifdef PLAYER_BUILD
                             8098 ; 20   |//#define MAX_MEDIA_TABLE_ENTRIES                12
                             8099 ; 21   |//#else
                             8100 ; 22   |//#define MAX_MEDIA_TABLE_ENTRIES                14
                             8101 ; 23   |//#endif
                             8102 ; 24   |// Mar 14 2007: Only requires the maximum number of drives in one media
                             8103 ; 25   |// NAND:(2 data drives + 9 system drives + 1 extra system drive in future) = 12
                             8104 ; 26   |#define MAX_MEDIA_TABLE_ENTRIES                12
                             8105 ; 27   |
                             8106 ; 28   |#define MAX_LOGICAL_MEDIA                       2
                             8107 ; 29   |
                             8108 ; 30   |//
                             8109 ; 31   |// WARNING
                             8110 ; 32   |// The maximum number of drives needed for player, mtp and usbmsc 
                             8111 ; 33   |// builds is currently the player build which has the largest number of drives = 12(NAND)+1(MMC).
                             8112 ; 34   |// Private lib references to this change to use a ddiproject global that's init per project 
                             8113 ; 35   |// instead so those plib references are no longer fixed at lib compile time. March 1 2005
                             8114 ; 36   |#ifdef PLAYER_BUILD
                             8115 ; 37   |#define MAX_LOGICAL_DRIVES                      13
                             8116 ; 38   |#else // MTP_BUILD & USBMSC/updater need support for the ram drive used in msc
                             8117 ; 39   |/********************************************************************************
                             8118 ; 40   | * We have to define 2 more than the actually size for usbmsc case
                             8119 ; 41   | * We have totally 9 system drives, 3 data drives, 1 extra system drive in future, 
                             8120 ; 42   | * so the total number is 13. The max will be 13 + 2 = 15
                             8121 ; 43   | ********************************************************************************/
                             8122 ; 44   |#define MAX_LOGICAL_DRIVES                      15
                             8123 ; 45   |#endif
                             8124 ; 46   |
                             8125 ; 47   |#define DDI_MAGIC_NUMBER                        0xADEADE
                             8126 ; 48   |
                             8127 ; 49   |///////////////////////////////////////////////////////////////////////////////
                             8128 ; 50   |// Error codes
                             8129 ; 51   |///////////////////////////////////////////////////////////////////////////////
                             8130 ; 52   |
                             8131 ; 53   |#include "errors.h"
                             8132 
                             8134 
                             8135 ; 1    |/////////////////////////////////////////////////////////////////////////////////
                             8136 ; 2    |//// Copyright(C) SigmaTel, Inc. 2003
                             8137 ; 3    |////
                             8138 ; 4    |//// Filename: errors.inc
                             8139 ; 5    |//// Description: 
                             8140 ; 6    |/////////////////////////////////////////////////////////////////////////////////
                             8141 ; 7    |
                             8142 ; 8    |#if (!defined(ERRORS_INC))
                             8143 ; 9    |#define ERRORS_INC 1
                             8144 ; 10   |
                             8145 ; 11   |#define LDRIVE_ERROR_INVALID_DRIVE_NUMBER 0x0101
                             8146 ; 12   |#define LDRIVE_ERROR_NOT_INITIALIZED 0x0102
                             8147 ; 13   |#define LDRIVE_ERROR_HARDWARE_FAILURE 0x0103
                             8148 ; 14   |#define LDRIVE_ERROR_INVALID_DRIVE_TYPE 0x0104
                             8149 ; 15   |#define LDRIVE_ERROR_INVALID_INFO_TYPE 0x0105
                             8150 ; 16   |#define LDRIVE_ERROR_SECTOR_OUT_OF_BOUNDS 0x0106
                             8151 ; 17   |#define LDRIVE_ERROR_WRITE_FAILURE 0x0107
                             8152 ; 18   |#define LDRIVE_ERROR_WRITE_PROTECTED 0x0108
                             8153 ; 19   |#define LDRIVE_ERROR_MULTI_WRITE_IN_PROGRESS 0x0109
                             8154 ; 20   |#define LDRIVE_ERROR_MUST_HAVE_MORE_THAN_ONE_SECTOR 0x010A
                             8155 ; 21   |#define LDRIVE_ERROR_MULTI_WRITE_NOT_SETUP 0x010B
                             8156 ; 22   |// The WRITE_ABORT Error is returned when the system drive detects a bad
                             8157 ; 23   |// block in the device. The block was marked bad and tables updated.
                             8158 ; 24   |// The application must start over.
                             8159 ; 25   |#define LDRIVE_ERROR_WRITE_ABORT 0x010C
                             8160 ; 26   |#define LDRIVE_ERROR_READ_FAILURE 0x010D
                             8161 ; 27   |#define LDRIVE_ERROR_MEDIA_NOT_ALLOCATED 0x010E
                             8162 ; 28   |#define LDRIVE_ERROR_LOW_LEVEL_MEDIA_FORMAT_REQUIRED 0x010F
                             8163 ; 29   |
                             8164 ; 30   |#define LMEDIA_ERROR_HARDWARE_FAILURE 0x0200
                             8165 ; 31   |#define LMEDIA_ERROR_INVALID_MEDIA_NUMBER 0x0201
                             8166 ; 32   |#define LMEDIA_ERROR_MEDIA_NOT_INITIALIZED 0x0202
                             8167 ; 33   |#define LMEDIA_ERROR_MEDIA_NOT_DISCOVERED 0x0203
                             8168 ; 34   |#define LMEDIA_ERROR_INVALID_MEDIA_INFO_TYPE 0x0204
                             8169 ; 35   |#define LMEDIA_ERROR_ALLOCATION_TO_LARGE 0x0205
                             8170 ; 36   |#define LMEDIA_ERROR_MEDIA_NOT_ERASED 0x0206
                             8171 ; 37   |#define LMEDIA_ERROR_MEDIA_ERASED 0x0207
                             8172 ; 38   |//Specific to NAND
                             8173 ; 39   |#define LMEDIA_ERROR_NO_REGIONS_IN_MEDIA 0x0208     
                             8174 ; 40   |#define LMEDIA_ERROR_DRIVES_MAX_OUT 0x0209 
                             8175 ; 41   |#define LMEDIA_ERROR_MEDIA_WRITE_PROTECTED 0x020A
                             8176 ; 42   |#define LMEDIA_ERROR_INVALID_INFO_TYPE 0x020B
                             8177 ; 43   |#define LMEDIA_ERROR_BAD_BLOCKS_MAX_OUT 0x020C
                             8178 ; 44   |#define LMEDIA_ERROR_NOT_ALLOCATED 0x020D
                             8179 ; 45   |
                             8180 ; 46   |#define LMEDIA_ERROR_DRIVE_TYPE_NOT_SUPPORTED 0x0210
                             8181 ; 47   |
                             8182 ; 48   |#define NAND_ERROR_WRITE_PHYS_SECTOR_PROGRAM_FAILED 0x0301
                             8183 ; 49   |#define ERROR_MULTI_WRITE_SECTOR_FIFO_OVERFLOW 0x0302
                             8184 ; 50   |#define ERROR_MULTI_WRITE_SECTOR_FIFO_UNDERFLOW 0x0303
                             8185 ; 51   |
                             8186 ; 52   |#define NAND_DATA_DRIVE_ERROR_LOGICAL_SECTOR_OUT_OF_BOUNDS 0x0401
                             8187 ; 53   |#define NAND_DATA_DRIVE_ERROR_RBLOCK_NOT_FOUND 0x0402
                             8188 ; 54   |#define NAND_DATA_DRIVE_ERROR_NO_FREE_RBLOCKS 0x0403
                             8189 ; 55   |#define NAND_DATA_DRIVE_ERROR_USECTOR_LOOKUP_INTERNAL_1 0x0404
                             8190 ; 56   |#define NAND_DATA_DRIVE_SECTOR_NOT_UPDATED 0x0405
                             8191 ; 57   |#define NAND_DATA_DRIVE_ERROR_CANT_RECYCLE_USECTOR_MAP 0x0406
                             8192 ; 58   |#define NAND_DATA_DRIVE_ERROR_UBLOCK_LBAS_INCONSISTENT 0x0407
                             8193 ; 59   |#define NAND_DATA_DRIVE_ERROR_HSECTORIDX_IN_UBLOCK_OUT_OF_RANGE 0x0408
                             8194 ; 60   |#define NAND_DATA_DRIVE_ERROR_CANT_RECYCLE_UBLOCK 0x0409
                             8195 ; 61   |#define NAND_DATA_DRIVE_ERROR_BBTABLE_FULL 0x040A
                             8196 ; 62   |#define NAND_DATA_DRIVE_ERROR_UPDATE_NOT_OPEN 0x040B
                             8197 ; 63   |#define NAND_DATA_DRIVE_ERROR_ADD_USECTOR_INTERNAL_1 0x040C
                             8198 ; 64   |#define NAND_DATA_DRIVE_ERROR_CANT_GET_ERASED_UBLOCK 0x040D
                             8199 ; 65   |#define NAND_DATA_DRIVE_ERROR_NO_ERASED_UBLOCKS 0x040E
                             8200 ; 66   |#define NAND_DATA_DRIVE_ERROR_CANT_ERASE_FREE_UBLOCK 0x040F
                             8201 ; 67   |#define NAND_DATA_DRIVE_ERROR_KILLUSECTOR_INTERNAL_1 0x0410
                             8202 ; 68   |#define NAND_DATA_DRIVE_ERROR_KILLUSECTOR_INTERNAL_2 0x0411
                             8203 ; 69   |#define NAND_DATA_DRIVE_RETURN_BLOCK_NOT_UPDATED 0x0412
                             8204 ; 70   |#define NAND_DATA_DRIVE_ERROR_UBLOCK_PROTECT_TABLE_FULL 0x0413
                             8205 ; 71   |#define NAND_DATA_DRIVE_ERROR_UBLOCK_ALREADY_PROTECTED 0x0414
                             8206 ; 72   |#define NAND_DATA_DRIVE_ERROR_UBLOCK_NOT_PROTECTED 0x0415
                             8207 ; 73   |#define NAND_DATA_DRIVE_ERROR_UBLOCKPROTECT_INTERNAL_1 0x0416
                             8208 ; 74   |#define NAND_DATA_DRIVE_ERROR_RECOVERUBLOCK_INTERNAL_1 0x0417
                             8209 ; 75   |#define NAND_DATA_DRIVE_ERROR_RECOVERUBLOCK_INTERNAL_2 0x0418
                             8210 ; 76   |#define NAND_DATA_DRIVE_ERROR_UBLOCK_NOT_IN_UTABLE 0x0419
                             8211 ; 77   |#define NAND_DATA_DRIVE_ERROR_CANT_ALLOCATE_USECTORS_MAPS 0x041A
                             8212 ; 78   |#define NAND_DATA_DRIVE_ERROR_CANT_INIT_DATA_REGIONS_LIST 0x041B
                             8213 ; 79   |#define NAND_DATA_DRIVE_ERROR_TOO_MANY_UBLOCKS_IN_CONFIG 0x041C
                             8214 ; 80   |#define NAND_DATA_DRIVE_ERROR_USECTOR_INDEX_IS_NOT_NEXT 0x041D
                             8215 ; 81   |#define NAND_DATA_DRIVE_ERROR_USECTOR_ALREADY_UPDATED 0x041E
                             8216 ; 82   |#define NAND_DATA_DRIVE_ERROR_BgGC_USECTOR_ERASE_TIMEDOUT 0x041F
                             8217 ; 83   |#define NAND_DATA_DRIVE_ERROR_BgGC_HSECTOR_COPY_TIMEDOUT 0x0420
                             8218 ; 84   |#define NAND_DATA_DRIVE_ERROR_BgGC_ALREADY_ENABLED 0x0421
                             8219 ; 85   |#define NAND_DATA_DRIVE_ERROR_BgGC_HSECTOR_ERASE_TIMEDOUT 0x0422
                             8220 ; 86   |#define NAND_DATA_DRIVE_ERROR_BgGC_SECTOR_NOT_UPDATED 0x0423
                             8221 ; 87   |#define NAND_DATA_DRIVE_ERROR_NO_STALE_UBLOCKS 0x0424
                             8222 ; 88   |#define NAND_DATA_DRIVE_ERROR_NAND_IS_READY_TIMEOUT 0x0425
                             8223 ; 89   |#define NAND_DATA_DRIVE_ERROR_CANT_CLOSE_UPDATE 0x0426
                             8224 ; 90   |
                             8225 ; 91   |#define NAND_DATA_DRIVE_ERROR_CMW_S0_FETCH_FAILED 0x042C
                             8226 ; 92   |#define NAND_DATA_DRIVE_ERROR_CMW_S1_FETCH_FAILED 0x042D
                             8227 ; 93   |#define NAND_DATA_DRIVE_ERROR_CMW_S2_1_FETCH_FAILED 0x042E
                             8228 ; 94   |#define NAND_DATA_DRIVE_ERROR_CMW_S2_2_FETCH_FAILED 0x042F
                             8229 ; 95   |#define NAND_DATA_DRIVE_ERROR_CMW_S3_1_FETCH_FAILED 0x0430
                             8230 ; 96   |#define NAND_DATA_DRIVE_ERROR_CMW_S3_2_FETCH_FAILED 0x0431
                             8231 ; 97   |#define NAND_DATA_DRIVE_ERROR_CMW_S4_1_FETCH_FAILED 0x0432
                             8232 ; 98   |#define NAND_DATA_DRIVE_ERROR_CMW_S4_2_FETCH_FAILED 0x0433
                             8233 ; 99   |#define NAND_DATA_DRIVE_ERROR_CMW_S5_FETCH_FAILED 0x0434
                             8234 ; 100  |#define NAND_DATA_DRIVE_ERROR_CMW_S0_ECC_TIMEOUT 0x0435
                             8235 ; 101  |#define NAND_DATA_DRIVE_ERROR_CMW_S2_ECC_TIMEOUT 0x0436
                             8236 ; 102  |#define NAND_DATA_DRIVE_ERROR_CMW_S3_ECC_TIMEOUT 0x0437
                             8237 ; 103  |#define NAND_DATA_DRIVE_ERROR_CMW_S4_ECC_TIMEOUT 0x0438
                             8238 ; 104  |#define NAND_DATA_DRIVE_ERROR_CMW_S5_ECC_TIMEOUT 0x0439
                             8239 ; 105  |#define NAND_DATA_DRIVE_ERROR_CMW_WRITE_FAILED 0x043A
                             8240 ; 106  |#define NAND_DATA_DRIVE_ERROR_CMW_RELEASE_FAILED 0x043B
                             8241 ; 107  |
                             8242 ; 108  |#define NAND_DATA_DRIVE_ERROR_INVALID_LOGICAL_SECTOR 0x0427
                             8243 ; 109  |#define NAND_DATA_DRIVE_ERROR_INVALID_RELATIVE_SECTOR 0x0428
                             8244 ; 110  |#define NAND_DATA_DRIVE_ERROR_UBLOCK_IS_EMPTY 0x0429
                             8245 ; 111  |#define NAND_DATA_DRIVE_ERROR_USECTOR_MAP_IS_BAD 0x042A
                             8246 ; 112  |#define NAND_DATA_DRIVE_ERROR_TOO_MANY_BLOCK_RECOVERIES 0x042B
                             8247 ; 113  |
                             8248 ; 114  |// indicates that during the NandHalInit, the NandType did not
                             8249 ; 115  |// match the previously initialized Nand chip type.
                             8250 ; 116  |#define NANDHAL_ERROR_NANDTYPE_MISMATCH 0x0500 
                             8251 ; 117  |#define NANDHAL_ERROR_LOOKUP_ID_FAILED 0x0501
                             8252 ; 118  |// Errors from calling HIL functions
                             8253 ; 119  |#define NANDHAL_ERROR_INIT_PORT 0x0502
                             8254 ; 120  |#define NANDHAL_ERROR_WRITE_PORT_CMD 0x0503
                             8255 ; 121  |#define NANDHAL_ERROR_WRITE_PORT_ADDR 0x0504
                             8256 ; 122  |#define NANDHAL_ERROR_READ_PORT_DATA 0x0505
                             8257 ; 123  |#define NANDHAL_ERROR_WAIT_FOR_READY_PORT 0x0506
                             8258 ; 124  |#define NANDHAL_ERROR_POWER_UP_FLASH_PADS 0x0507
                             8259 ; 125  |#define NANDHAL_ERROR_TERMINATE_PORT 0x0508
                             8260 ; 126  |#define NANDHAL_ERROR_LOCKPORT_TIMEOUT 0x0509
                             8261 ; 127  |#define NANDHAL_ERROR_LOCKNAND_TIMEOUT 0x050A
                             8262 ; 128  |// for 3410 build
                             8263 ; 129  |#define NANDHAL_ERROR_LOCKPORT_LOCKED 0x050B
                             8264 ; 130  |// for 3410 build
                             8265 ; 131  |#define NANDHAL_ERROR_LOCKNAND_LOCKED 0x050C
                             8266 ; 132  |#define NANDHAL_ERROR_WRITE_DATA_PORT 0x050D
                             8267 ; 133  |
                             8268 ; 134  |// indicates that the GetStatus returned a FAIL
                             8269 ; 135  |#define NANDHAL_ERROR_GETSTATUS_FAILED 0x050E
                             8270 ; 136  |#define NANDHAL_ERROR_WRITE_FAILED 0x050F
                             8271 ; 137  |#define NANDHAL_ERROR_READ_FAILED 0x0510
                             8272 ; 138  |#define NANDHAL_ERROR_READID1_FAILED 0x0511
                             8273 ; 139  |#define NANDHAL_ERROR_READID2_FAILED 0x0512
                             8274 ; 140  |#define NANDHAL_ERROR_READIDEXT_FAILED 0x0513
                             8275 ; 141  |// indicates the NAND was already BUSY
                             8276 ; 142  |#define NANDHAL_ERROR_SETNANDBUSY_FAILED 0x0514
                             8277 ; 143  |#define NANDHAL_ERROR_ASYNCWAIT_CALLBACK_ERR 0x0515
                             8278 ; 144  |// ECC Error Codes
                             8279 ; 145  |// ECC Computation has successfully completed
                             8280 ; 146  |#define COMPUTE_ECC_SUCCESS 0         
                             8281 ; 147  |// ECC computation still busy
                             8282 ; 148  |#define COMPUTE_ECC_NOT_DONE 0x0516
                             8283 ; 149  |// timed out while waiting on object
                             8284 ; 150  |#define NANDHAL_ERROR_LOCKECC_TIMEOUT 0x0517
                             8285 ; 151  |// flag already set for SDK2.4 lock
                             8286 ; 152  |#define NANDHAL_ERROR_LOCKECC_LOCKED 0x0518
                             8287 ; 153  |
                             8288 ; 154  |#define NANDHAL_ECC_NOERROR 0
                             8289 ; 155  |// SKIP 0519-051B for space optimization in ECC calculate functions
                             8290 ; 156  |#define NANDHAL_ECC_ERROR_FIXED 0x051C
                             8291 ; 157  |#define NANDHAL_ECC_ERROR_FIXED_REWRITE_SECTOR 0x051D
                             8292 ; 158  |#define NANDHAL_ECC_FIX_FAILED 0x051E
                             8293 ; 159  |#define NANDHAL_ECC_ERROR_FIXED_REWRITE_FAILED 0x051F
TASKING DSP2410 assembler v1.5r1 Build 138 SN 00100122
                                                                                                                                                                                                                                                       Page  31

M:ADDR CODE           CYCLES LINE SOURCELINE
                             8294 ; 160  |
                             8295 ; 161  |// MMC Errors
                             8296 ; 162  |#define MMC_MEDIA_ERROR_DEVICE_NOT_INSERTED 0x0600
                             8297 ; 163  |#define MMC_MEDIA_ERROR_RESET_FAILED 0x0601
                             8298 ; 164  |#define MMC_MEDIA_APP_COMMAND_FAILED 0x0602
                             8299 ; 165  |#define MMC_MEDIA_ERROR_INIT_FAILED 0x0603
                             8300 ; 166  |#define MMC_MEDIA_ERROR_SEND_OP_TIMEOUT 0x0604
                             8301 ; 167  |#define MMC_MEDIA_READ_OCR_FAILED 0x0605
                             8302 ; 168  |#define MMC_MEDIA_UNSUPPORTED_OCR_VOLTAGES 0x0606
                             8303 ; 169  |#define MMC_MEDIA_READ_CSD_FAILED 0x0607
                             8304 ; 170  |#define MMC_MEDIA_INVALID_CSD_VERSION 0x0608
                             8305 ; 171  |#define MMC_MEDIA_READ_CID_FAILED 0x0609
                             8306 ; 172  |#define MMC_MEDIA_INVALID_CID 0x060A
                             8307 ; 173  |#define MMC_MEDIA_SPEC_VERSION_NOT_SUPPORTED 0x060B
                             8308 ; 174  |#define MMC_MEDIA_ERROR_NOT_FORMATTED 0x060C
                             8309 ; 175  |#define MMC_MEDIA_ERROR_NOT_ENUMERATED 0x060D
                             8310 ; 176  |
                             8311 ; 177  |#define MMC_DATA_DRIVE_ERROR_WRITE_SECTOR_FAIL 0x0700
                             8312 ; 178  |#define MMC_DATA_DRIVE_ERROR_INVALID_SECTOR 0x0701
                             8313 ; 179  |#define MMC_DATA_DRIVE_ERROR_READ_SECTOR_FAIL 0x0702
                             8314 ; 180  |#define MMC_DATA_DRIVE_ERROR_WRITE_PROTECTED 0x0703
                             8315 ; 181  |#define MMC_DATA_DRIVE_ERROR_ERASE_FAILED 0x0704
                             8316 ; 182  |#define MMC_DATA_DRIVE_ERROR_SEQUENTIAL_FIRST_FAIL 0x0705
                             8317 ; 183  |#define MMC_DATA_DRIVE_ERROR_SEQUENTIAL_NEXT_FAIL 0x0706
                             8318 ; 184  |#define MMC_DATA_DRIVE_ERROR_SEQUENTIAL_END_FAIL 0x0707
                             8319 ; 185  |#define MMC_DATA_DRIVE_ERROR_BLOCK_ALIGN_FAIL 0x0708
                             8320 ; 186  |
                             8321 ; 187  |/////////////////////////////////////////////////////////////////////////////////
                             8322 ; 188  |//// MMC HAL Error codes
                             8323 ; 189  |/////////////////////////////////////////////////////////////////////////////////
                             8324 ; 190  |#define MMC_HAL_ERROR_PHYSICAL_DEVICE_BLOCKED 0x0800
                             8325 ; 191  |#define MMC_HAL_ERROR_PHYSICAL_DEVICE_NOT_BLOCKED 0x0801
                             8326 ; 192  |#define MMC_HAL_ERROR_SPI_BUS_BLOCKED 0x0802
                             8327 ; 193  |#define MMC_HAL_ERROR_SPI_BUS_NOT_BLOCKED 0x0803
                             8328 ; 194  |#define MMC_HAL_ERROR_SPI_DRIVER_INIT_FAILED 0x0804
                             8329 ; 195  |#define MMC_HAL_ERROR_SPI_BUS_INIT_FAILED 0x0805
                             8330 ; 196  |
                             8331 ; 197  |#define MMC_HAL_ERROR_NO_COMMAND_RESPONSE 0x0810
                             8332 ; 198  |#define MMC_HAL_ERROR_BAD_START_BYTE 0x0811
                             8333 ; 199  |#define MMC_HAL_ERROR_BAD_WRITE_STATUS 0x0812
                             8334 ; 200  |#define MMC_HAL_ERROR_BAD_CSD_WRITE_STATUS 0x0813
                             8335 ; 201  |
                             8336 ; 202  |#define MMC_HAL_ERROR_START_BYTE_TIMEOUT 0x0820
                             8337 ; 203  |#define MMC_HAL_ERROR_WRITE_BUSY_TIMEOUT 0x0821
                             8338 ; 204  |#define MMC_HAL_ERROR_CSD_WRITE_BUSY_TIMEOUT 0x0822
                             8339 ; 205  |#define MMC_HAL_ERROR_ERASE_BUSY_TIMEOUT 0x0823
                             8340 ; 206  |#define MMC_HAL_ERROR_REGISTER_READ_TIMEOUT 0x0824
                             8341 ; 207  |
                             8342 ; 208  |#define MMC_HAL_ERROR_CMD_FAIL_CMD0 0x0830
                             8343 ; 209  |#define MMC_HAL_ERROR_CMD_FAIL_CMD1 0x0831
                             8344 ; 210  |#define MMC_HAL_ERROR_CMD_FAIL_CMD9 0x0832
                             8345 ; 211  |#define MMC_HAL_ERROR_CMD_FAIL_CMD10 0x0833
                             8346 ; 212  |#define MMC_HAL_ERROR_CMD_FAIL_CMD12 0x0834
                             8347 ; 213  |#define MMC_HAL_ERROR_CMD_FAIL_CMD13 0x0835
                             8348 ; 214  |#define MMC_HAL_ERROR_CMD_FAIL_CMD16 0x0836
                             8349 ; 215  |#define MMC_HAL_ERROR_CMD_FAIL_CMD17 0x0837
                             8350 ; 216  |#define MMC_HAL_ERROR_CMD_FAIL_CMD18 0x0838
                             8351 ; 217  |#define MMC_HAL_ERROR_CMD_FAIL_CMD23 0x0839
                             8352 ; 218  |#define MMC_HAL_ERROR_CMD_FAIL_CMD24 0x083A
                             8353 ; 219  |#define MMC_HAL_ERROR_CMD_FAIL_CMD25 0x083B
                             8354 ; 220  |#define MMC_HAL_ERROR_CMD_FAIL_CMD27 0x083C
                             8355 ; 221  |#define MMC_HAL_ERROR_CMD_FAIL_CMD28 0x083D
                             8356 ; 222  |#define MMC_HAL_ERROR_CMD_FAIL_CMD29 0x083E
                             8357 ; 223  |#define MMC_HAL_ERROR_CMD_FAIL_CMD30 0x083F
                             8358 ; 224  |#define MMC_HAL_ERROR_CMD_FAIL_CMD32 0x0840
                             8359 ; 225  |#define MMC_HAL_ERROR_CMD_FAIL_CMD33 0x0841
                             8360 ; 226  |#define MMC_HAL_ERROR_CMD_FAIL_CMD35 0x0842
                             8361 ; 227  |#define MMC_HAL_ERROR_CMD_FAIL_CMD36 0x0843
                             8362 ; 228  |#define MMC_HAL_ERROR_CMD_FAIL_CMD38 0x0844
                             8363 ; 229  |#define MMC_HAL_ERROR_CMD_FAIL_CMD42 0x0845
                             8364 ; 230  |#define MMC_HAL_ERROR_CMD_FAIL_CMD55 0x0846
                             8365 ; 231  |#define MMC_HAL_ERROR_CMD_FAIL_CMD56 0x0847
                             8366 ; 232  |#define MMC_HAL_ERROR_CMD_FAIL_CMD58 0x0848
                             8367 ; 233  |#define MMC_HAL_ERROR_CMD_FAIL_CMD59 0x0849
                             8368 ; 234  |
                             8369 ; 235  |#define MMC_HAL_ERROR_SD_CMD_FAIL_ACMD13 0x0850
                             8370 ; 236  |#define MMC_HAL_ERROR_SD_CMD_FAIL_ACMD22 0x0851
                             8371 ; 237  |#define MMC_HAL_ERROR_SD_CMD_FAIL_ACMD23 0x0852
                             8372 ; 238  |#define MMC_HAL_ERROR_SD_CMD_FAIL_ACMD41 0x0853
                             8373 ; 239  |#define MMC_HAL_ERROR_SD_CMD_FAIL_ACMD42 0x0854
                             8374 ; 240  |#define MMC_HAL_ERROR_SD_CMD_FAIL_ACMD51 0x0855
                             8375 ; 241  |
                             8376 ; 242  |#define MMC_HAL_ERROR_BAD_CMD_RESPONSE_CMD0 0x0860
                             8377 ; 243  |#define MMC_HAL_ERROR_BAD_CMD_RESPONSE_CMD1 0x0861
                             8378 ; 244  |#define MMC_HAL_ERROR_BAD_CMD_RESPONSE_CMD9 0x0862
                             8379 ; 245  |#define MMC_HAL_ERROR_BAD_CMD_RESPONSE_CMD10 0x0863
                             8380 ; 246  |#define MMC_HAL_ERROR_BAD_CMD_RESPONSE_CMD12 0x0864
                             8381 ; 247  |#define MMC_HAL_ERROR_BAD_CMD_RESPONSE_CMD13 0x0865
                             8382 ; 248  |#define MMC_HAL_ERROR_BAD_CMD_RESPONSE_CMD16 0x0866
                             8383 ; 249  |#define MMC_HAL_ERROR_BAD_CMD_RESPONSE_CMD17 0x0867
                             8384 ; 250  |#define MMC_HAL_ERROR_BAD_CMD_RESPONSE_CMD18 0x0868
                             8385 ; 251  |#define MMC_HAL_ERROR_BAD_CMD_RESPONSE_CMD23 0x0869
                             8386 ; 252  |#define MMC_HAL_ERROR_BAD_CMD_RESPONSE_CMD24 0x086A
                             8387 ; 253  |#define MMC_HAL_ERROR_BAD_CMD_RESPONSE_CMD25 0x086B
                             8388 ; 254  |#define MMC_HAL_ERROR_BAD_CMD_RESPONSE_CMD27 0x086C
                             8389 ; 255  |#define MMC_HAL_ERROR_BAD_CMD_RESPONSE_CMD28 0x086D
                             8390 ; 256  |#define MMC_HAL_ERROR_BAD_CMD_RESPONSE_CMD29 0x086E
                             8391 ; 257  |#define MMC_HAL_ERROR_BAD_CMD_RESPONSE_CMD30 0x086F
                             8392 ; 258  |#define MMC_HAL_ERROR_BAD_CMD_RESPONSE_CMD32 0x0870
                             8393 ; 259  |#define MMC_HAL_ERROR_BAD_CMD_RESPONSE_CMD33 0x0871
                             8394 ; 260  |#define MMC_HAL_ERROR_BAD_CMD_RESPONSE_CMD35 0x0872
                             8395 ; 261  |#define MMC_HAL_ERROR_BAD_CMD_RESPONSE_CMD36 0x0873
                             8396 ; 262  |#define MMC_HAL_ERROR_BAD_CMD_RESPONSE_CMD38 0x0874
                             8397 ; 263  |#define MMC_HAL_ERROR_BAD_CMD_RESPONSE_CMD42 0x0875
                             8398 ; 264  |#define MMC_HAL_ERROR_BAD_CMD_RESPONSE_CMD55 0x0876
                             8399 ; 265  |#define MMC_HAL_ERROR_BAD_CMD_RESPONSE_CMD56 0x0877
                             8400 ; 266  |#define MMC_HAL_ERROR_BAD_CMD_RESPONSE_CMD58 0x0878
                             8401 ; 267  |#define MMC_HAL_ERROR_BAD_CMD_RESPONSE_CMD59 0x0879
                             8402 ; 268  |
                             8403 ; 269  |#define MMC_HAL_ERROR_SD_BAD_CMD_RESPONSE_ACMD13 0x0880
                             8404 ; 270  |#define MMC_HAL_ERROR_SD_BAD_CMD_RESPONSE_ACMD22 0x0881
                             8405 ; 271  |#define MMC_HAL_ERROR_SD_BAD_CMD_RESPONSE_ACMD23 0x0882
                             8406 ; 272  |#define MMC_HAL_ERROR_SD_BAD_CMD_RESPONSE_ACMD41 0x0883
                             8407 ; 273  |#define MMC_HAL_ERROR_SD_BAD_CMD_RESPONSE_ACMD42 0x0884
                             8408 ; 274  |#define MMC_HAL_ERROR_SD_BAD_CMD_RESPONSE_ACMD51 0x0885
                             8409 ; 275  |
                             8410 ; 276  |//;;;;;;; < Library Error Codes > ;;;;;;;;
                             8411 ; 277  |//MATH errors...
                             8412 ; 278  |#define ERRZeroDivide 0x7FFFFF
                             8413 ; 279  |
                             8414 ; 280  |//Memory Pointer errors...
                             8415 ; 281  |#define INVALID_MEMORY_SPACE 0x900000
                             8416 ; 282  |//****************************************************************/
                             8417 ; 283  |#if (!defined(NOERROR))
                             8418 ; 284  |#define NOERROR 0
                             8419 ; 285  |#endif
                             8420 ; 286  |
                             8421 ; 287  |////Added by RAKS
                             8422 ; 288  |
                             8423 ; 289  |#define ERRProgram 0x911111
                             8424 ; 290  |#define ERRNoMedia 0x922222
                             8425 ; 291  |#define ERRHwFail 0x933333   
                             8426 ; 292  |#define ERRInvMedia 0x944444
                             8427 ; 293  |#define ERRBlkFail 0x955555
                             8428 ; 294  |#define ERRInvDataStatus 0x966666
                             8429 ; 295  |#define ERRWriteFail 0x977777
                             8430 ; 296  |#define ERRECCCorr 0x988888
                             8431 ; 297  |#define ERRECCFail 0x999999
                             8432 ; 298  |#define ERRZoneFull 0x9aaaaa
                             8433 ; 299  |#define ERR_PAGE_UNASSIGNED 0x9aaaaB   
                             8434 ; 300  |// Partition Table Error Codes.                 Note 9AAAAA used above and below.
                             8435 ; 301  |//invalid partition table signature. 
                             8436 ; 302  |#define ERRPartTableSignature 0x9AAAAA   
                             8437 ; 303  |//boot ID bad
                             8438 ; 304  |#define ERRBootID 0x9BBBBB   
                             8439 ; 305  |#define ERRBootTableSignature 0x9CCCCC   
                             8440 ; 306  |////Nothing was here : RAKS
                             8441 ; 307  |//JUMP instruction bad
                             8442 ; 308  |#define ERRBootJump 0x9DDDDD  
                             8443 ; 309  |//ID Byte bad
                             8444 ; 310  |#define ERRIDByte 0x9EEEEE  
                             8445 ; 311  |
                             8446 ; 312  |
                             8447 ; 313  |//****************************************************************
                             8448 ; 314  |//        < < <  EMC5600 FAT12 FileSystem  > > >
                             8449 ; 315  |//****************************************************************
                             8450 ; 316  |// Master ERROR File
                             8451 ; 317  |//****************************************************************/
                             8452 ; 318  |// FAT File System Error Codes
                             8453 ; 319  |// corrupt FAT
                             8454 ; 320  |#define FATCorrupt -1        
                             8455 ; 321  |// invalid FAT sector
                             8456 ; 322  |#define DIRInvlaidSector -2        
                             8457 ; 323  |
                             8458 ; 324  |#define FATwarningFreeCx 0x0AFCFC
                             8459 ; 325  |#define FATwarningEndOfChain 0x0AECEC
                             8460 ; 326  |#define FATwarningReservedCx 0x0A1111
                             8461 ; 327  |#define FATwarningBadCx 0x0ABCBC       
                             8462 ; 328  |//FATcxsFree==0 
                             8463 ; 329  |#define FATwarningNoFreeCxs 0x0A0F0F   
                             8464 ; 330  |#define FATwarningBoundaryCx 0x0A2222
                             8465 ; 331  |#define FATwarningWriteBackAborted 0x0A3333
                             8466 ; 332  |
                             8467 ; 333  |#define FATfailedReadPrimaryFAT 0x7F0000
                             8468 ; 334  |#define FATfailedWritePrimaryFAT 0x7FFFFF   
                             8469 ; 335  |#define FATfailedWriteSecondaryFAT 0x7F8888
                             8470 ; 336  |
                             8471 ; 337  |#define FATerrorNoFreeBlocks 0x80A0A0
                             8472 ; 338  |#define FATerrorTableOverFlow 0x80CCCC
                             8473 ; 339  |#define FATerrorClusterUnderFlow 0x80DDDD
                             8474 ; 340  |#define FATerrorClusterOverFlow 0x80EEEE
                             8475 ; 341  |//No Free Cxs on FAT Scan!
                             8476 ; 342  |#define FATerrorNoFreeCxs 0x80FFFF   
                             8477 ; 343  |
                             8478 ; 344  |#define MATHerrorNotPowerOf2 0x802222
                             8479 ; 345  |
                             8480 ; 346  |#define MEDIAerrorFSNotSupported 0x810000
                             8481 ; 347  |#define MEDIAerrorMediaNotUsable 0x811111
                             8482 ; 348  |
                             8483 ; 349  |#define CXerrorValueOverFlow 0x82AAAA
                             8484 ; 350  |#define CXerrorValueUnderFlow 0x82BBBB
                             8485 ; 351  |
                             8486 ; 352  |#define HNDLerrorNoHandles 0x83AAAA
                             8487 ; 353  |#define HNDLerrorInvalidHandle 0x83BBBB
                             8488 ; 354  |#define HNDLerrorInvalidDevice 0x830D0D
                             8489 ; 355  |#define HNDLerrorIndexSect 0x83CCCC
                             8490 ; 356  |
                             8491 ; 357  |#define FCBwarningEndOfFile 0x84EFEF
                             8492 ; 358  |#define FCBerrorCXtoSect 0x84CCCC
                             8493 ; 359  |#define FCBerrorDiskFull 0x84DFDF
                             8494 ; 360  |
                             8495 ; 361  |#define SEEKprefix 0x85
                             8496 ; 362  |#define SEEKerrorAccessDenied 0x85ADAD
                             8497 ; 363  |#define SEEKerrorPassedBeginingOfFile 0x85BFBF
                             8498 ; 364  |#define SEEKerrorCurruptFCB 0x85CCCC
                             8499 ; 365  |#define SEEKerrorPassedEndOfFile 0x85EFEF
                             8500 ; 366  |
                             8501 ; 367  |#define READprefix 0x86
                             8502 ; 368  |#define READerrorMemoryOverFlow 0x860F0F
                             8503 ; 369  |#define READerrorInvalidBufferPntr 0x86BFBF
                             8504 ; 370  |#define READerrorInvalidByteCount 0x86BCBC
                             8505 ; 371  |#define READerrorAccessDenied 0x86ADAD
                             8506 ; 372  |#define READerrorFreeCx 0x860000
                             8507 ; 373  |#define READerrorEndOfChain 0x861111
                             8508 ; 374  |#define READerrorReservedCx 0x862222
                             8509 ; 375  |#define READerrorBadCx 0x863333
                             8510 ; 376  |
                             8511 ; 377  |#define WRITEprefix 0x87
                             8512 ; 378  |#define WRITEerrorMemoryOverFlow 0x870F0F
                             8513 ; 379  |#define WRITEerrorInvalidBufferPntr 0x87BFBF
                             8514 ; 380  |#define WRITEerrorInvalidByteCount 0x87BCBC
                             8515 ; 381  |#define WRITEerrorAccessDenied 0x87ADAD
                             8516 ; 382  |#define WRITEerrorFreeCx 0x870000
                             8517 ; 383  |#define WRITEerrorEndOfChain 0x871111
                             8518 ; 384  |#define WRITEerrorReservedCx 0x872222
                             8519 ; 385  |#define WRITEerrorBadCx 0x873333
                             8520 ; 386  |
                             8521 ; 387  |#define UTILprefix 0x88
                             8522 ; 388  |#define UTILerrorDeviceInvalid 0x88BDBD
                             8523 ; 389  |
                             8524 ; 390  |// Directory Error Codes
                             8525 ; 391  |
                             8526 ; 392  |// invalid DIR sector specified
                             8527 ; 393  |#define ERR_DIRInvalidSector 0xA00000  
                             8528 ; 394  |// PATH search string has invlaid directory
                             8529 ; 395  |#define ERR_DIRInvalidPath 0xA00001  
                             8530 ; 396  |#define ERR_DIR_ALREADY_EXISTS 0xA00002
                             8531 ; 397  |#define ERR_DIR_WRITE_FAILED 0xA00003
                             8532 ; 398  |#define ERR_DIR_NOT_EMPTY 0xA00003
                             8533 ; 399  |// Bad cluster number
                             8534 ; 400  |#define ERR_CLUSTER_OUT_OF_RANGE 0xA11111  
                             8535 ; 401  |// Can't open ROOT
                             8536 ; 402  |#define ERR_OPEN_ROOT 0xA22222  
                             8537 ; 403  |#define ERR_CLUSTER_FLAGGED_BAD 0xA33333 
                             8538 ; 404  |#define ERR_CLUSTER_UNREADABLE 0xA44444 
                             8539 ; 405  |#define ERR_SECTOR_UNREADABLE 0xA44441 
                             8540 ; 406  |// bad record number to read
                             8541 ; 407  |#define ERR_INVLAID_DIR_REQUEST 0xA55555  
                             8542 ; 408  |// record requeste not in range
                             8543 ; 409  |#define ERR_ReadRecordRangeError 0xA66666  
                             8544 ; 410  |// record requeste past end of ROOT
TASKING DSP2410 assembler v1.5r1 Build 138 SN 00100122
                                                                                                                                                                                                                                                       Page  32

M:ADDR CODE           CYCLES LINE SOURCELINE
                             8545 ; 411  |#define ERR_ReadPastEndOfROOT 0xA66660  
                             8546 ; 412  |// device number invalid
                             8547 ; 413  |#define ERR_BadDeviceNumber 0xA77777  
                             8548 ; 414  |// FCB Does not popint to a sub-Directory entry
                             8549 ; 415  |#define ERR_FCB_Not_SubDir 0xA88888  
                             8550 ; 416  |// Path specified is invalid
                             8551 ; 417  |#define ERR_INVLAID_PATH 0xA99999  
                             8552 ; 418  |#define ERR_FILE_NOT_FOUND 0xAAAAAA
                             8553 ; 419  |#define ERR_FILE_EXISTS 0xABBBBB
                             8554 ; 420  |#define ERR_DISK_FULL 0xACCCCC
                             8555 ; 421  |#define ERR_DIR_DEVICE_NOT_READY 0xACCCC0
                             8556 ; 422  |#define ERR_CX_ALLOCATION 0xADDDDD
                             8557 ; 423  |#define ERR_INVALID_MODE 0xAEEEEE
                             8558 ; 424  |
                             8559 ; 425  |#define ERR_DUPLICATE_FILE_NAME 0xAFFFFC
                             8560 ; 426  |#define ERR_FAT_WRITE_FAILED 0xAFFFFD
                             8561 ; 427  |#define ERR_CANT_DELETE_CHAIN 0xAFFFFE
                             8562 ; 428  |#define ERR_FAT_CHAIN_CORRUPT 0xAFFFFF
                             8563 ; 429  |// String Manipulation Error Codes
                             8564 ; 430  |#define ERR_END_OF_STRING 0xABBBB0
                             8565 ; 431  |
                             8566 ; 432  |#endif //@DEF(ERRORS_INC)
                             8567 ; 433  |
                             8568 
                             8570 
                             8571 ; 54   |
                             8572 ; 55   |///////////////////////////////////////////////////////////////////////////////
                             8573 ; 56   |// Typedefs
                             8574 ; 57   |///////////////////////////////////////////////////////////////////////////////
                             8575 ; 58   |
                             8576 ; 59   |typedef void (*MULTI_WRITE_CALLBACK_FUNCTION)(LONG lValue);
                             8577 ; 60   |
                             8578 ; 61   |#include "ddildl\ddildl_defs.h"
                             8579 
                             8581 
                             8582 ; 1    |////////////////////////////////////////////////////////////////////////////////
                             8583 ; 2    |// Copyright(C) SigmaTel, Inc. 2003-2005
                             8584 ; 3    |//
                             8585 ; 4    |// Filename: ddildl_defs.h
                             8586 ; 5    |// Description: 
                             8587 ; 6    |////////////////////////////////////////////////////////////////////////////////
                             8588 ; 7    |
                             8589 ; 8    |#ifndef _DDILDL_DEFS_H
                             8590 ; 9    |#define _DDILDL_DEFS_H
                             8591 ; 10   |
                             8592 ; 11   |///////////////////////////////////////////////////////////////////////////////
                             8593 ; 12   |// Typedefs
                             8594 ; 13   |///////////////////////////////////////////////////////////////////////////////
                             8595 ; 14   |
                             8596 ; 15   |typedef enum {
                             8597 ; 16   |  MediaStateUnknown,
                             8598 ; 17   |  MediaStateErased,
                             8599 ; 18   |  MediaStateAllocated
                             8600 ; 19   |} MEDIA_STATE, * P_MEDIA_STATE;
                             8601 ; 20   |
                             8602 ; 21   |typedef enum {
                             8603 ; 22   |    MediaTypeNand = 0,
                             8604 ; 23   |    MediaTypeMMC = 1,
                             8605 ; 24   |    MediaTypeHDD = 2,
                             8606 ; 25   |    MediaTypeRAM = 3
                             8607 ; 26   |} PHYSICAL_MEDIA_TYPE, * P_PHYSICAL_MEDIA_TYPE;
                             8608 ; 27   |
                             8609 ; 28   |typedef enum {
                             8610 ; 29   |    MediaInfoNumberOfDrives = 0,
                             8611 ; 30   |    MediaInfoSizeInBytes = 1,
                             8612 ; 31   |    MediaInfoAllocationUnitSizeInBytes = 2,
                             8613 ; 32   |    MediaInfoIsInitialized = 3,
                             8614 ; 33   |    MediaInfoMediaState = 4,
                             8615 ; 34   |    MediaInfoIsWriteProtected = 5,
                             8616 ; 35   |    MediaInfoPhysicalMediaType = 6,
                             8617 ; 36   |    MediaInfoSizeOfSerialNumberInBytes = 7,
                             8618 ; 37   |    MediaInfoSerialNumber = 8,
                             8619 ; 38   |    MediaInfoIsSystemMedia = 9,
                             8620 ; 39   |    MediaInfoIsMediaPresent = 10
                             8621 ; 40   |} LOGICAL_MEDIA_INFO, * P_LOGICAL_MEDIA_INFO;
                             8622 ; 41   |
                             8623 ; 42   |#ifdef MFG_TOOL
                             8624 ; 43   |  
                             8625 ; 44   |typedef enum {
                             8626 ; 45   |    SerialNoInfoSizeOfSerialNumberInBytes = 0,
                             8627 ; 46   |    SerialNoInfoSerialNumber = 1
                             8628 ; 47   |} SERIAL_NO_INFO, * P_SERIAL_NO_INFO;
                             8629 ; 48   |#endif
                             8630 ; 49   |
                             8631 ; 50   |typedef enum {
                             8632 ; 51   |    DriveInfoSectorSizeInBytes = 0,
                             8633 ; 52   |    DriveInfoEraseSizeInBytes = 1,
                             8634 ; 53   |    DriveInfoSizeInBytes = 2,
                             8635 ; 54   |    DriveInfoSizeInMegaBytes = 3,
                             8636 ; 55   |    DriveInfoSizeInSectors = 4,
                             8637 ; 56   |    DriveInfoType = 5,
                             8638 ; 57   |    DriveInfoTag = 6,
                             8639 ; 58   |    DriveInfoComponentVersion = 7,
                             8640 ; 59   |    DriveInfoProjectVersion = 8,
                             8641 ; 60   |    DriveInfoIsWriteProtected = 9,
                             8642 ; 61   |    DriveInfoSizeOfSerialNumberInBytes = 10,
                             8643 ; 62   |    DriveInfoSerialNumber = 11,
                             8644 ; 63   |    DriveInfoMediaPresent = 12,
                             8645 ; 64   |    DriveInfoMediaChange = 13,
                             8646 ; 65   |    DriveInfoSectorAllocation = 14
                             8647 ; 66   |} LOGICAL_DRIVE_INFO, * P_LOGICAL_DRIVE_INFO;
                             8648 ; 67   |
                             8649 ; 68   |#define DRIVE_TAG_STMPSYS_S         0x00        //!< player drive tag.
                             8650 ; 69   |#define DRIVE_TAG_HOSTLINK_S        0x01        //!< UsbMscMtp drive tag, old name was DRIVE_TAG_USBMSC_S. 
                             8651 ; 70   |#define DRIVE_TAG_RESOURCE_BIN      0x02        //!< player resource drive tag.
                             8652 ; 71   |#define DRIVE_TAG_EXTRA_S           0x03        //!< the host has 0x03 reserved for an extra system drive.
                             8653 ; 72   |// if you change line below, also change this equ: asm_DRIVE_TAG_RESOURCE1_BIN in player main.asm!! Values must match. 
                             8654 ; 73   |#define DRIVE_TAG_RESOURCE1_BIN (DRIVE_TAG_RESOURCE_BIN+0x10)//<! was just 0x04. old comment"the host has 0x04 reserved for an extra system drive." May17'06 JLN: correction: ChrisW says 0x10+resource.bin tag is ta
                                  g for 2nd ver of resource.bin in new 2.61x post sdkrelease updater. 
                             8655 ; 74   |#define DRIVE_TAG_RESOURCE2_BIN (DRIVE_TAG_RESOURCE_BIN+0x20)// master has tag 0x22 (3rd copy)
                             8656 ; 75   |#define DRIVE_TAG_OTGHOST_S         0x05        //!< the host has 0x05 reserved for OTG drive.
                             8657 ; 76   |#define DRIVE_TAG_HOSTRSC_BIN       0x06        //!< UsbMscMtp resource drive tag, old name was DRIVE_TAG_MTP_BIN.
                             8658 ; 77   |#define DRIVE_TAG_DATA              0x0A        //!< data drive tag.
                             8659 ; 78   |#define DRIVE_TAG_DATA_HIDDEN       0x0B        //!< hidden data drive tag, old name was DRIVE_TAG_HIDDEN
                             8660 ; 79   |#define DRIVE_TAG_BOOTMANAGER_S     0x50        //!< boot manager drive tag
                             8661 ; 80   |#define DRIVE_TAG_UPDATER_S         0xFF        //!< the host has 0xFF reserved for usbmsc.sb file used in recovery mode operation only.
                             8662 ; 81   |#define DRIVE_TAG_HOSTRSC1_BIN      0x16        //!< back up resource for hostrsrc.bin.
                             8663 ; 82   |#define DRIVE_TAG_HOSTRSC2_BIN      0x26        //!< MASTER COPY resource for hostrsrc.bin.
                             8664 ; 83   |// Do not use this enum... use the defs above.  We need to use defs so customers
                             8665 ; 84   |//  may extend the system drives without DDI source code.
                             8666 ; 85   |/*
                             8667 ; 86   |typedef enum {
                             8668 ; 87   |    ResourceBinDriveTag = 0x00,
                             8669 ; 88   |    BootManagerDriveTag = 0x50,
                             8670 ; 89   |    StmpSysDriveTag = 0x01,
                             8671 ; 90   |    UsbMscDriveTag = 0x02,
                             8672 ; 91   |    DataDriveTag = 0x0A
                             8673 ; 92   |} LOGICAL_DRIVE_TAG, * P_LOGICAL_DRIVE_TAG;
                             8674 ; 93   |*/
                             8675 ; 94   |
                             8676 ; 95   |typedef enum {
                             8677 ; 96   |    DriveTypeData = 0,
                             8678 ; 97   |    DriveTypeSystem = 1,
                             8679 ; 98   |    DriveTypeHidden = 2,
                             8680 ; 99   |    DriveTypeUnknown = 3
                             8681 ; 100  |} LOGICAL_DRIVE_TYPE, * P_LOGICAL_DRIVE_TYPE;
                             8682 
                             8689 
                             8690 ; 101  |
                             8691 ; 102  |typedef struct {
                             8692 ; 103  |    WORD wDriveNumber;          // In reference to the entire system
                             8693 ; 104  |    LOGICAL_DRIVE_TYPE Type;
                             8694 ; 105  |    WORD wTag;
                             8695 ; 106  |    DWORD dwSizeInBytes;
                             8696 ; 107  |    BOOL bRequired;
                             8697 ; 108  |} MEDIA_ALLOCATION_TABLE_ENTRY, * P_MEDIA_ALLOCATION_TABLE_ENTRY;
                             8698 
                             8706 
                             8707 ; 109  |
                             8708 ; 110  |typedef struct {
                             8709 ; 111  |    WORD wNumEntries;
                             8710 ; 112  |    MEDIA_ALLOCATION_TABLE_ENTRY Entry[MAX_MEDIA_TABLE_ENTRIES];
                             8711 ; 113  |} MEDIA_ALLOCATION_TABLE, * P_MEDIA_ALLOCATION_TABLE;
                             8712 ; 114  |
                             8713 ; 115  |
                             8714 ; 116  |#define TA6_ROM_REV_ID  6
                             8715 ; 117  |#define ROM_REV_ID  (*((WORD _X *)0xFA02) & 0x0F)
                             8716 ; 118  |
                             8717 ; 119  | 
                             8718 ; 120  |typedef union {
                             8719 ; 121  |
                             8720 ; 122  |    struct {
                             8721 ; 123  |        WORD MinorL      : 8;
                             8722 ; 124  |        WORD MinorH      : 8;
                             8723 ; 125  |        WORD MiddleL     : 8;
                             8724 ; 126  |        WORD MiddleH     : 8;
                             8725 ; 127  |        WORD MajorL      : 8;
                             8726 ; 128  |        WORD MajorH      : 8;
                             8727 ; 129  |        } PARTIAL_VERSION;
                             8728 ; 130  |        
                             8729 ; 131  |    DWORD   Version;        
                             8730 ; 132  |
                             8731 ; 133  |} SYSTEM_VERSION;
                             8732 ; 134  |
                             8733 ; 135  |
                             8734 ; 136  |#endif // #ifndef _DDILDL_DEFS_H
                             8735 
                             8737 
                             8738 ; 62   |
                             8739 ; 63   |///////////////////////////////////////////////////////////////////////////////
                             8740 ; 64   |// Prototypes
                             8741 ; 65   |// Note that these are prototypes for the highest level access to the DDI.
                             8742 ; 66   |//  The LDL steering mechanism converts the wLogMediaNumber & wLogDriveNumber
                             8743 ; 67   |//  parameters & passes pointers to the media/drive desctriptrs to the DDIs.
                             8744 ; 68   |///////////////////////////////////////////////////////////////////////////////
                             8745 ; 69   |RETCODE _reentrant MediaInit(WORD wLogMediaNumber);
                             8746 ; 70   |RETCODE _reentrant MediaAllocate(WORD wLogMediaNumber,
                             8747 
                             8755 
                             8756 ; 71   |    P_MEDIA_ALLOCATION_TABLE pMediaTable);
                             8757 ; 72   |RETCODE _reentrant MediaDiscoverAllocation(WORD wLogMediaNumber);
                             8758 ; 73   |RETCODE _reentrant MediaGetMediaTable(WORD wLogMediaNumber,
                             8759 ; 74   |    P_MEDIA_ALLOCATION_TABLE *pMediaTable);
                             8760 ; 75   |RETCODE _reentrant MediaGetInfo(WORD wLogMediaNumber, LOGICAL_MEDIA_INFO Type,
                             8761 
                             8775 
                             8776 ; 76   |    void * _Y pInfo);
                             8777 ; 77   |RETCODE _reentrant MediaErase(WORD wLogMediaNumber, WORD wMagicNumber);
                             8778 ; 78   |
                             8779 ; 79   |RETCODE _reentrant DriveInit(WORD wLogDriveNumber);
                             8780 ; 80   |RETCODE _reentrant DriveGetInfo(WORD wLogDriveNumber, LOGICAL_DRIVE_INFO Type,
                             8781 
                             8799 
                             8800 ; 81   |    void * pInfo);
                             8801 ; 82   |RETCODE _reentrant DriveSetInfo(WORD wLogDriveNumber, LOGICAL_DRIVE_INFO Type,
                             8802 ; 83   |    void * pInfo);
                             8803 ; 84   |RETCODE _reentrant DriveReadSector(WORD wLogDriveNumber, DWORD dwSectorNumber,
                             8804 ; 85   |    P_SECTOR_BUFFER pSectorData);
                             8805 ; 86   |RETCODE _reentrant DriveWriteSector(WORD wLogDriveNumber, DWORD dwSectorNumber,
                             8806 ; 87   |    P_SECTOR_BUFFER pSectorData);
                             8807 ; 88   |RETCODE _reentrant DriveMultiWriteSetup(WORD wLogDriveNumber,
                             8808 ; 89   |    DWORD dwStartSectorNumber, WORD wSectorCount,
                             8809 
                             8814 
                             8815 ; 90   |    MULTI_WRITE_CALLBACK_FUNCTION pCallBackFunction);
                             8816 ; 91   |RETCODE _reentrant DriveMultiWriteSector(WORD wLogDriveNumber,
                             8817 ; 92   |    P_SECTOR_BUFFER pSectorData, LONG lCallBackPassThru);
                             8818 ; 93   |RETCODE _reentrant DriveErase(WORD wLogDriveNumber, WORD wMagicNumber);
                             8819 ; 94   |RETCODE _reentrant DriveFlush(WORD wDriveNumber);
                             8820 ; 95   |
                             8821 ; 96   |RETCODE DdiInitAll(void);
                             8822 ; 97   |
                             8823 ; 98   |
                             8824 ; 99   |#endif // #ifndef _DDILDL_H
                             8825 
                             8838 
                             8839 ; 11   |
                             8840 ; 12   |///////////////////////////////////////
                             8841 ; 13   |// Logical Media structures
                             8842 ; 14   |///////////////////////////////////////
                             8843 ; 15   |
                             8844 ; 16   |typedef struct {
                             8845 ; 17   |    // Discovered at Run Time by MediaInit:
                             8846 ; 18   |    WORD    wMediaNumber;
                             8847 ; 19   |    BOOL    bInitialized;
                             8848 ; 20   |    MEDIA_STATE eState;
                             8849 ; 21   |    BOOL    bAllocated;
                             8850 ; 22   |    BOOL    bWriteProtected;
                             8851 ; 23   |    WORD    wNumberOfDrives;//on this media
                             8852 ; 24   |    DWORD   dwSizeInBytes;
                             8853 ; 25   |    WORD    wAllocationUnitSizeInBytes;
                             8854 ; 26   |    PHYSICAL_MEDIA_TYPE PhysicalType;
                             8855 ; 27   |    void * pMediaInfo;  // same as in LOGICAL_DRIVE_DESCRIPTOR
                             8856 ; 28   |} LOGICAL_MEDIA_DESCRIPTOR, * P_LOGICAL_MEDIA_DESCRIPTOR;
                             8857 
                             8872 
                             8873 ; 29   |
                             8874 ; 30   |// Logical Media API functions
                             8875 ; 31   |typedef _reentrant RETCODE (*P_MEDIA_INIT_FUNCTION)(P_LOGICAL_MEDIA_DESCRIPTOR);
                             8876 ; 32   |typedef RETCODE _reentrant (*P_MEDIA_ALLOCATE_FUNCTION)(P_LOGICAL_MEDIA_DESCRIPTOR,
                             8877 ; 33   |    P_MEDIA_ALLOCATION_TABLE);
TASKING DSP2410 assembler v1.5r1 Build 138 SN 00100122
                                                                                                                                                                                                                                                       Page  33

M:ADDR CODE           CYCLES LINE SOURCELINE
                             8878 ; 34   |typedef RETCODE _reentrant (*P_MEDIA_DISCOVER_ALLOCATION_FUNCTION)(P_LOGICAL_MEDIA_DESCRIPTOR);
                             8879 ; 35   |typedef RETCODE _reentrant (*P_MEDIA_GET_MEDIA_TABLE_FUNCTION)(P_LOGICAL_MEDIA_DESCRIPTOR,
                             8880 ; 36   |    P_MEDIA_ALLOCATION_TABLE);
                             8881 ; 37   |typedef RETCODE _reentrant (*P_MEDIA_GET_INFO_FUNCTION)(P_LOGICAL_MEDIA_DESCRIPTOR,
                             8882 ; 38   |    LOGICAL_MEDIA_INFO, void * _Y);
                             8883 ; 39   |typedef RETCODE _reentrant (*P_MEDIA_ERASE_FUNCTION)(P_LOGICAL_MEDIA_DESCRIPTOR,
                             8884 ; 40   |    WORD wMagicNumber);
                             8885 
                             8910 
                             8911 ; 41   |
                             8912 ; 42   |typedef struct {
                             8913 ; 43   |    WORD wInitCodeBank;
                             8914 ; 44   |    P_MEDIA_INIT_FUNCTION pInit;
                             8915 ; 45   |    WORD wAllocateCodeBank;
                             8916 ; 46   |    P_MEDIA_ALLOCATE_FUNCTION pAllocate;
                             8917 ; 47   |    WORD wDiscoverAllocationCodeBank;
                             8918 ; 48   |    P_MEDIA_DISCOVER_ALLOCATION_FUNCTION pDiscoverAllocation;
                             8919 ; 49   |    WORD wGetMediaTableCodeBank;
                             8920 ; 50   |    P_MEDIA_GET_MEDIA_TABLE_FUNCTION pGetMediatable;
                             8921 ; 51   |    WORD wGetInfoCodeBank;
                             8922 ; 52   |    P_MEDIA_GET_INFO_FUNCTION pGetInfo;
                             8923 ; 53   |    WORD wEraseCodeBank;
                             8924 ; 54   |    P_MEDIA_ERASE_FUNCTION pErase;
                             8925 ; 55   |} LOGICAL_MEDIA_API, * P_LOGICAL_MEDIA_API;
                             8926 
                             8943 
                             8944 ; 56   |
                             8945 ; 57   |typedef struct {
                             8946 ; 58   |    P_LOGICAL_MEDIA_DESCRIPTOR pDescriptor;
                             8947 ; 59   |    P_LOGICAL_MEDIA_API pApi;
                             8948 ; 60   |} LOGICAL_MEDIA, * P_LOGICAL_MEDIA;
                             8949 
                             8967 
                             8968 ; 61   |
                             8969 ; 62   |///////////////////////////////////////
                             8970 ; 63   |// Logical Drive structures
                             8971 ; 64   |///////////////////////////////////////
                             8972 ; 65   |
                             8973 ; 66   |typedef struct {
                             8974 ; 67   |    // Discovered at Run Time by MediaDiscover
                             8975 ; 68   |    BOOL    bInitialized;
                             8976 ; 69   |    BOOL    bPresent;       // Indicates if a system drive is present
                             8977 ; 70   |                            // wTag from Config Block matches wTag from Drive
                             8978 ; 71   |                            // redundant area
                             8979 ; 72   |    BOOL    bErased;
                             8980 ; 73   |    BOOL    bWriteProtected;
                             8981 ; 74   |    DWORD   dwNumberOfSectors;
                             8982 ; 75   |    LOGICAL_DRIVE_TYPE Type;
                             8983 ; 76   |    WORD    wTag;
                             8984 ; 77   |    WORD    wDriveNumber;
                             8985 ; 78   |    DWORD   dwSizeInBytes;
                             8986 ; 79   |    WORD    wSectorSizeInBytes; // not included bad blocks (NAND media)
                             8987 ; 80   |    WORD    wEraseSizeInBytes;
                             8988 ; 81   |    SYSTEM_VERSION ProjectVersion;
                             8989 ; 82   |    SYSTEM_VERSION ComponentVersion;
                             8990 ; 83   |    P_LOGICAL_MEDIA_DESCRIPTOR pLogicalMediaDescriptor;
                             8991 ; 84   |    void * pMediaInfo;  // same as in LOGICAL_MEDIA_DESCRIPTOR
                             8992 ; 85   |    void * pDriveInfo;
                             8993 ; 86   |} LOGICAL_DRIVE_DESCRIPTOR, * P_LOGICAL_DRIVE_DESCRIPTOR;
                             8994 
                             9015 
                             9016 ; 87   |
                             9017 ; 88   |// Logical Drive API functions
                             9018 ; 89   |typedef RETCODE _reentrant (*P_DRIVE_INIT_FUNCTION)(P_LOGICAL_DRIVE_DESCRIPTOR);
                             9019 ; 90   |typedef RETCODE _reentrant (*P_DRIVE_GET_INFO_FUNCTION)(P_LOGICAL_DRIVE_DESCRIPTOR,
                             9020 ; 91   |    LOGICAL_DRIVE_INFO, void *);
                             9021 ; 92   |typedef RETCODE _reentrant (*P_DRIVE_SET_INFO_FUNCTION)(P_LOGICAL_DRIVE_DESCRIPTOR,
                             9022 ; 93   |    LOGICAL_DRIVE_INFO, void *);
                             9023 ; 94   |typedef RETCODE _reentrant (*P_DRIVE_READ_SECTOR_FUNCTION)(P_LOGICAL_DRIVE_DESCRIPTOR,
                             9024 ; 95   |    DWORD, P_SECTOR_BUFFER);
                             9025 ; 96   |typedef RETCODE _reentrant (*P_DRIVE_WRITE_SECTOR_FUNCTION)(P_LOGICAL_DRIVE_DESCRIPTOR,
                             9026 ; 97   |    DWORD, P_SECTOR_BUFFER);
                             9027 ; 98   |typedef RETCODE _reentrant (*P_DRIVE_MULTI_WRITE_SETUP_FUNCTION)(P_LOGICAL_DRIVE_DESCRIPTOR,
                             9028 ; 99   |    DWORD, WORD, MULTI_WRITE_CALLBACK_FUNCTION);
                             9029 ; 100  |typedef RETCODE _reentrant (*P_DRIVE_MULTI_WRITE_SECTOR_FUNCTION)(P_LOGICAL_DRIVE_DESCRIPTOR,
                             9030 ; 101  |    P_SECTOR_BUFFER, LONG);
                             9031 ; 102  |typedef RETCODE _reentrant (*P_DRIVE_ERASE_FUNCTION)(P_LOGICAL_DRIVE_DESCRIPTOR, WORD);
                             9032 ; 103  |typedef RETCODE _reentrant (*P_DRIVE_FLUSH_FUNCTION)(P_LOGICAL_DRIVE_DESCRIPTOR);
                             9033 
                             9070 
                             9071 ; 104  |
                             9072 ; 105  |typedef struct {
                             9073 ; 106  |    WORD wInitCodeBank;
                             9074 ; 107  |    P_DRIVE_INIT_FUNCTION pInit;
                             9075 ; 108  |    WORD wGetInfoCodeBank;
                             9076 ; 109  |    P_DRIVE_GET_INFO_FUNCTION pGetInfo;
                             9077 ; 110  |    WORD wSetInfoCodeBank;
                             9078 ; 111  |    P_DRIVE_SET_INFO_FUNCTION pSetInfo;
                             9079 ; 112  |    WORD wReadSectorCodeBank;
                             9080 ; 113  |    P_DRIVE_READ_SECTOR_FUNCTION pReadSector;
                             9081 ; 114  |    WORD wWriteSectorCodeBank;
                             9082 ; 115  |    P_DRIVE_WRITE_SECTOR_FUNCTION pWriteSector;
                             9083 ; 116  |    WORD wMultiWriteSetupCodeBank;
                             9084 ; 117  |    P_DRIVE_MULTI_WRITE_SETUP_FUNCTION pMultiWriteSetup;
                             9085 ; 118  |    WORD wMultiWriteSectorCodeBank;
                             9086 ; 119  |    P_DRIVE_MULTI_WRITE_SECTOR_FUNCTION pMultiWriteSector;
                             9087 ; 120  |    WORD wEraseCodeBank;
                             9088 ; 121  |    P_DRIVE_ERASE_FUNCTION pErase;
                             9089 ; 122  |    WORD wFlushCodeBank;
                             9090 ; 123  |    P_DRIVE_FLUSH_FUNCTION pFlush;
                             9091 ; 124  |} LOGICAL_DRIVE_API, * P_LOGICAL_DRIVE_API;
                             9092 
                             9115 
                             9116 ; 125  |
                             9117 ; 126  |typedef struct {
                             9118 ; 127  |    P_LOGICAL_DRIVE_DESCRIPTOR pDescriptor;
                             9119 ; 128  |    P_LOGICAL_DRIVE_API pApi;
                             9120 ; 129  |} LOGICAL_DRIVE, * P_LOGICAL_DRIVE;
                             9121 
                             9123 
                             9124 ; 130  |
                             9125 ; 131  |///////////////////////////////////////////////////////////////////////////////
                             9126 ; 132  |// Global variables
                             9127 ; 133  |///////////////////////////////////////////////////////////////////////////////
                             9128 ; 134  |extern MEDIA_ALLOCATION_TABLE g_MediaAllocationTable[];
                             9129 
                             9131 
                             9132 ; 135  |extern LOGICAL_MEDIA_DESCRIPTOR g_MediaDescriptor[];
                             9133 
                             9138 
                             9139 ; 136  |extern LOGICAL_MEDIA g_Media[];
                             9140 ; 137  |extern WORD g_wNumMedia;
                             9141 
                             9143 
                             9144 ; 138  |extern LOGICAL_DRIVE_DESCRIPTOR g_DriveDescriptor[];
                             9145 
                             9150 
                             9151 ; 139  |extern LOGICAL_DRIVE g_Drive[];
                             9152 ; 140  |extern WORD g_wNumDrives;
                             9153 ; 141  |
                             9154 ; 142  |///////////////////////////////////////////////////////////////////////////////
                             9155 ; 143  |// SysCallFunction Variants
                             9156 ; 144  |///////////////////////////////////////////////////////////////////////////////
                             9157 ; 145  |RETCODE _asmfunc SysCallFunction_P_LOGICAL_MEDIA_DESCRIPTOR_f(WORD * RESOURCE,RETCODE _reentrant (int,int,int*),  int, int, int *);
                             9158 ; 146  |#define SysCallFunction_P_LOGICAL_MEDIA_DESCRIPTOR(rsrc,func,a,b,p) SysCallFunction_P_LOGICAL_MEDIA_DESCRIPTOR_f((void*)rsrc,(func),(a),(b),(p))
                             9159 ; 147  |
                             9160 ; 148  |#endif
                             9161 
                             9163 
                             9164 ; 16   |#include "mmchal.h"
                             9165 
                             9167 
                             9168 ; 1    |////////////////////////////////////////////////////////////////////////////////
                             9169 ; 2    |// Copyright(C) SigmaTel, Inc. 2000-2001
                             9170 ; 3    |//
                             9171 ; 4    |// Filename: mmchal.h
                             9172 ; 5    |// Description: 
                             9173 ; 6    |////////////////////////////////////////////////////////////////////////////////
                             9174 ; 7    |
                             9175 ; 8    |#ifndef _MMCHAL_H
                             9176 ; 9    |#define _MMCHAL_H
                             9177 ; 10   |
                             9178 ; 11   |///////////////////////////////////////////////////////////////////////////////
                             9179 ; 12   |// MMC HAL definitions
                             9180 ; 13   |///////////////////////////////////////////////////////////////////////////////
                             9181 ; 14   |
                             9182 ; 15   |#define MMC_NULL_ARG    0
                             9183 ; 16   |
                             9184 ; 17   |// MMC commands
                             9185 ; 18   |#define MMC_CMD0        0x40|0
                             9186 ; 19   |#define MMC_CMD1        0x40|1
                             9187 ; 20   |#define MMC_CMD8                0x40|8
                             9188 ; 21   |#define MMC_CMD9        0x40|9
                             9189 ; 22   |#define MMC_CMD10       0x40|10
                             9190 ; 23   |#define MMC_CMD12       0x40|12
                             9191 ; 24   |#define MMC_CMD13       0x40|13
                             9192 ; 25   |#define MMC_CMD16       0x40|16
                             9193 ; 26   |#define MMC_CMD17       0x40|17
                             9194 ; 27   |#define MMC_CMD18       0x40|18
                             9195 ; 28   |#define MMC_CMD23       0x40|23
                             9196 ; 29   |#define MMC_CMD24       0x40|24
                             9197 ; 30   |#define MMC_CMD25       0x40|25
                             9198 ; 31   |#define MMC_CMD27       0x40|27
                             9199 ; 32   |#define MMC_CMD28       0x40|28
                             9200 ; 33   |#define MMC_CMD29       0x40|29
                             9201 ; 34   |#define MMC_CMD30       0x40|30
                             9202 ; 35   |#define MMC_CMD32       0x40|32
                             9203 ; 36   |#define MMC_CMD33       0x40|33
                             9204 ; 37   |#define MMC_CMD35       0x40|35
                             9205 ; 38   |#define MMC_CMD36       0x40|36
                             9206 ; 39   |#define MMC_CMD38       0x40|38
                             9207 ; 40   |#define MMC_CMD42       0x40|42
                             9208 ; 41   |#define MMC_CMD55       0x40|55
                             9209 ; 42   |#define MMC_CMD56       0x40|56
                             9210 ; 43   |#define MMC_CMD58       0x40|58
                             9211 ; 44   |#define MMC_CMD59       0x40|59
                             9212 ; 45   |
                             9213 ; 46   |// SD-specific commands
                             9214 ; 47   |#define SD_ACMD13       0x40|13
                             9215 ; 48   |#define SD_ACMD22       0x40|22
                             9216 ; 49   |#define SD_ACMD23       0x40|23
                             9217 ; 50   |#define SD_ACMD41       0x40|41
                             9218 ; 51   |#define SD_ACMD42       0x40|42
                             9219 ; 52   |#define SD_ACMD51       0x40|51
                             9220 ; 53   |
                             9221 ; 54   |// Responses
                             9222 ; 55   |#define MMC_RESPONSE_TYPE       WORD
                             9223 ; 56   |#define MMC_RESPONSE_TYPE_R1    0
                             9224 ; 57   |#define MMC_RESPONSE_TYPE_R2    1
                             9225 ; 58   |#define MMC_RESPONSE_TYPE_R3    2
                             9226 ; 59   |
                             9227 ; 60   |#define MMC_R1_NO_ERROR                     0x00
                             9228 ; 61   |#define MMC_R1_IDLE_NO_ERROR                0x01
                             9229 ; 62   |#define MMC_R1_IN_IDLE_STATE_BITPOS         0
                             9230 ; 63   |#define MMC_R1_ERASE_RESET_BITPOS           1
                             9231 ; 64   |#define MMC_R1_ILLEGAL_COMMAND_BITPOS       2
                             9232 ; 65   |#define MMC_R1_COM_CRC_ERROR_BITPOS         3
                             9233 ; 66   |#define MMC_R1_ERASE_SEQUENCE_ERROR_BITPOS  4
                             9234 ; 67   |#define MMC_R1_ADDRESS_ERROR                5
                             9235 ; 68   |#define MMC_R1_PARAMETER_ERROR              6
                             9236 ; 69   |
                             9237 ; 70   |#define MMC_START_BYTE          0xFE
                             9238 ; 71   |
                             9239 ; 72   |#define MMC_CSD_VERSION_10      0
                             9240 ; 73   |#define MMC_CSD_VERSION_11      1
                             9241 ; 74   |#define MMC_CSD_VERSION_12      2
                             9242 ; 75   |#define MMC_CSD_VERSION_FROM_EXT_CSD    3
                             9243 ; 76   |
                             9244 ; 77   |#define MMC_SPEC_VERSION_10     0
                             9245 ; 78   |#define MMC_SPEC_VERSION_14     1
                             9246 ; 79   |#define MMC_SPEC_VERSION_20     2
                             9247 ; 80   |#define MMC_SPEC_VERSION_31     3
                             9248 ; 81   |#define MMC_SPEC_VERSION_40     4
                             9249 ; 82   |
                             9250 ; 83   |#define SD_CSD_VERSION_10       0
                             9251 ; 84   |
                             9252 ; 85   |#define MMC_CARD_TYPE           WORD
                             9253 ; 86   |#define MMC_CARD_TYPE_MMC       (MMC_CARD_TYPE)0
                             9254 ; 87   |#define MMC_CARD_TYPE_SD        (MMC_CARD_TYPE)1
                             9255 ; 88   |
                             9256 ; 89   |#define MMC_SUPPORTED_SECTOR_SIZE   512
                             9257 ; 90   |
                             9258 ; 91   |#define MMC_OCR_SUPPORT (DWORD)0x000000020000
                             9259 ; 92   |
                             9260 ; 93   |//   The STMP3400 max SCK speed is DCLK/6, STMP3410 is DCLK/2:
                             9261 ; 94   |//   Assume a 100MHz DCLK & SCK=DCLK/2=50Mhz. It takes a minimum of 15 DCLKs
                             9262 ; 95   |//   between each SPI byte transfer, so one byte takes (8*2)+15=31 DCLKs.  This
                             9263 ; 96   |//   is a byte rate of 1.612MBytes/s.  Assume all timeouts are 1s.
                             9264 ; 97   |#define MMC_PORT_TIMEOUT            (WORD)(100000000/31)
                             9265 ; 98   |#define MMC_START_BYTE_TIMEOUT      MMC_PORT_TIMEOUT
                             9266 ; 99   |#define MMC_WRITE_BUSY_TIMEOUT      MMC_PORT_TIMEOUT
                             9267 ; 100  |#define MMC_CSD_WRITE_BUSY_TIMEOUT  MMC_PORT_TIMEOUT
                             9268 ; 101  |#define MMC_ERASE_BUSY_TIMEOUT      MMC_PORT_TIMEOUT
                             9269 ; 102  |#define MMC_REGISTER_READ_TIMEOUT   MMC_PORT_TIMEOUT
                             9270 ; 103  |
                             9271 ; 104  |///////////////////////////////////////////////////////////////////////////////
                             9272 ; 105  |// MMC HAL structure definitions
                             9273 ; 106  |///////////////////////////////////////////////////////////////////////////////
                             9274 ; 107  |
                             9275 ; 108  |///////////////////////////////////////////////////////////////////////////////
                             9276 ; 109  |// MMC definitions
TASKING DSP2410 assembler v1.5r1 Build 138 SN 00100122
                                                                                                                                                                                                                                                       Page  34

M:ADDR CODE           CYCLES LINE SOURCELINE
                             9277 ; 110  |
                             9278 ; 111  |// ifdef this struct for SPI or MMCBUS (currently only support SPI)
                             9279 ; 112  |typedef struct {
                             9280 ; 113  |    _X WORD *wGpioBase;
                             9281 ; 114  |    WORD wGpioSetMask;
                             9282 ; 115  |    WORD wGpioClearMask;
                             9283 ; 116  |    _X WORD *wWriteProtectGpioBase;
                             9284 ; 117  |    WORD wWriteProtectGpioSetMask;
                             9285 ; 118  |    WORD wWriteProtectGpioClearMask;
                             9286 ; 119  |    _X WORD *wMediaDetectGpioBase;
                             9287 ; 120  |    WORD wMediaDetectGpioSetMask;
                             9288 ; 121  |    WORD wMediaDetectGpioClearMask;
                             9289 ; 122  |    WORD wMediaDetectPolarity;
                             9290 ; 123  |    WORD wSpiDeviceNumber;
                             9291 ; 124  |    BOOL bSPIBusInitialized;
                             9292 ; 125  |} MMC_PHYSICAL_BUS;
                             9293 ; 126  |
                             9294 ; 127  |typedef struct {
                             9295 ; 128  |    WORD wCommand;
                             9296 ; 129  |    WORD wArg3;
                             9297 ; 130  |    WORD wArg2;
                             9298 ; 131  |    WORD wArg1;
                             9299 ; 132  |    WORD wArg0;
                             9300 ; 133  |    WORD wCRC7;
                             9301 ; 134  |} MMC_CMD;
                             9302 ; 135  |
                             9303 ; 136  |typedef union {
                             9304 ; 137  |    struct {
                             9305 ; 138  |        WORD Idle            : 1;
                             9306 ; 139  |        WORD EraseReset      : 1;
                             9307 ; 140  |        WORD IllCommand      : 1;
                             9308 ; 141  |        WORD ComCrcError     : 1;
                             9309 ; 142  |        WORD EraseSeqError   : 1;
                             9310 ; 143  |        WORD AddressError    : 1;
                             9311 ; 144  |        WORD ParamError      : 1;
                             9312 ; 145  |        WORD ZeroBit         : 1;
                             9313 ; 146  |    } B;
                             9314 ; 147  |    WORD I;
                             9315 ; 148  |} MMC_RESPONSE_R1;
                             9316 ; 149  |
                             9317 ; 150  |typedef union {
                             9318 ; 151  |    struct {
                             9319 ; 152  |        WORD CardLocked      : 1;
                             9320 ; 153  |        WORD WpeLucf         : 1;
                             9321 ; 154  |        WORD Error           : 1;
                             9322 ; 155  |        WORD CCError         : 1;
                             9323 ; 156  |        WORD CardEccFail     : 1;
                             9324 ; 157  |        WORD WpViolation     : 1;
                             9325 ; 158  |        WORD EraseParam      : 1;
                             9326 ; 159  |        WORD OorCsdovw       : 1;
                             9327 ; 160  |        WORD Idle            : 1;
                             9328 ; 161  |        WORD EraseReset      : 1;
                             9329 ; 162  |        WORD IllCommand      : 1;
                             9330 ; 163  |        WORD ComCrcError     : 1;
                             9331 ; 164  |        WORD EraseSeqError   : 1;
                             9332 ; 165  |        WORD AddressError    : 1;
                             9333 ; 166  |        WORD ParamError      : 1;
                             9334 ; 167  |    } B;
                             9335 ; 168  |    WORD I;
                             9336 ; 169  |} MMC_RESPONSE_R2;
                             9337 
                             9359 
                             9360 ; 170  |
                             9361 ; 171  |typedef struct {
                             9362 ; 172  |    DWORD dwOcr;
                             9363 ; 173  |    MMC_RESPONSE_R1 R1;
                             9364 ; 174  |} MMC_RESPONSE_R3;
                             9365 
                             9405 
                             9406 ; 175  |
                             9407 ; 176  |typedef union {
                             9408 ; 177  |    MMC_RESPONSE_R1 R1;
                             9409 ; 178  |    MMC_RESPONSE_R2 R2;
                             9410 ; 179  |    MMC_RESPONSE_R3 R3;
                             9411 ; 180  |} MMC_RESPONSE;
                             9412 
                             9427 
                             9428 ; 181  |    
                             9429 ; 182  |
                             9430 ; 183  |///////////////////////////////////////////////////////////////////////////////
                             9431 ; 184  |// MMC prototypes
                             9432 ; 185  |///////////////////////////////////////////////////////////////////////////////
                             9433 ; 186  |
                             9434 ; 187  |// functions that map directly to MMC commands
                             9435 ; 188  |RETCODE _reentrant HalMmcGoIdleStateSync(MMC_PHYSICAL_BUS * pBusPointer, MMC_RESPONSE * Response);
                             9436 
                             9442 
                             9443 ; 189  |RETCODE _reentrant HalMmcSendOpCondSync(MMC_PHYSICAL_BUS * pBusPointer, MMC_RESPONSE * Response);
                             9444 ; 190  |RETCODE _reentrant HalMmcSendCidSync(MMC_PHYSICAL_BUS * pBusPointer, WORD _X pwRegBuffer[],
                             9445 ; 191  |    MMC_RESPONSE * Response);
                             9446 ; 192  |RETCODE _reentrant HalMmcSendCsdSync(MMC_PHYSICAL_BUS * pBusPointer, WORD _X pwRegBuffer[],
                             9447 ; 193  |    MMC_RESPONSE * Response);
                             9448 ; 194  |RETCODE _reentrant HalMmcAppCmdSync(MMC_PHYSICAL_BUS * pBusPointer, MMC_RESPONSE * Response);
                             9449 ; 195  |RETCODE _reentrant HalMmcReadOcrSync(MMC_PHYSICAL_BUS * pBusPointer, MMC_RESPONSE * Response);
                             9450 ; 196  |RETCODE _reentrant HalMmcSendStatusSync(MMC_PHYSICAL_BUS * pBusPointer, MMC_RESPONSE * Response);
                             9451 ; 197  |RETCODE _reentrant HalMmcReadSingleBlockSync(MMC_PHYSICAL_BUS * pBusPointer, DWORD dwAddress,
                             9452 ; 198  |    WORD _X pwReadBuffer[], MMC_RESPONSE * Response);
                             9453 ; 199  |RETCODE _reentrant HalMmcProgramCsdSync(MMC_PHYSICAL_BUS * pBusPointer, WORD _X pwRegBuffer[],
                             9454 ; 200  |    MMC_RESPONSE * Response);
                             9455 ; 201  |RETCODE _reentrant HalMmcSetBlocklenSync(MMC_PHYSICAL_BUS * pBusPointer, DWORD dwLength, 
                             9456 ; 202  |    MMC_RESPONSE * Response);
                             9457 ; 203  |RETCODE _reentrant HalMmcBusInit(MMC_PHYSICAL_BUS * pBusPointer);
                             9458 ; 204  |
                             9459 ; 205  |RETCODE _reentrant HalMmcWriteBlockSync(MMC_PHYSICAL_BUS * pBusPointer, DWORD dwAddress,
                             9460 ; 206  |    WORD _X pwWriteBuffer[], MMC_RESPONSE * Response);
                             9461 ; 207  |RETCODE _reentrant HalMmcWriteMultipleBlockFirstSync(MMC_PHYSICAL_BUS * pBusPointer, DWORD dwAddress,
                             9462 ; 208  |    WORD _X pwWriteBuffer[], MMC_RESPONSE * Response);
                             9463 ; 209  |RETCODE _reentrant HalMmcWriteMultipleBlockNextSync(MMC_PHYSICAL_BUS * pBusPointer, DWORD dwAddress,
                             9464 ; 210  |    WORD _X pwWriteBuffer[], MMC_RESPONSE * Response);
                             9465 ; 211  |RETCODE _reentrant HalMmcWriteMultipleBlockEndSync(MMC_PHYSICAL_BUS * pBusPointer);
                             9466 ; 212  |RETCODE _reentrant HalMmcTagSectorStartSync(MMC_PHYSICAL_BUS * pBusPointer, DWORD dwAddress,
                             9467 ; 213  |    MMC_RESPONSE * Response);
                             9468 ; 214  |RETCODE _reentrant HalMmcTagSectorEndSync(MMC_PHYSICAL_BUS * pBusPointer, DWORD dwAddress,
                             9469 ; 215  |    MMC_RESPONSE * Response);
                             9470 ; 216  |RETCODE _reentrant HalMmcTagEraseGroupStartSync(MMC_PHYSICAL_BUS * pBusPointer, DWORD dwAddress,
                             9471 ; 217  |    MMC_RESPONSE * Response);
                             9472 ; 218  |RETCODE _reentrant HalMmcTagEraseGroupEndSync(MMC_PHYSICAL_BUS * pBusPointer, DWORD dwAddress,
                             9473 ; 219  |    MMC_RESPONSE * Response);
                             9474 ; 220  |RETCODE _reentrant HalMmcErase(MMC_PHYSICAL_BUS * pBusPointer, MMC_RESPONSE * Response);
                             9475 ; 221  |
                             9476 ; 222  |// functions that map directly to SD commands
                             9477 ; 223  |RETCODE _reentrant HalSdSendOpCondSync(MMC_PHYSICAL_BUS * pBusPointer, MMC_RESPONSE * Response);
                             9478 ; 224  |
                             9479 ; 225  |// other HAL functions
                             9480 ; 226  |#ifdef MMC_SEMAPHORE
                             9481 ; 227  |RETCODE _reentrant HalMmcPhysicalGrab(WORD wNum);
                             9482 ; 228  |RETCODE _reentrant HalMmcPhysicalRelease(WORD wNum);
                             9483 ; 229  |#endif
                             9484 ; 230  |BOOL _reentrant HalMmcIsDeviceInserted(MMC_PHYSICAL_BUS * pBusPointer);
                             9485 ; 231  |
                             9486 ; 232  |// ancillary functions
                             9487 ; 233  |RETCODE _reentrant MmcSendCommandSync(MMC_PHYSICAL_BUS * pBusPointer, WORD wCommand, 
                             9488 ; 234  |    DWORD dwArgument, MMC_RESPONSE * Response, MMC_RESPONSE_TYPE ResponseType);
                             9489 ; 235  |RETCODE _reentrant MmcWaitForRegisterSync(MMC_PHYSICAL_BUS * pBusPointer);
                             9490 ; 236  |RETCODE _reentrant MmcTransactionCompleteSync(MMC_PHYSICAL_BUS * pBusPointer);
                             9491 
                             9500 
                             9501 ; 237  |RETCODE _reentrant MmcCalcCommandCrc(MMC_CMD * pCmd);
                             9502 ; 238  |
                             9503 ; 239  |#endif // #ifndef _MMCHAL_H
                             9504 
                             9506 
                             9507 ; 17   |
                             9508 ; 18   |///////////////////////////////////////////////////////////////////////////////
                             9509 ; 19   |// Definitions
                             9510 ; 20   |///////////////////////////////////////////////////////////////////////////////
                             9511 ; 21   |
                             9512 ; 22   |#define MMC_SECTOR_SIZE_IN_BYTES            512
                             9513 ; 23   |
                             9514 ; 24   |typedef enum {
                             9515 ; 25   |  eMmcLockStateFree   = 0,
                             9516 ; 26   |  eMmcLockStateLocked = 1
                             9517 ; 27   |} MMC_LOCK_STATE;
                             9518 ; 28   |
                             9519 ; 29   |typedef BOOL    (*P_MMCBUSYDONE_CALLBACK_FUNCTION)(int, void*);
                             9520 ; 30   |
                             9521 ; 31   |/////////////////////////////////////////////////////////////////////////////////
                             9522 ; 32   |// MMC Physical Device Struct
                             9523 ; 33   |/////////////////////////////////////////////////////////////////////////////////
                             9524 ; 34   |typedef struct {
                             9525 ; 35   |    BOOL  bMMCCardPresent;
                             9526 ; 36   |        BOOL    bEnumerated;
                             9527 ; 37   |    BOOL        bWriteProtected;
                             9528 ; 38   |    BOOL        bEraseTested;
                             9529 ; 39   |    BOOL        bEraseIsFunctional;
                             9530 ; 40   |//    BOOL      bMmcMultiWriteSupported;
                             9531 ; 41   |//    BOOL      bMmcMultiWriteInProgress;
                             9532 ; 42   |} MMC_PHYSICAL_DEVICE_FLAGS, * P_MMC_PHYSICAL_DEVICE_FLAGS;
                             9533 ; 43   |
                             9534 ; 44   |
                             9535 ; 45   |/////////////////////////////////////////////////////////////////////////////////
                             9536 ; 46   |// MMC CID Struct
                             9537 ; 47   |/////////////////////////////////////////////////////////////////////////////////
                             9538 ; 48   |typedef struct {
                             9539 ; 49   |
                             9540 ; 50   |        WORD    wMID;       //Manufacturer ID
                             9541 ; 51   |    WORD        wCIN[4];        // Spec 1.4 only
                             9542 ; 52   |    WORD        wOID;       // OEM/App ID
                             9543 ; 53   |    DWORD       dwPNM;  // Product Name
                             9544 ; 54   |    WORD        wPRV;       // Product Revision
                             9545 ; 55   |    DWORD       dwPSN;  // Product Serial Number
                             9546 ; 56   |    WORD        wMDT;       // Manufacturing Date
                             9547 ; 57   |    WORD        wCRC;       // CRC checksum
                             9548 ; 58   |} MMC_CID, *P_MMC_CID;
                             9549 ; 59   |
                             9550 ; 60   |/////////////////////////////////////////////////////////////////////////////////
                             9551 ; 61   |// MMC CSD Struct
                             9552 ; 62   |/////////////////////////////////////////////////////////////////////////////////
                             9553 ; 63   |typedef struct {
                             9554 ; 64   |
                             9555 ; 65   |    WORD        wCSD_STRUCTURE;         // *
                             9556 ; 66   |    WORD        wSPEC_VERS;                 // * System Specification Version
                             9557 ; 67   |    WORD        wTAAC;                        // Data Read Access Time 1
                             9558 ; 68   |    WORD        wNSAC;                        // Data Read Access Time 2
                             9559 ; 69   |    WORD        wTRANS_SPEED;             // Max Data Transfer Rate
                             9560 ; 70   |    WORD        wCCC;                           // Card Command Classes
                             9561 ; 71   |    WORD        wREAD_BL_LEN;             // * Max Read Data block Length
                             9562 ; 72   |    WORD        wREAD_BL_PARTIAL;               // Partial Blocks for read allowed
                             9563 ; 73   |    WORD        wWRITE_BLK_MISALIGN;    // Write Block misaligned
                             9564 ; 74   |    WORD        wREAD_BLK_MISALIGN;     // Read Block misaligned
                             9565 ; 75   |    WORD        wDSR_INP;                     // DSR Implemented
                             9566 ; 76   |    WORD        wC_SIZE;                            // * Device Size
                             9567 ; 77   |    WORD        wVDD_R_CURR_MIN;        // Max Read Current at Vdd Min
                             9568 ; 78   |    WORD        wVDD_R_CURR_MAX;        // Max Read Current at Vdd Max
                             9569 ; 79   |    WORD        wVDD_W_CURR_MIN;  // Max Write Current at Vdd Min
                             9570 ; 80   |    WORD        wVDD_W_CURR_MAX;        // Max Write Current at Vdd Max
                             9571 ; 81   |    WORD        wC_SIZE_MULT;             // * Device Size Mulitplier
                             9572 ; 82   |    WORD        wERASE_BLK_EN;          // Erase Block Enable (SD 1.0)
                             9573 ; 83   |    WORD        wSECTOR_SIZE;             // Sector Size (SD 1.0)
                             9574 ; 84   |    WORD        wERASE_GRP_SIZE;        // * Erase Group Size
                             9575 ; 85   |    WORD        wERASE_GRP_MULT;        // * Erase Group Multiplier
                             9576 ; 86   |    WORD        wWP_GRP_SIZE;             // Write Protect Group Size
                             9577 ; 87   |    WORD        wWP_GROUP_ENABLE;       // Write Protect Group Enable
                             9578 ; 88   |    WORD        wDEFAULT_ECC;             // Manufacturer Default ECC
                             9579 ; 89   |    WORD        wR2W_FACTOR;              // Write Speed Factor
                             9580 ; 90   |    WORD        wWRITE_BL_LEN;    // Max Write data block length
                             9581 ; 91   |    WORD        wWRITE_BL_PARTIAL;      // Partial blocks for  Write allowed
                             9582 ; 92   |    WORD        wFILE_FORMAT_GRP;       // File format group
                             9583 ; 93   |    WORD        wCOPY;                        // Copy Flag (OTP)
                             9584 ; 94   |    WORD        wPERM_WRITE_PROTECT;    // Permanent Write Protection
                             9585 ; 95   |    WORD        wTMP_WRITE_PROTECT;     // Temporary Write Protection
                             9586 ; 96   |    WORD        wFILE_FORMAT;             // File Format
                             9587 ; 97   |    WORD        wECC;                           // ECC
                             9588 ; 98   |    WORD        wCRC;                           // CRC
                             9589 ; 99   |                            //      *  =  Spec 3.1
                             9590 ; 100  |
                             9591 ; 101  |} MMC_CSD, *P_MMC_CSD;
                             9592 ; 102  |
                             9593 ; 103  |typedef struct _MMCMultiWriteStruct
                             9594 ; 104  |{
                             9595 ; 105  |  BOOL  bMultiWriteSupported;
                             9596 ; 106  |  BOOL  bMultiWriteStarted;
                             9597 ; 107  |  BOOL  bMultiWriteInProgress;
                             9598 ; 108  |  DWORD dwMultiWriteStartSectorNumber;
                             9599 ; 109  |  DWORD dwMultiWriteCurrentSectorNumber;
                             9600 ; 110  |  WORD  wMultiWriteSectorsRemaining;
                             9601 ; 111  |  DWORD dwMMCPreviousWriteSector;
                             9602 ; 112  |  MULTI_WRITE_CALLBACK_FUNCTION pCallBackFunction;
                             9603 ; 113  |} MMCMultiWriteStruct;
                             9604 
                             9676 
                             9677 ; 114  |
                             9678 ; 115  |/////////////////////////////////////////////////////////////////////////////////
                             9679 ; 116  |// MMC Media Info Struct
                             9680 ; 117  |/////////////////////////////////////////////////////////////////////////////////
                             9681 ; 118  |typedef struct {
                             9682 ; 119  |  MMC_LOCK_STATE  Lock;
                             9683 ; 120  |  BOOL            bMMCIsBusy;       // Used for SetMMCBusy and MMCIsReady
                             9684 ; 121  |  P_MMCBUSYDONE_CALLBACK_FUNCTION pMMCBusyDoneCallbackFunction;
                             9685 ; 122  |  void *          pMMCBusyArg;              // Used for SetMMCBusy and MMCIsReady
                             9686 ; 123  |  DWORD           dwTotalSectors;           //
TASKING DSP2410 assembler v1.5r1 Build 138 SN 00100122
                                                                                                                                                                                                                                                       Page  35

M:ADDR CODE           CYCLES LINE SOURCELINE
                             9687 ; 124  |  MMC_PHYSICAL_DEVICE_FLAGS     Flags;  // operation flags
                             9688 ; 125  |  MMC_CARD_TYPE   Type;         // MMC or SD?
                             9689 ; 126  |  MMC_CID                     Cid;              // Card ID structure
                             9690 ; 127  |  MMC_CSD                     Csd;              // Card Specific Data Register
                             9691 ; 128  |  WORD                  wEraseSize;     // Erase Size
                             9692 ; 129  |  DWORD                 dwDeviceSize;
                             9693 ; 130  |  MMC_PHYSICAL_BUS * pMMCPhysicalBus;     //SPI Bus Pin definitions for Media.
                             9694 ; 131  |  MMCMultiWriteStruct MultWrite;
                             9695 ; 132  |} MMC_MEDIA_INFO, * P_MMC_MEDIA_INFO;
                             9696 
                             9698 
                             9699 ; 133  |
                             9700 ; 134  |
                             9701 ; 135  |///////////////////////////////////////////////////////////////////////////////
                             9702 ; 136  |// Error codes
                             9703 ; 137  |///////////////////////////////////////////////////////////////////////////////
                             9704 ; 138  |
                             9705 ; 139  |///////////////////////////////////////////////////////////////////////////////
                             9706 ; 140  |// Typedefs
                             9707 ; 141  |///////////////////////////////////////////////////////////////////////////////
                             9708 ; 142  |
                             9709 ; 143  |
                             9710 ; 144  |///////////////////////////////////////////////////////////////////////////////
                             9711 ; 145  |// Prototypes
                             9712 ; 146  |///////////////////////////////////////////////////////////////////////////////
                             9713 ; 147  |
                             9714 ; 148  |
                             9715 ; 149  |///////////////////////////////////////////////////////////////////////////////
                             9716 ; 150  |// Global variables
                             9717 ; 151  |///////////////////////////////////////////////////////////////////////////////
                             9718 ; 152  |extern LOGICAL_MEDIA_API MMCMediaApi;
                             9719 
                             9721 
                             9722 ; 153  |extern LOGICAL_DRIVE_API MMCDataDriveApi;
                             9723 
                             9741 
                             9742 ; 154  |extern MMC_MEDIA_INFO MEDIA_DDI_MEM MmcMediaInfo;
                             9743 ; 155  |
                             9744 ; 156  |#endif // #ifndef _MMCDDI_H
                             9745 
                             9747 
                             9748 ; 35   |  #include "MMCCommon.h"
                             9749 
                             9751 
                             9752 ; 1    |////////////////////////////////////////////////////////////////////////////////
                             9753 ; 2    |// Copyright(C) SigmaTel, Inc. 2003
                             9754 ; 3    |//
                             9755 ; 4    |// Filename: MMCCommon.h
                             9756 ; 5    |// Description: 
                             9757 ; 6    |////////////////////////////////////////////////////////////////////////////////
                             9758 ; 7    |
                             9759 ; 8    |#ifndef _MMC_COMMON_H
                             9760 ; 9    |#define _MMC_COMMON_H
                             9761 ; 10   |
                             9762 ; 11   |///////////////////////////////////////////////////////////////////////////////
                             9763 ; 12   |// Includes
                             9764 ; 13   |///////////////////////////////////////////////////////////////////////////////
                             9765 ; 14   |
                             9766 ; 15   |///////////////////////////////////////////////////////////////////////////////
                             9767 ; 16   |// Definitions
                             9768 ; 17   |///////////////////////////////////////////////////////////////////////////////
                             9769 ; 18   |//#define SECTOR_SIZE                     (528/3)
                             9770 ; 19   |#define MMC_BUFFER_SECTOR_SIZE            (528/3) // 528 so buffers can be shared 
                             9771 ; 20   |                                                  // with NAND.
                             9772 ; 21   |#define MMC_SECTOR_SIZE                   (512/3)
                             9773 
                             9777 
                             9778 ; 22   |///////////////////////////////////////////////////////////////////////////////
                             9779 ; 23   |// Error codes
                             9780 ; 24   |///////////////////////////////////////////////////////////////////////////////
                             9781 ; 25   |
                             9782 ; 26   |///////////////////////////////////////////////////////////////////////////////
                             9783 ; 27   |// Typedefs
                             9784 ; 28   |///////////////////////////////////////////////////////////////////////////////
                             9785 ; 29   |
                             9786 ; 30   |///////////////////////////////////////////////////////////////////////////////
                             9787 ; 31   |// Prototypes
                             9788 ; 32   |///////////////////////////////////////////////////////////////////////////////
                             9789 ; 33   |RETCODE _reentrant MmcSerialNumberInit(P_MMC_MEDIA_INFO pMediaInfo);
                             9790 ; 34   |RETCODE _reentrant MmcEnumeratePhysicalDevice(P_MMC_MEDIA_INFO pMediaInfo, WORD wNum);
                             9791 ; 35   |RETCODE _reentrant ResetDevice(P_MMC_MEDIA_INFO pMediaInfo);
                             9792 ; 36   |RETCODE _reentrant ProcessOcr(P_MMC_MEDIA_INFO pMediaInfo);
                             9793 ; 37   |RETCODE _reentrant ProcessCsd(P_MMC_MEDIA_INFO pMediaInfo);
                             9794 ; 38   |RETCODE _reentrant ProcessCid(P_MMC_MEDIA_INFO pMediaInfo);
                             9795 ; 39   |RETCODE _reentrant MmcTestErase(P_MMC_MEDIA_INFO pMediaInfo, DWORD dwStartBlockAddress,
                             9796 ; 40   |                                DWORD dwEndBlockAddress);
                             9797 ; 41   |RETCODE _reentrant HalMmcEraseBlocks(P_MMC_MEDIA_INFO pMediaInfo,
                             9798 ; 42   |                                     DWORD dwStartBlockAddress, DWORD dwEndBlockAddress);
                             9799 ; 43   |
                             9800 ; 44   |BOOL _reentrant MmcIsHardwareWriteProtected(P_MMC_MEDIA_INFO pMediaInfo);
                             9801 ; 45   |
                             9802 ; 46   |BOOL _reentrant MmcMultiBlockWriteIsSupported(P_MMC_MEDIA_INFO pMediaInfo);
                             9803 ; 47   |
                             9804 ; 48   |RETCODE _reentrant MmcFlagMediaChange(void);
                             9805 ; 49   |
                             9806 ; 50   |RETCODE _reentrant MMCDetectMedia(P_MMC_MEDIA_INFO pMmcMediaInfo);
                             9807 ; 51   |BOOL _reentrant MMCDetectMediaChange (P_MMC_MEDIA_INFO pMmcMediaInfo);
                             9808 ; 52   |
                             9809 ; 53   |#endif // #ifndef _MMC_COMMON_H
                             9810 
                             9812 
                             9813 ; 36   |#endif
                             9814 ; 37   |
                             9815 ; 38   |    #pragma asm
                             9819 ; 42   |    #pragma endasm
                             9820 ; 43   |    
                             9821 ; 44   |////////////////////////////////////////////////////////////////////////////////
                             9822 ; 45   |// Symbol Exports
                             9823 ; 46   |////////////////////////////////////////////////////////////////////////////////
                             9824 ; 47   |
                             9825 ; 48   |////////////////////////////////////////////////////////////////////////////////
                             9826 ; 49   |// Externs
                             9827 ; 50   |////////////////////////////////////////////////////////////////////////////////
                             9828 ; 51   |
                             9829 ; 52   |////////////////////////////////////////////////////////////////////////////////
                             9830 ; 53   |// Defs
                             9831 ; 54   |////////////////////////////////////////////////////////////////////////////////
                             9832 ; 55   |
                             9833 ; 56   |////////////////////////////////////////////////////////////////////////////////
                             9834 ; 57   |// Prototypes
                             9835 ; 58   |////////////////////////////////////////////////////////////////////////////////
                             9836 ; 59   |
                             9837 ; 60   |RETCODE UsbMscProjectInitDevice0(void);
                             9838 ; 61   |RETCODE UsbMscProjectResetDevice0(void);
                             9839 ; 62   |#if ((NUM_REMOVABLE_MEDIA == 1) && (MULTI_LUN_BUILD==0))
                             9840 ; 63   |RETCODE UsbMscProjectInitDevice1(void);
                             9841 ; 64   |RETCODE UsbMscProjectResetDevice1(void);
                             9842 ; 65   |#endif
                             9843 ; 66   |
                             9844 ; 67   |////////////////////////////////////////////////////////////////////////////////
                             9845 ; 68   |// Debug Variables
                             9846 ; 69   |////////////////////////////////////////////////////////////////////////////////
                             9847 ; 70   |
                             9848 ; 71   |////////////////////////////////////////////////////////////////////////////////
                             9849 ; 72   |// Variables
                             9850 ; 73   |////////////////////////////////////////////////////////////////////////////////
                             9851 ; 74   |
                             9852 ; 75   |WORD g_wUsbMscNumDevices = USBMSC_NUM_DEVICES;
                             9853 
                             9854 
Y:0000                       9855         org     y,".ydatausbmscproject",init:
                             9856 Fg_wUsbMscNumDevices:
Y:0000 000001                9857         dc      $000001
                             9860 
                             9861 ; 76   |
                             9862 ; 77   |#ifndef MTP_BUILD
                             9863 ; 78   |
                             9864 ; 79   |WORD _X Device1CommandInBuffer[64];
                             9865 ; 80   |WORD _X Device1CommandOutBuffer[64];
                             9866 ; 81   |
                             9867 ; 82   |USBMSC_DEVICE UsbMscDevice[SCSI_NUM_TARGETS];
                             9868 ; 83   |
                             9869 ; 84   |#ifndef USBMSC_HANDLER_STACK_SIZE 
                             9870 ; 85   |#define USBMSC_HANDLER_STACK_SIZE 500
                             9871 ; 86   |#endif 
                             9872 ; 87   |
                             9873 ; 88   |WORD g_USBMSCHandler0Stack[USBMSC_HANDLER_STACK_SIZE];
                             9874 ; 89   |
                             9875 ; 90   |_circ WORD g_USBMSCHandler0MessageQueue[16];
                             9876 ; 91   |CircularBufferDescriptor g_USBMSCHandler0MessageQueueDescriptor={ g_USBMSCHandler0MessageQueue,g_USBMSCHandler0MessageQueue};
                             9877 
                             9878 Fg_USBMSCHandler0MessageQueueDescriptor:
Y:0001 rrrrrr 00000F         9879         dc      Fg_USBMSCHandler0MessageQueue,16-1,Fg_USBMSCHandler0MessageQueue,16-1
       rrrrrr 00000F              
                             9882 
                             9883 ; 92   |TaskEntry g_USBMSCHandler0 = {&g_USBMSCHandler0MessageQueueDescriptor,  //Message queue
                             9884 
                             9885 Fg_USBMSCHandler0:
Y:0005 rrrrrr 000000         9886         dc      Fg_USBMSCHandler0MessageQueueDescriptor,$000000,$000000,$000000
       000000 000000              
Y:0009 rrrrrr 000000         9887         dc      Fg_USBMSCHandler0Stack,$000000,$000000,$000000,$000000,$000000
       000000 000000              
       000000 000000              
Y:000F 000000 000000         9888         dc      $000000,$000000,$000000,$000000,Fg_USBMSCHandler0Stack,$0001f4
       000000 000000              
       rrrrrr 0001F4              
Y:0015 rrrrrr                9889         dc      FUsbMscHandler0
                             9892 
                             9893 ; 93   |                                NULL,                                   //Waiting on Ptr (meaning depends on state)
                             9894 ; 94   |                                0,                                      //waiting on value (meaning depends on state)
                             9895 ; 95   |                                EVENT_TIMEOUT,                          //current state
                             9896 ; 96   |                                g_USBMSCHandler0Stack,                  //current stack pointer
                             9897 ; 97   |                                0,                                      //Task ID
                             9898 ; 98   |                                TIMEOUT_IMMEDIATE,                      //Initial timeout value
                             9899 ; 99   |                                {0},                                    //Region requirements
                             9900 ; 100  |                                0,                                      //Priority
                             9901 ; 101  |                                g_USBMSCHandler0Stack,                  //Initial stack ptr (only used in init)
                             9902 ; 102  |                                USBMSC_HANDLER_STACK_SIZE,              //Stack size
                             9903 ; 103  |                                UsbMscHandler0};                        //Initial entry point
                             9904 ; 104  |
                             9905 ; 105  |
                             9906 ; 106  |SECTOR_TYPE Target0SectorArray[USBMSC_MAX_NUM_SECTOR_BUFFERS];
                             9907 ; 107  |WORD _X Target0BufferArray[USBMSC_TOTAL_BUFFER_SIZE];
                             9908 ; 108  |
                             9909 ; 109  |#else                           // ifndef MTP_BUILD
                             9910 ; 110  |
                             9911 ; 111  |
                             9912 ; 112  |extern SECTOR_TYPE Target0SectorArray[USBMSC_MAX_NUM_SECTOR_BUFFERS];
                             9913 ; 113  |extern WORD _X Target0BufferArray[USBMSC_TOTAL_BUFFER_SIZE];
                             9914 ; 114  |
                             9915 ; 115  |extern USBMSC_DEVICE UsbMscDevice[SCSI_NUM_TARGETS];
                             9916 ; 116  |#endif                          // ifndef MTP_BUILD
                             9917 ; 117  |        
                             9918 ; 118  |////////////////////////////////////////////////////////////////////////////////
                             9919 ; 119  |// Code
                             9920 ; 120  |////////////////////////////////////////////////////////////////////////////////
                             9921 ; 121  |
                             9922 ; 122  |
                             9923 ; 123  |////////////////////////////////////////////////////////////////////////////////
                             9924 ; 124  |//
                             9925 ; 125  |//>  Name:          UsbMscProjectInitDevice0
                             9926 ; 126  |//
                             9927 ; 127  |//   Type:          Function
                             9928 ; 128  |//
                             9929 ; 129  |//   Description:   Project-specific USB MSC device init for device 0
                             9930 ; 130  |//
                             9931 ; 131  |//   Inputs:        none
                             9932 ; 132  |//
                             9933 ; 133  |//   Outputs:       RETCODE
                             9934 ; 134  |//
                             9935 ; 135  |//   Notes:         none
                             9936 ; 136  |//<
                             9937 ; 137  |////////////////////////////////////////////////////////////////////////////////
                             9938 ; 138  |RETCODE UsbMscProjectInitDevice0(void)
                             9939 ; 139  |{
                             9940 
P:0000                       9941         org     p,".ptextusbmscproject":
                             9946 FUsbMscProjectInitDevice0:
P:0000 05707C rrrrrr  4    4 9947         movec   ssh,y:ss_UsbMscProjectInitDevice0
                             9957 
                             9958 ; 140  |    WORD sectorBufferSizeInWords;
                             9959 ; 141  |    USBMSC_DEVICE * pDev;
                             9960 ; 142  |    WORD i;
                             9961 ; 143  |    
                             9962 ; 144  |    // Device 1 setup
                             9963 ; 145  |    pDev = &(UsbMscDevice[USBMSC_DEVICE_0]);
                             9964 
P:0002 66F400 rrrrrr  3    7 9966         move    #FUsbMscDevice,r6
P:0004 6E7000 rrrrrr  3   10 9967         move    r6,y:ss_UsbMscProjectInitDevice0+1
                             9969 
                             9970 ; 146  |
                             9971 ; 147  |    // Run the reset routine
                             9972 ; 148  |    UsbMscProjectResetDevice0();
                             9973 
P:0006 0BF080 rrrrrr  6   16 9975         jsr     FUsbMscProjectResetDevice0
                             9976 
                             9977 ; 149  |
                             9978 ; 150  |    #if defined(DEVICE_3410) || defined(DEVICE_3310)
                             9979 ; 151  |    
                             9980 ; 152  |        usb_device_init_endpoint(pDev->wBulkInEndpointNum ,64,USB_IN,USB_BULK_ENDPOINT,FALSE);
                             9981 ; 153  |        usb_device_init_endpoint(pDev->wBulkOutEndpointNum,64,USB_OUT,USB_BULK_ENDPOINT,FALSE);
TASKING DSP2410 assembler v1.5r1 Build 138 SN 00100122
                                                                                                                                                                                                                                                       Page  36

M:ADDR CODE           CYCLES LINE SOURCELINE
                             9982 ; 154  |        
                             9983 ; 155  |    #else
                             9984 ; 156  |
                             9985 ; 157  |        // Do nothing.
                             9986 ; 158  |        // The endpoints will be initialized in the UsbMscCbwProcessor()
                             9987 ; 159  |    
                             9988 ; 160  |    #endif
                             9989 ; 161  |    
                             9990 ; 162  |    usb_device_register_service(pDev->wBulkInEndpointNum,UsbMscBulkInService);
                             9991 
P:0008 3A0200         2   18 9993         move    #2,n2
P:0009 6AF000 rrrrrr  3   21 9994         move    y:ss_UsbMscProjectInitDevice0+1,r2
P:000B 000000         2   23 9995         nop
P:000C 044A16         4   27 9996         lua     (r2)+n2,r6
P:000D 000000         2   29 9997         nop
P:000E 5EE600         2   31 9998         move    y:(r6),a
P:000F 60F400 rrrrrr  3   34 9999         move    #FUsbMscBulkInService,r0
P:0011 0BF080 rrrrrr  6   4010000         jsr     Fusb_device_register_service
                            10001 
                            10002 ; 163  |    usb_device_register_service(pDev->wBulkOutEndpointNum,UsbMscBulkOutService);
                            10003 
P:0013 380600         2   4210005         move    #6,n0
P:0014 68F000 rrrrrr  3   4510006         move    y:ss_UsbMscProjectInitDevice0+1,r0
P:0016 000000         2   4710007         nop
P:0017 044816         4   5110008         lua     (r0)+n0,r6
P:0018 000000         2   5310009         nop
P:0019 5EE600         2   5510010         move    y:(r6),a
P:001A 60F400 rrrrrr  3   5810011         move    #FUsbMscBulkOutService,r0
P:001C 0BF080 rrrrrr  6   6410012         jsr     Fusb_device_register_service
                            10013 
                            10014 ; 164  |    usb_device_register_service(0,USBMSCRequestHandler);
                            10015 
P:001E 200013         2   6610017         clr     a   
P:001F 60F400 rrrrrr  3   6910018         move    #FUSBMSCRequestHandler,r0
P:0021 0BF080 rrrrrr  6   7510019         jsr     Fusb_device_register_service
                            10020 
                            10021 ; 165  |
                            10022 ; 166  |    usb_device_register_service(USB_SERVICE_BUS_RESET,UsbMscResetService);
                            10023 
P:0023 56F400 000010  3   7810025         move    #>16,a
P:0025 60F400 rrrrrr  3   8110026         move    #FUsbMscResetService,r0
P:0027 0BF080 rrrrrr  6   8710027         jsr     Fusb_device_register_service
                            10028 
                            10029 ; 167  |
                            10030 ; 168  |#ifdef DEVICE_3500
                            10031 ; 169  |    usb_device_register_service(USB_SERVICE_SUSPEND,UsbMscSuspendService);
                            10032 
P:0029 56F400 000011  3   9010034         move    #>17,a
P:002B 60F400 rrrrrr  3   9310035         move    #FUsbMscSuspendService,r0
P:002D 0BF080 rrrrrr  6   9910036         jsr     Fusb_device_register_service
                            10037 
                            10038 ; 170  |    usb_device_register_service(USB_SERVICE_RESUME,UsbMscResumeService);
                            10039 
P:002F 56F400 000013  3  10210041         move    #>19,a
P:0031 60F400 rrrrrr  3  10510042         move    #FUsbMscResumeService,r0
P:0033 0BF080 rrrrrr  6  11110043         jsr     Fusb_device_register_service
                            10044 
                            10045 ; 171  |#endif
                            10046 ; 172  |
                            10047 ; 173  |    for(i=0;i<SCSI_DEVICE_NUM_LUNS_DEV_0;i++)
                            10048 
P:0035 260000         2  11310050         move    #0,y0
P:0036 6DF000 rrrrrr  3  11610052         move    y:ss_UsbMscProjectInitDevice0+1,r5
                            10055 
                            10056 ; 174  |    {
                            10057 ; 175  |        ScsiLunSetupDefaultSenseData(&(pDev->Lun[i]));
                            10058 
P:0038 3D1400         2  11810060 L3:     move    #20,n5
P:0039 6D7000 rrrrrr  3  12110061         move    r5,y:ss_UsbMscProjectInitDevice0+1
P:003B 044D16         4  12510062         lua     (r5)+n5,r6
P:003C 4E7000 rrrrrr  3  12810065         move    y0,y:ss_UsbMscProjectInitDevice0+2
P:003E 45F400 000035  3  13110066         move    #>53,x1
P:0040 2000E8         2  13310067         mpy     y0,x1,b
P:0041 20002A         2  13510068         asr     b
P:0042 213E00         2  13710071         move    b0,n6
P:0043 7E7000 rrrrrr  3  14010072         move    n6,y:ss_UsbMscProjectInitDevice0+3
P:0045 204E00         2  14210073         move    (r6)+n6
P:0046 6E7000 rrrrrr  3  14510074         move    r6,y:ss_UsbMscProjectInitDevice0+4
P:0048 22D000         2  14710075         move    r6,r0
P:0049 0BF080 rrrrrr  6  15310076         jsr     FScsiLunSetupDefaultSenseData
P:004B 6CF000 rrrrrr  3  15610077         move    y:ss_UsbMscProjectInitDevice0+4,r4
P:004D 7EF000 rrrrrr  3  15910078         move    y:ss_UsbMscProjectInitDevice0+3,n6
                            10079 
                            10080 ; 176  |        pDev->Lun[i].wCompletionStatus = USBMSC_CSW_COMMAND_PASSED;
                            10081 
P:004F 3D1600         2  16110083         move    #22,n5
P:0050 6DF000 rrrrrr  3  16410084         move    y:ss_UsbMscProjectInitDevice0+1,r5
P:0052 000000         2  16610085         nop
P:0053 044D16         4  17010086         lua     (r5)+n5,r6
P:0054 000000         2  17210089         nop
P:0055 204E00         2  17410090         move    (r6)+n6
P:0056 20001B         2  17610091         clr     b   
P:0057 5D6600         2  17810092         move    b1,y:(r6)
                            10093 
                            10094 ; 177  |        pDev->Lun[i].dwNumBytesXferred = 0;
                            10095 
P:0058 595C00         2  18010097         move    b0,y:(r4)+
P:0059 5D5400         2  18210098         move    b1,y:(r4)-
P:005A 5FF000 rrrrrr  3  18510100         move    y:ss_UsbMscProjectInitDevice0+2,b
P:005C 44F400 000001  3  18810101         move    #>1,x0
P:005E 200048         2  19010102         add     x0,b
P:005F 21A600         2  19210105         move    b1,y0
P:0060 200059         2  19410108         tfr     y0,b
P:0061 47F400 000002  3  19710109         move    #>2,y1
P:0063 2B0000         2  19910110         move    #0,b2
P:0064 20007D         2  20110111         cmp     y1,b
P:0065 0AF0A9 rrrrrr  6  20710112         jlt     L3
                            10113 
                            10114 ; 178  |    }
                            10115 ; 179  |
                            10116 ; 180  |    // Lun 0 stuff
                            10117 ; 181  |    pDev->Lun[0].wInquiryVendorData[0] = (g_SCSIVendorID[0]<<16);
                            10118 
P:0067 4EF000 rrrrrr  3  21010120         move    y:Fg_SCSIVendorID,y0
P:0069 0108E8         2  21210122         mpy     y0,#8,b
P:006A 3D3300         2  21410123         move    #51,n5
P:006B 000000         2  21610124         nop
P:006C 044D16         4  22010125         lua     (r5)+n5,r6
P:006D 212500         2  22210126         move    b0,x1
P:006E 4D6600         2  22410127         move    x1,y:(r6)
                            10128 
                            10129 ; 182  |    pDev->Lun[0].wInquiryVendorData[1] = g_SCSIVendorID[1] | 
                            10130 ; 183  |        (g_SCSIVendorID[2]<<8) |
                            10131 ; 184  |        (g_SCSIVendorID[3]<<16);
                            10132 
P:006F 5CF000 rrrrrr  3  22710134         move    y:Fg_SCSIVendorID+1,a1
P:0071 4EF000 rrrrrr  3  23010135         move    y:Fg_SCSIVendorID+2,y0
P:0073 0110E8         2  23210136         mpy     y0,#16,b
P:0074 212600         2  23410137         move    b0,y0
P:0075 200052         2  23610138         or      y0,a
P:0076 4EF000 rrrrrr  3  23910139         move    y:Fg_SCSIVendorID+3,y0
P:0078 0108E8         2  24110140         mpy     y0,#8,b
P:0079 212700         2  24310141         move    b0,y1
P:007A 200072         2  24510142         or      y1,a
P:007B 3D3400         2  24710143         move    #52,n5
P:007C 000000         2  24910144         nop
P:007D 044D16         4  25310145         lua     (r5)+n5,r6
P:007E 218800         2  25510146         move    a1,a0
P:007F 586600         2  25710147         move    a0,y:(r6)
                            10148 
                            10149 ; 185  |    pDev->Lun[0].wInquiryVendorData[2] = g_SCSIVendorID[4] | 
                            10150 ; 186  |        (g_SCSIVendorID[5]<<8) |
                            10151 ; 187  |        (g_SCSIVendorID[6]<<16);
                            10152 
P:0080 5CF000 rrrrrr  3  26010154         move    y:Fg_SCSIVendorID+4,a1
P:0082 4FF000 rrrrrr  3  26310155         move    y:Fg_SCSIVendorID+5,y1
P:0084 0110C8         2  26510156         mpy     y1,#16,b
P:0085 212400         2  26710157         move    b0,x0
P:0086 200042         2  26910158         or      x0,a
P:0087 4EF000 rrrrrr  3  27210159         move    y:Fg_SCSIVendorID+6,y0
P:0089 0108E8         2  27410160         mpy     y0,#8,b
P:008A 212700         2  27610161         move    b0,y1
P:008B 200072         2  27810162         or      y1,a
P:008C 3D3500         2  28010163         move    #53,n5
P:008D 000000         2  28210164         nop
P:008E 044D16         4  28610165         lua     (r5)+n5,r6
P:008F 5C7000 rrrrrr  3  28910166         move    a1,y:ss_UsbMscProjectInitDevice0+2
P:0091 5C6600         2  29110167         move    a1,y:(r6)
                            10168 
                            10169 ; 188  |    pDev->Lun[0].wInquiryVendorData[3] = g_SCSIVendorID[7] | 
                            10170 ; 189  |        (g_SCSIProductID[0]<<8) |
                            10171 ; 190  |        (g_SCSIProductID[1]<<16);
                            10172 
P:0092 5CF000 rrrrrr  3  29410174         move    y:Fg_SCSIVendorID+7,a1
P:0094 4FF000 rrrrrr  3  29710175         move    y:Fg_SCSIProductID,y1
P:0096 0110C8         2  29910176         mpy     y1,#16,b
P:0097 212400         2  30110177         move    b0,x0
P:0098 200042         2  30310178         or      x0,a
P:0099 4EF000 rrrrrr  3  30610179         move    y:Fg_SCSIProductID+1,y0
P:009B 0108E8         2  30810180         mpy     y0,#8,b
P:009C 212700         2  31010181         move    b0,y1
P:009D 200072         2  31210182         or      y1,a
P:009E 3D3600         2  31410183         move    #54,n5
P:009F 000000         2  31610184         nop
P:00A0 044D16         4  32010185         lua     (r5)+n5,r6
P:00A1 5C7000 rrrrrr  3  32310186         move    a1,y:ss_UsbMscProjectInitDevice0+3
P:00A3 5C6600         2  32510187         move    a1,y:(r6)
                            10188 
                            10189 ; 191  |    pDev->Lun[0].wInquiryVendorData[4] = g_SCSIProductID[2] | 
                            10190 ; 192  |        (g_SCSIProductID[3]<<8) |
                            10191 ; 193  |        (g_SCSIProductID[4]<<16);
                            10192 
P:00A4 5CF000 rrrrrr  3  32810194         move    y:Fg_SCSIProductID+2,a1
P:00A6 4FF000 rrrrrr  3  33110195         move    y:Fg_SCSIProductID+3,y1
P:00A8 0110C8         2  33310196         mpy     y1,#16,b
P:00A9 212400         2  33510197         move    b0,x0
P:00AA 200042         2  33710198         or      x0,a
P:00AB 4EF000 rrrrrr  3  34010199         move    y:Fg_SCSIProductID+4,y0
P:00AD 0108E8         2  34210200         mpy     y0,#8,b
P:00AE 212700         2  34410201         move    b0,y1
P:00AF 200072         2  34610202         or      y1,a
P:00B0 3D3700         2  34810203         move    #55,n5
P:00B1 000000         2  35010204         nop
P:00B2 044D16         4  35410205         lua     (r5)+n5,r6
P:00B3 5C7000 rrrrrr  3  35710206         move    a1,y:ss_UsbMscProjectInitDevice0+4
P:00B5 5C6600         2  35910207         move    a1,y:(r6)
                            10208 
                            10209 ; 194  |    pDev->Lun[0].wInquiryVendorData[5] = g_SCSIProductID[5] | 
                            10210 ; 195  |        (g_SCSIProductID[6]<<8) |
                            10211 ; 196  |        (g_SCSIProductID[7]<<16);
                            10212 
P:00B6 5CF000 rrrrrr  3  36210214         move    y:Fg_SCSIProductID+5,a1
P:00B8 4FF000 rrrrrr  3  36510215         move    y:Fg_SCSIProductID+6,y1
P:00BA 0110C8         2  36710216         mpy     y1,#16,b
P:00BB 212400         2  36910217         move    b0,x0
P:00BC 200042         2  37110218         or      x0,a
P:00BD 4EF000 rrrrrr  3  37410219         move    y:Fg_SCSIProductID+7,y0
P:00BF 0108E8         2  37610220         mpy     y0,#8,b
P:00C0 212700         2  37810221         move    b0,y1
P:00C1 200072         2  38010222         or      y1,a
P:00C2 3D3800         2  38210223         move    #$38,n5
P:00C3 000000         2  38410224         nop
P:00C4 044D16         4  38810225         lua     (r5)+n5,r6
P:00C5 5C7000 rrrrrr  3  39110226         move    a1,y:ss_UsbMscProjectInitDevice0+5
P:00C7 5C6600         2  39310227         move    a1,y:(r6)
                            10228 
                            10229 ; 197  |    pDev->Lun[0].wInquiryVendorData[6] = g_SCSIProductID[8] | 
                            10230 ; 198  |        (g_SCSIProductID[9]<<8) |
                            10231 ; 199  |        (g_SCSIProductID[10]<<16);
                            10232 
P:00C8 5CF000 rrrrrr  3  39610234         move    y:Fg_SCSIProductID+8,a1
P:00CA 4FF000 rrrrrr  3  39910235         move    y:Fg_SCSIProductID+9,y1
P:00CC 0110C8         2  40110236         mpy     y1,#16,b
P:00CD 212400         2  40310237         move    b0,x0
P:00CE 200042         2  40510238         or      x0,a
P:00CF 4EF000 rrrrrr  3  40810239         move    y:Fg_SCSIProductID+10,y0
P:00D1 0108E8         2  41010240         mpy     y0,#8,b
P:00D2 212700         2  41210241         move    b0,y1
P:00D3 200072         2  41410242         or      y1,a
P:00D4 3D3900         2  41610243         move    #$39,n5
P:00D5 000000         2  41810244         nop
P:00D6 044D16         4  42210245         lua     (r5)+n5,r6
P:00D7 5C7000 rrrrrr  3  42510246         move    a1,y:ss_UsbMscProjectInitDevice0+6
P:00D9 5C6600         2  42710247         move    a1,y:(r6)
                            10248 
                            10249 ; 200  |    pDev->Lun[0].wInquiryVendorData[7] = g_SCSIProductID[11] | 
                            10250 ; 201  |        (g_SCSIProductID[12]<<8) |
                            10251 ; 202  |        (g_SCSIProductID[13]<<16);
                            10252 
P:00DA 5CF000 rrrrrr  3  43010254         move    y:Fg_SCSIProductID+11,a1
P:00DC 4FF000 rrrrrr  3  43310255         move    y:Fg_SCSIProductID+12,y1
P:00DE 0110C8         2  43510256         mpy     y1,#16,b
P:00DF 212400         2  43710257         move    b0,x0
P:00E0 200042         2  43910258         or      x0,a
P:00E1 4EF000 rrrrrr  3  44210259         move    y:Fg_SCSIProductID+13,y0
P:00E3 0108E8         2  44410260         mpy     y0,#8,b
P:00E4 212700         2  44610261         move    b0,y1
P:00E5 200072         2  44810262         or      y1,a
P:00E6 3D3A00         2  45010263         move    #58,n5
P:00E7 000000         2  45210264         nop
P:00E8 044D16         4  45610265         lua     (r5)+n5,r6
TASKING DSP2410 assembler v1.5r1 Build 138 SN 00100122
                                                                                                                                                                                                                                                       Page  37

M:ADDR CODE           CYCLES LINE SOURCELINE
P:00E9 000000         2  45810266         nop
P:00EA 5C6600         2  46010267         move    a1,y:(r6)
                            10268 
                            10269 ; 203  |    pDev->Lun[0].wInquiryVendorData[8] = g_SCSIProductID[14] | 
                            10270 ; 204  |        (g_SCSIProductID[15]<<8) |
                            10271 ; 205  |        ('0'<<16);
                            10272 
P:00EB 6EF000 rrrrrr  3  46310274         move    y:Fg_SCSIProductID+14,r6
P:00ED 4FF000 rrrrrr  3  46610275         move    y:Fg_SCSIProductID+15,y1
P:00EF 0110C8         2  46810276         mpy     y1,#16,b
P:00F0 212400         2  47010277         move    b0,x0
P:00F1 22CD00         2  47210278         move    r6,b1
P:00F2 20004A         2  47410279         or      x0,b
P:00F3 21A400         2  47610280         move    b1,x0
P:00F4 0AC474         4  48010281         bset    #20,x0
P:00F5 0AC475         4  48410282         bset    #21,x0
P:00F6 3D3B00         2  48610283         move    #59,n5
P:00F7 000000         2  48810284         nop
P:00F8 044D16         4  49210285         lua     (r5)+n5,r6
P:00F9 000000         2  49410286         nop
P:00FA 4C6600         2  49610287         move    x0,y:(r6)
                            10288 
                            10289 ; 206  |    pDev->Lun[0].wInquiryVendorData[9] = '1' | 
                            10290 ; 207  |        ('0'<<8) |
                            10291 ; 208  |        ('0'<<16);
                            10292 
P:00FB 3D3C00         2  49810294         move    #$3C,n5
P:00FC 000000         2  50010295         nop
P:00FD 044D16         4  50410296         lua     (r5)+n5,r6
P:00FE 57F400 303031  3  50710297         move    #3158065,b
P:0100 5D6600         2  50910298         move    b1,y:(r6)
                            10299 
                            10300 ; 209  |
                            10301 ; 210  |    pDev->Lun[0].wInquiryVendorSpecific[0] = 
                            10302 ; 211  |        (0<<20) | (pDev->wDeviceNumber<<16) |             // Lun 0, Device num
                            10303 ; 212  |        (SCSI_INQUIRY_VENDOR_SPECIFIC_STRUCT_MDS<<8) | 1; // MDS, 1 struct       
                            10304 
P:0101 46F400 000001  3  51210306         move    #>1,y0
P:0103 045D16         4  51610307         lua     (r5)+,r6
P:0104 000000         2  51810308         nop
P:0105 4FE600         2  52010309         move    y:(r6),y1
P:0106 0108C8         2  52210310         mpy     y1,#8,b
P:0107 0AC960         4  52610311         bset    #0,b0
P:0108 0AC968         4  53010312         bset    #8,b0
P:0109 3D3D00         2  53210313         move    #$3D,n5
P:010A 000000         2  53410314         nop
P:010B 044D14         4  53810315         lua     (r5)+n5,r4
P:010C 000000         2  54010316         nop
P:010D 596400         2  54210317         move    b0,y:(r4)
                            10318 
                            10319 ; 213  |    pDev->Lun[0].wInquiryVendorSpecific[1] = 
                            10320 ; 214  |        (SCSI_MDS_MEDIA_TYPE_NAND<<8) |                   // Nand
                            10321 ; 215  |        SCSI_MDS_FLAGS_SYSTEM_MEDIA_FLAG_SYSTEM;          // System media 
                            10322 
P:010E 3D3E00         2  54410324         move    #$3E,n5
P:010F 000000         2  54610325         nop
P:0110 044D14         4  55010326         lua     (r5)+n5,r4
P:0111 000000         2  55210327         nop
P:0112 4E6400         2  55410328         move    y0,y:(r4)
                            10329 
                            10330 ; 216  |    pDev->Lun[0].wInquiryVendorSpecific[2] = 0;
                            10331 
P:0113 3D3F00         2  55610333         move    #$3F,n5
P:0114 000000         2  55810334         nop
P:0115 044D14         4  56210335         lua     (r5)+n5,r4
P:0116 3A0000         2  56410336         move    #0,n2
P:0117 7A6400         2  56610337         move    n2,y:(r4)
                            10338 
                            10339 ; 217  |    pDev->Lun[0].wInquiryVendorSpecific[3] = 0;
                            10340 
P:0118 3D4000         2  56810342         move    #$40,n5
P:0119 000000         2  57010343         nop
P:011A 044D14         4  57410344         lua     (r5)+n5,r4
P:011B 000000         2  57610345         nop
P:011C 7A6400         2  57810346         move    n2,y:(r4)
                            10347 
                            10348 ; 218  |    pDev->Lun[0].wInquiryVendorSpecific[4] = 0;
                            10349 
P:011D 3D4100         2  58010351         move    #$41,n5
P:011E 000000         2  58210352         nop
P:011F 044D14         4  58610353         lua     (r5)+n5,r4
P:0120 000000         2  58810354         nop
P:0121 7A6400         2  59010355         move    n2,y:(r4)
                            10356 
                            10357 ; 219  |    pDev->Lun[0].wInquiryVendorSpecific[5] = 0;
                            10358 
P:0122 3D4200         2  59210360         move    #66,n5
P:0123 000000         2  59410361         nop
P:0124 044D14         4  59810362         lua     (r5)+n5,r4
P:0125 000000         2  60010363         nop
P:0126 7A6400         2  60210364         move    n2,y:(r4)
                            10365 
                            10366 ; 220  |    pDev->Lun[0].wInquiryVendorSpecific[6] = 0;
                            10367 
P:0127 3D4300         2  60410369         move    #67,n5
P:0128 000000         2  60610370         nop
P:0129 044D14         4  61010371         lua     (r5)+n5,r4
P:012A 000000         2  61210372         nop
P:012B 7A6400         2  61410373         move    n2,y:(r4)
                            10374 
                            10375 ; 221  |    pDev->Lun[0].FlagMediaChange = ScsiDummyFlagMediaChange;
                            10376 
P:012C 3D4400         2  61610378         move    #68,n5
P:012D 000000         2  61810379         nop
P:012E 044D14         4  62210380         lua     (r5)+n5,r4
P:012F 76F400 rrrrrr  3  62510381         move    #FScsiDummyFlagMediaChange,n6
P:0131 7E6400         2  62710382         move    n6,y:(r4)
                            10383 
                            10384 ; 222  |
                            10385 ; 223  |#if (MULTI_LUN_BUILD==1)
                            10386 ; 224  |    // Lun 1 stuff
                            10387 ; 225  |    pDev->Lun[1].wInquiryVendorData[0] = (g_SCSIVendorID[0]<<16);
                            10388 
P:0132 3D6800         2  62910390         move    #104,n5
P:0133 000000         2  63110391         nop
P:0134 044D14         4  63510392         lua     (r5)+n5,r4
P:0135 000000         2  63710393         nop
P:0136 4D6400         2  63910394         move    x1,y:(r4)
                            10395 
                            10396 ; 226  |    pDev->Lun[1].wInquiryVendorData[1] = g_SCSIVendorID[1] | 
                            10397 ; 227  |        (g_SCSIVendorID[2]<<8) |
                            10398 ; 228  |        (g_SCSIVendorID[3]<<16);
                            10399 
P:0137 3D6900         2  64110401         move    #105,n5
P:0138 000000         2  64310402         nop
P:0139 044D14         4  64710403         lua     (r5)+n5,r4
P:013A 000000         2  64910404         nop
P:013B 586400         2  65110405         move    a0,y:(r4)
                            10406 
                            10407 ; 229  |    pDev->Lun[1].wInquiryVendorData[2] = g_SCSIVendorID[4] | 
                            10408 ; 230  |        (g_SCSIVendorID[5]<<8) |
                            10409 ; 231  |        (g_SCSIVendorID[6]<<16);
                            10410 
P:013C 3D6A00         2  65310412         move    #106,n5
P:013D 000000         2  65510413         nop
P:013E 044D14         4  65910414         lua     (r5)+n5,r4
P:013F 58F000 rrrrrr  3  66210415         move    y:ss_UsbMscProjectInitDevice0+2,a0
P:0141 586400         2  66410416         move    a0,y:(r4)
                            10417 
                            10418 ; 232  |    pDev->Lun[1].wInquiryVendorData[3] = g_SCSIVendorID[7] | 
                            10419 ; 233  |        (g_SCSIProductID[0]<<8) |
                            10420 ; 234  |        (g_SCSIProductID[1]<<16);
                            10421 
P:0142 3D6B00         2  66610423         move    #107,n5
P:0143 000000         2  66810424         nop
P:0144 044D14         4  67210425         lua     (r5)+n5,r4
P:0145 4FF000 rrrrrr  3  67510426         move    y:ss_UsbMscProjectInitDevice0+3,y1
P:0147 4F6400         2  67710427         move    y1,y:(r4)
                            10428 
                            10429 ; 235  |    pDev->Lun[1].wInquiryVendorData[4] = g_SCSIProductID[2] | 
                            10430 ; 236  |        (g_SCSIProductID[3]<<8) |
                            10431 ; 237  |        (g_SCSIProductID[4]<<16);
                            10432 
P:0148 3D6C00         2  67910434         move    #108,n5
P:0149 000000         2  68110435         nop
P:014A 044D14         4  68510436         lua     (r5)+n5,r4
P:014B 5DF000 rrrrrr  3  68810437         move    y:ss_UsbMscProjectInitDevice0+4,b1
P:014D 5D6400         2  69010438         move    b1,y:(r4)
                            10439 
                            10440 ; 238  |    pDev->Lun[1].wInquiryVendorData[5] = g_SCSIProductID[5] | 
                            10441 ; 239  |        (g_SCSIProductID[6]<<8) |
                            10442 ; 240  |        (g_SCSIProductID[7]<<16);
                            10443 
P:014E 3D6D00         2  69210445         move    #109,n5
P:014F 000000         2  69410446         nop
P:0150 044D14         4  69810447         lua     (r5)+n5,r4
P:0151 4FF000 rrrrrr  3  70110448         move    y:ss_UsbMscProjectInitDevice0+5,y1
P:0153 4F6400         2  70310449         move    y1,y:(r4)
                            10450 
                            10451 ; 241  |    pDev->Lun[1].wInquiryVendorData[6] = g_SCSIProductID[8] | 
                            10452 ; 242  |        (g_SCSIProductID[9]<<8) |
                            10453 ; 243  |        (g_SCSIProductID[10]<<16);
                            10454 
P:0154 3D6E00         2  70510456         move    #110,n5
P:0155 000000         2  70710457         nop
P:0156 044D14         4  71110458         lua     (r5)+n5,r4
P:0157 5DF000 rrrrrr  3  71410459         move    y:ss_UsbMscProjectInitDevice0+6,b1
P:0159 5D6400         2  71610460         move    b1,y:(r4)
                            10461 
                            10462 ; 244  |    pDev->Lun[1].wInquiryVendorData[7] = g_SCSIProductID[11] | 
                            10463 ; 245  |        (g_SCSIProductID[12]<<8) |
                            10464 ; 246  |        (g_SCSIProductID[13]<<16);
                            10465 
P:015A 3D6F00         2  71810467         move    #111,n5
P:015B 000000         2  72010468         nop
P:015C 044D14         4  72410469         lua     (r5)+n5,r4
P:015D 000000         2  72610470         nop
P:015E 5C6400         2  72810471         move    a1,y:(r4)
                            10472 
                            10473 ; 247  |    pDev->Lun[1].wInquiryVendorData[8] = g_SCSIProductID[14] | 
                            10474 ; 248  |        (g_SCSIProductID[15]<<8) |
                            10475 ; 249  |        ('0'<<16);
                            10476 
P:015F 3D7000         2  73010478         move    #$70,n5
P:0160 000000         2  73210479         nop
P:0161 044D14         4  73610480         lua     (r5)+n5,r4
P:0162 000000         2  73810481         nop
P:0163 4C6400         2  74010482         move    x0,y:(r4)
                            10483 
                            10484 ; 250  |    pDev->Lun[1].wInquiryVendorData[9] = '1' | 
                            10485 ; 251  |        ('0'<<8) |
                            10486 ; 252  |        ('0'<<16);
                            10487 
P:0164 3D7100         2  74210489         move    #$71,n5
P:0165 000000         2  74410490         nop
P:0166 044D14         4  74810491         lua     (r5)+n5,r4
P:0167 54F400 303031  3  75110492         move    #3158065,a1
P:0169 5C6400         2  75310493         move    a1,y:(r4)
                            10494 
                            10495 ; 253  |
                            10496 ; 254  |    pDev->Lun[1].wInquiryVendorSpecific[0] = 
                            10497 ; 255  |        (0<<20) | (pDev->wDeviceNumber<<16) |             // Lun 0, Device num
                            10498 ; 256  |        (SCSI_INQUIRY_VENDOR_SPECIFIC_STRUCT_MDS<<8) | 1; // MDS, 1 struct       
                            10499 
P:016A 4FE600         2  75510501         move    y:(r6),y1
P:016B 0108C8         2  75710502         mpy     y1,#8,b
P:016C 0AC960         4  76110503         bset    #0,b0
P:016D 0AC968         4  76510504         bset    #8,b0
P:016E 3D7200         2  76710505         move    #114,n5
P:016F 000000         2  76910506         nop
P:0170 044D16         4  77310507         lua     (r5)+n5,r6
P:0171 000000         2  77510508         nop
P:0172 596600         2  77710509         move    b0,y:(r6)
                            10510 
                            10511 ; 257  |    pDev->Lun[1].wInquiryVendorSpecific[1] = 
                            10512 ; 258  |        #ifdef MMC
                            10513 ; 259  |            (SCSI_MDS_MEDIA_TYPE_MMC_UNKNOWN_VERSION<<8) |    // MMC
                            10514 ; 260  |        #else
                            10515 ; 261  |            (SCSI_MDS_MEDIA_TYPE_SMARTMEDIA<<8) |             // SmartMedia
                            10516 ; 262  |        #endif
                            10517 ; 263  |        SCSI_MDS_FLAGS_SYSTEM_MEDIA_FLAG_NON_SYSTEM;      // Non-system media 
                            10518 
P:0173 3D7300         2  77910520         move    #115,n5
P:0174 000000         2  78110521         nop
P:0175 044D16         4  78510522         lua     (r5)+n5,r6
P:0176 47F400 001300  3  78810523         move    #$1300,y1
P:0178 4F6600         2  79010524         move    y1,y:(r6)
                            10525 
                            10526 ; 264  |    pDev->Lun[1].wInquiryVendorSpecific[2] = 0;
                            10527 
P:0179 3D7400         2  79210529         move    #116,n5
P:017A 000000         2  79410530         nop
P:017B 044D16         4  79810531         lua     (r5)+n5,r6
P:017C 000000         2  80010532         nop
P:017D 7A6600         2  80210533         move    n2,y:(r6)
                            10534 
                            10535 ; 265  |    pDev->Lun[1].wInquiryVendorSpecific[3] = 0;
                            10536 
P:017E 3D7500         2  80410538         move    #117,n5
P:017F 000000         2  80610539         nop
P:0180 044D16         4  81010540         lua     (r5)+n5,r6
TASKING DSP2410 assembler v1.5r1 Build 138 SN 00100122
                                                                                                                                                                                                                                                       Page  38

M:ADDR CODE           CYCLES LINE SOURCELINE
P:0181 000000         2  81210541         nop
P:0182 7A6600         2  81410542         move    n2,y:(r6)
                            10543 
                            10544 ; 266  |    pDev->Lun[1].wInquiryVendorSpecific[4] = 0;
                            10545 
P:0183 3D7600         2  81610547         move    #118,n5
P:0184 000000         2  81810548         nop
P:0185 044D16         4  82210549         lua     (r5)+n5,r6
P:0186 000000         2  82410550         nop
P:0187 7A6600         2  82610551         move    n2,y:(r6)
                            10552 
                            10553 ; 267  |    pDev->Lun[1].wInquiryVendorSpecific[5] = 0;
                            10554 
P:0188 3D7700         2  82810556         move    #119,n5
P:0189 000000         2  83010557         nop
P:018A 044D16         4  83410558         lua     (r5)+n5,r6
P:018B 000000         2  83610559         nop
P:018C 7A6600         2  83810560         move    n2,y:(r6)
                            10561 
                            10562 ; 268  |    pDev->Lun[1].wInquiryVendorSpecific[6] = 0;
                            10563 
P:018D 3D7800         2  84010565         move    #$78,n5
P:018E 000000         2  84210566         nop
P:018F 044D16         4  84610567         lua     (r5)+n5,r6
P:0190 000000         2  84810568         nop
P:0191 7A6600         2  85010569         move    n2,y:(r6)
                            10570 
                            10571 ; 269  |    #ifdef MMC
                            10572 ; 270  |        pDev->Lun[1].FlagMediaChange = MmcFlagMediaChange;
                            10573 
P:0192 3D7900         2  85210575         move    #$79,n5
P:0193 000000         2  85410576         nop
P:0194 044D16         4  85810577         lua     (r5)+n5,r6
P:0195 62F400 rrrrrr  3  86110578         move    #FMmcFlagMediaChange,r2
P:0197 6A6600         2  86310579         move    r2,y:(r6)
                            10580 
                            10581 ; 271  |    #else
                            10582 ; 272  |        pDev->Lun[1].FlagMediaChange = ScsiDummyFlagMediaChange;
                            10583 ; 273  |    #endif
                            10584 ; 274  |    
                            10585 ; 275  |#endif   //MultiLUN build.
                            10586 ; 276  |    // Add one to the length of the sector buffer to account for the USB DMA defect
                            10587 ; 277  |    sectorBufferSizeInWords = g_NandAuxData.SectorTotalSizeInWords + 1;
                            10588 
P:0198 5FF000 rrrrrr  3  86610590         move    y:Fg_NandAuxData+5,b
P:019A 200058         2  86810591         add     y0,b
                            10593 
                            10594 ; 278  |    // Pad the start address of the buffer array to avoid the USB DMA defect
                            10595 ; 279  |    SectorArrayInitialize(&pDev->SectorArray,USBMSC_TOTAL_BUFFER_SIZE/sectorBufferSizeInWords,sectorBufferSizeInWords, Target0SectorArray,(Target0BufferArray+1));
                            10596 
P:019B 38EC00         2  87010598         move    #236,n0
P:019C 22B000         2  87210599         move    r5,r0
P:019D 000000         2  87410600         nop
P:019E 204800         2  87610601         move    (r0)+n0
P:019F 56F400 000B11  3  87910604         move    #2833,a
P:01A1 0BF080 rrrrrr  6  88510605         jsr     Rdiv_uiuiui
P:01A3 210E00         2  88710606         move    a0,a
P:01A4 61F400 rrrrrr  3  89010607         move    #FTarget0BufferArray+1,r1
P:01A6 64F400 rrrrrr  3  89310608         move    #FTarget0SectorArray,r4
P:01A8 0BF080 rrrrrr  6  89910609         jsr     FSectorArrayInitialize
                            10611 
                            10612 ; 280  |
                            10613 ; 281  |    // Device1CommandInBuffer is shared with Mtp
                            10614 ; 282  |    pDev->CommandInBuffer  = Device1CommandInBuffer;
                            10615 
P:01AA 3E0400         2  90110617         move    #4,n6
P:01AB 6EF000 rrrrrr  3  90410618         move    y:ss_UsbMscProjectInitDevice0+1,r6
P:01AD 000000         2  90610619         nop
P:01AE 044E15         4  91010620         lua     (r6)+n6,r5
P:01AF 61F400 rrrrrr  3  91310623         move    #FDevice1CommandInBuffer,r1
P:01B1 696500         2  91510624         move    r1,y:(r5)
                            10625 
                            10626 ; 283  |    pDev->CommandOutBuffer = Device1CommandOutBuffer;
                            10627 
P:01B2 3E0300         2  91710629         move    #3,n6
P:01B3 000000         2  91910630         nop
P:01B4 204E00         2  92110631         move    (r6)+n6
P:01B5 71F400 rrrrrr  3  92410633         move    #FDevice1CommandOutBuffer,n1
P:01B7 796600         2  92610634         move    n1,y:(r6)
                            10635 
                            10636 ; 284  |
                            10637 ; 285  |    return SUCCESS;
                            10638 
P:01B8 200013         2  92810640         clr     a   
P:01B9 218E00         2  93010641         move    a1,a
                            10642 
                            10643 ; 286  |}
                            10644 
P:01BA 05F07C rrrrrr  4  93410646         movec   y:ss_UsbMscProjectInitDevice0,ssh
P:01BC 000000         2  93610648         nop
P:01BD 00000C         4  94010649         rts
                            10650 
Y:0000                      10651         org     y,".yovlusbmscproject@UsbMscProjectInitDevice0",overlay:
                            10652 ss_UsbMscProjectInitDevice0:
Y:0000                      10653         ds      8
   |   RESERVED                   
Y:0007
                            10654 
P:01BE                      10655         org     p,".ptextusbmscproject":
                            10657 
                            10658 ; 287  |
                            10659 ; 288  |////////////////////////////////////////////////////////////////////////////////
                            10660 ; 289  |//
                            10661 ; 290  |//>  Name:          UsbMscProjectResetDevice0
                            10662 ; 291  |//
                            10663 ; 292  |//   Type:          Function
                            10664 ; 293  |//
                            10665 ; 294  |//   Description:   Project-specific USB MSC device reset for device 0
                            10666 ; 295  |//
                            10667 ; 296  |//   Inputs:        none
                            10668 ; 297  |//
                            10669 ; 298  |//   Outputs:       RETCODE
                            10670 ; 299  |//
                            10671 ; 300  |//   Notes:         none
                            10672 ; 301  |//<
                            10673 ; 302  |////////////////////////////////////////////////////////////////////////////////
                            10674 ; 303  |RETCODE UsbMscProjectResetDevice0(void)
                            10675 ; 304  |{
                            10676 
                            10681 FUsbMscProjectResetDevice0:
P:01BE 05707C rrrrrr  4  94410682         movec   ssh,y:ss_UsbMscProjectResetDevice0
                            10688 
                            10689 ; 305  |    USBMSC_DEVICE * pDev;
                            10690 ; 306  |    WORD i;
                            10691 ; 307  |    
                            10692 ; 308  |    // Device 0 setup
                            10693 ; 309  |    pDev = &(UsbMscDevice[USBMSC_DEVICE_0]);
                            10694 
P:01C0 64F400 rrrrrr  3  94710696         move    #FUsbMscDevice,r4
                            10698 
                            10699 ; 310  |
                            10700 ; 311  |    pDev->wDeviceNumber = 0;
                            10701 
P:01C2 2D0100         2  94910703         move    #1,b1
P:01C3 045C16         4  95310704         lua     (r4)+,r6
P:01C4 200013         2  95510705         clr     a   
P:01C5 5C6600         2  95710706         move    a1,y:(r6)
                            10707 
                            10708 ; 312  |
                            10709 ; 313  |    // Setup the BulkIn Endpoint
                            10710 ; 314  |    pDev->wBulkInEndpointNum=1;
                            10711 
P:01C6 290200         2  95910713         move    #2,b0
P:01C7 3C0200         2  96110714         move    #2,n4
P:01C8 000000         2  96310715         nop
P:01C9 044C16         4  96710716         lua     (r4)+n4,r6
P:01CA 000000         2  96910717         nop
P:01CB 5D6600         2  97110718         move    b1,y:(r6)
                            10719 
                            10720 ; 315  |
                            10721 ; 316  |#ifdef DEVICE_3500
                            10722 ; 317  |    // Setup the BulkOut Endpoint
                            10723 ; 318  |    pDev->wBulkOutEndpointNum=2;
                            10724 
P:01CC 3C0600         2  97310726         move    #6,n4
P:01CD 000000         2  97510727         nop
P:01CE 044C16         4  97910728         lua     (r4)+n4,r6
P:01CF 000000         2  98110729         nop
P:01D0 596600         2  98310730         move    b0,y:(r6)
                            10731 
                            10732 ; 319  |#else
                            10733 ; 320  |    // Setup the BulkOut Endpoint
                            10734 ; 321  |    pDev->wBulkOutEndpointNum=4;
                            10735 ; 322  |#endif
                            10736 ; 323  |
                            10737 ; 324  |    // Setup the Usb Interface
                            10738 ; 325  |    pDev->wInterface = 0;
                            10739 
P:01D1 3C0700         2  98510741         move    #7,n4
P:01D2 6C7000 rrrrrr  3  98810742         move    r4,y:ss_UsbMscProjectResetDevice0+1
P:01D4 044C16         4  99210743         lua     (r4)+n4,r6
P:01D5 000000         2  99410746         nop
P:01D6 5C6600         2  99610747         move    a1,y:(r6)
                            10748 
                            10749 ; 326  |
                            10750 ; 327  |    // prevent MMC enum & USB current overage if we're in low power mode.
                            10751 ; 328  |    // This reports max lun dev num as having no additional removable media other 
                            10752 ; 329  |    // than NAND flash drive, so mmc drive does not appear on USBMSC peer.  
                            10753 ; 330  |    if ( usb_get_current_limit() <= 100)
                            10754 
P:01D7 0BF080 rrrrrr  6 100210756         jsr     Fusb_get_current_limit
P:01D9 46F400 000064  3 100510757         move    #>100,y0
P:01DB 2A0000         2 100710758         move    #0,a2
P:01DC 200055         2 100910759         cmp     y0,a
P:01DD 0AF0A7 rrrrrr  6 101510760         jgt     L4
                            10761 
                            10762 ; 331  |        pDev->wNumLunsSupported = 1; // JLN: emulates case: NUM_REMOVABLE_MEDIA==0. (non MMC case). Reviewed. 
                            10763 
P:01DF 3E0800         2 101710765         move    #8,n6
P:01E0 6EF000 rrrrrr  3 102010766         move    y:ss_UsbMscProjectResetDevice0+1,r6
P:01E2 22D500         2 102210767         move    r6,r5
P:01E3 204E00         2 102410768         move    (r6)+n6
P:01E4 290100         2 102610771         move    #1,b0
P:01E5 0AF080 rrrrrr  6 103210772         jmp     L5
                            10773 
                            10774 ; 332  |    else
                            10775 ; 333  |        pDev->wNumLunsSupported = SCSI_DEVICE_NUM_LUNS_DEV_0;
                            10776 
                            10778 L4:
P:01E7 3E0800         2 103410781         move    #8,n6
P:01E8 6EF000 rrrrrr  3 103710782         move    y:ss_UsbMscProjectResetDevice0+1,r6
P:01EA 22D500         2 103910783         move    r6,r5
P:01EB 204E00         2 104110784         move    (r6)+n6
P:01EC 290200         2 104310787         move    #2,b0
P:01ED 596600         2 104510788 L5:     move    b0,y:(r6)
                            10789 
                            10790 ; 334  |
                            10791 ; 335  |    pDev->bCommandActive = FALSE;
                            10792 
P:01EE 3DE800         2 104710794         move    #232,n5
P:01EF 000000         2 104910795         nop
P:01F0 044D16         4 105310796         lua     (r5)+n5,r6
P:01F1 240000         2 105510797         move    #0,x0
P:01F2 4C6600         2 105710798         move    x0,y:(r6)
                            10799 
                            10800 ; 336  |    pDev->bMSCReset = FALSE;
                            10801 
P:01F3 3DE900         2 105910803         move    #233,n5
P:01F4 000000         2 106110804         nop
P:01F5 044D16         4 106510805         lua     (r5)+n5,r6
P:01F6 000000         2 106710806         nop
P:01F7 4C6600         2 106910807         move    x0,y:(r6)
                            10808 
                            10809 ; 337  |    pDev->InitializeFunction = UsbMscProjectInitDevice0;
                            10810 
P:01F8 3DEA00         2 107110812         move    #234,n5
P:01F9 000000         2 107310813         nop
P:01FA 044D16         4 107710814         lua     (r5)+n5,r6
P:01FB 70F400 rrrrrr  3 108010815         move    #FUsbMscProjectInitDevice0,n0
P:01FD 786600         2 108210816         move    n0,y:(r6)
                            10817 
                            10818 ; 338  |    pDev->ResetFunction = UsbMscProjectResetDevice0;
                            10819 
P:01FE 3DEB00         2 108410821         move    #235,n5
P:01FF 000000         2 108610822         nop
P:0200 044D16         4 109010823         lua     (r5)+n5,r6
P:0201 47F400 rrrrrr  3 109310824         move    #FUsbMscProjectResetDevice0,y1
P:0203 4F6600         2 109510825         move    y1,y:(r6)
                            10826 
                            10827 ; 339  |    
                            10828 ; 340  |    //TODO:  Set up sectors
                            10829 ; 341  |    
                            10830 ; 342  |    for(i=0;i<SCSI_DEVICE_NUM_LUNS_DEV_0;i++)
                            10831 
P:0204 45F400 000002  3 109810833         move    #>2,x1
P:0206 200061         2 110010834         tfr     x1,a
P:0207 200049         2 110210835         tfr     x0,b
P:0208 46F400 000035  3 110510837         move    #>53,y0
P:020A 200003         2 110710838         tst     a
P:020B 0AF0AA rrrrrr  6 111310839         jeq     L7
P:020D 06CC00 rrrrrr  6 111910840         do      a1,L7
TASKING DSP2410 assembler v1.5r1 Build 138 SN 00100122
                                                                                                                                                                                                                                                       Page  39

M:ADDR CODE           CYCLES LINE SOURCELINE
                            10842 
                            10843 ; 343  |    {
                            10844 ; 344  |        pDev->Lun[i].bStopped = FALSE;
                            10845 
P:020F 3D1E00         2 112110847         move    #30,n5
P:0210 000000         2 112310848         nop
P:0211 044D16         4 112710849         lua     (r5)+n5,r6
P:0212 21A700         2 112910850         move    b1,y1
P:0213 2000B0         2 113110851         mpy     y1,y0,a
P:0214 200022         2 113310852         asr     a
P:0215 211E00         2 113510853         move    a0,n6
P:0216 211C00         2 113710854         move    a0,n4
P:0217 204E00         2 113910855         move    (r6)+n6
P:0218 4C6600         2 114110856         move    x0,y:(r6)
                            10857 
                            10858 ; 345  |        pDev->Lun[i].bWriteProtected = FALSE;
                            10859 
P:0219 3D1F00         2 114310861         move    #$1F,n5
P:021A 000000         2 114510862         nop
P:021B 044D16         4 114910863         lua     (r5)+n5,r6
P:021C 000000         2 115110864         nop
P:021D 204E00         2 115310865         move    (r6)+n6
P:021E 4C6600         2 115510866         move    x0,y:(r6)
                            10867 
                            10868 ; 346  |        pDev->Lun[i].bMediaConnected = TRUE;      // This is the internal media
                            10869 
P:021F 3D2000         2 115710871         move    #$20,n5
P:0220 000000         2 115910872         nop
P:0221 044D16         4 116310873         lua     (r5)+n5,r6
P:0222 000000         2 116510874         nop
P:0223 204E00         2 116710875         move    (r6)+n6
P:0224 47F400 000001  3 117010876         move    #>1,y1
P:0226 4F6600         2 117210877         move    y1,y:(r6)
                            10878 
                            10879 ; 347  |        pDev->Lun[i].bMediaIsRemovable = FALSE;
                            10880 
P:0227 3D2100         2 117410882         move    #$21,n5
P:0228 000000         2 117610883         nop
P:0229 044D16         4 118010884         lua     (r5)+n5,r6
P:022A 000000         2 118210885         nop
P:022B 204E00         2 118410886         move    (r6)+n6
P:022C 4C6600         2 118610887         move    x0,y:(r6)
                            10888 
                            10889 ; 348  |        pDev->Lun[i].wRemovableType = 0;          // don't care
                            10890 
P:022D 3D2200         2 118810892         move    #34,n5
P:022E 000000         2 119010893         nop
P:022F 044D16         4 119410894         lua     (r5)+n5,r6
P:0230 000000         2 119610895         nop
P:0231 204E00         2 119810896         move    (r6)+n6
P:0232 4C6600         2 120010897         move    x0,y:(r6)
                            10898 
                            10899 ; 349  |        pDev->Lun[i].wRemovableEntry = 0;         // don't care
                            10900 
P:0233 3D2300         2 120210902         move    #35,n5
P:0234 000000         2 120410903         nop
P:0235 044D16         4 120810904         lua     (r5)+n5,r6
P:0236 000000         2 121010905         nop
P:0237 204E00         2 121210906         move    (r6)+n6
P:0238 4C6600         2 121410907         move    x0,y:(r6)
                            10908 
                            10909 ; 350  |        pDev->Lun[i].wRemovableMask = 0       ;   // don't care
                            10910 
P:0239 3D2400         2 121610912         move    #36,n5
P:023A 000000         2 121810913         nop
P:023B 044D16         4 122210914         lua     (r5)+n5,r6
P:023C 000000         2 122410915         nop
P:023D 204E00         2 122610916         move    (r6)+n6
P:023E 4C6600         2 122810917         move    x0,y:(r6)
                            10918 
                            10919 ; 351  |        pDev->Lun[i].bMediaEnumerated = FALSE;
                            10920 
P:023F 3D2500         2 123010922         move    #37,n5
P:0240 000000         2 123210923         nop
P:0241 044D16         4 123610924         lua     (r5)+n5,r6
P:0242 000000         2 123810925         nop
P:0243 204E00         2 124010926         move    (r6)+n6
P:0244 4C6600         2 124210927         move    x0,y:(r6)
                            10928 
                            10929 ; 352  |        pDev->Lun[i].bStartUnitAttention = TRUE;
                            10930 
P:0245 3D2C00         2 124410932         move    #44,n5
P:0246 000000         2 124610933         nop
P:0247 044D16         4 125010934         lua     (r5)+n5,r6
P:0248 000000         2 125210935         nop
P:0249 204E00         2 125410936         move    (r6)+n6
P:024A 4F6600         2 125610937         move    y1,y:(r6)
                            10938 
                            10939 ; 353  |        pDev->Lun[i].bMediaChanged = FALSE;
                            10940 
P:024B 3D2600         2 125810942         move    #38,n5
P:024C 000000         2 126010943         nop
P:024D 044D16         4 126410944         lua     (r5)+n5,r6
P:024E 000000         2 126610945         nop
P:024F 204E00         2 126810946         move    (r6)+n6
P:0250 4C6600         2 127010947         move    x0,y:(r6)
                            10948 
                            10949 ; 354  |        pDev->Lun[i].bMediaValid = FALSE;
                            10950 
P:0251 3D2800         2 127210952         move    #40,n5
P:0252 000000         2 127410953         nop
P:0253 044D16         4 127810954         lua     (r5)+n5,r6
P:0254 000000         2 128010955         nop
P:0255 204E00         2 128210956         move    (r6)+n6
P:0256 4C6600         2 128410957         move    x0,y:(r6)
                            10958 
                            10959 ; 355  |        pDev->Lun[i].eMediaState = ScsiMediaStateUnknown;
                            10960 
P:0257 3D2900         2 128610962         move    #41,n5
P:0258 000000         2 128810963         nop
P:0259 044D16         4 129210964         lua     (r5)+n5,r6
P:025A 000000         2 129410965         nop
P:025B 204E00         2 129610966         move    (r6)+n6
P:025C 4C6600         2 129810967         move    x0,y:(r6)
                            10968 
                            10969 ; 356  |        pDev->Lun[i].MediaSize.dwTotalSizeInMegaBytes = 0;
                            10970 
P:025D 3D2D00         2 130010972         move    #45,n5
P:025E 000000         2 130210973         nop
P:025F 044D16         4 130610974         lua     (r5)+n5,r6
P:0260 000000         2 130810975         nop
P:0261 204E00         2 131010976         move    (r6)+n6
P:0262 4C6600         2 131210977         move    x0,y:(r6)
                            10978 
                            10979 ; 357  |        pDev->Lun[i].MediaSize.dwTotalNumberOfSectors = 0;
                            10980 
P:0263 3D2E00         2 131410982         move    #46,n5
P:0264 000000         2 131610983         nop
P:0265 044D16         4 132010984         lua     (r5)+n5,r6
P:0266 000000         2 132210985         nop
P:0267 204E00         2 132410986         move    (r6)+n6
P:0268 200013         2 132610987         clr     a   
P:0269 585E00         2 132810988         move    a0,y:(r6)+
P:026A 5C5600         2 133010989         move    a1,y:(r6)-
                            10990 
                            10991 ; 358  |        pDev->Lun[i].MediaSize.dwTotalNumberOfBytes = 0;
                            10992 
P:026B 3D3000         2 133210994         move    #$30,n5
P:026C 000000         2 133410995         nop
P:026D 044D16         4 133810996         lua     (r5)+n5,r6
P:026E 000000         2 134010997         nop
P:026F 204E00         2 134210998         move    (r6)+n6
P:0270 585E00         2 134410999         move    a0,y:(r6)+
P:0271 5C5600         2 134611000         move    a1,y:(r6)-
                            11001 
                            11002 ; 359  |        pDev->Lun[i].MediaSize.wSectorSizeInBytes = 0;
                            11003 
P:0272 3D3200         2 134811005         move    #50,n5
P:0273 000000         2 135011006         nop
P:0274 044D16         4 135411007         lua     (r5)+n5,r6
P:0275 000000         2 135611008         nop
P:0276 204E00         2 135811009         move    (r6)+n6
P:0277 4C6600         2 136011010         move    x0,y:(r6)
                            11011 
                            11012 ; 360  |        pDev->Lun[i].bMediaInsertionDetected = FALSE;
                            11013 
P:0278 3D2700         2 136211015         move    #39,n5
P:0279 000000         2 136411016         nop
P:027A 044D14         4 136811017         lua     (r5)+n5,r4
P:027B 000000         2 137011018         nop
P:027C 044C16         4 137411019         lua     (r4)+n4,r6
P:027D 000000         2 137611020         nop
P:027E 4C6600         2 137811021         move    x0,y:(r6)
P:027F 200078         2 138011023         add     y1,b
                       (261)11024 L7:
                            11026 
                            11027 ; 361  |    }
                            11028 ; 362  |    
                            11029 ; 363  |#ifdef MMC
                            11030 ; 364  |    pDev->Lun[0].wFileSystemDriveNumber = NUM_LOGICAL_MEDIA-2;
                            11031 
P:0280 3D2A00         2 138211033         move    #42,n5
P:0281 000000         2 138411034         nop
P:0282 044D16         4 138811035         lua     (r5)+n5,r6
P:0283 290100         2 139011036         move    #1,b0
P:0284 596600         2 139211037         move    b0,y:(r6)
                            11039 
                            11040 ; 365  |    pDev->Lun[0].wFileSystemMediaNumber = NUM_LOGICAL_MEDIA-2;
                            11041 
P:0285 3D2B00         2 139411043         move    #43,n5
P:0286 000000         2 139611044         nop
P:0287 044D16         4 140011045         lua     (r5)+n5,r6
P:0288 000000         2 140211046         nop
P:0289 596600         2 140411047         move    b0,y:(r6)
                            11048 
                            11049 ; 366  |#else
                            11050 ; 367  |    pDev->Lun[0].wFileSystemDriveNumber = NUM_LOGICAL_MEDIA-1;
                            11051 ; 368  |    pDev->Lun[0].wFileSystemMediaNumber = NUM_LOGICAL_MEDIA-1;
                            11052 ; 369  |#endif
                            11053 ; 370  |
                            11054 ; 371  |#if (MULTI_LUN_BUILD==1)
                            11055 ; 372  |    pDev->Lun[1].bMediaIsRemovable = TRUE;
                            11056 
P:028A 3D5600         2 140611058         move    #86,n5
P:028B 000000         2 140811059         nop
P:028C 044D16         4 141211060         lua     (r5)+n5,r6
P:028D 000000         2 141411061         nop
P:028E 596600         2 141611062         move    b0,y:(r6)
                            11063 
                            11064 ; 373  |    #ifdef MMC
                            11065 ; 374  |        pDev->Lun[1].wRemovableType = MEDIA_TYPE_MMC;            
                            11066 
P:028F 3D5700         2 141811068         move    #87,n5
P:0290 000000         2 142011069         nop
P:0291 044D16         4 142411070         lua     (r5)+n5,r6
P:0292 000000         2 142611071         nop
P:0293 596600         2 142811072         move    b0,y:(r6)
                            11073 
                            11074 ; 375  |    #else
                            11075 ; 376  |        pDev->Lun[1].wRemovableType = MEDIA_TYPE_SMARTMEDIA;            
                            11076 ; 377  |    #endif
                            11077 ; 378  |    pDev->Lun[1].wRemovableEntry = 0;           
                            11078 
P:0294 3D5800         2 143011080         move    #88,n5
P:0295 000000         2 143211081         nop
P:0296 044D16         4 143611082         lua     (r5)+n5,r6
P:0297 000000         2 143811083         nop
P:0298 4C6600         2 144011084         move    x0,y:(r6)
                            11085 
                            11086 ; 379  |    pDev->Lun[1].wRemovableMask = 0x000001;     
                            11087 
P:0299 3D5900         2 144211089         move    #89,n5
P:029A 000000         2 144411090         nop
P:029B 044D16         4 144811091         lua     (r5)+n5,r6
P:029C 000000         2 145011092         nop
P:029D 596600         2 145211093         move    b0,y:(r6)
                            11094 
                            11095 ; 380  |
                            11096 ; 381  |#ifdef MTP_BUILD
                            11097 ; 382  |    pDev->Lun[1].wFileSystemDriveNumber = 1;
                            11098 ; 383  |    pDev->Lun[1].wFileSystemMediaNumber = 1;
                            11099 ; 384  |#else
                            11100 ; 385  |    pDev->Lun[1].wFileSystemDriveNumber = 2;
                            11101 
P:029E 3D5F00         2 145411103         move    #95,n5
P:029F 000000         2 145611104         nop
P:02A0 044D16         4 146011105         lua     (r5)+n5,r6
P:02A1 000000         2 146211106         nop
P:02A2 4D6600         2 146411107         move    x1,y:(r6)
                            11108 
                            11109 ; 386  |    pDev->Lun[1].wFileSystemMediaNumber = 2;
                            11110 
P:02A3 3D6000         2 146611112         move    #$60,n5
P:02A4 000000         2 146811113         nop
P:02A5 044D16         4 147211114         lua     (r5)+n5,r6
P:02A6 000000         2 147411115         nop
P:02A7 4D6600         2 147611116         move    x1,y:(r6)
                            11117 
                            11118 ; 387  |#endif
                            11119 ; 388  |#endif
                            11120 ; 389  |
TASKING DSP2410 assembler v1.5r1 Build 138 SN 00100122
                                                                                                                                                                                                                                                       Page  40

M:ADDR CODE           CYCLES LINE SOURCELINE
                            11121 ; 390  |    return SUCCESS;
                            11122 
P:02A8 200041         2 147811124         tfr     x0,a
P:02A9 218E00         2 148011125         move    a1,a
                            11126 
                            11127 ; 391  |}
                            11128 
P:02AA 05F07C rrrrrr  4 148411130         movec   y:ss_UsbMscProjectResetDevice0,ssh
P:02AC 000000         2 148611132         nop
P:02AD 00000C         4 149011133         rts
                            11135 
Y:0000                      11136         org     y,".yovlusbmscproject@UsbMscProjectResetDevice0",overlay:
                            11137 ss_UsbMscProjectResetDevice0:
Y:0000                      11138         ds      2
   |   RESERVED                   
Y:0001
                            11139 
P:02AE                      11140         org     p,".ptextusbmscproject":
                            11142 
                            11143 ; 392  |
                            11144 ; 393  |#if ((NUM_REMOVABLE_MEDIA == 1) && (MULTI_LUN_BUILD==0))
                            11145 ; 394  |////////////////////////////////////////////////////////////////////////////////
                            11146 ; 395  |//
                            11147 ; 396  |//>  Name:          UsbMscProjectInitDevice1
                            11148 ; 397  |//
                            11149 ; 398  |//   Type:          Function
                            11150 ; 399  |//
                            11151 ; 400  |//   Description:   Project-specific USB MSC device init for device 1
                            11152 ; 401  |//
                            11153 ; 402  |//   Inputs:        none
                            11154 ; 403  |//
                            11155 ; 404  |//   Outputs:       RETCODE
                            11156 ; 405  |//
                            11157 ; 406  |//   Notes:         none
                            11158 ; 407  |//<
                            11159 ; 408  |////////////////////////////////////////////////////////////////////////////////
                            11160 ; 409  |RETCODE UsbMscProjectInitDevice1(void)
                            11161 ; 410  |{
                            11162 ; 411  |    
                            11163 ; 412  |    USBMSC_DEVICE * pDev;
                            11164 ; 413  |    WORD i;
                            11165 ; 414  |    
                            11166 ; 415  |    // Device 1 setup
                            11167 ; 416  |    pDev = &(UsbMscDevice[USBMSC_DEVICE_1]);
                            11168 ; 417  |
                            11169 ; 418  |    // Run the reset routine
                            11170 ; 419  |    UsbMscProjectResetDevice1();
                            11171 ; 420  |
                            11172 ; 421  |    UsbEndpointSetup(pDev->pBulkIn);
                            11173 ; 422  |    UsbEndpointSetup(pDev->pBulkOut);
                            11174 ; 423  |
                            11175 ; 424  |    for(i=0;i<SCSI_DEVICE_NUM_LUNS_DEV_1;i++)
                            11176 ; 425  |    {
                            11177 ; 426  |        ScsiLunSetupDefaultSenseData(&(pDev->Lun[i]));
                            11178 ; 427  |        pDev->Lun[i].wCompletionStatus = USBMSC_CSW_COMMAND_PASSED;
                            11179 ; 428  |        pDev->Lun[i].dwNumBytesXferred = 0;
                            11180 ; 429  |    }
                            11181 ; 430  |
                            11182 ; 431  |    // Lun 0 stuff
                            11183 ; 432  |    pDev->Lun[0].wInquiryVendorData[0] = (g_SCSIVendorID[0]<<16);
                            11184 ; 433  |    pDev->Lun[0].wInquiryVendorData[1] = g_SCSIVendorID[1] | 
                            11185 ; 434  |        (g_SCSIVendorID[2]<<8) |
                            11186 ; 435  |        (g_SCSIVendorID[3]<<16);
                            11187 ; 436  |    pDev->Lun[0].wInquiryVendorData[2] = g_SCSIVendorID[4] | 
                            11188 ; 437  |        (g_SCSIVendorID[5]<<8) |
                            11189 ; 438  |        (g_SCSIVendorID[6]<<16);
                            11190 ; 439  |    pDev->Lun[0].wInquiryVendorData[3] = g_SCSIVendorID[7] | 
                            11191 ; 440  |        (g_SCSIProductID[0]<<8) |
                            11192 ; 441  |        (g_SCSIProductID[1]<<16);
                            11193 ; 442  |    pDev->Lun[0].wInquiryVendorData[4] = g_SCSIProductID[2] | 
                            11194 ; 443  |        (g_SCSIProductID[3]<<8) |
                            11195 ; 444  |        (g_SCSIProductID[4]<<16);
                            11196 ; 445  |    pDev->Lun[0].wInquiryVendorData[5] = g_SCSIProductID[5] | 
                            11197 ; 446  |        (g_SCSIProductID[6]<<8) |
                            11198 ; 447  |        (g_SCSIProductID[7]<<16);
                            11199 ; 448  |    pDev->Lun[0].wInquiryVendorData[6] = g_SCSIProductID[8] | 
                            11200 ; 449  |        (g_SCSIProductID[9]<<8) |
                            11201 ; 450  |        (g_SCSIProductID[10]<<16);
                            11202 ; 451  |    pDev->Lun[0].wInquiryVendorData[7] = g_SCSIProductID[11] | 
                            11203 ; 452  |        (g_SCSIProductID[12]<<8) |
                            11204 ; 453  |        (g_SCSIProductID[13]<<16);
                            11205 ; 454  |    pDev->Lun[0].wInquiryVendorData[8] = g_SCSIProductID[14] | 
                            11206 ; 455  |        (g_SCSIProductID[15]<<8) |
                            11207 ; 456  |        (HARDWARE_VERSION_MAJOR_CHAR<<16);
                            11208 ; 457  |    pDev->Lun[0].wInquiryVendorData[9] = HARDWARE_VERSION_MINOR_CHAR_2 | 
                            11209 ; 458  |        (HARDWARE_VERSION_MINOR_CHAR_1<<8) |
                            11210 ; 459  |        (HARDWARE_VERSION_MINOR_CHAR_0<<16);
                            11211 ; 460  |
                            11212 ; 461  |    pDev->Lun[0].wInquiryVendorSpecific[0] = 
                            11213 ; 462  |        (0<<20) | (pDev->wDeviceNumber<<16) |             // Lun 0, Device num
                            11214 ; 463  |        (SCSI_INQUIRY_VENDOR_SPECIFIC_STRUCT_MDS<<8) | 1; // MDS, 1 struct       
                            11215 ; 464  |    pDev->Lun[0].wInquiryVendorSpecific[1] = 
                            11216 ; 465  |        #ifdef MMC
                            11217 ; 466  |            (SCSI_MDS_MEDIA_TYPE_MMC_UNKNOWN_VERSION<<8) |    // MMC
                            11218 ; 467  |        #else
                            11219 ; 468  |            (SCSI_MDS_MEDIA_TYPE_SMARTMEDIA<<8) |             // SmartMedia
                            11220 ; 469  |        #endif
                            11221 ; 470  |        SCSI_MDS_FLAGS_SYSTEM_MEDIA_FLAG_NON_SYSTEM;      // Non-system media 
                            11222 ; 471  |    pDev->Lun[0].wInquiryVendorSpecific[2] = 0;
                            11223 ; 472  |    pDev->Lun[0].wInquiryVendorSpecific[3] = 0;
                            11224 ; 473  |    pDev->Lun[0].wInquiryVendorSpecific[4] = 0;
                            11225 ; 474  |    pDev->Lun[0].wInquiryVendorSpecific[5] = 0;
                            11226 ; 475  |    pDev->Lun[0].wInquiryVendorSpecific[6] = 0;
                            11227 ; 476  |    #ifdef MMC
                            11228 ; 477  |        pDev->Lun[0].FlagMediaChange = MmcFlagMediaChange;
                            11229 ; 478  |    #else
                            11230 ; 479  |        pDev->Lun[0].FlagMediaChange = ScsiDummyFlagMediaChange;
                            11231 ; 480  |    #endif
                            11232 ; 481  |
                            11233 ; 482  |    return SUCCESS;
                            11234 ; 483  |}
                            11235 ; 484  |
                            11236 ; 485  |////////////////////////////////////////////////////////////////////////////////
                            11237 ; 486  |//
                            11238 ; 487  |//>  Name:          UsbMscProjectResetDevice1
                            11239 ; 488  |//
                            11240 ; 489  |//   Type:          Function
                            11241 ; 490  |//
                            11242 ; 491  |//   Description:   Project-specific USB MSC device reset for device 1
                            11243 ; 492  |//
                            11244 ; 493  |//   Inputs:        none
                            11245 ; 494  |//
                            11246 ; 495  |//   Outputs:       RETCODE
                            11247 ; 496  |//
                            11248 ; 497  |//   Notes:         none
                            11249 ; 498  |//<
                            11250 ; 499  |////////////////////////////////////////////////////////////////////////////////
                            11251 ; 500  |RETCODE  UsbMscProjectResetDevice1(void)
                            11252 ; 501  |{
                            11253 ; 502  |    USBMSC_DEVICE * pDev;
                            11254 ; 503  |    WORD i;
                            11255 ; 504  |    
                            11256 ; 505  |    // Device 0 setup
                            11257 ; 506  |    pDev = &(UsbMscDevice[USBMSC_DEVICE_1]);
                            11258 ; 507  |
                            11259 ; 508  |    pDev->wDeviceNumber = USBMSC_DEVICE_1;
                            11260 ; 509  |
                            11261 ; 510  |    UsbEp2IsrFunction = ScsiBulkInIsrFunction;
                            11262 ; 511  |    wUsbEp2IsrFunctionParam = USBMSC_DEVICE_1; // Target 1 Bulk In
                            11263 ; 512  |    UsbEp5IsrFunction = UsbMscCbwProcessorIsrFunction;
                            11264 ; 513  |    wUsbEp5IsrFunctionParam = USBMSC_DEVICE_1; // Target 1 Bulk Out
                            11265 ; 514  |
                            11266 ; 515  |    // Setup the Usb Interface
                            11267 ; 516  |    pDev->pInterface = &(UsbInterface[1]);
                            11268 ; 517  |    pDev->pInterface->wInterface = 1;
                            11269 ; 518  |    pDev->pInterface->bClearFeature = FALSE;
                            11270 ; 519  |
                            11271 ; 520  |    // Setup the BulkIn Endpoint
                            11272 ; 521  |    pDev->pBulkIn = &(UsbEndpoint[USB_ENDPOINT_2]);
                            11273 ; 522  |    pDev->pBulkIn->pwBuffer = wUsbEp2Buffer;
                            11274 ; 523  |    pDev->pBulkIn->pFunction = &UsbEp2IsrFunction;
                            11275 ; 524  |    pDev->bBulkInDataComplete = FALSE;
                            11276 ; 525  |
                            11277 ; 526  |    // Setup the BulkOut Endpoint
                            11278 ; 527  |    pDev->pBulkOut = &(UsbEndpoint[USB_ENDPOINT_5]);
                            11279 ; 528  |    pDev->pBulkOut->pwBuffer = wUsbEp5Buffer;
                            11280 ; 529  |    pDev->pBulkOut->pFunction = &UsbEp5IsrFunction;
                            11281 ; 530  |    pDev->bBulkOutDataReady = FALSE;
                            11282 ; 531  |
                            11283 ; 532  |    pDev->wNumLunsSupported = SCSI_DEVICE_NUM_LUNS_DEV_1;
                            11284 ; 533  |    pDev->bCommandActive = FALSE;
                            11285 ; 534  |    pDev->bResetDevice = FALSE;
                            11286 ; 535  |    pDev->InitializeFunction = UsbMscProjectInitDevice1;
                            11287 ; 536  |    pDev->ResetFunction = UsbMscProjectResetDevice1;
                            11288 ; 537  |    
                            11289 ; 538  |    for(i=0;i<USBMSC_NUM_SECTOR_BUFFERS;i++)
                            11290 ; 539  |    {
                            11291 ; 540  |        pDev->Sector[i].bValid = FALSE;
                            11292 ; 541  |        pDev->Sector[i].pwData = &(Target1BufferArray[i]);
                            11293 ; 542  |    }
                            11294 ; 543  |    
                            11295 ; 544  |    for(i=0;i<SCSI_DEVICE_NUM_LUNS_DEV_1;i++)
                            11296 ; 545  |    {
                            11297 ; 546  |        pDev->Lun[i].bStopped = FALSE;
                            11298 ; 547  |        pDev->Lun[i].bWriteProtected = FALSE;
                            11299 ; 548  |        pDev->Lun[i].bMediaConnected = FALSE;       // external media
                            11300 ; 549  |        pDev->Lun[i].bMediaIsRemovable = TRUE;
                            11301 ; 550  |        #ifdef MMC
                            11302 ; 551  |            pDev->Lun[i].wRemovableType = MEDIA_TYPE_MMC;            
                            11303 ; 552  |        #else
                            11304 ; 553  |            pDev->Lun[i].wRemovableType = MEDIA_TYPE_SMARTMEDIA;            
                            11305 ; 554  |        #endif
                            11306 ; 555  |        pDev->Lun[i].wRemovableEntry = 0;           
                            11307 ; 556  |        pDev->Lun[i].wRemovableMask = 0x000001;     
                            11308 ; 557  |        pDev->Lun[i].bMediaEnumerated = FALSE;
                            11309 ; 558  |        pDev->Lun[i].bStartUnitAttention = TRUE;
                            11310 ; 559  |        pDev->Lun[i].bMediaChanged = FALSE;
                            11311 ; 560  |        pDev->Lun[i].bMediaValid = FALSE;
                            11312 ; 561  |        pDev->Lun[i].eMediaState = ScsiMediaStateUnknown;
                            11313 ; 562  |        pDev->Lun[i].MediaSize.dwTotalSizeInMegaBytes = 0;
                            11314 ; 563  |        pDev->Lun[i].MediaSize.dwTotalNumberOfSectors = 0;
                            11315 ; 564  |        pDev->Lun[i].MediaSize.dwTotalNumberOfBytes = 0;
                            11316 ; 565  |        pDev->Lun[i].MediaSize.wSectorSizeInBytes = 0;
                            11317 ; 566  |        pDev->Lun[i].bMediaInsertionDetected = FALSE;
                            11318 ; 567  |    }
                            11319 ; 568  |    
                            11320 ; 569  |    pDev->Lun[0].wFileSystemDriveNumber = 2;
                            11321 ; 570  |    pDev->Lun[0].wFileSystemMediaNumber= 2;
                            11322 ; 571  |
                            11323 ; 572  |    return SUCCESS;
                            11324 ; 573  |}
                            11325 ; 574  |#endif
                            11326 
                            11334 
                            11338 
X:0000                      11339         org     x,".xbssusbmscproject",bss:
                            11340 FTarget0BufferArray:
X:0000                      11341         ds      2833
   |   RESERVED                   
X:0B10
                            11350 
Y:0000                      11351         org     y,".ybssusbmscproject",bss:
                            11352 Fg_USBMSCHandler0Stack:
Y:0000                      11353         ds      500
   |   RESERVED                   
Y:01F3
                            11362 
X:0B11                      11363         org     x,".xbssusbmscproject",bss:
                            11364 FDevice1CommandInBuffer:
X:0B11                      11365         ds      64
   |   RESERVED                   
X:0B50
                            11377 
Y:0000                      11378         org     y,".ybssusbmscproject.g_USBMSCHandler0MessageQueue",bss:
                            11379         baddr   m,16
                            11380 Fg_USBMSCHandler0MessageQueue:
Y:0000                      11381         ds      16
   |   RESERVED                   
Y:000F
                            11384 
X:0B51                      11385         org     x,".xbssusbmscproject",bss:
                            11386 FDevice1CommandOutBuffer:
X:0B51                      11387         ds      64
   |   RESERVED                   
X:0B90
                            11391 
Y:01F4                      11392         org     y,".ybssusbmscproject",bss:
                            11393 FUsbMscDevice:
Y:01F4                      11394         ds      242
   |   RESERVED                   
Y:02E5
                            11411 FTarget0SectorArray:
Y:02E6                      11412         ds      32
   |   RESERVED                   
Y:0305
                            11415 
                            11416         extern  Rdiv_uiuiui, FMmcFlagMediaChange, FScsiDummyFlagMediaChange
                            11417         extern  FScsiLunSetupDefaultSenseData, FSectorArrayInitialize
                            11418         extern  FUSBMSCRequestHandler, FUsbMscBulkInService
                            11419         extern  FUsbMscBulkOutService, FUsbMscHandler0
                            11420         extern  FUsbMscResetService, FUsbMscResumeService
TASKING DSP2410 assembler v1.5r1 Build 138 SN 00100122
                                                                                                                                                                                                                                                       Page  41

M:ADDR CODE           CYCLES LINE SOURCELINE
                            11421         extern  FUsbMscSuspendService, y:Fg_NandAuxData
                            11422         extern  y:Fg_SCSIProductID, y:Fg_SCSIVendorID
                            11423         extern  Fusb_device_register_service, Fusb_get_current_limit
                            11424 
                            11425         global  FDevice1CommandInBuffer, FDevice1CommandOutBuffer
                            11426         global  FTarget0BufferArray, FTarget0SectorArray, FUsbMscDevice
                            11427         global  FUsbMscProjectInitDevice0, FUsbMscProjectResetDevice0
                            11428         global  Fg_USBMSCHandler0, Fg_USBMSCHandler0MessageQueue
                            11429         global  Fg_USBMSCHandler0MessageQueueDescriptor
                            11430         global  Fg_USBMSCHandler0Stack, Fg_wUsbMscNumDevices
                            11431 
                            11432         local   L3, L4, L5, L7, ss_UsbMscProjectInitDevice0
                            11433         local   ss_UsbMscProjectResetDevice0
                            11434 
                            11435         calls   "UsbMscProjectInitDevice0", "Rdiv_uiuiui"
                            11436         calls   "UsbMscProjectInitDevice0", "ScsiLunSetupDefaultSenseData"
                            11437         calls   "UsbMscProjectInitDevice0", "SectorArrayInitialize"
                            11438         calls   "UsbMscProjectInitDevice0", "UsbMscProjectResetDevice0"
                            11439         calls   "UsbMscProjectInitDevice0", "usb_device_register_service"
                            11440         calls   "UsbMscProjectResetDevice0", "usb_get_current_limit"
                            11441 
