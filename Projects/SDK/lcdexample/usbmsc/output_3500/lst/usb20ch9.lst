TASKING DSP2410 assembler v1.5r1 Build 138 SN 00100122
                                                                                                                            Page   1
C:\STMP3XXX_SDK_FIRMWARE_320_finalfix\Projects\SDK\lcdexample\usbmsc\Make\cc871cab.src
M:ADDR CODE           CYCLES LINE SOURCELINE
                                1 ; TASKING DSP2410 C compiler v1.5r1 Build 208 SN 00100122
                                2 ; options: -OG -si -w68 -w66 -I..\output_3500\include
                                3 ;          -I..\..\..\..\..\Projects\sdk\lcdexample\usbmsc -I -I..\..
                                4 ;          -I..\..\..\..\..\inc -I..\..\..\..\..\System\Common
                                5 ;          -I..\..\..\..\..\System\Common\symbols -I
                                6 ;          -I..\..\..\..\..\Algorithms\DRM\janus\src\h
                                7 ;          -I..\..\..\..\..\devicedriver\media\ddildl
                                8 ;          -I..\..\..\..\..\devicedriver\media\ddildl\include
                                9 ;          -I..\..\..\..\..\devicedriver\media\MediaTypeMMC\DDI\include
                               10 ;          -I..\..\..\..\..\devicedriver\media\ddildl\include
                               11 ;          -I..\..\..\..\..\devicedriver\media\MediaTypeMMC\DDI\include
                               12 ;          -I..\..\..\..\..\devicedriver\media\MediaTypeMMC\DDI\Media
                               13 ;          -I..\..\..\..\..\devicedriver\media\MediaTypeMMC\HAL\include
                               14 ;          -I..\..\..\..\..\devicedriver\media\MediaTypeRAM\include
                               15 ;          -I..\..\..\..\..\devicedriver\media\MediaTypeRAM\DDI\DataDrive\include
                               16 ;          -I..\..\..\..\..\devicedriver\media\MediaTypeRAM\DDI\include
                               17 ;          -I..\..\..\..\..\devicedriver\media\MediaTypeRAM\HAL\include
                               18 ;          -I..\..\..\..\..\devicedriver\media\MediaTypeRAM\DDI\DataDrive
                               19 ;          -I..\..\..\..\..\devicedriver\media\MediaTypeRAM\include
                               20 ;          -I..\..\..\..\..\devicedriver\media\MediaTypeRAM\DDI\SystemDrive\include
                               21 ;          -I..\..\..\..\..\devicedriver\media\MediaTypeRAM\DDI\include
                               22 ;          -I..\..\..\..\..\devicedriver\media\MediaTypeRAM\HAL\include
                               23 ;          -I..\..\..\..\..\devicedriver\media\MediaTypeRAM\DDI\SystemDrive
                               24 ;          -I..\..\..\..\..\devicedriver\media\MediaTypeRAM\include
                               25 ;          -I..\..\..\..\..\devicedriver\media\MediaTypeRAM\DDI\Media\include
                               26 ;          -I..\..\..\..\..\devicedriver\media\MediaTypeRAM\DDI\include
                               27 ;          -I..\..\..\..\..\devicedriver\media\MediaTypeRAM\HAL\include
                               28 ;          -I..\..\..\..\..\devicedriver\media\MediaTypeRAM\DDI\Media
                               29 ;          -I..\..\..\..\..\devicedriver\media\MediaTypeRAM\include
                               30 ;          -I..\..\..\..\..\devicedriver\media\MediaTypeRAM\DDI\include
                               31 ;          -I..\..\..\..\..\devicedriver\media\MediaTypeRAM\HAL\include
                               32 ;          -I..\..\..\..\..\devicedriver\media\MediaTypeNAND\include
                               33 ;          -I..\..\..\..\..\devicedriver\media\MediaTypeNAND\DDI\DataDrive\include
                               34 ;          -I..\..\..\..\..\devicedriver\media\MediaTypeNAND\DDI\include
                               35 ;          -I..\..\..\..\..\devicedriver\media\MediaTypeNAND\HAL\include
                               36 ;          -I..\..\..\..\..\devicedriver\media\MediaTypeNAND\DDI\DataDrive
                               37 ;          -I..\..\..\..\..\devicedriver\media\ddildl\include -I
                               38 ;          -I..\..\..\..\..\FileSystem\Fat32\cmp\cmp_stdtype
                               39 ;          -I..\..\..\..\..\FileSystem\Fat32\cmp\cmp_debug
                               40 ;          -I..\..\..\..\..\FileSystem\Fat32\cmp\cmp_file_system
                               41 ;          -I..\..\..\..\..\DeviceDriver\Media\cmp\cmp_media_nand
                               42 ;          -I..\..\..\..\..\devicedriver\media\MediaTypeNAND\include
                               43 ;          -I..\..\..\..\..\devicedriver\media\MediaTypeNAND\DDI\Common\include
                               44 ;          -I..\..\..\..\..\devicedriver\media\MediaTypeNAND\DDI\include
                               45 ;          -I..\..\..\..\..\devicedriver\media\MediaTypeNAND\HAL\include
                               46 ;          -I..\..\..\..\..\devicedriver\media\MediaTypeNAND\DDI\Common
                               47 ;          -I..\..\..\..\..\devicedriver\media\MediaTypeNAND\include
                               48 ;          -I..\..\..\..\..\devicedriver\media\MediaTypeNAND\DDI\SystemDrive\include
                               49 ;          -I..\..\..\..\..\devicedriver\media\MediaTypeNAND\DDI\include
                               50 ;          -I..\..\..\..\..\devicedriver\media\MediaTypeNAND\HAL\include
                               51 ;          -I..\..\..\..\..\devicedriver\media\MediaTypeNAND\DDI\SystemDrive
                               52 ;          -I..\..\..\..\..\devicedriver\media\MediaTypeNAND\include
                               53 ;          -I..\..\..\..\..\devicedriver\media\MediaTypeNAND\DDI\Media\include
                               54 ;          -I..\..\..\..\..\devicedriver\media\MediaTypeNAND\DDI\include
                               55 ;          -I..\..\..\..\..\devicedriver\media\MediaTypeNAND\HAL\include
                               56 ;          -I..\..\..\..\..\devicedriver\media\MediaTypeNAND\DDI\Media
                               57 ;          -I..\..\..\..\..\devicedriver\media\include
                               58 ;          -I..\..\..\..\..\devicedriver\media\ddildl
                               59 ;          -I..\..\..\..\..\devicedriver\media\ddildl\include
                               60 ;          -I..\..\..\..\..\devicedriver\media\MediaTypeNAND\DDI\Common\include
                               61 ;          -I..\..\..\..\..\devicedriver\media\MediaTypeNAND\DDI\include
                               62 ;          -I..\..\..\..\..\DeviceDriver\Media\MediaTypeNAND\HAL
TASKING DSP2410 assembler v1.5r1 Build 138 SN 00100122
                                                                                                                            Page   2

M:ADDR CODE           CYCLES LINE SOURCELINE
                               63 ;          -I..\..\..\..\..\DeviceDriver\Media\MediaTypeNAND\HAL\include
                               64 ;          -I..\..\..\..\..\DeviceDriver\Media\include
                               65 ;          -I..\..\..\..\..\DeviceDriver\Media\PortHIL\GPFlash\include
                               66 ;          -I..\..\..\..\..\DeviceDriver\Media\PortHIL\GPFlash
                               67 ;          -I..\..\..\..\..\system\common\resourcemanager -I..\..\..\..\..\inc
                               68 ;          -I..\..\..\..\..\DeviceDriver\Media\usb\Ch9
                               69 ;          -I..\..\..\..\..\DeviceDriver\Media\scsi
                               70 ;          -I..\..\..\..\..\DeviceDriver\Media\usbmsc
                               71 ;          -I..\..\..\..\..\DeviceDriver\Media\mtp
                               72 ;          -I..\..\..\..\..\System\Common\updater
                               73 ;          -I..\..\..\..\..\libsource\sysserialnumber -DALL -DD3500 -DMMC
                               74 ;          -DLIION -DTUNER_STFM1000 -DSTFM1000_LCD=TRUE -DDCDC_POWER_TRANSFER
                               75 ;          -DBACKLIGHT -DWMAAPI_NO_DRM -DREVB_ENGR_BD -DSED15XX_LCD -DFAT16
                               76 ;          -DDEVICE_3500 -DENGR_BD -DUSBMSC_BUILD -DBATTERY_TYPE_LI_ION
                               77 ;          -DBATTERY_CHARGE -DUSE_PLAYLIST3_HOST -DASCII_ONLY -DRETAIL
                               78 ;          -DDEVICE_3500 -DMMC -Dk_opt_performance_enhancement
                               79 ;          -I..\..\..\..\..\devicedriver\display
                               80 ;          -I..\..\..\..\..\System\MsgModules\Hardware\Display -g -O2 -R -Cs
                               81 ;          -MmyL
                               82 
                               90 
                               91 ;     usb20ch9.c:
                               92 ; 1    |////////////////////////////////////////////////////////////////////////////////
                               93 ; 2    |// Copyright(C) SigmaTel, Inc. 2002 - 2003
                               94 ; 3    |//
                               95 ; 4    |// File : usb20ch9.c
                               96 ; 5    |// Description : USB2.0 Chapter Application skeleton
                               97 ; 6    |////////////////////////////////////////////////////////////////////////////////
                               98 ; 7    |
                               99 ; 8    |#include "types.h"
                              100 
                              102 
                              103 ; 1    |////////////////////////////////////////////////////////////////////////////////
                              104 ; 2    |// Copyright(C) SigmaTel, Inc. 2000-2004
                              105 ; 3    |//
                              106 ; 4    |// Filename: types.h
                              107 ; 5    |// Description: Standard data types
                              108 ; 6    |////////////////////////////////////////////////////////////////////////////////
                              109 ; 7    |
                              110 ; 8    |#ifndef _TYPES_H
                              111 ; 9    |#define _TYPES_H
                              112 ; 10   |
                              113 ; 11   |// TODO:  move this outta here!
                              114 ; 12   |#if !defined(NOERROR)
                              115 ; 13   |#define NOERROR 0
                              116 ; 14   |#define SUCCESS 0
                              117 ; 15   |#endif 
                              118 ; 16   |#if !defined(SUCCESS)
                              119 ; 17   |#define SUCCESS  0
                              120 ; 18   |#endif
                              121 ; 19   |#if !defined(ERROR)
                              122 ; 20   |#define ERROR   -1
                              123 ; 21   |#endif
                              124 ; 22   |#if !defined(FALSE)
                              125 ; 23   |#define FALSE 0
                              126 ; 24   |#endif
                              127 ; 25   |#if !defined(TRUE)
                              128 ; 26   |#define TRUE  1
                              129 ; 27   |#endif
                              130 ; 28   |
                              131 ; 29   |#if !defined(NULL)
                              132 ; 30   |#define NULL 0
TASKING DSP2410 assembler v1.5r1 Build 138 SN 00100122
                                                                                                                            Page   3

M:ADDR CODE           CYCLES LINE SOURCELINE
                              133 ; 31   |#endif
                              134 ; 32   |
                              135 ; 33   |#define MAX_INT     0x7FFFFF
                              136 ; 34   |#define MAX_LONG    0x7FFFFFffffff
                              137 ; 35   |        // max positive unsigned long value: -1 == 0xFFFFFFffffff
                              138 ; 36   |#define MAX_ULONG   (-1) 
                              139 ; 37   |
                              140 ; 38   |#define WORD_SIZE   24              // word size in bits
                              141 ; 39   |#define BYTES_PER_WORD 3            // 8 bit bytes
                              142 ; 40   |
                              143 ; 41   |
                              144 ; 42   |#define BYTE    unsigned char       // btVarName
                              145 ; 43   |#define CHAR    signed char         // cVarName
                              146 ; 44   |#define USHORT  unsigned short      // usVarName
                              147 ; 45   |#define SHORT   unsigned short      // sVarName
                              148 ; 46   |#define WORD    unsigned int        // wVarName
                              149 ; 47   |#define INT     signed int          // iVarName
                              150 ; 48   |#define DWORD   unsigned long       // dwVarName
                              151 ; 49   |#define LONG    signed long         // lVarName
                              152 ; 50   |#define BOOL    unsigned int        // bVarName
                              153 ; 51   |#define FRACT   _fract              // frVarName
                              154 ; 52   |#define LFRACT  long _fract         // lfrVarName
                              155 ; 53   |#define CIRC    _circ               // cp<type prefix>VarName (see below)
                              156 ; 54   |#define FLOAT   float               // fVarName
                              157 ; 55   |#define DBL     double              // dVarName
                              158 ; 56   |#define ENUM    enum                // eVarName
                              159 ; 57   |#define CMX     _complex            // cmxVarName
                              160 ; 58   |typedef WORD UCS3;                   // 
                              161 ; 59   |
                              162 ; 60   |#define UINT16  unsigned short
                              163 ; 61   |#define UINT8   unsigned char   
                              164 ; 62   |#define UINT32  unsigned long
                              165 ; 63   |#define UINT64  unsigned long   // need to figure out how to do 64 bit values.  Or port ex
                                  isiting code to only use 48 bit
                              166 ; 64   |#define INT64   unsigned long   // need to figure out how to do 64 bit values.  Or port ex
                                  isiting code to only use 48 bit
                              167 ; 65   |#define WCHAR   UINT16
                              168 ; 66   |
                              169 ; 67   |//UINT128 is 16 bytes or 6 words
                              170 ; 68   |typedef struct UINT128_3500 {   
                              171 ; 69   |    int val[6];     
                              172 ; 70   |} UINT128_3500;
                              173 ; 71   |
                              174 ; 72   |#define UINT128   UINT128_3500
                              175 ; 73   |
                              176 ; 74   |// Little endian word packed byte strings:   
                              177 ; 75   |//      _packed BYTE bTextVarName[]="a string";  bText is a packed byte string prefix
                              178 ; 76   |// Convert to big endian words by reordering bytes from high to low using swizzle.
                              179 ; 77   |// Little endian word packed byte strings:   
                              180 ; 78   |//      _packed BYTE bTextVarName[]="a string";  bText is a packed byte string prefix
                              181 ; 79   |// Convert to big endian words by reordering bytes from high to low using swizzle.
                              182 ; 80   |
                              183 ; 81   |// Declare Memory Spaces To Use When Coding
                              184 ; 82   |// A. Sector Buffers
                              185 ; 83   |#define SECTOR_BUFFER_MEM_X _X
                              186 ; 84   |#define SECTOR_BUFFER_MEM_Y _Y
                              187 ; 85   |#define SECTOR_BUFFER_MEM SECTOR_BUFFER_MEM_X
                              188 ; 86   |typedef WORD SECTOR_BUFFER_MEM SECTOR_BUFFER;
                              189 
                              191 
                              192 ; 87   |typedef SECTOR_BUFFER * P_SECTOR_BUFFER;
                              193 ; 88   |// B. Media DDI Memory
TASKING DSP2410 assembler v1.5r1 Build 138 SN 00100122
                                                                                                                            Page   4

M:ADDR CODE           CYCLES LINE SOURCELINE
                              194 ; 89   |#define MEDIA_DDI_MEM _Y
                              195 ; 90   |
                              196 ; 91   |
                              197 ; 92   |
                              198 ; 93   |// Pointers to linear structures are labeled as: p<type prefix>VarName
                              199 ; 94   |// Examples of circular pointers:
                              200 ; 95   |//    INT CIRC cpiVarName
                              201 ; 96   |//    DWORD CIRC cpdwVarName
                              202 ; 97   |
                              203 ; 98   |#define RETCODE INT                 // rcVarName
                              204 ; 99   |
                              205 ; 100  |// generic bitfield structure
                              206 ; 101  |struct Bitfield {
                              207 ; 102  |    unsigned int B0  :1;
                              208 ; 103  |    unsigned int B1  :1;
                              209 ; 104  |    unsigned int B2  :1;
                              210 ; 105  |    unsigned int B3  :1;
                              211 ; 106  |    unsigned int B4  :1;
                              212 ; 107  |    unsigned int B5  :1;
                              213 ; 108  |    unsigned int B6  :1;
                              214 ; 109  |    unsigned int B7  :1;
                              215 ; 110  |    unsigned int B8  :1;
                              216 ; 111  |    unsigned int B9  :1;
                              217 ; 112  |    unsigned int B10 :1;
                              218 ; 113  |    unsigned int B11 :1;
                              219 ; 114  |    unsigned int B12 :1;
                              220 ; 115  |    unsigned int B13 :1;
                              221 ; 116  |    unsigned int B14 :1;
                              222 ; 117  |    unsigned int B15 :1;
                              223 ; 118  |    unsigned int B16 :1;
                              224 ; 119  |    unsigned int B17 :1;
                              225 ; 120  |    unsigned int B18 :1;
                              226 ; 121  |    unsigned int B19 :1;
                              227 ; 122  |    unsigned int B20 :1;
                              228 ; 123  |    unsigned int B21 :1;
                              229 ; 124  |    unsigned int B22 :1;
                              230 ; 125  |    unsigned int B23 :1;
                              231 ; 126  |};
                              232 ; 127  |
                              233 ; 128  |union BitInt {
                              234 ; 129  |        struct Bitfield B;
                              235 ; 130  |        int        I;
                              236 ; 131  |};
                              237 ; 132  |
                              238 ; 133  |#define MAX_MSG_LENGTH 10
                              239 ; 134  |struct CMessage
                              240 ; 135  |{
                              241 ; 136  |        unsigned int m_uLength;
                              242 ; 137  |        unsigned int m_uMsg[MAX_MSG_LENGTH];
                              243 ; 138  |};
                              244 ; 139  |
                              245 ; 140  |typedef struct {
                              246 ; 141  |    WORD m_wLength;
                              247 ; 142  |    WORD m_wMessage;
                              248 ; 143  |    WORD m_wParams[MAX_MSG_LENGTH];
                              249 ; 144  |} Message;
                              250 ; 145  |
                              251 ; 146  |struct MessageQueueDescriptor
                              252 ; 147  |{
                              253 ; 148  |        int *m_pBase;
                              254 ; 149  |        int m_iModulo;
                              255 ; 150  |        int m_iSize;
TASKING DSP2410 assembler v1.5r1 Build 138 SN 00100122
                                                                                                                            Page   5

M:ADDR CODE           CYCLES LINE SOURCELINE
                              256 ; 151  |        int *m_pHead;
                              257 ; 152  |        int *m_pTail;
                              258 ; 153  |};
                              259 ; 154  |
                              260 ; 155  |struct ModuleEntry
                              261 ; 156  |{
                              262 ; 157  |    int m_iSignaledEventMask;
                              263 ; 158  |    int m_iWaitEventMask;
                              264 ; 159  |    int m_iResourceOfCode;
                              265 ; 160  |    struct MessageQueueDescriptor *m_pMessageQueue;
                              266 ; 161  |    int _asmfunc (*m_pProcessEntryPoint)(union WaitMask Signals,struct MessageQueueDescrip
                                  tor *);
                              267 ; 162  |    int _asmfunc (*m_pInitFunction)(struct MessageQueueDescriptor *);
                              268 ; 163  |    int m_uTimeOutHigh;
                              269 ; 164  |    int m_uTimeOutLow;
                              270 ; 165  |    int _asmfunc (*m_pBackgroundFunction)(struct MessageQueueDescriptor *);
                              271 ; 166  |};
                              272 ; 167  |
                              273 ; 168  |union WaitMask{
                              274 ; 169  |    struct B{
                              275 ; 170  |        unsigned int m_bNone     :1;
                              276 ; 171  |        unsigned int m_bMessage  :1;
                              277 ; 172  |        unsigned int m_bTimer    :1;
                              278 ; 173  |        unsigned int m_bButton   :1;
                              279 ; 174  |    } B;
                              280 ; 175  |    int I;
                              281 ; 176  |} ;
                              282 ; 177  |
                              283 ; 178  |
                              284 ; 179  |struct Button {
                              285 ; 180  |        WORD wButtonEvent;
                              286 ; 181  |        WORD wUnused[MAX_MSG_LENGTH];   
                              287 ; 182  |};
                              288 ; 183  |
                              289 ; 184  |struct Message {
                              290 ; 185  |        WORD wMsgLength;
                              291 ; 186  |        WORD wMsgCommand;
                              292 ; 187  |        WORD wMsgParms[MAX_MSG_LENGTH-1];
                              293 ; 188  |};
                              294 ; 189  |
                              295 ; 190  |union EventTypes {
                              296 ; 191  |        struct CMessage msg;
                              297 ; 192  |        struct Button Button ;
                              298 ; 193  |        struct Message Message;
                              299 ; 194  |};
                              300 ; 195  |
                              301 ; 196  |// next 2 used to get updater build to return correct protocol ver in scsi response.
                              302 ; 197  |#define BUILD_TYPE_UPDATER  0x100
                              303 ; 198  |#define BUILD_TYPE_HOSTLINK 0x101
                              304 ; 199  |#define BUILD_TYPE_PLAYER   0x102
                              305 ; 200  |
                              306 ; 201  |// Resets part if RETAIL build. DEBUG build executes debug instruction to halt.
                              307 ; 202  |#define SystemHalt() __asm(" include 'sysmacro.asm' \n error") 
                              308 ; 203  |#define assert(x)    if(!(x)) __asm(" include 'sysmacro.asm' \n error")
                              309 ; 204  |
                              310 ; 205  |#if DEBUG
                              311 ; 206  |// For DEBUG builds, DebugBuildAssert(condition) halts if condition evaluates to FALSE. 
                              312 ; 207  |#define DebugBuildAssert(x)    if(!(x)) __asm(" debug ")
                              313 ; 208  |#else 
                              314 ; 209  |// For RETAIL builds, DebugBuildAssert(condition) does nothing & execution continues rathe
                                  r than halt or reset. 
                              315 ; 210  |#define DebugBuildAssert(x)    
TASKING DSP2410 assembler v1.5r1 Build 138 SN 00100122
                                                                                                                            Page   6

M:ADDR CODE           CYCLES LINE SOURCELINE
                              316 ; 211  |#endif
                              317 ; 212  |
                              318 ; 213  |// Do this in your C files to make a reminder that's displayed during the build.
                              319 ; 214  |//  #pragma asm
                              320 ; 215  |//  WARN 'Note to builder: reminder to do this after verifying that'
                              321 ; 216  |//  #pragma endasm
                              322 ; 217  |
                              323 ; 218  |
                              324 ; 219  |#ifdef COLOR_262K
                              325 ; 220  |#define RGB(r,g,b)    ((0x0000FC & (r)) << 10) | ((0x0000FC & (g)) << 4) | ((0x0000FC & (b
                                  )) >> 2)    //262k
                              326 ; 221  |#elif defined(COLOR_65K)
                              327 ; 222  |#define RGB(r,g,b)    ((0x0000F8 & (r)) << 8) | ((0x0000FC & (g)) << 3) | ((0x0000F8 & (b)
                                  ) >> 3)  //65k
                              328 ; 223  |#else
                              329 ; 224  |#define RGB(r,g,b)       ((0x0000F0 & (r)) << 4) | (0x0000F0 & (g)) | ((0x0000F0 & (b)) >>
                                   4)
                              330 ; 225  |#endif
                              331 ; 226  |    
                              332 ; 227  |#endif // #ifndef _TYPES_H
                              333 
                              335 
                              336 ; 9    |#include "usb_api.h"
                              337 
                              339 
                              340 ; 1    |////////////////////////////////////////////////////////////////////////////////
                              341 ; 2    |// Copyright(C) SigmaTel, Inc. 2002 - 2003
                              342 ; 3    |//
                              343 ; 4    |// File : USB_API.H
                              344 ; 5    |// Description : USB_API.H defines and structures definition for USB device
                              345 ; 6    |//               driver API.
                              346 ; 7    |//               This 
                              347 ; 8    |////////////////////////////////////////////////////////////////////////////////
                              348 ; 9    |
                              349 ; 10   |#ifndef __usb_api_h__
                              350 ; 11   |#define __usb_api_h__ 1
                              351 ; 12   |
                              352 ; 13   |#include "types.h"
                              353 
                              355 
                              356 ; 1    |////////////////////////////////////////////////////////////////////////////////
                              357 ; 2    |// Copyright(C) SigmaTel, Inc. 2000-2004
                              358 ; 3    |//
                              359 ; 4    |// Filename: types.h
                              360 ; 5    |// Description: Standard data types
                              361 ; 6    |////////////////////////////////////////////////////////////////////////////////
                              362 ; 7    |
                              363 ; 8    |#ifndef _TYPES_H
                              364 ; 9    |#define _TYPES_H
                              365 ; 10   |
                              366 ; 11   |// TODO:  move this outta here!
                              367 ; 12   |#if !defined(NOERROR)
                              368 ; 13   |#define NOERROR 0
                              369 ; 14   |#define SUCCESS 0
                              370 ; 15   |#endif 
                              371 ; 16   |#if !defined(SUCCESS)
                              372 ; 17   |#define SUCCESS  0
                              373 ; 18   |#endif
                              374 ; 19   |#if !defined(ERROR)
                              375 ; 20   |#define ERROR   -1
                              376 ; 21   |#endif
                              377 ; 22   |#if !defined(FALSE)
TASKING DSP2410 assembler v1.5r1 Build 138 SN 00100122
                                                                                                                            Page   7

M:ADDR CODE           CYCLES LINE SOURCELINE
                              378 ; 23   |#define FALSE 0
                              379 ; 24   |#endif
                              380 ; 25   |#if !defined(TRUE)
                              381 ; 26   |#define TRUE  1
                              382 ; 27   |#endif
                              383 ; 28   |
                              384 ; 29   |#if !defined(NULL)
                              385 ; 30   |#define NULL 0
                              386 ; 31   |#endif
                              387 ; 32   |
                              388 ; 33   |#define MAX_INT     0x7FFFFF
                              389 ; 34   |#define MAX_LONG    0x7FFFFFffffff
                              390 ; 35   |        // max positive unsigned long value: -1 == 0xFFFFFFffffff
                              391 ; 36   |#define MAX_ULONG   (-1) 
                              392 ; 37   |
                              393 ; 38   |#define WORD_SIZE   24              // word size in bits
                              394 ; 39   |#define BYTES_PER_WORD 3            // 8 bit bytes
                              395 ; 40   |
                              396 ; 41   |
                              397 ; 42   |#define BYTE    unsigned char       // btVarName
                              398 ; 43   |#define CHAR    signed char         // cVarName
                              399 ; 44   |#define USHORT  unsigned short      // usVarName
                              400 ; 45   |#define SHORT   unsigned short      // sVarName
                              401 ; 46   |#define WORD    unsigned int        // wVarName
                              402 ; 47   |#define INT     signed int          // iVarName
                              403 ; 48   |#define DWORD   unsigned long       // dwVarName
                              404 ; 49   |#define LONG    signed long         // lVarName
                              405 ; 50   |#define BOOL    unsigned int        // bVarName
                              406 ; 51   |#define FRACT   _fract              // frVarName
                              407 ; 52   |#define LFRACT  long _fract         // lfrVarName
                              408 ; 53   |#define CIRC    _circ               // cp<type prefix>VarName (see below)
                              409 ; 54   |#define FLOAT   float               // fVarName
                              410 ; 55   |#define DBL     double              // dVarName
                              411 ; 56   |#define ENUM    enum                // eVarName
                              412 ; 57   |#define CMX     _complex            // cmxVarName
                              413 ; 58   |typedef WORD UCS3;                   // 
                              414 ; 59   |
                              415 ; 60   |#define UINT16  unsigned short
                              416 ; 61   |#define UINT8   unsigned char   
                              417 ; 62   |#define UINT32  unsigned long
                              418 ; 63   |#define UINT64  unsigned long   // need to figure out how to do 64 bit values.  Or port ex
                                  isiting code to only use 48 bit
                              419 ; 64   |#define INT64   unsigned long   // need to figure out how to do 64 bit values.  Or port ex
                                  isiting code to only use 48 bit
                              420 ; 65   |#define WCHAR   UINT16
                              421 ; 66   |
                              422 ; 67   |//UINT128 is 16 bytes or 6 words
                              423 ; 68   |typedef struct UINT128_3500 {   
                              424 ; 69   |    int val[6];     
                              425 ; 70   |} UINT128_3500;
                              426 ; 71   |
                              427 ; 72   |#define UINT128   UINT128_3500
                              428 ; 73   |
                              429 ; 74   |// Little endian word packed byte strings:   
                              430 ; 75   |//      _packed BYTE bTextVarName[]="a string";  bText is a packed byte string prefix
                              431 ; 76   |// Convert to big endian words by reordering bytes from high to low using swizzle.
                              432 ; 77   |// Little endian word packed byte strings:   
                              433 ; 78   |//      _packed BYTE bTextVarName[]="a string";  bText is a packed byte string prefix
                              434 ; 79   |// Convert to big endian words by reordering bytes from high to low using swizzle.
                              435 ; 80   |
                              436 ; 81   |// Declare Memory Spaces To Use When Coding
                              437 ; 82   |// A. Sector Buffers
TASKING DSP2410 assembler v1.5r1 Build 138 SN 00100122
                                                                                                                            Page   8

M:ADDR CODE           CYCLES LINE SOURCELINE
                              438 ; 83   |#define SECTOR_BUFFER_MEM_X _X
                              439 ; 84   |#define SECTOR_BUFFER_MEM_Y _Y
                              440 ; 85   |#define SECTOR_BUFFER_MEM SECTOR_BUFFER_MEM_X
                              441 ; 86   |typedef WORD SECTOR_BUFFER_MEM SECTOR_BUFFER;
                              442 ; 87   |typedef SECTOR_BUFFER * P_SECTOR_BUFFER;
                              443 ; 88   |// B. Media DDI Memory
                              444 ; 89   |#define MEDIA_DDI_MEM _Y
                              445 ; 90   |
                              446 ; 91   |
                              447 ; 92   |
                              448 ; 93   |// Pointers to linear structures are labeled as: p<type prefix>VarName
                              449 ; 94   |// Examples of circular pointers:
                              450 ; 95   |//    INT CIRC cpiVarName
                              451 ; 96   |//    DWORD CIRC cpdwVarName
                              452 ; 97   |
                              453 ; 98   |#define RETCODE INT                 // rcVarName
                              454 ; 99   |
                              455 ; 100  |// generic bitfield structure
                              456 ; 101  |struct Bitfield {
                              457 ; 102  |    unsigned int B0  :1;
                              458 ; 103  |    unsigned int B1  :1;
                              459 ; 104  |    unsigned int B2  :1;
                              460 ; 105  |    unsigned int B3  :1;
                              461 ; 106  |    unsigned int B4  :1;
                              462 ; 107  |    unsigned int B5  :1;
                              463 ; 108  |    unsigned int B6  :1;
                              464 ; 109  |    unsigned int B7  :1;
                              465 ; 110  |    unsigned int B8  :1;
                              466 ; 111  |    unsigned int B9  :1;
                              467 ; 112  |    unsigned int B10 :1;
                              468 ; 113  |    unsigned int B11 :1;
                              469 ; 114  |    unsigned int B12 :1;
                              470 ; 115  |    unsigned int B13 :1;
                              471 ; 116  |    unsigned int B14 :1;
                              472 ; 117  |    unsigned int B15 :1;
                              473 ; 118  |    unsigned int B16 :1;
                              474 ; 119  |    unsigned int B17 :1;
                              475 ; 120  |    unsigned int B18 :1;
                              476 ; 121  |    unsigned int B19 :1;
                              477 ; 122  |    unsigned int B20 :1;
                              478 ; 123  |    unsigned int B21 :1;
                              479 ; 124  |    unsigned int B22 :1;
                              480 ; 125  |    unsigned int B23 :1;
                              481 ; 126  |};
                              482 ; 127  |
                              483 ; 128  |union BitInt {
                              484 ; 129  |        struct Bitfield B;
                              485 ; 130  |        int        I;
                              486 ; 131  |};
                              487 ; 132  |
                              488 ; 133  |#define MAX_MSG_LENGTH 10
                              489 ; 134  |struct CMessage
                              490 ; 135  |{
                              491 ; 136  |        unsigned int m_uLength;
                              492 ; 137  |        unsigned int m_uMsg[MAX_MSG_LENGTH];
                              493 ; 138  |};
                              494 ; 139  |
                              495 ; 140  |typedef struct {
                              496 ; 141  |    WORD m_wLength;
                              497 ; 142  |    WORD m_wMessage;
                              498 ; 143  |    WORD m_wParams[MAX_MSG_LENGTH];
                              499 ; 144  |} Message;
TASKING DSP2410 assembler v1.5r1 Build 138 SN 00100122
                                                                                                                            Page   9

M:ADDR CODE           CYCLES LINE SOURCELINE
                              500 ; 145  |
                              501 ; 146  |struct MessageQueueDescriptor
                              502 ; 147  |{
                              503 ; 148  |        int *m_pBase;
                              504 ; 149  |        int m_iModulo;
                              505 ; 150  |        int m_iSize;
                              506 ; 151  |        int *m_pHead;
                              507 ; 152  |        int *m_pTail;
                              508 ; 153  |};
                              509 ; 154  |
                              510 ; 155  |struct ModuleEntry
                              511 ; 156  |{
                              512 ; 157  |    int m_iSignaledEventMask;
                              513 ; 158  |    int m_iWaitEventMask;
                              514 ; 159  |    int m_iResourceOfCode;
                              515 ; 160  |    struct MessageQueueDescriptor *m_pMessageQueue;
                              516 ; 161  |    int _asmfunc (*m_pProcessEntryPoint)(union WaitMask Signals,struct MessageQueueDescrip
                                  tor *);
                              517 ; 162  |    int _asmfunc (*m_pInitFunction)(struct MessageQueueDescriptor *);
                              518 ; 163  |    int m_uTimeOutHigh;
                              519 ; 164  |    int m_uTimeOutLow;
                              520 ; 165  |    int _asmfunc (*m_pBackgroundFunction)(struct MessageQueueDescriptor *);
                              521 ; 166  |};
                              522 ; 167  |
                              523 ; 168  |union WaitMask{
                              524 ; 169  |    struct B{
                              525 ; 170  |        unsigned int m_bNone     :1;
                              526 ; 171  |        unsigned int m_bMessage  :1;
                              527 ; 172  |        unsigned int m_bTimer    :1;
                              528 ; 173  |        unsigned int m_bButton   :1;
                              529 ; 174  |    } B;
                              530 ; 175  |    int I;
                              531 ; 176  |} ;
                              532 ; 177  |
                              533 ; 178  |
                              534 ; 179  |struct Button {
                              535 ; 180  |        WORD wButtonEvent;
                              536 ; 181  |        WORD wUnused[MAX_MSG_LENGTH];   
                              537 ; 182  |};
                              538 ; 183  |
                              539 ; 184  |struct Message {
                              540 ; 185  |        WORD wMsgLength;
                              541 ; 186  |        WORD wMsgCommand;
                              542 ; 187  |        WORD wMsgParms[MAX_MSG_LENGTH-1];
                              543 ; 188  |};
                              544 ; 189  |
                              545 ; 190  |union EventTypes {
                              546 ; 191  |        struct CMessage msg;
                              547 ; 192  |        struct Button Button ;
                              548 ; 193  |        struct Message Message;
                              549 ; 194  |};
                              550 ; 195  |
                              551 ; 196  |// next 2 used to get updater build to return correct protocol ver in scsi response.
                              552 ; 197  |#define BUILD_TYPE_UPDATER  0x100
                              553 ; 198  |#define BUILD_TYPE_HOSTLINK 0x101
                              554 ; 199  |#define BUILD_TYPE_PLAYER   0x102
                              555 ; 200  |
                              556 ; 201  |// Resets part if RETAIL build. DEBUG build executes debug instruction to halt.
                              557 ; 202  |#define SystemHalt() __asm(" include 'sysmacro.asm' \n error") 
                              558 ; 203  |#define assert(x)    if(!(x)) __asm(" include 'sysmacro.asm' \n error")
                              559 ; 204  |
                              560 ; 205  |#if DEBUG
TASKING DSP2410 assembler v1.5r1 Build 138 SN 00100122
                                                                                                                            Page  10

M:ADDR CODE           CYCLES LINE SOURCELINE
                              561 ; 206  |// For DEBUG builds, DebugBuildAssert(condition) halts if condition evaluates to FALSE. 
                              562 ; 207  |#define DebugBuildAssert(x)    if(!(x)) __asm(" debug ")
                              563 ; 208  |#else 
                              564 ; 209  |// For RETAIL builds, DebugBuildAssert(condition) does nothing & execution continues rathe
                                  r than halt or reset. 
                              565 ; 210  |#define DebugBuildAssert(x)    
                              566 ; 211  |#endif
                              567 ; 212  |
                              568 ; 213  |// Do this in your C files to make a reminder that's displayed during the build.
                              569 ; 214  |//  #pragma asm
                              570 ; 215  |//  WARN 'Note to builder: reminder to do this after verifying that'
                              571 ; 216  |//  #pragma endasm
                              572 ; 217  |
                              573 ; 218  |
                              574 ; 219  |#ifdef COLOR_262K
                              575 ; 220  |#define RGB(r,g,b)    ((0x0000FC & (r)) << 10) | ((0x0000FC & (g)) << 4) | ((0x0000FC & (b
                                  )) >> 2)    //262k
                              576 ; 221  |#elif defined(COLOR_65K)
                              577 ; 222  |#define RGB(r,g,b)    ((0x0000F8 & (r)) << 8) | ((0x0000FC & (g)) << 3) | ((0x0000F8 & (b)
                                  ) >> 3)  //65k
                              578 ; 223  |#else
                              579 ; 224  |#define RGB(r,g,b)       ((0x0000F0 & (r)) << 4) | (0x0000F0 & (g)) | ((0x0000F0 & (b)) >>
                                   4)
                              580 ; 225  |#endif
                              581 ; 226  |    
                              582 ; 227  |#endif // #ifndef _TYPES_H
                              583 
                              585 
                              586 ; 14   |#include "project.h"
                              587 
                              589 
                              590 ; 1    |/////////////////////////////////////////////////////////////////////////////////
                              591 ; 2    |//  Copyright(C) SigmaTel, Inc. 2000-2004
                              592 ; 3    |//  Filename: project.inc
                              593 ; 4    |//  Description: 
                              594 ; 5    |/////////////////////////////////////////////////////////////////////////////////
                              595 ; 6    |
                              596 ; 7    |#if (!defined(_PROJECT_INC))
                              597 ; 8    |#define _PROJECT_INC 1
                              598 ; 9    |
                              599 ; 10   |#if defined(STMP_BUILD_PLAYER)
                              600 ; 11   |#include "hwequ.h"
                              601 ; 12   |#else 
                              602 ; 13   |//include "regscodec.inc"
                              603 ; 14   |#endif
                              604 ; 15   |
                              605 ; 16   |//////////////////////////////////////////////////////////////////////////////////
                              606 ; 17   |// Uncomment next define to allow player boot if you have stfm1000 macro enabled (defaults
                                   ON) & 
                              607 ; 18   |// your board crystal is not able to output nominal voltage range. Used in player main.asm
                                  . STMP00012148
                              608 ; 19   |// Defining this will result in lower battery life (price of using a lower quality crystal
                                  ). 
                              609 ; 20   |// Those that want to save battery life and have good crystals that meet our HW team's spe
                                  cs can 
                              610 ; 21   |// comment out this line to reduce crystal bias current and so battery current in player m
                                  ode.  
                              611 ; 22   |#define SUPPORT_MARGINAL_XTALS 1
                              612 ; 23   |
                              613 ; 24   |/////////////////////////////////////////////////////////////////////////////////
                              614 ; 25   |// BOOT SPEED CONFIG & ASSOCIATED BATTERY VOLTAGE CHECK ENABLE
                              615 ; 26   |/////////////////////////////////////////////////////////////////////////////////
TASKING DSP2410 assembler v1.5r1 Build 138 SN 00100122
                                                                                                                            Page  11

M:ADDR CODE           CYCLES LINE SOURCELINE
                              616 ; 27   |// Users can enable one of ATTEMPT_FAST_BOOT or FASTEST boot or neither project define bel
                                  ow by defining
                              617 ; 28   |// values as 0 or 1, else it defaults to the boot speed used in previous SDKs.
                              618 ; 29   |#define ATTEMPT_FAST_BOOT 1
                              619 ; 30   |#define ATTEMPT_FASTEST_BOOT 0   
                              620 ; 31   |// Changing this define to 0 removes Vbat threshholding & unconditionally gives fast boot 
                                  config above- 
                              621 ; 32   |// disabling this check is suggested for profiling if you want to try to tweak down thresh
                                  holds by maybe 50mV.
                              622 ; 33   |// Also the tests should clear the fast boot config defines to link & boot at normal speed
                                  .
                              623 ; 34   |#define SPEED_BOOT_BATTERY_CHECK 1
                              624 ; 35   |
                              625 ; 36   |/////////////////////////////////////////////////////////////////////////////////
                              626 ; 37   |// MEDIA DEFINITIONS
                              627 ; 38   |/////////////////////////////////////////////////////////////////////////////////
                              628 ; 39   |
                              629 ; 40   |/////////////////////////////////////////////////////////////////////////////////
                              630 ; 41   |// MNAND - Number of chips forming the internal physical device (i.e. # of NANDs)
                              631 ; 42   |#if defined(NAND1)
                              632 ; 43   |#define SM_INTERNAL_CHIPS 1
                              633 ; 44   |#else 
                              634 ; 45   |#if defined(NAND2)
                              635 ; 46   |#define SM_INTERNAL_CHIPS 2
                              636 ; 47   |#else 
                              637 ; 48   |#if defined(NAND3)
                              638 ; 49   |#define SM_INTERNAL_CHIPS 3
                              639 ; 50   |#else 
                              640 ; 51   |#if defined(NAND4)
                              641 ; 52   |#define SM_INTERNAL_CHIPS 4
                              642 ; 53   |#else 
                              643 ; 54   |#define SM_INTERNAL_CHIPS 1
                              644 ; 55   |#endif
                              645 ; 56   |#endif
                              646 ; 57   |#endif
                              647 ; 58   |#endif
                              648 ; 59   |
                              649 ; 60   |/////////////////////////////////////////////////////////////////////////////////
                              650 ; 61   |// If SMARTMEDIA_DETECT_ACTIVE_HIGH is defined:
                              651 ; 62   |//   SmartMedia will be detected as inserted if the GPIO pin reads 1 and removed if it rea
                                  ds 0.  
                              652 ; 63   |// If SMARTMEDIA_DETECT_ACTIVE_HIGH is not defined ** comment out next line **
                              653 ; 64   |//   SmartMedia will be detected as inserted if the GPIO pin reads 0 and removed if it rea
                                  ds 1.
                              654 ; 65   |//*** comment out if active high ****
                              655 ; 66   |//SMARTMEDIA_DETECT_ACTIVE_HIGH  equ     1
                              656 ; 67   |
                              657 ; 68   |#if defined(SMEDIA)
                              658 ; 69   |#define NUM_REMOVABLE_MEDIA 1
                              659 ; 70   |#define NUM_SM_EXTERNAL 1
                              660 ; 71   |#define MMC_MAX_PHYSICAL_DEVICES 0
                              661 ; 72   |#define SM_MAX_LOGICAL_DEVICES 2
                              662 ; 73   |#else 
                              663 ; 74   |#if defined(MMC)
                              664 ; 75   |#define NUM_REMOVABLE_MEDIA 1
                              665 ; 76   |#define NUM_SM_EXTERNAL 0
                              666 ; 77   |#define MMC_MAX_PHYSICAL_DEVICES 1
                              667 ; 78   |#define SM_MAX_LOGICAL_DEVICES 1
                              668 ; 79   |#else 
                              669 ; 80   |#define NUM_REMOVABLE_MEDIA 0
                              670 ; 81   |#define NUM_SM_EXTERNAL 0
                              671 ; 82   |#define MMC_MAX_PHYSICAL_DEVICES 0
TASKING DSP2410 assembler v1.5r1 Build 138 SN 00100122
                                                                                                                            Page  12

M:ADDR CODE           CYCLES LINE SOURCELINE
                              672 ; 83   |#define SM_MAX_LOGICAL_DEVICES 1
                              673 ; 84   |#endif
                              674 ; 85   |#endif
                              675 ; 86   |
                              676 ; 87   |/////////////////////////////////////////////////////////////////////////////////
                              677 ; 88   |// Mass Storage Class definitions
                              678 ; 89   |/////////////////////////////////////////////////////////////////////////////////
                              679 ; 90   |// Set to 0 if Composite Device build is desired.    
                              680 ; 91   |#define MULTI_LUN_BUILD 1   
                              681 ; 92   |
                              682 ; 93   |////////////////////////////////////////////////////////////////////////////////
                              683 ; 94   |//  SCSI
                              684 ; 95   |#if (MULTI_LUN_BUILD==0)
                              685 ; 96   |  #if (NUM_REMOVABLE_MEDIA == 1)
                              686 ; 97   |    #define SCSI_NUM_TARGETS                        2
                              687 ; 98   |    #define SCSI_DEVICE_NUM_LUNS_DEV_0              1
                              688 ; 99   |    #define SCSI_DEVICE_NUM_LUNS_DEV_1              1
                              689 ; 100  |  #else
                              690 ; 101  |    #define SCSI_NUM_TARGETS                        1
                              691 ; 102  |    #define SCSI_DEVICE_NUM_LUNS_DEV_0              1
                              692 ; 103  |  #endif
                              693 ; 104  |#else
                              694 ; 105  |    #define SCSI_NUM_TARGETS                        1
                              695 ; 106  |  #if (NUM_REMOVABLE_MEDIA == 1)
                              696 ; 107  |    #define SCSI_DEVICE_NUM_LUNS_DEV_0              2
                              697 ; 108  |  #else
                              698 ; 109  |    #define SCSI_DEVICE_NUM_LUNS_DEV_0              1  
                              699 ; 110  |  #endif
                              700 ; 111  |#endif
                              701 ; 112  |
                              702 ; 113  |
                              703 ; 114  |#define USBMSC_NUM_DEVICES                      SCSI_NUM_TARGETS
                              704 ; 115  |
                              705 ; 116  |
                              706 ; 117  |////////////////////////////////////////////////////////////////////////////////
                              707 ; 118  |// Define number of logical medias and drives for three builds (MTP, USBMSC, and Player)
                              708 ; 119  |////////////////////////////////////////////////////////////////////////////////
                              709 ; 120  |#ifdef MMC
                              710 ; 121  |#ifdef MTP_BUILD
                              711 ; 122  |// --------------------
                              712 ; 123  |// MTP and MMC
                              713 ; 124  |// --------------------
                              714 ; 125  |#define NUM_LOGICAL_MEDIA       2
                              715 ; 126  |#define NUM_LOGICAL_DRIVES      8
                              716 ; 127  |#else  // ifndef MTP_BUILD
                              717 ; 128  |#ifdef STMP_BUILD_PLAYER
                              718 ; 129  |// --------------------
                              719 ; 130  |// Player and MMC
                              720 ; 131  |// --------------------
                              721 ; 132  |#else
                              722 ; 133  |// --------------------
                              723 ; 134  |// USBMSC and MMC
                              724 ; 135  |// --------------------
                              725 ; 136  |#define NUM_LOGICAL_MEDIA       3
                              726 ; 137  |#define NUM_LOGICAL_DRIVES      8
                              727 ; 138  |#endif // ifdef STMP_BUILD_PLAYER
                              728 ; 139  |#endif // ifdef MTP_BUILD
                              729 ; 140  |#else  // ifndef MMC
                              730 ; 141  |#ifdef MTP_BUILD
                              731 ; 142  |// --------------------
                              732 ; 143  |// MTP and NAND only
                              733 ; 144  |// --------------------
TASKING DSP2410 assembler v1.5r1 Build 138 SN 00100122
                                                                                                                            Page  13

M:ADDR CODE           CYCLES LINE SOURCELINE
                              734 ; 145  |#define NUM_LOGICAL_MEDIA       1
                              735 ; 146  |#define NUM_LOGICAL_DRIVES      7
                              736 ; 147  |#else  // ifndef MTP_BUILD
                              737 ; 148  |#ifdef STMP_BUILD_PLAYER
                              738 ; 149  |// --------------------
                              739 ; 150  |// Player and NAND only
                              740 ; 151  |// --------------------
                              741 ; 152  |#else
                              742 ; 153  |// --------------------
                              743 ; 154  |// USBMSC and NAND only
                              744 ; 155  |// --------------------
                              745 ; 156  |#define NUM_LOGICAL_MEDIA       2
                              746 ; 157  |#define NUM_LOGICAL_DRIVES      7
                              747 ; 158  |#endif // ifdef STMP_BUILD_PLAYER
                              748 ; 159  |#endif // ifdef MTP_BUILD
                              749 ; 160  |#endif // ifdef MMC 
                              750 ; 161  |
                              751 ; 162  |// If we are in an MTP build then we don't use as many transfers buffers.
                              752 ; 163  |#if (defined(MTP_BUILD))
                              753 ; 164  |#define MAX_USB_TRANSFERS_QUEUED 16
                              754 ; 165  |
                              755 ; 166  |////!
                              756 ; 167  |////! This varible holds the watchdog count for the store flush.
                              757 ; 168  |////!
                              758 ; 169  |///
                              759 ; 170  |#include <types.h>
                              760 ; 171  |extern volatile INT g_StoreWatchDogCount;
                              761 ; 172  |extern const INT g_StoreWatchDogTimeout;
                              762 ; 173  |#endif
                              763 ; 174  |
                              764 ; 175  |////////////////////////////////////////////////////////////////////////////////
                              765 ; 176  |// These are needed here for Mass Storage Class
                              766 ; 177  |// Needs to be cleaned up
                              767 ; 178  |////////////////////////////////////////////////////////////////////////////////
                              768 ; 179  |#if (!defined(STMP_BUILD_PLAYER))
                              769 ; 180  |#define SCRATCH_USER_Y_SIZE 512
                              770 ; 181  |#define SCRATCH_USER_X_SIZE 512
                              771 ; 182  |
                              772 ; 183  |#define BROWNOUT_LEVEL1_DETECTED                0x000001
                              773 ; 184  |
                              774 ; 185  |#endif
                              775 ; 186  |
                              776 ; 187  |
                              777 ; 188  |/////////////////////////////////////////////////////////////////////////////////
                              778 ; 189  |// SmartMedia/NAND defs
                              779 ; 190  |#define SM_MAX_PHYSICAL_DEVICES SM_INTERNAL_CHIPS+NUM_SM_EXTERNAL
                              780 ; 191  |#define SM_REMOVABLE_DEVICE_NUM SM_INTERNAL_CHIPS
                              781 ; 192  |
                              782 ; 193  |/////////////////////////////////////////////////////////////////////////////////
                              783 ; 194  |// Sysloadresources defs
                              784 ; 195  |#define SM_MAX_RESOURCE_DEVICES SM_INTERNAL_CHIPS+NUM_SM_EXTERNAL
                              785 ; 196  |
                              786 ; 197  |/////////////////////////////////////////////////////////////////////////////////
                              787 ; 198  |// MMC defs
                              788 ; 199  |#define MMC_MAX_PARTITIONS 1
                              789 ; 200  |#define MMC_MAX_LOGICAL_DEVICES MMC_MAX_PHYSICAL_DEVICES*MMC_MAX_PARTITIONS
                              790 ; 201  |
                              791 ; 202  |/////////////////////////////////////////////////////////////////////////////////
                              792 ; 203  |// SPI defs
                              793 ; 204  |#define SPI_MAX_DEVICES MMC_MAX_PHYSICAL_DEVICES
                              794 ; 205  |
                              795 ; 206  |/////////////////////////////////////////////////////////////////////////////////
TASKING DSP2410 assembler v1.5r1 Build 138 SN 00100122
                                                                                                                            Page  14

M:ADDR CODE           CYCLES LINE SOURCELINE
                              796 ; 207  |// Global media defs
                              797 ; 208  |#define MAX_PHYSICAL_DEVICES SM_MAX_PHYSICAL_DEVICES+MMC_MAX_PHYSICAL_DEVICES
                              798 ; 209  |#define MAX_LOGICAL_DEVICES SM_MAX_LOGICAL_DEVICES+MMC_MAX_LOGICAL_DEVICES
                              799 ; 210  |
                              800 ; 211  |/////////////////////////////////////////////////////////////////////////////////
                              801 ; 212  |// DO NOT CHANGE THESE!!!
                              802 ; 213  |#define SM_MAX_PARTITIONS 4
                              803 ; 214  |#define MAX_HANDLES 2
                              804 ; 215  |/////////////////////////////////////////////////////////////////////////////////
                              805 ; 216  |
                              806 ; 217  |
                              807 ; 218  |/////////////////////////////////////////////////////////////////////////////////
                              808 ; 219  |// Battery LRADC Values 
                              809 ; 220  |/////////////////////////////////////////////////////////////////////////////////
                              810 ; 221  |// brownout trip point in mV (moved by RS)
                              811 ; 222  |// BATT_SAFETY_MARGIN:  percentage value used by:
                              812 ; 223  |//   * SysSaveSettings to determine if enough power is left to attempt a settings save. 
                              813 ; 224  |//   * Recorder to conditionally prevent the start or continuation of 
                              814 ; 225  |//     audio recording to media.
                              815 ; 226  |#define BATT_SAFETY_MARGIN 10
                              816 ; 227  |
                              817 ; 228  |//; player resource drive refresh allowed only when battery usable % is above this value. 
                                  
                              818 ; 229  |//; 50% of usable range [0.9V to 1.5V] is around 1.2V This is the safe target alkaline vol
                                  tage to do a refresh.
                              819 ; 230  |//; LIION will also require 50% which will work but that could be changed in the future. 
                              820 ; 231  |//RESOURCE_REFRESH_MIN_BATT_PCT equ 50
                              821 ; 232  |
                              822 ; 233  |// stmp00005071 adds these for mp3 encode stability at low battery per battery type & mmc 
                                  presence.
                              823 ; 234  |
                              824 ; 235  |//// Vbat threshholds empirically tuned by profiling max bat current for 3 HW cases: 
                              825 ; 236  |//// 1 GigaByte MMC, NAND flash only, & LiIon Buck mode. See voicemenu pre-encode Vbat che
                                  ck.
                              826 ; 237  |#if (!defined(CLCD))
                              827 ; 238  |#define MP3_ENC_MMC_MIN_V_BAT_MV 1100
                              828 ; 239  |#define MP3_ENC_NANDONLY_MIN_V_BAT_MV 1000
                              829 ; 240  |#else 
                              830 ; 241  |#define MP3_ENC_MMC_MIN_V_BAT_MV 1250
                              831 ; 242  |#define MP3_ENC_NANDONLY_MIN_V_BAT_MV 1150
                              832 ; 243  |#endif
                              833 ; 244  |#define MP3_ENC_BUCKMODE_MIN_V_BAT_MV 3300
                              834 ; 245  |
                              835 ; 246  |// These Vbat use-range-percentages are derived to correspond with target battery 
                              836 ; 247  |// voltages of 1.10V for MMC, 1.0V for nand only (alkaline or nimh), and 3.3V for any LiIo
                                  n.
                              837 ; 248  |// See mp3 encoder overlay.
                              838 ; 249  |#define MP3_ENC_MMC_MIN_V_BAT_RANGE_PCT 33
                              839 ; 250  |#define MP3_ENC_NANDONLY_MIN_V_BAT_RANGE_PCT 17
                              840 ; 251  |#define MP3_ENC_BUCKMODE_MIN_V_BAT_RANGE_PCT 25
                              841 ; 252  |
                              842 ; 253  |/////////////////////////////////////////////////////////////////////////////////
                              843 ; 254  |// Voice recording filenames
                              844 ; 255  |// number of digits in filename Vxxx.wav
                              845 ; 256  |/////////////////////////////////////////////////////////////////////////////////
                              846 ; 257  |#define DIGITS_IN_VOICE_FILENAME 3   
                              847 ; 258  |
                              848 ; 259  |/////////////////////////////////////////////////////////////////////////////////
                              849 ; 260  |// Mic Bias: Set this enable to 1 to internally generate mic bias voltage. 
                              850 ; 261  |// Also below, must configure internal resistor value and pin to use for DC bias. 
                              851 ; 262  |// Can set to 0 to disable internally generated mic bias voltage at pin lradc1/2.
                              852 ; 263  |#if defined(DEVICE_3500)
TASKING DSP2410 assembler v1.5r1 Build 138 SN 00100122
                                                                                                                            Page  15

M:ADDR CODE           CYCLES LINE SOURCELINE
                              853 ; 264  |#define ENABLE_INTERNALLY_GENERATED_MICBIAS 1 
                              854 ; 265  |// MIC BIAS circuit source selection: use Low Resolution ADC pin 2 or 1 to bias mic. 
                              855 ; 266  |// Per your layout: select LRADC 2 or 1 below 
                              856 ; 267  |//   (pin LRADC 2 for 35xx cpu card revB, LRADC 1 for 35xx cpu card revC, ref schematics, 
                                  & demo player)
                              857 ; 268  |#define LRADC_NUM_FOR_MIC_BIAS 1 
                              858 ; 269  |// Sets internal mic bias R to value 2, 4, or 8 (in kOhms).
                              859 ; 270  |#define MICBIAS_CONFIGURED_RESISTOR_KOHMS 8
                              860 ; 271  |
                              861 ; 272  |// Allows mic bias to settle before sampling. This delay currently unused. For rec btn whe
                                  n bias not yet ready.
                              862 ; 273  |#define REC_BTN_INTERNAL_MIC_BIAS_SETTLING_DELAY_MS 400 
                              863 ; 274  |// Option always keeps bias enabled after mainmenu init. This allows for start pop prevent
                                  ion if you use rec button from outside voice menu.
                              864 ; 275  |// This selection costs 1 mWatt but gains the desired low record button to sampling latenc
                                  y in the record-from-music-menu use-case.
                              865 ; 276  |#define KEEP_MIC_BIAS_ENABLED 0
                              866 ; 277  |
                              867 ; 278  |#else 
                              868 ; 279  |// STMP3410
                              869 ; 280  |#define ENABLE_INTERNALLY_GENERATED_MICBIAS 0
                              870 ; 281  |#define LRADC_NUM_FOR_MIC_BIAS 1 
                              871 ; 282  |#define MICBIAS_CONFIGURED_RESISTOR_KOHMS 2
                              872 ; 283  |#endif
                              873 ; 284  |
                              874 ; 285  |/////////////////////////////////////////////////////////////////////////////////
                              875 ; 286  |// Number of available soft timers
                              876 ; 287  |/////////////////////////////////////////////////////////////////////////////////
                              877 ; 288  |#if defined(SYNC_LYRICS)
                              878 ; 289  |#define SOFT_TIMERS 10
                              879 ; 290  |#else 
                              880 ; 291  |#if defined(JPEG_DECODER)
                              881 ; 292  |#define SOFT_TIMERS 10
                              882 ; 293  |#else 
                              883 ; 294  |#define SOFT_TIMERS 9
                              884 ; 295  |#endif
                              885 ; 296  |#endif
                              886 ; 297  |
                              887 ; 298  |/////////////////////////////////////////////////////////////////////////////////
                              888 ; 299  |//  sizes
                              889 ; 300  |/////////////////////////////////////////////////////////////////////////////////
                              890 ; 301  |#if defined(MMC)
                              891 ; 302  |#if defined(USE_PLAYLIST5)
                              892 ; 303  |#define MENU_STACK_SIZE 1500
                              893 ; 304  |#else 
                              894 ; 305  |#define MENU_STACK_SIZE 1250
                              895 ; 306  |#endif //if @def('USE_PLAYLIST5')
                              896 ; 307  |#else 
                              897 ; 308  |#if defined(USE_PLAYLIST5)
                              898 ; 309  |#define MENU_STACK_SIZE 1500
                              899 ; 310  |#else 
                              900 ; 311  |#define MENU_STACK_SIZE 1250
                              901 ; 312  |#endif //if @def('USE_PLAYLIST5')
                              902 ; 313  |#endif //if @def('MMC')
                              903 ; 314  |
                              904 ; 315  |// NOTE: SDK2.6 USED 550 FOR NEXT LINE, BUT SDK3.0BETA USED 750. Should it be ifdef MTP 75
                                  0 else 550 for other builds? TOVERIFY. MYALLOC
                              905 ; 316  |// 
                              906 ; 317  |#define STACK_L1_SIZE 750
                              907 ; 318  |#define STACK_L2_SIZE 100
                              908 ; 319  |#define STACK_L3_SIZE 160
                              909 ; 320  |
TASKING DSP2410 assembler v1.5r1 Build 138 SN 00100122
                                                                                                                            Page  16

M:ADDR CODE           CYCLES LINE SOURCELINE
                              910 ; 321  |// If we are in MTP mode the overlay task stack can shrink.
                              911 ; 322  |// TODO shrink this stack for MTP, I will leave it at 500 until we verify that it 
                              912 ; 323  |// is ok with switching code.
                              913 ; 324  |#if defined(MTP_BUILD)
                              914 ; 325  |#define OVERLAY_MANAGER_STACK_SIZE 300
                              915 ; 326  |#endif
                              916 ; 327  |
                              917 ; 328  |/////////////////////////////////////////////////////////////////////////////////
                              918 ; 329  |// maximum number of nested funclets 
                              919 ; 330  |/////////////////////////////////////////////////////////////////////////////////
                              920 ; 331  |#define MAX_NESTED_FUNCLET 6 
                              921 ; 332  |
                              922 ; 333  |/////////////////////////////////////////////////////////////////////////////////
                              923 ; 334  |//    LCD DEFINITIONS
                              924 ; 335  |/////////////////////////////////////////////////////////////////////////////////
                              925 ; 336  |
                              926 ; 337  |#define SPACE_CHAR 0x000020          
                              927 ; 338  |#define ZERO_CHAR 0x000030
                              928 ; 339  |#define COLON_CHAR 0x00003A
                              929 ; 340  |#define PERIOD_CHAR 0x00002E
                              930 ; 341  |
                              931 ; 342  |#if (defined(S6B33B0A_LCD))
                              932 ; 343  |#define LCD_X_SIZE 128
                              933 ; 344  |#define LCD_Y_SIZE 159
                              934 ; 345  |#endif
                              935 ; 346  |
                              936 ; 347  |#if (defined(SED15XX_LCD))
                              937 ; 348  |#define LCD_X_SIZE 128
                              938 ; 349  |#define LCD_Y_SIZE 64
                              939 ; 350  |#endif
                              940 ; 351  |
                              941 ; 352  |
                              942 ; 353  |//////////////////////////////////////////////////////////////////////////////////
                              943 ; 354  |//   Details on Customizing Contrast
                              944 ; 355  |/////////////////////////////////////////////////////////////////////////////////
                              945 ; 356  |//   Max supported LCD range is 0 - 3F; however due to hardware/voltage differences
                              946 ; 357  |//   the range of visibility is usually smaller than this.  It is important to 
                              947 ; 358  |//   calibrate the visible range, because the contrast setting is saved.
                              948 ; 359  |//   If the user shuts off the player while lcd is not visible, the player is useless
                              949 ; 360  |//   unless the ezact sequence is remembered.
                              950 ; 361  |//   To find out what range your player supports: 
                              951 ; 362  |//   change these equs to full range or comment out (full range is default)
                              952 ; 363  |//;;;;;;
                              953 ; 364  |// uncomment the line below to build code that will provide raw contrast value
                              954 ; 365  |// recommended calibration using player -- uncomment 
                              955 ; 366  |//;;;;;;
                              956 ; 367  |//CONTRAST_CALIBRATION    equ  1
                              957 ; 368  |////////////////////////////
                              958 ; 369  |#if (defined(DEMO_HW))
                              959 ; 370  |// this is the setting for ET301 demos; Next 2 line have not been updated for new Shingyi 
                                  LCD (June6'05)
                              960 ; 371  |#define LCD_MAX_CONTRAST 0x32 
                              961 ; 372  |#define LCD_MIN_CONTRAST 0x1E
                              962 ; 373  |#else 
                              963 ; 374  |
                              964 ; 375  |#if (defined(S6B33B0A_LCD))
                              965 ; 376  |#define LCD_MAX_CONTRAST 210
                              966 ; 377  |#define LCD_MIN_CONTRAST 160    
                              967 ; 378  |#endif
                              968 ; 379  |
                              969 ; 380  |#if (defined(SED15XX_LCD))
                              970 ; 381  |// Next 3 line comment was for OLD shingyi LCD: (default LCD before sdk2.6)
TASKING DSP2410 assembler v1.5r1 Build 138 SN 00100122
                                                                                                                            Page  17

M:ADDR CODE           CYCLES LINE SOURCELINE
                              971 ; 382  |// Engineering board regs support range [17-37].
                              972 ; 383  |//   Engineering board DC/DC support range [24-46]. 
                              973 ; 384  |//   One default contrast range [24-42] works for both.
                              974 ; 385  |// The 3 sets of contrast ranges below are updated for SDK2.6 to support either 
                              975 ; 386  |// new or old ShingYih LCDs. "File" refers to \resource\shingyih\system_lcd_init_seq.src
                              976 ; 387  |// 3/10/05 - Use one of the 2 next contrast ranges depending on which
                              977 ; 388  |// ShingYih LCD you have.  See \resources\shingyi\readme.txt 
                              978 ; 389  |// Optimal for NEW LCD with NEW file (SDK2.6 default)  
                              979 ; 390  |// G098064-41 LCD module (present on engr board revH LCD card)
                              980 ; 391  |
                              981 ; 392  |#if (defined(NEWSHINGYIH))
                              982 ; 393  |#define LCD_MAX_CONTRAST 250
                              983 ; 394  |#define LCD_MIN_CONTRAST 0
                              984 ; 395  |#else 
                              985 ; 396  |//-----
                              986 ; 397  |// Near optimal for OLD LCD with NEW file. 
                              987 ; 398  |// NOT optimal for the new lcd but pretty good. So u may use this if u want 1 build for bo
                                  th LCDs.
                              988 ; 399  |#define LCD_MAX_CONTRAST 250
                              989 ; 400  |#define LCD_MIN_CONTRAST 0
                              990 ; 401  |
                              991 ; 402  |//=====
                              992 ; 403  |// Optimal for OLD ShingYih LCD with OLD file (as sdk2.521)
                              993 ; 404  |// Suggest going with default new init file & values above for your LCD instead of this hi
                                  storic ver.
                              994 ; 405  |//LCD_MAX_CONTRAST equ 42
                              995 ; 406  |//LCD_MIN_CONTRAST equ 24 
                              996 ; 407  |
                              997 ; 408  |#endif
                              998 ; 409  |#endif
                              999 ; 410  |
                             1000 ; 411  |#endif
                             1001 ; 412  |
                             1002 ; 413  |//////////////////////////////////////////////////////////////////////////////////
                             1003 ; 414  |// The default value of the lcd contrast in % of range
                             1004 ; 415  |//   the default value is used when no settings.dat is available
                             1005 ; 416  |//////////////////////////////////////////////////////////////////////////////////
                             1006 ; 417  |
                             1007 ; 418  |#if (defined(S6B33B0A_LCD))
                             1008 ; 419  |// 60% of range is default value
                             1009 ; 420  |#define DEFAULT_CONTRAST 50 
                             1010 ; 421  |#endif
                             1011 ; 422  |
                             1012 ; 423  |#if (defined(SED15XX_LCD))
                             1013 ; 424  |// % of range is default value (was 60%)
                             1014 ; 425  |#define DEFAULT_CONTRAST 50 
                             1015 ; 426  |#endif
                             1016 ; 427  |
                             1017 ; 428  |
                             1018 ; 429  |// percentage change per increment/decrement message (LCD_DEC_CONTRAST/LCD_INC_CONTRAST)
                             1019 ; 430  |// make lower when doing calibration
                             1020 ; 431  |#define LCD_STEPSIZE_CONTRAST 10  
                             1021 ; 432  |
                             1022 ; 433  |
                             1023 ; 434  |/////////////////////////////////////////////////////////////////////////////////
                             1024 ; 435  |// For FFWD and RWND
                             1025 ; 436  |/////////////////////////////////////////////////////////////////////////////////
                             1026 ; 437  |#define SECONDS_TO_SKIP 1
                             1027 ; 438  |#define SECONDS_TO_SKIP1 3
                             1028 ; 439  |#define SECONDS_TO_SKIP2 6
                             1029 ; 440  |// number of seconds to cause reset to begin of song for PREV push
                             1030 ; 441  |#define PREV_SONG_THRESHOLD 5  
TASKING DSP2410 assembler v1.5r1 Build 138 SN 00100122
                                                                                                                            Page  18

M:ADDR CODE           CYCLES LINE SOURCELINE
                             1031 ; 442  |// number of 300 mSec periods before the numbers of seconds to skip increases
                             1032 ; 443  |#define FIRST_TIME_BOUNDARY 15 
                             1033 ; 444  |// number of 300 mSec periods before the numbers of seconds to skip increases
                             1034 ; 445  |#define SECOND_TIME_BOUNDARY 30 
                             1035 ; 446  |
                             1036 ; 447  |// For audible FFW/RWD
                             1037 ; 448  |#define SECONDS_TO_SKIP_FOR_3X_RATE 1
                             1038 ; 449  |#define SECONDS_TO_SKIP_FOR_60X_RATE 18
                             1039 ; 450  |#define SECONDS_TO_SKIP_FOR_600X_RATE 180
                             1040 ; 451  |#define SECONDS_TO_SKIP_FOR_1800X_RATE 540
                             1041 ; 452  |// number of 300 mSec periods before the numbers of seconds to skip increases
                             1042 ; 453  |#define LEVEL1_BOUNDARY 17 
                             1043 ; 454  |// number of 300 mSec periods before the numbers of seconds to skip increases
                             1044 ; 455  |#define LEVEL2_BOUNDARY 33 
                             1045 ; 456  |// number of 300 mSec periods before the numbers of seconds to skip increases
                             1046 ; 457  |#define LEVEL3_BOUNDARY 50 
                             1047 ; 458  |// Stmp00010296 Ticket #71685:  for song shorter than the min. skip size
                             1048 ; 459  |// if song_time < skip_size, bCurrentSongShort=>TRUE (ignore FWD/RWD commands)
                             1049 ; 460  |// Short Song Time, songs too short to play.
                             1050 ; 461  |#define SHORT_SONG_TIME SECONDS_TO_SKIP         
                             1051 ; 462  |
                             1052 ; 463  |/////////////////////////////////////////////////////////////////////////////////
                             1053 ; 464  |// MP3 Sync Values
                             1054 ; 465  |/////////////////////////////////////////////////////////////////////////////////
                             1055 ; 466  |// # bytes to look for sync before marking it bad
                             1056 ; 467  |#define MP3_SYNC_THRESHOLD 70000 
                             1057 ; 468  |// # bytes to look for sync before slowing decoder isr frequency (to let menus run)
                             1058 ; 469  |#define MP3_SYNC_THRESHOLD1 10000 
                             1059 ; 470  |// once we have sync'd, the isr should be called this frequently
                             1060 ; 471  |#define MP3_DECODERISR_FAST 7500  
                             1061 ; 472  |// if decoder is having difficulty syncing, switch isr to be called less frequently
                             1062 ; 473  |#define MP3_DECODERISR_SLOW 50000 
                             1063 ; 474  |
                             1064 ; 475  |
                             1065 ; 476  |/////////////////////////////////////////////////////////////////////////////////
                             1066 ; 477  |//// Multi-Stage Volume Control Definitions
                             1067 ; 478  |/////////////////////////////////////////////////////////////////////////////////
                             1068 ; 479  |//// Use Multi-Stage Volume
                             1069 ; 480  |#define MULTI_STAGE_VOLUME 0x1                  
                             1070 ; 481  |
                             1071 ; 482  |//// Master Volume definitions
                             1072 ; 483  |#define MIX_MSTR_MAX_VOL 0x0
                             1073 ; 484  |#define NUM_MSTR_ATT_STEPS (0x1F-MIX_MSTR_MAX_VOL)
                             1074 ; 485  |
                             1075 ; 486  |//// DAC-Mode definitions
                             1076 ; 487  |//// Adjusts 0dB point
                             1077 ; 488  |#define MIX_DAC_NOM_VOL 0x6                  
                             1078 ; 489  |#define MIX_DAC_MIN_VOL 0x1F
                             1079 ; 490  |// For minimum clipping: Set MIX_DAC_MAX_VOL below to match MIX_DAC_NOM_VOL value 2 lines 
                                  above.
                             1080 ; 491  |// For additional gain (with possible clipping): Set MIX_DAC_MAX_VOL in range below. 
                             1081 ; 492  |//                                               Each integer below MIX_DAC_NOM_VOL provid
                                  es 1.5 dB gain on Stmp34x0; 
                             1082 ; 493  |//                                               Max gain possible: 8 step diff would prov
                                  ide +12dB gain.   
                             1083 ; 494  |// range: [0 to MIX_DAC_NOM_VOL] (0 for loudest volume)
                             1084 ; 495  |#define MIX_DAC_MAX_VOL 0x0  
                             1085 ; 496  |
                             1086 ; 497  |#define NUM_DAC_ATT_STEPS (MIX_DAC_MIN_VOL-MIX_DAC_NOM_VOL+1)
                             1087 ; 498  |#define NUM_DAC_GAIN_STEPS (MIX_DAC_NOM_VOL-MIX_DAC_MAX_VOL)
                             1088 ; 499  |#define NUM_DAC_MODE_VOL_STEPS (NUM_DAC_ATT_STEPS+NUM_MSTR_ATT_STEPS+NUM_DAC_GAIN_STEPS+1)
                                  
TASKING DSP2410 assembler v1.5r1 Build 138 SN 00100122
                                                                                                                            Page  19

M:ADDR CODE           CYCLES LINE SOURCELINE
                             1089 ; 500  |
                             1090 ; 501  |//// If there is no stored volume, set to 50% of DAC-Mode max; change if DAC Mode is not t
                                  he default
                             1091 ; 502  |//// STMP35xx has 2dB attenuation per step so default needs a few more steps above midpoin
                                  t.
                             1092 ; 503  |#define DEFAULT_VOLUME ((NUM_DAC_MODE_VOL_STEPS/2)+6)         
                             1093 ; 504  |
                             1094 ; 505  |//// Set maximum restored volume to 75% of DAC-Mode max; change if DAC Mode is not the def
                                  ault
                             1095 ; 506  |#define MAX_RESTORED_VOLUME ((3*NUM_DAC_MODE_VOL_STEPS)/4)   
                             1096 ; 507  |
                             1097 ; 508  |
                             1098 ; 509  |//// Line In definitions (used for Line-In 1)
                             1099 ; 510  |//// 0dB point of the Line In
                             1100 ; 511  |#define MIX_LINE_NOM_VOL 0x8                  
                             1101 ; 512  |//// Minimum volume of Line In
                             1102 ; 513  |#define MIX_LINE_MIN_VOL 0x1F                 
                             1103 ; 514  |//// Maximum volume of Line In (can adjust extra gain)
                             1104 ; 515  |#define MIX_LINE_MAX_VOL 0x6                  
                             1105 ; 516  |#define NUM_LINE_ATT_STEPS (MIX_LINE_MIN_VOL-MIX_LINE_NOM_VOL+1)
                             1106 ; 517  |#define NUM_LINE_GAIN_STEPS (MIX_LINE_NOM_VOL-MIX_LINE_MAX_VOL)
                             1107 ; 518  |#define NUM_LINE_MODE_VOL_STEPS (NUM_LINE_ATT_STEPS+NUM_MSTR_ATT_STEPS+NUM_LINE_GAIN_STEPS
                                  +1)
                             1108 ; 519  |
                             1109 ; 520  |//// Line In definitions (used for FM tuner with 144 pin package)
                             1110 ; 521  |//// 0dB point of the Line In
                             1111 ; 522  |#define MIX_FM_NOM_VOL 0x8                  
                             1112 ; 523  |//// Minimum volume of Line In
                             1113 ; 524  |#define MIX_FM_MIN_VOL 0x1F                 
                             1114 ; 525  |//// Maximum volume of Line In (can adjust extra gain)
                             1115 ; 526  |#define MIX_FM_MAX_VOL 0x6                  
                             1116 ; 527  |#define NUM_FM_ATT_STEPS (MIX_FM_MIN_VOL-MIX_FM_NOM_VOL+1)
                             1117 ; 528  |#define NUM_FM_GAIN_STEPS (MIX_FM_NOM_VOL-MIX_FM_MAX_VOL)
                             1118 ; 529  |#define NUM_FM_MODE_VOL_STEPS (NUM_FM_ATT_STEPS+NUM_MSTR_ATT_STEPS+NUM_FM_GAIN_STEPS+1)
                             1119 ; 530  |
                             1120 ; 531  |/////////////////////////////////////////////////////////////////////////////////
                             1121 ; 532  |//// When enabled (1), periodically checks for one of several FM state machine invalid dea
                                  dlock states & recovers. 
                             1122 ; 533  |//// Define as 0 to disable FM-deadlock-state checking and recovery.
                             1123 ; 534  |#define FM_WATCHDOG_ENABLE 1
                             1124 ; 535  |
                             1125 ; 536  |#if !defined(STMP_BUILD_PLAYER)
                             1126 ; 537  |////
                             1127 ; 538  |////! This varible holds the lcd display state for the mtp project.
                             1128 ; 539  |////
                             1129 ; 540  |///
                             1130 ; 541  |#include <types.h>
                             1131 
                             1133 
                             1134 ; 1    |////////////////////////////////////////////////////////////////////////////////
                             1135 ; 2    |// Copyright(C) SigmaTel, Inc. 2000-2004
                             1136 ; 3    |//
                             1137 ; 4    |// Filename: types.h
                             1138 ; 5    |// Description: Standard data types
                             1139 ; 6    |////////////////////////////////////////////////////////////////////////////////
                             1140 ; 7    |
                             1141 ; 8    |#ifndef _TYPES_H
                             1142 ; 9    |#define _TYPES_H
                             1143 ; 10   |
                             1144 ; 11   |// TODO:  move this outta here!
                             1145 ; 12   |#if !defined(NOERROR)
                             1146 ; 13   |#define NOERROR 0
TASKING DSP2410 assembler v1.5r1 Build 138 SN 00100122
                                                                                                                            Page  20

M:ADDR CODE           CYCLES LINE SOURCELINE
                             1147 ; 14   |#define SUCCESS 0
                             1148 ; 15   |#endif 
                             1149 ; 16   |#if !defined(SUCCESS)
                             1150 ; 17   |#define SUCCESS  0
                             1151 ; 18   |#endif
                             1152 ; 19   |#if !defined(ERROR)
                             1153 ; 20   |#define ERROR   -1
                             1154 ; 21   |#endif
                             1155 ; 22   |#if !defined(FALSE)
                             1156 ; 23   |#define FALSE 0
                             1157 ; 24   |#endif
                             1158 ; 25   |#if !defined(TRUE)
                             1159 ; 26   |#define TRUE  1
                             1160 ; 27   |#endif
                             1161 ; 28   |
                             1162 ; 29   |#if !defined(NULL)
                             1163 ; 30   |#define NULL 0
                             1164 ; 31   |#endif
                             1165 ; 32   |
                             1166 ; 33   |#define MAX_INT     0x7FFFFF
                             1167 ; 34   |#define MAX_LONG    0x7FFFFFffffff
                             1168 ; 35   |        // max positive unsigned long value: -1 == 0xFFFFFFffffff
                             1169 ; 36   |#define MAX_ULONG   (-1) 
                             1170 ; 37   |
                             1171 ; 38   |#define WORD_SIZE   24              // word size in bits
                             1172 ; 39   |#define BYTES_PER_WORD 3            // 8 bit bytes
                             1173 ; 40   |
                             1174 ; 41   |
                             1175 ; 42   |#define BYTE    unsigned char       // btVarName
                             1176 ; 43   |#define CHAR    signed char         // cVarName
                             1177 ; 44   |#define USHORT  unsigned short      // usVarName
                             1178 ; 45   |#define SHORT   unsigned short      // sVarName
                             1179 ; 46   |#define WORD    unsigned int        // wVarName
                             1180 ; 47   |#define INT     signed int          // iVarName
                             1181 ; 48   |#define DWORD   unsigned long       // dwVarName
                             1182 ; 49   |#define LONG    signed long         // lVarName
                             1183 ; 50   |#define BOOL    unsigned int        // bVarName
                             1184 ; 51   |#define FRACT   _fract              // frVarName
                             1185 ; 52   |#define LFRACT  long _fract         // lfrVarName
                             1186 ; 53   |#define CIRC    _circ               // cp<type prefix>VarName (see below)
                             1187 ; 54   |#define FLOAT   float               // fVarName
                             1188 ; 55   |#define DBL     double              // dVarName
                             1189 ; 56   |#define ENUM    enum                // eVarName
                             1190 ; 57   |#define CMX     _complex            // cmxVarName
                             1191 ; 58   |typedef WORD UCS3;                   // 
                             1192 ; 59   |
                             1193 ; 60   |#define UINT16  unsigned short
                             1194 ; 61   |#define UINT8   unsigned char   
                             1195 ; 62   |#define UINT32  unsigned long
                             1196 ; 63   |#define UINT64  unsigned long   // need to figure out how to do 64 bit values.  Or port ex
                                  isiting code to only use 48 bit
                             1197 ; 64   |#define INT64   unsigned long   // need to figure out how to do 64 bit values.  Or port ex
                                  isiting code to only use 48 bit
                             1198 ; 65   |#define WCHAR   UINT16
                             1199 ; 66   |
                             1200 ; 67   |//UINT128 is 16 bytes or 6 words
                             1201 ; 68   |typedef struct UINT128_3500 {   
                             1202 ; 69   |    int val[6];     
                             1203 ; 70   |} UINT128_3500;
                             1204 ; 71   |
                             1205 ; 72   |#define UINT128   UINT128_3500
                             1206 ; 73   |
TASKING DSP2410 assembler v1.5r1 Build 138 SN 00100122
                                                                                                                            Page  21

M:ADDR CODE           CYCLES LINE SOURCELINE
                             1207 ; 74   |// Little endian word packed byte strings:   
                             1208 ; 75   |//      _packed BYTE bTextVarName[]="a string";  bText is a packed byte string prefix
                             1209 ; 76   |// Convert to big endian words by reordering bytes from high to low using swizzle.
                             1210 ; 77   |// Little endian word packed byte strings:   
                             1211 ; 78   |//      _packed BYTE bTextVarName[]="a string";  bText is a packed byte string prefix
                             1212 ; 79   |// Convert to big endian words by reordering bytes from high to low using swizzle.
                             1213 ; 80   |
                             1214 ; 81   |// Declare Memory Spaces To Use When Coding
                             1215 ; 82   |// A. Sector Buffers
                             1216 ; 83   |#define SECTOR_BUFFER_MEM_X _X
                             1217 ; 84   |#define SECTOR_BUFFER_MEM_Y _Y
                             1218 ; 85   |#define SECTOR_BUFFER_MEM SECTOR_BUFFER_MEM_X
                             1219 ; 86   |typedef WORD SECTOR_BUFFER_MEM SECTOR_BUFFER;
                             1220 ; 87   |typedef SECTOR_BUFFER * P_SECTOR_BUFFER;
                             1221 ; 88   |// B. Media DDI Memory
                             1222 ; 89   |#define MEDIA_DDI_MEM _Y
                             1223 ; 90   |
                             1224 ; 91   |
                             1225 ; 92   |
                             1226 ; 93   |// Pointers to linear structures are labeled as: p<type prefix>VarName
                             1227 ; 94   |// Examples of circular pointers:
                             1228 ; 95   |//    INT CIRC cpiVarName
                             1229 ; 96   |//    DWORD CIRC cpdwVarName
                             1230 ; 97   |
                             1231 ; 98   |#define RETCODE INT                 // rcVarName
                             1232 ; 99   |
                             1233 ; 100  |// generic bitfield structure
                             1234 ; 101  |struct Bitfield {
                             1235 ; 102  |    unsigned int B0  :1;
                             1236 ; 103  |    unsigned int B1  :1;
                             1237 ; 104  |    unsigned int B2  :1;
                             1238 ; 105  |    unsigned int B3  :1;
                             1239 ; 106  |    unsigned int B4  :1;
                             1240 ; 107  |    unsigned int B5  :1;
                             1241 ; 108  |    unsigned int B6  :1;
                             1242 ; 109  |    unsigned int B7  :1;
                             1243 ; 110  |    unsigned int B8  :1;
                             1244 ; 111  |    unsigned int B9  :1;
                             1245 ; 112  |    unsigned int B10 :1;
                             1246 ; 113  |    unsigned int B11 :1;
                             1247 ; 114  |    unsigned int B12 :1;
                             1248 ; 115  |    unsigned int B13 :1;
                             1249 ; 116  |    unsigned int B14 :1;
                             1250 ; 117  |    unsigned int B15 :1;
                             1251 ; 118  |    unsigned int B16 :1;
                             1252 ; 119  |    unsigned int B17 :1;
                             1253 ; 120  |    unsigned int B18 :1;
                             1254 ; 121  |    unsigned int B19 :1;
                             1255 ; 122  |    unsigned int B20 :1;
                             1256 ; 123  |    unsigned int B21 :1;
                             1257 ; 124  |    unsigned int B22 :1;
                             1258 ; 125  |    unsigned int B23 :1;
                             1259 ; 126  |};
                             1260 ; 127  |
                             1261 ; 128  |union BitInt {
                             1262 ; 129  |        struct Bitfield B;
                             1263 ; 130  |        int        I;
                             1264 ; 131  |};
                             1265 ; 132  |
                             1266 ; 133  |#define MAX_MSG_LENGTH 10
                             1267 ; 134  |struct CMessage
                             1268 ; 135  |{
TASKING DSP2410 assembler v1.5r1 Build 138 SN 00100122
                                                                                                                            Page  22

M:ADDR CODE           CYCLES LINE SOURCELINE
                             1269 ; 136  |        unsigned int m_uLength;
                             1270 ; 137  |        unsigned int m_uMsg[MAX_MSG_LENGTH];
                             1271 ; 138  |};
                             1272 ; 139  |
                             1273 ; 140  |typedef struct {
                             1274 ; 141  |    WORD m_wLength;
                             1275 ; 142  |    WORD m_wMessage;
                             1276 ; 143  |    WORD m_wParams[MAX_MSG_LENGTH];
                             1277 ; 144  |} Message;
                             1278 ; 145  |
                             1279 ; 146  |struct MessageQueueDescriptor
                             1280 ; 147  |{
                             1281 ; 148  |        int *m_pBase;
                             1282 ; 149  |        int m_iModulo;
                             1283 ; 150  |        int m_iSize;
                             1284 ; 151  |        int *m_pHead;
                             1285 ; 152  |        int *m_pTail;
                             1286 ; 153  |};
                             1287 ; 154  |
                             1288 ; 155  |struct ModuleEntry
                             1289 ; 156  |{
                             1290 ; 157  |    int m_iSignaledEventMask;
                             1291 ; 158  |    int m_iWaitEventMask;
                             1292 ; 159  |    int m_iResourceOfCode;
                             1293 ; 160  |    struct MessageQueueDescriptor *m_pMessageQueue;
                             1294 ; 161  |    int _asmfunc (*m_pProcessEntryPoint)(union WaitMask Signals,struct MessageQueueDescrip
                                  tor *);
                             1295 ; 162  |    int _asmfunc (*m_pInitFunction)(struct MessageQueueDescriptor *);
                             1296 ; 163  |    int m_uTimeOutHigh;
                             1297 ; 164  |    int m_uTimeOutLow;
                             1298 ; 165  |    int _asmfunc (*m_pBackgroundFunction)(struct MessageQueueDescriptor *);
                             1299 ; 166  |};
                             1300 ; 167  |
                             1301 ; 168  |union WaitMask{
                             1302 ; 169  |    struct B{
                             1303 ; 170  |        unsigned int m_bNone     :1;
                             1304 ; 171  |        unsigned int m_bMessage  :1;
                             1305 ; 172  |        unsigned int m_bTimer    :1;
                             1306 ; 173  |        unsigned int m_bButton   :1;
                             1307 ; 174  |    } B;
                             1308 ; 175  |    int I;
                             1309 ; 176  |} ;
                             1310 ; 177  |
                             1311 ; 178  |
                             1312 ; 179  |struct Button {
                             1313 ; 180  |        WORD wButtonEvent;
                             1314 ; 181  |        WORD wUnused[MAX_MSG_LENGTH];   
                             1315 ; 182  |};
                             1316 ; 183  |
                             1317 ; 184  |struct Message {
                             1318 ; 185  |        WORD wMsgLength;
                             1319 ; 186  |        WORD wMsgCommand;
                             1320 ; 187  |        WORD wMsgParms[MAX_MSG_LENGTH-1];
                             1321 ; 188  |};
                             1322 ; 189  |
                             1323 ; 190  |union EventTypes {
                             1324 ; 191  |        struct CMessage msg;
                             1325 ; 192  |        struct Button Button ;
                             1326 ; 193  |        struct Message Message;
                             1327 ; 194  |};
                             1328 ; 195  |
                             1329 ; 196  |// next 2 used to get updater build to return correct protocol ver in scsi response.
TASKING DSP2410 assembler v1.5r1 Build 138 SN 00100122
                                                                                                                            Page  23

M:ADDR CODE           CYCLES LINE SOURCELINE
                             1330 ; 197  |#define BUILD_TYPE_UPDATER  0x100
                             1331 ; 198  |#define BUILD_TYPE_HOSTLINK 0x101
                             1332 ; 199  |#define BUILD_TYPE_PLAYER   0x102
                             1333 ; 200  |
                             1334 ; 201  |// Resets part if RETAIL build. DEBUG build executes debug instruction to halt.
                             1335 ; 202  |#define SystemHalt() __asm(" include 'sysmacro.asm' \n error") 
                             1336 ; 203  |#define assert(x)    if(!(x)) __asm(" include 'sysmacro.asm' \n error")
                             1337 ; 204  |
                             1338 ; 205  |#if DEBUG
                             1339 ; 206  |// For DEBUG builds, DebugBuildAssert(condition) halts if condition evaluates to FALSE. 
                             1340 ; 207  |#define DebugBuildAssert(x)    if(!(x)) __asm(" debug ")
                             1341 ; 208  |#else 
                             1342 ; 209  |// For RETAIL builds, DebugBuildAssert(condition) does nothing & execution continues rathe
                                  r than halt or reset. 
                             1343 ; 210  |#define DebugBuildAssert(x)    
                             1344 ; 211  |#endif
                             1345 ; 212  |
                             1346 ; 213  |// Do this in your C files to make a reminder that's displayed during the build.
                             1347 ; 214  |//  #pragma asm
                             1348 ; 215  |//  WARN 'Note to builder: reminder to do this after verifying that'
                             1349 ; 216  |//  #pragma endasm
                             1350 ; 217  |
                             1351 ; 218  |
                             1352 ; 219  |#ifdef COLOR_262K
                             1353 ; 220  |#define RGB(r,g,b)    ((0x0000FC & (r)) << 10) | ((0x0000FC & (g)) << 4) | ((0x0000FC & (b
                                  )) >> 2)    //262k
                             1354 ; 221  |#elif defined(COLOR_65K)
                             1355 ; 222  |#define RGB(r,g,b)    ((0x0000F8 & (r)) << 8) | ((0x0000FC & (g)) << 3) | ((0x0000F8 & (b)
                                  ) >> 3)  //65k
                             1356 ; 223  |#else
                             1357 ; 224  |#define RGB(r,g,b)       ((0x0000F0 & (r)) << 4) | (0x0000F0 & (g)) | ((0x0000F0 & (b)) >>
                                   4)
                             1358 ; 225  |#endif
                             1359 ; 226  |    
                             1360 ; 227  |#endif // #ifndef _TYPES_H
                             1361 
                             1363 
                             1364 ; 542  |extern volatile WORD g_wActivityState;
                             1365 ; 543  |#endif // if !@def('STMP_BUILD_PLAYER')
                             1366 ; 544  |
                             1367 ; 545  |void _reentrant Init5VSense(void);
                             1368 ; 546  |void _reentrant ServiceDCDC(void);
                             1369 ; 547  |
                             1370 ; 548  |////////////////////////////////////////////////////////////////////////////
                             1371 ; 549  |//// JPEG Thumbnail Mode Setting
                             1372 ; 550  |//// number of column in thumbnail mode
                             1373 ; 551  |#define THUMBNAIL_X 2           
                             1374 ; 552  |//// number of row in  thumbnail mode
                             1375 ; 553  |#define THUMBNAIL_Y 2           
                             1376 ; 554  |//// thumbnail boundary offset x
                             1377 ; 555  |#define THUMBNAIL_X_OFFSET 4            
                             1378 ; 556  |//// thumbnail boundary offset y
                             1379 ; 557  |#define THUMBNAIL_Y_OFFSET 4            
                             1380 ; 558  |
                             1381 ; 559  |#endif // if (!@def(_PROJECT_INC))
                             1382 ; 560  |
                             1383 
                             1385 
                             1386 ; 15   |
                             1387 ; 16   |#ifndef _USB_MEM
                             1388 ; 17   |//if not overwridden, default to the compiler default memory space
                             1389 ; 18   |#define _USB_MEM
TASKING DSP2410 assembler v1.5r1 Build 138 SN 00100122
                                                                                                                            Page  24

M:ADDR CODE           CYCLES LINE SOURCELINE
                             1390 ; 19   |#endif
                             1391 ; 20   |
                             1392 ; 21   |#define USB_LANGUAGE_ENGLISH 0x0409
                             1393 ; 22   |#define USB_LANGUAGE_CHINESE_PRC 0x0804
                             1394 ; 23   |#define USB_LANGUAGE_CHINESE_TAIWAN 0x0404
                             1395 ; 24   |#define USB_LANGUAGE_JAPANESE 0x0411
                             1396 ; 25   |
                             1397 ; 26   |#define MAX_STRING 30
                             1398 ; 27   |
                             1399 ; 28   |#define  USB_SPEED_FULL                      (0)
                             1400 ; 29   |#define  USB_SPEED_LOW                       (1)
                             1401 ; 30   |#define  USB_SPEED_HIGH                      (2)
                             1402 ; 31   |
                             1403 ; 32   |#define EP_FS_MAX_PACKET_SIZE               (64)    
                             1404 ; 33   |
                             1405 ; 34   |#define EP_HS_MAX_PACKET_SIZE               (512)   
                             1406 ; 35   |
                             1407 ; 36   |// Data transferred to devices based on Sigmatel 3500 chip may sometimes be 
                             1408 ; 37   |// corrupted. The corruption occurs when device is connected in USB High Speed 
                             1409 ; 38   |// mode, and size of the transfer in bytes is divisible by 128, but not 
                             1410 ; 39   |// divisible by the packet size. The workaround is implemented in Microsoft MTP 
                             1411 ; 40   |// driver to allow support for those devices.
                             1412 ; 41   |
                             1413 ; 42   |// the bug can corrupt the end of data buffer. It occurs when host sends out a 
                             1414 ; 43   |// short packet that is multiple of 128 bytes. During this scenario the USB core
                             1415 ; 44   |// does writes that are voided (byte enable == all zero), which was an undefined 
                             1416 ; 45   |// capability and thus the gasket did not apply a proper response. This should 
                             1417 ; 46   |// not affect Mass Storage applications because data transfers are 512 bytes and 
                             1418 ; 47   |// scsi commands are < 16 bytes. Other applications with their own driver will
                             1419 ; 48   |// need to pad the packets if they fall into the error case. "What this basically 
                             1420 ; 49   |// boils down to is that any time the host sends a short packet of 128, 256 or
                             1421 ; 50   |// 384 bytes to a high-speed connected player a number of bytes will be corrupted.
                             1422 ; 51   |// This is easiest to reproduce in SendObject commands but can strike any of the 
                             1423 ; 52   |// commands that take an arbitrary amount of data.
                             1424 ; 53   |#define ARC_HS_128_MODULO_BUG               (128)
                             1425 ; 54   |
                             1426 ; 55   |
                             1427 ; 56   |/* Error codes */
                             1428 ; 57   |#define USB_OK                              (0x00)
                             1429 ; 58   |#define USBERR_REGISTER_SERVICE             (0x01)  // Failed to register a service
                             1430 ; 59   |#define USBERR_NO_SERVICE                   (0x02)  // No registered service found 
                             1431 ; 60   |#define USBERR_TX_FAILED                    (0x03)  // Fail to prepare XD descriptor
                             1432 ; 61   |#define USBERR_SIZE_TOO_LARGE               (0x04)  // Number of bytes to transfer is too 
                                  large
                             1433 ; 62   |#define USBERR_EP_INIT_FAILED               (0x05)  // Endpoint init fail
                             1434 ; 63   |#define USBERR_CONFIG_FAILED                (0x06)  // Error reported by the application
                             1435 ; 64   |                                                    // if the new config failed or not sup
                                  ported
                             1436 ; 65   |#define USBERR_DEVICE_NOT_CONFIGURED        (0x07)  // Error reported by the transfer func
                                  tion
                             1437 ; 66   |                                                    // if attempting to transfer while the
                                   device
                             1438 ; 67   |                                                    // is not configured
                             1439 ; 68   |#define USBERR_INIT_FAILED                  (0x08)  // Fail to initialize the USB API
                             1440 ; 69   |
                             1441 ; 70   |
                             1442 ; 71   |/* Endpoint types */
                             1443 ; 72   |#define  USB_CONTROL_ENDPOINT             (0)
                             1444 ; 73   |#define  USB_ISOCHRONOUS_ENDPOINT         (1)
                             1445 ; 74   |#define  USB_BULK_ENDPOINT                (2)
                             1446 ; 75   |#define  USB_INTERRUPT_ENDPOINT           (3)
                             1447 ; 76   |
TASKING DSP2410 assembler v1.5r1 Build 138 SN 00100122
                                                                                                                            Page  25

M:ADDR CODE           CYCLES LINE SOURCELINE
                             1448 ; 77   |/* End point direction */
                             1449 ; 78   |#define  USB_OUT                         (0)
                             1450 ; 79   |#define  USB_IN                          (1)
                             1451 ; 80   |
                             1452 ; 81   |/* End point packed size */
                             1453 ; 82   |#define  USB_FS_MAX_PACKET_SIZE           (64)
                             1454 ; 83   |#define  USB_HS_BULK_OUT_MAX_PACKET_SIZE  (256)
                             1455 ; 84   |#define  USB_HS_BULK_IN_MAX_PACKET_SIZE   (128)
                             1456 ; 85   |
                             1457 ; 86   |
                             1458 ; 87   |#define  USB_TEST_MODE_TEST_J             (0x01)
                             1459 ; 88   |#define  USB_TEST_MODE_TEST_K             (0x02)
                             1460 ; 89   |#define  USB_TEST_MODE_TEST_SE0_NAK       (0x03)
                             1461 ; 90   |#define  USB_TEST_MODE_TEST_PACKET        (0x04)
                             1462 ; 91   |
                             1463 ; 92   |/* Available service types */
                             1464 ; 93   |/* Services 0 through 15 are reserved for endpoints */
                             1465 ; 94   |#define  USB_SERVICE_EP0                  (0x00)
                             1466 ; 95   |#define  USB_SERVICE_EP1                  (0x01)
                             1467 ; 96   |#define  USB_SERVICE_EP2                  (0x02)
                             1468 ; 97   |#define  USB_SERVICE_EP3                  (0x03)
                             1469 ; 98   |#define  USB_SERVICE_EP4                  (0x04)
                             1470 ; 99   |#define  USB_SERVICE_EP5                  (0x05)
                             1471 ; 100  |#define  USB_SERVICE_EP6                  (0x06)
                             1472 ; 101  |#define  USB_SERVICE_EP7                  (0x07)
                             1473 ; 102  |#define  USB_SERVICE_EP8                  (0x08)
                             1474 ; 103  |#define  USB_SERVICE_EP9                  (0x09)
                             1475 ; 104  |#define  USB_SERVICE_EP10                 (0x0a)
                             1476 ; 105  |#define  USB_SERVICE_EP11                 (0x0b)
                             1477 ; 106  |#define  USB_SERVICE_EP12                 (0x0c)
                             1478 ; 107  |#define  USB_SERVICE_EP13                 (0x0d)
                             1479 ; 108  |#define  USB_SERVICE_EP14                 (0x0e)
                             1480 ; 109  |#define  USB_SERVICE_EP15                 (0x0f)
                             1481 ; 110  |#define  USB_SERVICE_BUS_RESET            (0x10)
                             1482 ; 111  |#define  USB_SERVICE_SUSPEND              (0x11)
                             1483 ; 112  |#define  USB_SERVICE_SOF                  (0x12)
                             1484 ; 113  |#define  USB_SERVICE_RESUME               (0x13)
                             1485 ; 114  |#define  USB_SERVICE_SLEEP                (0x14)
                             1486 ; 115  |#define  USB_SERVICE_SPEED_DETECTION      (0x15)
                             1487 ; 116  |#define  USB_SERVICE_TEST                 (0x16)
                             1488 ; 117  |#define  USB_SERVICE_CHANGE_CONFIG        (0x17)
                             1489 ; 118  |#define  USB_SERVICE_CHANGE_IFACE         (0x18)   
                             1490 ; 119  |#define  NON_EP_SERVICES                  (USB_SERVICE_SPEED_DETECTION - USB_SERVICE_EP15)
                                  
                             1491 ; 120  |
                             1492 ; 121  |// This is the maximum service structures allocated 
                             1493 ; 122  |// One for each End point + the common services (non endpoint services) 
                             1494 ; 123  |#define MAX_NUMBER_SERVICES               (MAX_NUM_EP + NON_EP_SERVICES)  
                             1495 ; 124  |
                             1496 ; 125  |#define NUMBER_BYTES_IN_SETUP               (8)
                             1497 ; 126  |
                             1498 ; 127  |// possible values of btStatus on the xd_struct
                             1499 ; 128  |#define  USB_STATUS_TRANSFER_IDLE           (0)
                             1500 ; 129  |#define  USB_STATUS_TRANSFER_SUCCESS        (1)            
                             1501 ; 130  |#define  USB_STATUS_TRANSFER_ACCEPTED       (2)
                             1502 ; 131  |#define  USB_STATUS_TRANSFER_IN_PROGRESS    (3)
                             1503 ; 132  |#define  USB_STATUS_TRANSFER_ERROR          (4)
                             1504 ; 133  |
                             1505 ; 134  |// types of status set/returned by set_status() and get_status()
                             1506 ; 135  |#define  USB_STATUS_DEVICE_STATE          (0x01)
                             1507 ; 136  |#define  USB_STATUS_INTERFACE             (0x02)
                             1508 ; 137  |#define  USB_STATUS_ADDRESS               (0x03)
TASKING DSP2410 assembler v1.5r1 Build 138 SN 00100122
                                                                                                                            Page  26

M:ADDR CODE           CYCLES LINE SOURCELINE
                             1509 ; 138  |#define  USB_STATUS_CURRENT_CONFIG        (0x04)
                             1510 ; 139  |#define  USB_STATUS_SOF_COUNT             (0x05)
                             1511 ; 140  |#define  USB_STATUS                       (0x06)
                             1512 ; 141  |#define  USB_STATUS_TEST_MODE             (0x07)
                             1513 ; 142  |#define  USB_STATUS_DEVICE_SPEED          (0x08)  
                             1514 ; 143  |#define  USB_STATUS_DEVICE_TEST           (0x09)  
                             1515 ; 144  |#define  USB_STATUS_CURRENT_IFACE         (0x0a)
                             1516 ; 145  |#define  USB_STATUS_CONNECTION            (0x0b)  
                             1517 ; 146  |// For status endpoint, the endpoint number is coded in the less significant nibble
                             1518 ; 147  |#define  USB_STATUS_ENDPOINT              (0x10)
                             1519 ; 148  |#define  USB_STATUS_ENDPOINT_NUMBER_MASK  (0x0F)
                             1520 ; 149  |
                             1521 ; 150  |#define USB_MAX_SIZE_PER_TRANSFER       (0x4000)    // This is the maximum size that
                             1522 ; 151  |                                                    // we allow per transfer
                             1523 ; 152  |
                             1524 ; 153  |//Possible states the device can be in
                             1525 ; 154  |#define  USB_STATE_UNKNOWN                   (0xff)
                             1526 ; 155  |#define  USB_STATE_UNPLUGGED                 (0x05) // USB Cable unplugged
                             1527 ; 156  |#define  USB_STATE_PLUGGED                   (0x04) // USB Cable inserted
                             1528 ; 157  |#define  USB_STATE_POWERED                   (0x03)
                             1529 ; 158  |#define  USB_STATE_DEFAULT                   (0x02)
                             1530 ; 159  |#define  USB_STATE_ADDRESSED                 (0x01)
                             1531 ; 160  |#define  USB_STATE_CONFIGURED                (0x00)
                             1532 ; 161  |#define  USB_STATE_SUSPENDED                 (0x80)
                             1533 ; 162  |
                             1534 ; 163  |// Possible states the connection can be in
                             1535 ; 164  |//#define USB_STATE_UNKNOWN                 (0xff)
                             1536 ; 165  |#define USB_CONNECTED                       (0x00)
                             1537 ; 166  |#define USB_DISCONNECTED                    (0x01)
                             1538 ; 167  |
                             1539 ; 168  |
                             1540 ; 169  |
                             1541 ; 170  |typedef union
                             1542 ; 171  |{
                             1543 ; 172  |    struct
                             1544 ; 173  |    {
                             1545 ; 174  |        int Recipient               : 5;
                             1546 ; 175  |        int Type                    : 2;
                             1547 ; 176  |        int DataTransferDirection   : 1;
                             1548 ; 177  |        int Request                 : 8;
                             1549 ; 178  |        int                         : 8;
                             1550 ; 179  |    } B;
                             1551 ; 180  |    
                             1552 ; 181  |    int I;
                             1553 ; 182  |} USBRequestType ;
                             1554 
                             1568 
                             1569 ; 183  |
                             1570 ; 184  |typedef struct {
                             1571 ; 185  |   BYTE     bValid;
                             1572 ; 186  |   USBRequestType RequestType;
                             1573 ; 187  |   BYTE     btRequest;
                             1574 ; 188  |   WORD     wValue;
                             1575 ; 189  |   WORD     wIndex;
                             1576 ; 190  |   WORD     wLength;
                             1577 ; 191  |    } USB_SetupData;
                             1578 ; 192  |
                             1579 ; 193  |// Descriptor sizes in bytes
                             1580 ; 194  |#define SIZE_DEVICE_DESCRIPTOR_IN_BYTES     (18)
                             1581 ; 195  |#define SIZE_DEVICE_DESCRIPTOR_IN_WORDS     (6)
                             1582 ; 196  |#define SIZE_DEVICE_QUALIFIER_DESCRIPTOR_IN_BYTES   (10)
                             1583 ; 197  |#define SIZE_DEVICE_QUALIFIER_DESCRIPTOR_IN_WORDS   (4)
TASKING DSP2410 assembler v1.5r1 Build 138 SN 00100122
                                                                                                                            Page  27

M:ADDR CODE           CYCLES LINE SOURCELINE
                             1584 ; 198  |#define SIZE_CONFIG_DESCRIPTOR_IN_BYTES     (9)
                             1585 ; 199  |#define SIZE_CONFIG_DESCRIPTOR_IN_WORDS     (3)
                             1586 ; 200  |#define SIZE_INTERFACE_DESCRIPTOR_IN_BYTES  (9)
                             1587 ; 201  |#define SIZE_INTERFACE_DESCRIPTOR_IN_WORDS  (3)
                             1588 ; 202  |#define SIZE_ENDPOINT_DESCRIPTOR_IN_BYTES   (7)
                             1589 ; 203  |
                             1590 ; 204  |
                             1591 ; 205  |// Descriptor types
                             1592 ; 206  |#define DESCRIPTOR_TYPE_DEVICE              (0x01)
                             1593 ; 207  |#define DESCRIPTOR_TYPE_CONFIG              (0x02)
                             1594 ; 208  |#define DESCRIPTOR_TYPE_STRING              (0x03)
                             1595 ; 209  |#define DESCRIPTOR_TYPE_INTERFACE           (0x04)
                             1596 ; 210  |#define DESCRIPTOR_TYPE_ENDPOINT            (0x05)
                             1597 ; 211  |#define DESCRIPTOR_TYPE_DEVICE_QUALIFIER    (0x06)
                             1598 ; 212  |#define DESCRIPTOR_TYPE_OTHER_SPEED_CONFIG  (0x07)
                             1599 ; 213  |#define DESCRIPTOR_TYPE_INTERFACE_POWER     (0x08)
                             1600 ; 214  |
                             1601 ; 215  |
                             1602 ; 216  |#define USB_REQUEST_DIRECTION_HOST_TO_DEVICE    ((WORD)0x000000)
                             1603 ; 217  |#define USB_REQUEST_DIRECTION_DEVICE_TO_HOST    ((WORD)0x000001)
                             1604 ; 218  |
                             1605 ; 219  |#define USB_REQUEST_TYPE_STANDARD               ((WORD)0x000000)
                             1606 ; 220  |#define USB_REQUEST_TYPE_CLASS                  ((WORD)0x000001)
                             1607 ; 221  |#define USB_REQUEST_TYPE_VENDOR                 ((WORD)0x000002)
                             1608 ; 222  |#define USB_REQUEST_TYPE_RESERVED               ((WORD)0x000003)
                             1609 ; 223  |
                             1610 ; 224  |#define USB_REQUEST_RECIPIENT_DEVICE            ((WORD)0x000000)
                             1611 ; 225  |#define USB_REQUEST_RECIPIENT_INTERFACE         ((WORD)0x000001)
                             1612 ; 226  |#define USB_REQUEST_RECIPIENT_ENDPOINT          ((WORD)0x000002)
                             1613 ; 227  |#define USB_REQUEST_RECIPIENT_OTHER             ((WORD)0x000003)
                             1614 ; 228  |
                             1615 ; 229  |#define USB_REQUEST_STANDARD_GET_STATUS         ((WORD)0x000000)
                             1616 ; 230  |#define USB_REQUEST_STANDARD_CLEAR_FEATURE      ((WORD)0x000001)
                             1617 ; 231  |#define USB_REQUEST_STANDARD_RESERVED_1         ((WORD)0x000002)
                             1618 ; 232  |#define USB_REQUEST_STANDARD_SET_FEATURE        ((WORD)0x000003)
                             1619 ; 233  |#define USB_REQUEST_STANDARD_RESERVED_2         ((WORD)0x000004)
                             1620 ; 234  |#define USB_REQUEST_STANDARD_SET_ADDRESS        ((WORD)0x000005)
                             1621 ; 235  |#define USB_REQUEST_STANDARD_GET_DESCRIPTOR     ((WORD)0x000006)
                             1622 ; 236  |#define USB_REQUEST_STANDARD_SET_DESCRIPTOR     ((WORD)0x000007)
                             1623 ; 237  |#define USB_REQUEST_STANDARD_GET_CONFIGURATION  ((WORD)0x000008)
                             1624 ; 238  |#define USB_REQUEST_STANDARD_SET_CONFIGURATION  ((WORD)0x000009)
                             1625 ; 239  |#define USB_REQUEST_STANDARD_GET_INTERFACE      ((WORD)0x00000A)
                             1626 ; 240  |#define USB_REQUEST_STANDARD_SET_INTERFACE      ((WORD)0x00000B)
                             1627 ; 241  |#define USB_REQUEST_STANDARD_SYNCH_FRAME        ((WORD)0x00000C)
                             1628 ; 242  |
                             1629 ; 243  |#define USB_CLEAR_FEATURE_ENDPOINT_HALT         (0)
                             1630 ; 244  |#define USB_CLEAR_FEATURE_REMOTE_WAKEUP         (1)
                             1631 ; 245  |
                             1632 ; 246  |
                             1633 ; 247  |// Struct Device Descriptor
                             1634 ; 248  |typedef struct {
                             1635 ; 249  |    BYTE    bLength;                // (0) Size of this descriptor in bytes (18)
                             1636 ; 250  |    BYTE    btDescriptorType;       // (1) Device descriptor type (1)
                             1637 ; 251  |    BYTE    btBcdUsbLsb;            // (2) USB specification release number (for version 2
                                  .00 0x00)
                             1638 ; 252  |    BYTE    btBcdUsbMsb;            // (3)                                  (for version 2
                                  .00 0x02)     
                             1639 ; 253  |    BYTE    btDeviceClass;          // (4) Class code
                             1640 ; 254  |    BYTE    btDeviceSubclass;       // (5) Subclass code
                             1641 ; 255  |    BYTE    btDeviceProtocol;       // (6) Protocol code
                             1642 ; 256  |    BYTE    btMaxPacketSize0;       // (7) Maximum packet size for endpoint 0 (8, 16, 32 o
                                  r 64)
TASKING DSP2410 assembler v1.5r1 Build 138 SN 00100122
                                                                                                                            Page  28

M:ADDR CODE           CYCLES LINE SOURCELINE
                             1643 ; 257  |    BYTE    btIdVendorLsb;          // (8) Vendor Id
                             1644 ; 258  |    BYTE    btIdVendorMsb;          // (9)
                             1645 ; 259  |    BYTE    btIdProductLsb;         // (10) Product Id
                             1646 ; 260  |    BYTE    btIdProductMsb;         // (11)
                             1647 ; 261  |    BYTE    btBcdReleaseLsb;        // (12) Device release number in BCD
                             1648 ; 262  |    BYTE    btBcdReleaseMsb;        // (13)
                             1649 ; 263  |    BYTE    btIndexManufacturer;    // (14) Index of string descriptor describing Manufact
                                  urer
                             1650 ; 264  |    BYTE    btIndexProduct;         // (15) Index of string descriptor describing Product
                             1651 ; 265  |    BYTE    btIndexSerialNumber;    // (16) Index of string descriptor describing Device S
                                  erial Number
                             1652 ; 266  |    BYTE    btNumConfigurations;    // (17) Number of possible configurations
                             1653 ; 267  |} Struct_Standard_Dev_Desc;
                             1654 ; 268  |
                             1655 ; 269  |// Struct Device Qualifier Descriptor
                             1656 ; 270  |typedef struct {
                             1657 ; 271  |    BYTE    bLength;                // (0) Size of this descriptor in bytes (10)
                             1658 ; 272  |    BYTE    btDescriptorType;       // (1) Device descriptor type (6)
                             1659 ; 273  |    BYTE    btBcdUsbLsb;            // (2) USB specification release number (for version 2
                                  .00 0x00)
                             1660 ; 274  |    BYTE    btBcdUsbMsb;            // (3)                                  (for version 2
                                  .00 0x02)     
                             1661 ; 275  |    BYTE    btDeviceClass;          // (4) Class code
                             1662 ; 276  |    BYTE    btDeviceSubclass;       // (5) Subclass code
                             1663 ; 277  |    BYTE    btDeviceProtocol;       // (6) Protocol code
                             1664 ; 278  |    BYTE    btMaxPacketSize0;       // (7) Maximum packet size for endpoint 0 other speed 
                                  (8, 16, 32 or 64)
                             1665 ; 279  |    BYTE    btNumConfigurations;    // (8) Number of other-speed possible configurations
                             1666 ; 280  |    BYTE    btReserved;             // (9) Reserved for future use, must be 0
                             1667 ; 281  |} Struct_Dev_Qualifier_Desc;
                             1668 ; 282  |
                             1669 ; 283  |// Struct Configuration Descriptor
                             1670 ; 284  |typedef struct {
                             1671 ; 285  |    BYTE    bLength;                // (0) Size of this descriptor in bytes (9)
                             1672 ; 286  |    BYTE    btDescriptorType;       // (1) Device descriptor type (2 or 7)
                             1673 ; 287  |    BYTE    btTotalLengthLsb;       // (2) Total length of data returned for this config.
                             1674 ; 288  |    BYTE    btTotalLengthMsb;       // (3)                                  
                             1675 ; 289  |    BYTE    btNumInterfaces;        // (4) Number of Interfaces supported by this configur
                                  ation
                             1676 ; 290  |    BYTE    btConfigurationValue;   // (5) Value to use as an argument to the SetConfigura
                                  tion() request
                             1677 ; 291  |    BYTE    btIndexConfiguration;   // (6) Index of string descriptor describing this conf
                                  iguration
                             1678 ; 292  |    BYTE    btBitMapAttributes;     // (7) Configuration Characteristics
                             1679 ; 293  |                                    //     D7:      Reserved (set to one)
                             1680 ; 294  |                                    //     D6:      Self-powered
                             1681 ; 295  |                                    //     D5:      Remote Wakeup
                             1682 ; 296  |                                    //     D4..0:   Reserved (reset to zero)        
                             1683 ; 297  |    BYTE    btMaxPower;             // (8) Maximum power consumption expressed in 2mA unit
                                  s.
                             1684 ; 298  |} Struct_Standard_Config_Desc, Struct_Other_Speed_Config_Desc;
                             1685 ; 299  |
                             1686 ; 300  |// Struct Interface Descriptor
                             1687 ; 301  |typedef struct {
                             1688 ; 302  |    BYTE    bLength;                // (0) Size of this descriptor in bytes (9)
                             1689 ; 303  |    BYTE    btDescriptorType;       // (1) Device descriptor type (4)
                             1690 ; 304  |    BYTE    btInterfaceNum;         // (2) Number of this interface. Zero-based value.
                             1691 ; 305  |    BYTE    btAlternateSetting;     // (3)                                  
                             1692 ; 306  |    BYTE    btNumEndpoints;         // (4) Number of endpointsused by this interface (excl
                                  uding endpoint 0).
                             1693 ; 307  |    BYTE    btInterfaceClass;       // (5) Class code
                             1694 ; 308  |    BYTE    btInterfaceSubClass;    // (6) Sub Class code
TASKING DSP2410 assembler v1.5r1 Build 138 SN 00100122
                                                                                                                            Page  29

M:ADDR CODE           CYCLES LINE SOURCELINE
                             1695 ; 309  |    BYTE    btInterfaceProtocol;    // (7) Protocol Code
                             1696 ; 310  |    BYTE    btIndexInterface;       // (8) Index of string descriptor describing this inte
                                  rface
                             1697 ; 311  |} Struct_Standard_Interface_Desc;
                             1698 ; 312  |
                             1699 ; 313  |// Struct Endpoint Descriptor
                             1700 ; 314  |typedef struct {
                             1701 ; 315  |    BYTE    bLength;                // (0) Size of this descriptor in bytes (7)
                             1702 ; 316  |    BYTE    btDescriptorType;       // (1) Device descriptor type (5)
                             1703 ; 317  |    BYTE    btEndpointAddress;      // (2) Address of the endpoint on the USB device descr
                                  ibed by this descriptor
                             1704 ; 318  |                                    //      Bit 3..0: Endpoint number
                             1705 ; 319  |                                    //      Bit 6..4: Reserved, reset to zero
                             1706 ; 320  |                                    //      Bit 7:    Direction. Ignored for control endpo
                                  ints (0 OUT, 1 IN)
                             1707 ; 321  |    BYTE    btBitMapAttributes;     // (3) Endpoint attributes
                             1708 ; 322  |                                    //      bits 1..0: Transfer Type (00 Control, 01 Iso, 
                                  10 Bulk, 11 Int)
                             1709 ; 323  |                                    //      bits 5..2: If not an iso endpoints, they are r
                                  eserved and must be reset to zero.
                             1710 ; 324  |                                    //      bits 7..6: Reserved bits, must be reset to zer
                                  o.                                    
                             1711 ; 325  |    BYTE    btMaxPacketSizeLsb;     // (4) Maximum packet size. Refer to standard for bits
                                   specification
                             1712 ; 326  |    BYTE    btMaxPacketSizeMsb;     // (5)
                             1713 ; 327  |    BYTE    btInterval;             // (6) Interval for polling endpoint for data transfer
                                  s (refer to standard)
                             1714 ; 328  |} Struct_Standard_Endpoint_Desc;
                             1715 ; 329  |
                             1716 ; 330  |typedef struct {
                             1717 ; 331  |    BYTE    btLength;                   // (0) Size of this descriptor in bytes (2*MAX_USB
                                  _LANG + 2)
                             1718 ; 332  |    BYTE    btDescriptorType;           // (1) String descriptor type (3)
                             1719 ; 333  |    BYTE    btString[MAX_STRING*2];       
                             1720 ; 334  |} Struct_String_Desc;
                             1721 ; 335  |
                             1722 ; 336  |//
                             1723 ; 337  |// Externals
                             1724 ; 338  |//
                             1725 ; 339  |extern void _reentrant usb_dci_chip_enable (void);
                             1726 ; 340  |extern void _reentrant usb_dci_shutdown(void);
                             1727 ; 341  |
                             1728 ; 342  |BYTE _reentrant usb_device_init(void);
                             1729 ; 343  |void _inline usb_device_shutdown(void)
                             1730 ; 344  |{
                             1731 ; 345  |    usb_dci_shutdown();
                             1732 ; 346  |}
                             1733 ; 347  |
                             1734 ; 348  |BYTE _reentrant usb_device_register_service(BYTE btType, void (* Service)(BOOL bSetup, BYT
                                  E btDirection, BYTE _USB_MEM * pbtBuffer, WORD wLength,WORD wPrivateData)); 
                             1735 ; 349  |//Remove unused function usb_device_get_service() to reclain _P memroy.
                             1736 ; 350  |//BYTE _reentrant usb_device_get_service(BYTE btType, void (* Service)(BOOL bSetup, BYTE b
                                  tDirection, BYTE _USB_MEM * pbtBuffer, WORD wLength)); 
                             1737 ; 351  |
                             1738 ; 352  |BYTE _reentrant usb_device_init_endpoint(BYTE btEndpoint, USHORT usMaxPacketSize, BYTE btD
                                  irection, BYTE btType, BOOL bFlag);
                             1739 ; 353  |
                             1740 ; 354  |extern USB_SetupData *_reentrant usb_dci_get_setup_data(BYTE btEndpoint);
                             1741 
                             1750 
                             1751 ; 355  |#define usb_device_read_setup_data(btEndpoint) usb_dci_get_setup_data(btEndpoint)
                             1752 ; 356  |
TASKING DSP2410 assembler v1.5r1 Build 138 SN 00100122
                                                                                                                            Page  30

M:ADDR CODE           CYCLES LINE SOURCELINE
                             1753 ; 357  |void _reentrant usb_device_get_status(BYTE btType, USHORT * pusStatus);
                             1754 ; 358  |void _reentrant usb_device_set_status(BYTE btType, USHORT usStatus);
                             1755 ; 359  |BYTE _reentrant usb_device_get_transfer_status(BYTE btEndpoint, BYTE btDirection);
                             1756 ; 360  |
                             1757 ; 361  |extern void _reentrant usb_dci_stall_endpoint(BYTE btEndpoint, BYTE btDirection);
                             1758 ; 362  |#define usb_device_stall_endpoint(btEndpoint, btDirection) usb_dci_stall_endpoint((btEndpo
                                  int), (btDirection))
                             1759 ; 363  |
                             1760 ; 364  |extern void _reentrant usb_dci_unstall_endpoint(BYTE btEndpoint, BYTE btDirection);
                             1761 ; 365  |#define usb_device_unstall_endpoint(btEndpoint, btDirection) usb_dci_unstall_endpoint((btE
                                  ndpoint), (btDirection))
                             1762 ; 366  |
                             1763 ; 367  |extern void _reentrant usb_dci_finish_transaction(BYTE btEndpoint);
                             1764 ; 368  |#define usb_device_finish_transaction(btEndpoint) usb_dci_finish_transaction(btEndpoint);
                             1765 ; 369  |
                             1766 ; 370  |////////////////////////////////////////////////////////////////////////////////
                             1767 ; 371  |//
                             1768 ; 372  |//>  Name:          usb_device_enable
                             1769 ; 373  |//
                             1770 ; 374  |//   Type:          Function
                             1771 ; 375  |//
                             1772 ; 376  |//   Description:   Enables the USB device for transfers
                             1773 ; 377  |//
                             1774 ; 378  |//   Inputs:        none
                             1775 ; 379  |//
                             1776 ; 380  |//   Outputs:       USB_OK or error code
                             1777 ; 381  |//
                             1778 ; 382  |//   Notes:         none
                             1779 ; 383  |//<
                             1780 ; 384  |////////////////////////////////////////////////////////////////////////////////
                             1781 ; 385  |void _inline usb_device_enable(void)
                             1782 ; 386  |{
                             1783 ; 387  |    usb_dci_chip_enable();
                             1784 ; 388  |}
                             1785 ; 389  |
                             1786 ; 390  |void _reentrant usb_device_release(void);
                             1787 ; 391  |void _reentrant usb_device_hold(void);
                             1788 ; 392  |BYTE _reentrant usb_device_is_hold(void);
                             1789 ; 393  |void _reentrant usb_device_data_phase_required(void);
                             1790 ; 394  |
                             1791 ; 395  |BOOL _reentrant usb_device_is_first_init(void);
                             1792 ; 396  |void _reentrant usb_device_set_first_init(void);
                             1793 ; 397  |void _reentrant usb_device_clear_first_init(void);
                             1794 ; 398  |
                             1795 ; 399  |WORD _reentrant usb_get_current_limit(void);
                             1796 ; 400  |RETCODE _reentrant usb_set_current_limit(WORD);
                             1797 ; 401  |
                             1798 ; 402  |////////////////////////////////////////////////////////////////////
                             1799 ; 403  |extern BYTE _reentrant usb_dci_get_endpoint_status(BYTE btEndpoint);
                             1800 ; 404  |#define usb_device_get_endpoint_status(btEndpoint) usb_dci_get_endpoint_status(btEndpoint)
                                  
                             1801 ; 405  |
                             1802 ; 406  |#define USB_ENDPOINT_STATUS_OK                          0
                             1803 ; 407  |#define USB_ENDPOINT_STATUS_STALLED                     1
                             1804 ; 408  |#define USB_ENDPOINT_STATUS_RECIEVED_UNSTALL_REQUEST    2
                             1805 ; 409  |// WHQL
                             1806 ; 410  |#define USB_ENDPOINT_STATUS_HOST_STALLED                3
                             1807 ; 411  |////////////////////////////////////////////////////////////////////
                             1808 ; 412  |
                             1809 ; 413  |
                             1810 ; 414  |BYTE _reentrant usb_device_send_data(BYTE btEndpoint, WORD _X * pbtStmpWordAdd, BYTE btByt
                                  eOffset, USHORT usSize, WORD wPrivateData, BOOL bIsDataPhase);
TASKING DSP2410 assembler v1.5r1 Build 138 SN 00100122
                                                                                                                            Page  31

M:ADDR CODE           CYCLES LINE SOURCELINE
                             1811 ; 415  |BYTE _reentrant usb_device_recv_data(BYTE btEndpoint, WORD _X * pbtStmpWordAdd, BYTE btByt
                                  eOffset, USHORT usSize, WORD wPrivateData, BOOL bIsDataPhase);
                             1812 ; 416  |void _reentrant ch9ServiceEp0(BOOL bSetup, BYTE btDirection, WORD _X *pbtBuffer, WORD wLen
                                  gth,WORD wPrivateData);
                             1813 ; 417  |BYTE _reentrant usb_device_transfer_data(BYTE btEndpoint, WORD _X* pbtStmpWordAdd, 
                             1814 ; 418  |                                         BYTE btByteOffset, USHORT usSize, WORD wPrivateDa
                                  ta, 
                             1815 ; 419  |                                         BOOL bIsDataPhase, WORD wDirection);
                             1816 ; 420  |
                             1817 ; 421  |#ifndef CUSTOMIZE_UNICODE
                             1818 ; 422  |extern const BYTE g_Manufacturer[];
                             1819 ; 423  |extern const BYTE g_ProductName[];
                             1820 ; 424  |extern const BYTE g_ConfigString[];
                             1821 ; 425  |extern const BYTE g_Interface0String[];
                             1822 ; 426  |extern const BYTE g_Interface1String[];
                             1823 ; 427  |extern const BYTE g_MSOSDescriptorString[];
                             1824 ; 428  |#else   // CUSTOMIZE_UNICODE
                             1825 ; 429  |extern const WORD g_Manufacturer[];
                             1826 ; 430  |extern const WORD g_ProductName[];
                             1827 ; 431  |extern const WORD g_ConfigString[];
                             1828 ; 432  |extern const WORD g_Interface0String[];
                             1829 ; 433  |extern const WORD g_Interface1String[];
                             1830 ; 434  |extern const WORD g_MSOSDescriptorString[];
                             1831 ; 435  |#endif
                             1832 ; 436  |extern WORD g_LanguageList[];
                             1833 ; 437  |
                             1834 ; 438  |extern const BYTE g_SCSIVendorID[];
                             1835 ; 439  |extern const BYTE g_SCSIProductID[];
                             1836 ; 440  |extern void *g_pStrings[];
                             1837 ; 441  |
                             1838 ; 442  |extern WORD g_wUSBVendorID;
                             1839 ; 443  |extern WORD g_wUSBProductID;
                             1840 ; 444  |extern WORD g_wUSBReleaseID;
                             1841 ; 445  |
                             1842 ; 446  |#endif
                             1843 ; 447  |/* EOF */
                             1844 ; 448  |
                             1845 
                             1847 
                             1848 ; 10   |#include "..\..\usb_internal.h"
                             1849 
                             1851 
                             1852 ; 1    |#ifndef _USB_INTERNAL_H
                             1853 ; 2    |#define _USB_INTERNAL_H
                             1854 ; 3    |
                             1855 ; 4    |#include "project.h"
                             1856 
                             1858 
                             1859 ; 1    |/////////////////////////////////////////////////////////////////////////////////
                             1860 ; 2    |//  Copyright(C) SigmaTel, Inc. 2000-2004
                             1861 ; 3    |//  Filename: project.inc
                             1862 ; 4    |//  Description: 
                             1863 ; 5    |/////////////////////////////////////////////////////////////////////////////////
                             1864 ; 6    |
                             1865 ; 7    |#if (!defined(_PROJECT_INC))
                             1866 ; 8    |#define _PROJECT_INC 1
                             1867 ; 9    |
                             1868 ; 10   |#if defined(STMP_BUILD_PLAYER)
                             1869 ; 11   |#include "hwequ.h"
                             1870 ; 12   |#else 
                             1871 ; 13   |//include "regscodec.inc"
                             1872 ; 14   |#endif
TASKING DSP2410 assembler v1.5r1 Build 138 SN 00100122
                                                                                                                            Page  32

M:ADDR CODE           CYCLES LINE SOURCELINE
                             1873 ; 15   |
                             1874 ; 16   |//////////////////////////////////////////////////////////////////////////////////
                             1875 ; 17   |// Uncomment next define to allow player boot if you have stfm1000 macro enabled (defaults
                                   ON) & 
                             1876 ; 18   |// your board crystal is not able to output nominal voltage range. Used in player main.asm
                                  . STMP00012148
                             1877 ; 19   |// Defining this will result in lower battery life (price of using a lower quality crystal
                                  ). 
                             1878 ; 20   |// Those that want to save battery life and have good crystals that meet our HW team's spe
                                  cs can 
                             1879 ; 21   |// comment out this line to reduce crystal bias current and so battery current in player m
                                  ode.  
                             1880 ; 22   |#define SUPPORT_MARGINAL_XTALS 1
                             1881 ; 23   |
                             1882 ; 24   |/////////////////////////////////////////////////////////////////////////////////
                             1883 ; 25   |// BOOT SPEED CONFIG & ASSOCIATED BATTERY VOLTAGE CHECK ENABLE
                             1884 ; 26   |/////////////////////////////////////////////////////////////////////////////////
                             1885 ; 27   |// Users can enable one of ATTEMPT_FAST_BOOT or FASTEST boot or neither project define bel
                                  ow by defining
                             1886 ; 28   |// values as 0 or 1, else it defaults to the boot speed used in previous SDKs.
                             1887 ; 29   |#define ATTEMPT_FAST_BOOT 1
                             1888 ; 30   |#define ATTEMPT_FASTEST_BOOT 0   
                             1889 ; 31   |// Changing this define to 0 removes Vbat threshholding & unconditionally gives fast boot 
                                  config above- 
                             1890 ; 32   |// disabling this check is suggested for profiling if you want to try to tweak down thresh
                                  holds by maybe 50mV.
                             1891 ; 33   |// Also the tests should clear the fast boot config defines to link & boot at normal speed
                                  .
                             1892 ; 34   |#define SPEED_BOOT_BATTERY_CHECK 1
                             1893 ; 35   |
                             1894 ; 36   |/////////////////////////////////////////////////////////////////////////////////
                             1895 ; 37   |// MEDIA DEFINITIONS
                             1896 ; 38   |/////////////////////////////////////////////////////////////////////////////////
                             1897 ; 39   |
                             1898 ; 40   |/////////////////////////////////////////////////////////////////////////////////
                             1899 ; 41   |// MNAND - Number of chips forming the internal physical device (i.e. # of NANDs)
                             1900 ; 42   |#if defined(NAND1)
                             1901 ; 43   |#define SM_INTERNAL_CHIPS 1
                             1902 ; 44   |#else 
                             1903 ; 45   |#if defined(NAND2)
                             1904 ; 46   |#define SM_INTERNAL_CHIPS 2
                             1905 ; 47   |#else 
                             1906 ; 48   |#if defined(NAND3)
                             1907 ; 49   |#define SM_INTERNAL_CHIPS 3
                             1908 ; 50   |#else 
                             1909 ; 51   |#if defined(NAND4)
                             1910 ; 52   |#define SM_INTERNAL_CHIPS 4
                             1911 ; 53   |#else 
                             1912 ; 54   |#define SM_INTERNAL_CHIPS 1
                             1913 ; 55   |#endif
                             1914 ; 56   |#endif
                             1915 ; 57   |#endif
                             1916 ; 58   |#endif
                             1917 ; 59   |
                             1918 ; 60   |/////////////////////////////////////////////////////////////////////////////////
                             1919 ; 61   |// If SMARTMEDIA_DETECT_ACTIVE_HIGH is defined:
                             1920 ; 62   |//   SmartMedia will be detected as inserted if the GPIO pin reads 1 and removed if it rea
                                  ds 0.  
                             1921 ; 63   |// If SMARTMEDIA_DETECT_ACTIVE_HIGH is not defined ** comment out next line **
                             1922 ; 64   |//   SmartMedia will be detected as inserted if the GPIO pin reads 0 and removed if it rea
                                  ds 1.
                             1923 ; 65   |//*** comment out if active high ****
TASKING DSP2410 assembler v1.5r1 Build 138 SN 00100122
                                                                                                                            Page  33

M:ADDR CODE           CYCLES LINE SOURCELINE
                             1924 ; 66   |//SMARTMEDIA_DETECT_ACTIVE_HIGH  equ     1
                             1925 ; 67   |
                             1926 ; 68   |#if defined(SMEDIA)
                             1927 ; 69   |#define NUM_REMOVABLE_MEDIA 1
                             1928 ; 70   |#define NUM_SM_EXTERNAL 1
                             1929 ; 71   |#define MMC_MAX_PHYSICAL_DEVICES 0
                             1930 ; 72   |#define SM_MAX_LOGICAL_DEVICES 2
                             1931 ; 73   |#else 
                             1932 ; 74   |#if defined(MMC)
                             1933 ; 75   |#define NUM_REMOVABLE_MEDIA 1
                             1934 ; 76   |#define NUM_SM_EXTERNAL 0
                             1935 ; 77   |#define MMC_MAX_PHYSICAL_DEVICES 1
                             1936 ; 78   |#define SM_MAX_LOGICAL_DEVICES 1
                             1937 ; 79   |#else 
                             1938 ; 80   |#define NUM_REMOVABLE_MEDIA 0
                             1939 ; 81   |#define NUM_SM_EXTERNAL 0
                             1940 ; 82   |#define MMC_MAX_PHYSICAL_DEVICES 0
                             1941 ; 83   |#define SM_MAX_LOGICAL_DEVICES 1
                             1942 ; 84   |#endif
                             1943 ; 85   |#endif
                             1944 ; 86   |
                             1945 ; 87   |/////////////////////////////////////////////////////////////////////////////////
                             1946 ; 88   |// Mass Storage Class definitions
                             1947 ; 89   |/////////////////////////////////////////////////////////////////////////////////
                             1948 ; 90   |// Set to 0 if Composite Device build is desired.    
                             1949 ; 91   |#define MULTI_LUN_BUILD 1   
                             1950 ; 92   |
                             1951 ; 93   |////////////////////////////////////////////////////////////////////////////////
                             1952 ; 94   |//  SCSI
                             1953 ; 95   |#if (MULTI_LUN_BUILD==0)
                             1954 ; 96   |  #if (NUM_REMOVABLE_MEDIA == 1)
                             1955 ; 97   |    #define SCSI_NUM_TARGETS                        2
                             1956 ; 98   |    #define SCSI_DEVICE_NUM_LUNS_DEV_0              1
                             1957 ; 99   |    #define SCSI_DEVICE_NUM_LUNS_DEV_1              1
                             1958 ; 100  |  #else
                             1959 ; 101  |    #define SCSI_NUM_TARGETS                        1
                             1960 ; 102  |    #define SCSI_DEVICE_NUM_LUNS_DEV_0              1
                             1961 ; 103  |  #endif
                             1962 ; 104  |#else
                             1963 ; 105  |    #define SCSI_NUM_TARGETS                        1
                             1964 ; 106  |  #if (NUM_REMOVABLE_MEDIA == 1)
                             1965 ; 107  |    #define SCSI_DEVICE_NUM_LUNS_DEV_0              2
                             1966 ; 108  |  #else
                             1967 ; 109  |    #define SCSI_DEVICE_NUM_LUNS_DEV_0              1  
                             1968 ; 110  |  #endif
                             1969 ; 111  |#endif
                             1970 ; 112  |
                             1971 ; 113  |
                             1972 ; 114  |#define USBMSC_NUM_DEVICES                      SCSI_NUM_TARGETS
                             1973 ; 115  |
                             1974 ; 116  |
                             1975 ; 117  |////////////////////////////////////////////////////////////////////////////////
                             1976 ; 118  |// Define number of logical medias and drives for three builds (MTP, USBMSC, and Player)
                             1977 ; 119  |////////////////////////////////////////////////////////////////////////////////
                             1978 ; 120  |#ifdef MMC
                             1979 ; 121  |#ifdef MTP_BUILD
                             1980 ; 122  |// --------------------
                             1981 ; 123  |// MTP and MMC
                             1982 ; 124  |// --------------------
                             1983 ; 125  |#define NUM_LOGICAL_MEDIA       2
                             1984 ; 126  |#define NUM_LOGICAL_DRIVES      8
                             1985 ; 127  |#else  // ifndef MTP_BUILD
TASKING DSP2410 assembler v1.5r1 Build 138 SN 00100122
                                                                                                                            Page  34

M:ADDR CODE           CYCLES LINE SOURCELINE
                             1986 ; 128  |#ifdef STMP_BUILD_PLAYER
                             1987 ; 129  |// --------------------
                             1988 ; 130  |// Player and MMC
                             1989 ; 131  |// --------------------
                             1990 ; 132  |#else
                             1991 ; 133  |// --------------------
                             1992 ; 134  |// USBMSC and MMC
                             1993 ; 135  |// --------------------
                             1994 ; 136  |#define NUM_LOGICAL_MEDIA       3
                             1995 ; 137  |#define NUM_LOGICAL_DRIVES      8
                             1996 ; 138  |#endif // ifdef STMP_BUILD_PLAYER
                             1997 ; 139  |#endif // ifdef MTP_BUILD
                             1998 ; 140  |#else  // ifndef MMC
                             1999 ; 141  |#ifdef MTP_BUILD
                             2000 ; 142  |// --------------------
                             2001 ; 143  |// MTP and NAND only
                             2002 ; 144  |// --------------------
                             2003 ; 145  |#define NUM_LOGICAL_MEDIA       1
                             2004 ; 146  |#define NUM_LOGICAL_DRIVES      7
                             2005 ; 147  |#else  // ifndef MTP_BUILD
                             2006 ; 148  |#ifdef STMP_BUILD_PLAYER
                             2007 ; 149  |// --------------------
                             2008 ; 150  |// Player and NAND only
                             2009 ; 151  |// --------------------
                             2010 ; 152  |#else
                             2011 ; 153  |// --------------------
                             2012 ; 154  |// USBMSC and NAND only
                             2013 ; 155  |// --------------------
                             2014 ; 156  |#define NUM_LOGICAL_MEDIA       2
                             2015 ; 157  |#define NUM_LOGICAL_DRIVES      7
                             2016 ; 158  |#endif // ifdef STMP_BUILD_PLAYER
                             2017 ; 159  |#endif // ifdef MTP_BUILD
                             2018 ; 160  |#endif // ifdef MMC 
                             2019 ; 161  |
                             2020 ; 162  |// If we are in an MTP build then we don't use as many transfers buffers.
                             2021 ; 163  |#if (defined(MTP_BUILD))
                             2022 ; 164  |#define MAX_USB_TRANSFERS_QUEUED 16
                             2023 ; 165  |
                             2024 ; 166  |////!
                             2025 ; 167  |////! This varible holds the watchdog count for the store flush.
                             2026 ; 168  |////!
                             2027 ; 169  |///
                             2028 ; 170  |#include <types.h>
                             2029 ; 171  |extern volatile INT g_StoreWatchDogCount;
                             2030 ; 172  |extern const INT g_StoreWatchDogTimeout;
                             2031 ; 173  |#endif
                             2032 ; 174  |
                             2033 ; 175  |////////////////////////////////////////////////////////////////////////////////
                             2034 ; 176  |// These are needed here for Mass Storage Class
                             2035 ; 177  |// Needs to be cleaned up
                             2036 ; 178  |////////////////////////////////////////////////////////////////////////////////
                             2037 ; 179  |#if (!defined(STMP_BUILD_PLAYER))
                             2038 ; 180  |#define SCRATCH_USER_Y_SIZE 512
                             2039 ; 181  |#define SCRATCH_USER_X_SIZE 512
                             2040 ; 182  |
                             2041 ; 183  |#define BROWNOUT_LEVEL1_DETECTED                0x000001
                             2042 ; 184  |
                             2043 ; 185  |#endif
                             2044 ; 186  |
                             2045 ; 187  |
                             2046 ; 188  |/////////////////////////////////////////////////////////////////////////////////
                             2047 ; 189  |// SmartMedia/NAND defs
TASKING DSP2410 assembler v1.5r1 Build 138 SN 00100122
                                                                                                                            Page  35

M:ADDR CODE           CYCLES LINE SOURCELINE
                             2048 ; 190  |#define SM_MAX_PHYSICAL_DEVICES SM_INTERNAL_CHIPS+NUM_SM_EXTERNAL
                             2049 ; 191  |#define SM_REMOVABLE_DEVICE_NUM SM_INTERNAL_CHIPS
                             2050 ; 192  |
                             2051 ; 193  |/////////////////////////////////////////////////////////////////////////////////
                             2052 ; 194  |// Sysloadresources defs
                             2053 ; 195  |#define SM_MAX_RESOURCE_DEVICES SM_INTERNAL_CHIPS+NUM_SM_EXTERNAL
                             2054 ; 196  |
                             2055 ; 197  |/////////////////////////////////////////////////////////////////////////////////
                             2056 ; 198  |// MMC defs
                             2057 ; 199  |#define MMC_MAX_PARTITIONS 1
                             2058 ; 200  |#define MMC_MAX_LOGICAL_DEVICES MMC_MAX_PHYSICAL_DEVICES*MMC_MAX_PARTITIONS
                             2059 ; 201  |
                             2060 ; 202  |/////////////////////////////////////////////////////////////////////////////////
                             2061 ; 203  |// SPI defs
                             2062 ; 204  |#define SPI_MAX_DEVICES MMC_MAX_PHYSICAL_DEVICES
                             2063 ; 205  |
                             2064 ; 206  |/////////////////////////////////////////////////////////////////////////////////
                             2065 ; 207  |// Global media defs
                             2066 ; 208  |#define MAX_PHYSICAL_DEVICES SM_MAX_PHYSICAL_DEVICES+MMC_MAX_PHYSICAL_DEVICES
                             2067 ; 209  |#define MAX_LOGICAL_DEVICES SM_MAX_LOGICAL_DEVICES+MMC_MAX_LOGICAL_DEVICES
                             2068 ; 210  |
                             2069 ; 211  |/////////////////////////////////////////////////////////////////////////////////
                             2070 ; 212  |// DO NOT CHANGE THESE!!!
                             2071 ; 213  |#define SM_MAX_PARTITIONS 4
                             2072 ; 214  |#define MAX_HANDLES 2
                             2073 ; 215  |/////////////////////////////////////////////////////////////////////////////////
                             2074 ; 216  |
                             2075 ; 217  |
                             2076 ; 218  |/////////////////////////////////////////////////////////////////////////////////
                             2077 ; 219  |// Battery LRADC Values 
                             2078 ; 220  |/////////////////////////////////////////////////////////////////////////////////
                             2079 ; 221  |// brownout trip point in mV (moved by RS)
                             2080 ; 222  |// BATT_SAFETY_MARGIN:  percentage value used by:
                             2081 ; 223  |//   * SysSaveSettings to determine if enough power is left to attempt a settings save. 
                             2082 ; 224  |//   * Recorder to conditionally prevent the start or continuation of 
                             2083 ; 225  |//     audio recording to media.
                             2084 ; 226  |#define BATT_SAFETY_MARGIN 10
                             2085 ; 227  |
                             2086 ; 228  |//; player resource drive refresh allowed only when battery usable % is above this value. 
                                  
                             2087 ; 229  |//; 50% of usable range [0.9V to 1.5V] is around 1.2V This is the safe target alkaline vol
                                  tage to do a refresh.
                             2088 ; 230  |//; LIION will also require 50% which will work but that could be changed in the future. 
                             2089 ; 231  |//RESOURCE_REFRESH_MIN_BATT_PCT equ 50
                             2090 ; 232  |
                             2091 ; 233  |// stmp00005071 adds these for mp3 encode stability at low battery per battery type & mmc 
                                  presence.
                             2092 ; 234  |
                             2093 ; 235  |//// Vbat threshholds empirically tuned by profiling max bat current for 3 HW cases: 
                             2094 ; 236  |//// 1 GigaByte MMC, NAND flash only, & LiIon Buck mode. See voicemenu pre-encode Vbat che
                                  ck.
                             2095 ; 237  |#if (!defined(CLCD))
                             2096 ; 238  |#define MP3_ENC_MMC_MIN_V_BAT_MV 1100
                             2097 ; 239  |#define MP3_ENC_NANDONLY_MIN_V_BAT_MV 1000
                             2098 ; 240  |#else 
                             2099 ; 241  |#define MP3_ENC_MMC_MIN_V_BAT_MV 1250
                             2100 ; 242  |#define MP3_ENC_NANDONLY_MIN_V_BAT_MV 1150
                             2101 ; 243  |#endif
                             2102 ; 244  |#define MP3_ENC_BUCKMODE_MIN_V_BAT_MV 3300
                             2103 ; 245  |
                             2104 ; 246  |// These Vbat use-range-percentages are derived to correspond with target battery 
TASKING DSP2410 assembler v1.5r1 Build 138 SN 00100122
                                                                                                                            Page  36

M:ADDR CODE           CYCLES LINE SOURCELINE
                             2105 ; 247  |// voltages of 1.10V for MMC, 1.0V for nand only (alkaline or nimh), and 3.3V for any LiIo
                                  n.
                             2106 ; 248  |// See mp3 encoder overlay.
                             2107 ; 249  |#define MP3_ENC_MMC_MIN_V_BAT_RANGE_PCT 33
                             2108 ; 250  |#define MP3_ENC_NANDONLY_MIN_V_BAT_RANGE_PCT 17
                             2109 ; 251  |#define MP3_ENC_BUCKMODE_MIN_V_BAT_RANGE_PCT 25
                             2110 ; 252  |
                             2111 ; 253  |/////////////////////////////////////////////////////////////////////////////////
                             2112 ; 254  |// Voice recording filenames
                             2113 ; 255  |// number of digits in filename Vxxx.wav
                             2114 ; 256  |/////////////////////////////////////////////////////////////////////////////////
                             2115 ; 257  |#define DIGITS_IN_VOICE_FILENAME 3   
                             2116 ; 258  |
                             2117 ; 259  |/////////////////////////////////////////////////////////////////////////////////
                             2118 ; 260  |// Mic Bias: Set this enable to 1 to internally generate mic bias voltage. 
                             2119 ; 261  |// Also below, must configure internal resistor value and pin to use for DC bias. 
                             2120 ; 262  |// Can set to 0 to disable internally generated mic bias voltage at pin lradc1/2.
                             2121 ; 263  |#if defined(DEVICE_3500)
                             2122 ; 264  |#define ENABLE_INTERNALLY_GENERATED_MICBIAS 1 
                             2123 ; 265  |// MIC BIAS circuit source selection: use Low Resolution ADC pin 2 or 1 to bias mic. 
                             2124 ; 266  |// Per your layout: select LRADC 2 or 1 below 
                             2125 ; 267  |//   (pin LRADC 2 for 35xx cpu card revB, LRADC 1 for 35xx cpu card revC, ref schematics, 
                                  & demo player)
                             2126 ; 268  |#define LRADC_NUM_FOR_MIC_BIAS 1 
                             2127 ; 269  |// Sets internal mic bias R to value 2, 4, or 8 (in kOhms).
                             2128 ; 270  |#define MICBIAS_CONFIGURED_RESISTOR_KOHMS 8
                             2129 ; 271  |
                             2130 ; 272  |// Allows mic bias to settle before sampling. This delay currently unused. For rec btn whe
                                  n bias not yet ready.
                             2131 ; 273  |#define REC_BTN_INTERNAL_MIC_BIAS_SETTLING_DELAY_MS 400 
                             2132 ; 274  |// Option always keeps bias enabled after mainmenu init. This allows for start pop prevent
                                  ion if you use rec button from outside voice menu.
                             2133 ; 275  |// This selection costs 1 mWatt but gains the desired low record button to sampling latenc
                                  y in the record-from-music-menu use-case.
                             2134 ; 276  |#define KEEP_MIC_BIAS_ENABLED 0
                             2135 ; 277  |
                             2136 ; 278  |#else 
                             2137 ; 279  |// STMP3410
                             2138 ; 280  |#define ENABLE_INTERNALLY_GENERATED_MICBIAS 0
                             2139 ; 281  |#define LRADC_NUM_FOR_MIC_BIAS 1 
                             2140 ; 282  |#define MICBIAS_CONFIGURED_RESISTOR_KOHMS 2
                             2141 ; 283  |#endif
                             2142 ; 284  |
                             2143 ; 285  |/////////////////////////////////////////////////////////////////////////////////
                             2144 ; 286  |// Number of available soft timers
                             2145 ; 287  |/////////////////////////////////////////////////////////////////////////////////
                             2146 ; 288  |#if defined(SYNC_LYRICS)
                             2147 ; 289  |#define SOFT_TIMERS 10
                             2148 ; 290  |#else 
                             2149 ; 291  |#if defined(JPEG_DECODER)
                             2150 ; 292  |#define SOFT_TIMERS 10
                             2151 ; 293  |#else 
                             2152 ; 294  |#define SOFT_TIMERS 9
                             2153 ; 295  |#endif
                             2154 ; 296  |#endif
                             2155 ; 297  |
                             2156 ; 298  |/////////////////////////////////////////////////////////////////////////////////
                             2157 ; 299  |//  sizes
                             2158 ; 300  |/////////////////////////////////////////////////////////////////////////////////
                             2159 ; 301  |#if defined(MMC)
                             2160 ; 302  |#if defined(USE_PLAYLIST5)
                             2161 ; 303  |#define MENU_STACK_SIZE 1500
TASKING DSP2410 assembler v1.5r1 Build 138 SN 00100122
                                                                                                                            Page  37

M:ADDR CODE           CYCLES LINE SOURCELINE
                             2162 ; 304  |#else 
                             2163 ; 305  |#define MENU_STACK_SIZE 1250
                             2164 ; 306  |#endif //if @def('USE_PLAYLIST5')
                             2165 ; 307  |#else 
                             2166 ; 308  |#if defined(USE_PLAYLIST5)
                             2167 ; 309  |#define MENU_STACK_SIZE 1500
                             2168 ; 310  |#else 
                             2169 ; 311  |#define MENU_STACK_SIZE 1250
                             2170 ; 312  |#endif //if @def('USE_PLAYLIST5')
                             2171 ; 313  |#endif //if @def('MMC')
                             2172 ; 314  |
                             2173 ; 315  |// NOTE: SDK2.6 USED 550 FOR NEXT LINE, BUT SDK3.0BETA USED 750. Should it be ifdef MTP 75
                                  0 else 550 for other builds? TOVERIFY. MYALLOC
                             2174 ; 316  |// 
                             2175 ; 317  |#define STACK_L1_SIZE 750
                             2176 ; 318  |#define STACK_L2_SIZE 100
                             2177 ; 319  |#define STACK_L3_SIZE 160
                             2178 ; 320  |
                             2179 ; 321  |// If we are in MTP mode the overlay task stack can shrink.
                             2180 ; 322  |// TODO shrink this stack for MTP, I will leave it at 500 until we verify that it 
                             2181 ; 323  |// is ok with switching code.
                             2182 ; 324  |#if defined(MTP_BUILD)
                             2183 ; 325  |#define OVERLAY_MANAGER_STACK_SIZE 300
                             2184 ; 326  |#endif
                             2185 ; 327  |
                             2186 ; 328  |/////////////////////////////////////////////////////////////////////////////////
                             2187 ; 329  |// maximum number of nested funclets 
                             2188 ; 330  |/////////////////////////////////////////////////////////////////////////////////
                             2189 ; 331  |#define MAX_NESTED_FUNCLET 6 
                             2190 ; 332  |
                             2191 ; 333  |/////////////////////////////////////////////////////////////////////////////////
                             2192 ; 334  |//    LCD DEFINITIONS
                             2193 ; 335  |/////////////////////////////////////////////////////////////////////////////////
                             2194 ; 336  |
                             2195 ; 337  |#define SPACE_CHAR 0x000020          
                             2196 ; 338  |#define ZERO_CHAR 0x000030
                             2197 ; 339  |#define COLON_CHAR 0x00003A
                             2198 ; 340  |#define PERIOD_CHAR 0x00002E
                             2199 ; 341  |
                             2200 ; 342  |#if (defined(S6B33B0A_LCD))
                             2201 ; 343  |#define LCD_X_SIZE 128
                             2202 ; 344  |#define LCD_Y_SIZE 159
                             2203 ; 345  |#endif
                             2204 ; 346  |
                             2205 ; 347  |#if (defined(SED15XX_LCD))
                             2206 ; 348  |#define LCD_X_SIZE 128
                             2207 ; 349  |#define LCD_Y_SIZE 64
                             2208 ; 350  |#endif
                             2209 ; 351  |
                             2210 ; 352  |
                             2211 ; 353  |//////////////////////////////////////////////////////////////////////////////////
                             2212 ; 354  |//   Details on Customizing Contrast
                             2213 ; 355  |/////////////////////////////////////////////////////////////////////////////////
                             2214 ; 356  |//   Max supported LCD range is 0 - 3F; however due to hardware/voltage differences
                             2215 ; 357  |//   the range of visibility is usually smaller than this.  It is important to 
                             2216 ; 358  |//   calibrate the visible range, because the contrast setting is saved.
                             2217 ; 359  |//   If the user shuts off the player while lcd is not visible, the player is useless
                             2218 ; 360  |//   unless the ezact sequence is remembered.
                             2219 ; 361  |//   To find out what range your player supports: 
                             2220 ; 362  |//   change these equs to full range or comment out (full range is default)
                             2221 ; 363  |//;;;;;;
                             2222 ; 364  |// uncomment the line below to build code that will provide raw contrast value
TASKING DSP2410 assembler v1.5r1 Build 138 SN 00100122
                                                                                                                            Page  38

M:ADDR CODE           CYCLES LINE SOURCELINE
                             2223 ; 365  |// recommended calibration using player -- uncomment 
                             2224 ; 366  |//;;;;;;
                             2225 ; 367  |//CONTRAST_CALIBRATION    equ  1
                             2226 ; 368  |////////////////////////////
                             2227 ; 369  |#if (defined(DEMO_HW))
                             2228 ; 370  |// this is the setting for ET301 demos; Next 2 line have not been updated for new Shingyi 
                                  LCD (June6'05)
                             2229 ; 371  |#define LCD_MAX_CONTRAST 0x32 
                             2230 ; 372  |#define LCD_MIN_CONTRAST 0x1E
                             2231 ; 373  |#else 
                             2232 ; 374  |
                             2233 ; 375  |#if (defined(S6B33B0A_LCD))
                             2234 ; 376  |#define LCD_MAX_CONTRAST 210
                             2235 ; 377  |#define LCD_MIN_CONTRAST 160    
                             2236 ; 378  |#endif
                             2237 ; 379  |
                             2238 ; 380  |#if (defined(SED15XX_LCD))
                             2239 ; 381  |// Next 3 line comment was for OLD shingyi LCD: (default LCD before sdk2.6)
                             2240 ; 382  |// Engineering board regs support range [17-37].
                             2241 ; 383  |//   Engineering board DC/DC support range [24-46]. 
                             2242 ; 384  |//   One default contrast range [24-42] works for both.
                             2243 ; 385  |// The 3 sets of contrast ranges below are updated for SDK2.6 to support either 
                             2244 ; 386  |// new or old ShingYih LCDs. "File" refers to \resource\shingyih\system_lcd_init_seq.src
                             2245 ; 387  |// 3/10/05 - Use one of the 2 next contrast ranges depending on which
                             2246 ; 388  |// ShingYih LCD you have.  See \resources\shingyi\readme.txt 
                             2247 ; 389  |// Optimal for NEW LCD with NEW file (SDK2.6 default)  
                             2248 ; 390  |// G098064-41 LCD module (present on engr board revH LCD card)
                             2249 ; 391  |
                             2250 ; 392  |#if (defined(NEWSHINGYIH))
                             2251 ; 393  |#define LCD_MAX_CONTRAST 250
                             2252 ; 394  |#define LCD_MIN_CONTRAST 0
                             2253 ; 395  |#else 
                             2254 ; 396  |//-----
                             2255 ; 397  |// Near optimal for OLD LCD with NEW file. 
                             2256 ; 398  |// NOT optimal for the new lcd but pretty good. So u may use this if u want 1 build for bo
                                  th LCDs.
                             2257 ; 399  |#define LCD_MAX_CONTRAST 250
                             2258 ; 400  |#define LCD_MIN_CONTRAST 0
                             2259 ; 401  |
                             2260 ; 402  |//=====
                             2261 ; 403  |// Optimal for OLD ShingYih LCD with OLD file (as sdk2.521)
                             2262 ; 404  |// Suggest going with default new init file & values above for your LCD instead of this hi
                                  storic ver.
                             2263 ; 405  |//LCD_MAX_CONTRAST equ 42
                             2264 ; 406  |//LCD_MIN_CONTRAST equ 24 
                             2265 ; 407  |
                             2266 ; 408  |#endif
                             2267 ; 409  |#endif
                             2268 ; 410  |
                             2269 ; 411  |#endif
                             2270 ; 412  |
                             2271 ; 413  |//////////////////////////////////////////////////////////////////////////////////
                             2272 ; 414  |// The default value of the lcd contrast in % of range
                             2273 ; 415  |//   the default value is used when no settings.dat is available
                             2274 ; 416  |//////////////////////////////////////////////////////////////////////////////////
                             2275 ; 417  |
                             2276 ; 418  |#if (defined(S6B33B0A_LCD))
                             2277 ; 419  |// 60% of range is default value
                             2278 ; 420  |#define DEFAULT_CONTRAST 50 
                             2279 ; 421  |#endif
                             2280 ; 422  |
                             2281 ; 423  |#if (defined(SED15XX_LCD))
TASKING DSP2410 assembler v1.5r1 Build 138 SN 00100122
                                                                                                                            Page  39

M:ADDR CODE           CYCLES LINE SOURCELINE
                             2282 ; 424  |// % of range is default value (was 60%)
                             2283 ; 425  |#define DEFAULT_CONTRAST 50 
                             2284 ; 426  |#endif
                             2285 ; 427  |
                             2286 ; 428  |
                             2287 ; 429  |// percentage change per increment/decrement message (LCD_DEC_CONTRAST/LCD_INC_CONTRAST)
                             2288 ; 430  |// make lower when doing calibration
                             2289 ; 431  |#define LCD_STEPSIZE_CONTRAST 10  
                             2290 ; 432  |
                             2291 ; 433  |
                             2292 ; 434  |/////////////////////////////////////////////////////////////////////////////////
                             2293 ; 435  |// For FFWD and RWND
                             2294 ; 436  |/////////////////////////////////////////////////////////////////////////////////
                             2295 ; 437  |#define SECONDS_TO_SKIP 1
                             2296 ; 438  |#define SECONDS_TO_SKIP1 3
                             2297 ; 439  |#define SECONDS_TO_SKIP2 6
                             2298 ; 440  |// number of seconds to cause reset to begin of song for PREV push
                             2299 ; 441  |#define PREV_SONG_THRESHOLD 5  
                             2300 ; 442  |// number of 300 mSec periods before the numbers of seconds to skip increases
                             2301 ; 443  |#define FIRST_TIME_BOUNDARY 15 
                             2302 ; 444  |// number of 300 mSec periods before the numbers of seconds to skip increases
                             2303 ; 445  |#define SECOND_TIME_BOUNDARY 30 
                             2304 ; 446  |
                             2305 ; 447  |// For audible FFW/RWD
                             2306 ; 448  |#define SECONDS_TO_SKIP_FOR_3X_RATE 1
                             2307 ; 449  |#define SECONDS_TO_SKIP_FOR_60X_RATE 18
                             2308 ; 450  |#define SECONDS_TO_SKIP_FOR_600X_RATE 180
                             2309 ; 451  |#define SECONDS_TO_SKIP_FOR_1800X_RATE 540
                             2310 ; 452  |// number of 300 mSec periods before the numbers of seconds to skip increases
                             2311 ; 453  |#define LEVEL1_BOUNDARY 17 
                             2312 ; 454  |// number of 300 mSec periods before the numbers of seconds to skip increases
                             2313 ; 455  |#define LEVEL2_BOUNDARY 33 
                             2314 ; 456  |// number of 300 mSec periods before the numbers of seconds to skip increases
                             2315 ; 457  |#define LEVEL3_BOUNDARY 50 
                             2316 ; 458  |// Stmp00010296 Ticket #71685:  for song shorter than the min. skip size
                             2317 ; 459  |// if song_time < skip_size, bCurrentSongShort=>TRUE (ignore FWD/RWD commands)
                             2318 ; 460  |// Short Song Time, songs too short to play.
                             2319 ; 461  |#define SHORT_SONG_TIME SECONDS_TO_SKIP         
                             2320 ; 462  |
                             2321 ; 463  |/////////////////////////////////////////////////////////////////////////////////
                             2322 ; 464  |// MP3 Sync Values
                             2323 ; 465  |/////////////////////////////////////////////////////////////////////////////////
                             2324 ; 466  |// # bytes to look for sync before marking it bad
                             2325 ; 467  |#define MP3_SYNC_THRESHOLD 70000 
                             2326 ; 468  |// # bytes to look for sync before slowing decoder isr frequency (to let menus run)
                             2327 ; 469  |#define MP3_SYNC_THRESHOLD1 10000 
                             2328 ; 470  |// once we have sync'd, the isr should be called this frequently
                             2329 ; 471  |#define MP3_DECODERISR_FAST 7500  
                             2330 ; 472  |// if decoder is having difficulty syncing, switch isr to be called less frequently
                             2331 ; 473  |#define MP3_DECODERISR_SLOW 50000 
                             2332 ; 474  |
                             2333 ; 475  |
                             2334 ; 476  |/////////////////////////////////////////////////////////////////////////////////
                             2335 ; 477  |//// Multi-Stage Volume Control Definitions
                             2336 ; 478  |/////////////////////////////////////////////////////////////////////////////////
                             2337 ; 479  |//// Use Multi-Stage Volume
                             2338 ; 480  |#define MULTI_STAGE_VOLUME 0x1                  
                             2339 ; 481  |
                             2340 ; 482  |//// Master Volume definitions
                             2341 ; 483  |#define MIX_MSTR_MAX_VOL 0x0
                             2342 ; 484  |#define NUM_MSTR_ATT_STEPS (0x1F-MIX_MSTR_MAX_VOL)
                             2343 ; 485  |
TASKING DSP2410 assembler v1.5r1 Build 138 SN 00100122
                                                                                                                            Page  40

M:ADDR CODE           CYCLES LINE SOURCELINE
                             2344 ; 486  |//// DAC-Mode definitions
                             2345 ; 487  |//// Adjusts 0dB point
                             2346 ; 488  |#define MIX_DAC_NOM_VOL 0x6                  
                             2347 ; 489  |#define MIX_DAC_MIN_VOL 0x1F
                             2348 ; 490  |// For minimum clipping: Set MIX_DAC_MAX_VOL below to match MIX_DAC_NOM_VOL value 2 lines 
                                  above.
                             2349 ; 491  |// For additional gain (with possible clipping): Set MIX_DAC_MAX_VOL in range below. 
                             2350 ; 492  |//                                               Each integer below MIX_DAC_NOM_VOL provid
                                  es 1.5 dB gain on Stmp34x0; 
                             2351 ; 493  |//                                               Max gain possible: 8 step diff would prov
                                  ide +12dB gain.   
                             2352 ; 494  |// range: [0 to MIX_DAC_NOM_VOL] (0 for loudest volume)
                             2353 ; 495  |#define MIX_DAC_MAX_VOL 0x0  
                             2354 ; 496  |
                             2355 ; 497  |#define NUM_DAC_ATT_STEPS (MIX_DAC_MIN_VOL-MIX_DAC_NOM_VOL+1)
                             2356 ; 498  |#define NUM_DAC_GAIN_STEPS (MIX_DAC_NOM_VOL-MIX_DAC_MAX_VOL)
                             2357 ; 499  |#define NUM_DAC_MODE_VOL_STEPS (NUM_DAC_ATT_STEPS+NUM_MSTR_ATT_STEPS+NUM_DAC_GAIN_STEPS+1)
                                  
                             2358 ; 500  |
                             2359 ; 501  |//// If there is no stored volume, set to 50% of DAC-Mode max; change if DAC Mode is not t
                                  he default
                             2360 ; 502  |//// STMP35xx has 2dB attenuation per step so default needs a few more steps above midpoin
                                  t.
                             2361 ; 503  |#define DEFAULT_VOLUME ((NUM_DAC_MODE_VOL_STEPS/2)+6)         
                             2362 ; 504  |
                             2363 ; 505  |//// Set maximum restored volume to 75% of DAC-Mode max; change if DAC Mode is not the def
                                  ault
                             2364 ; 506  |#define MAX_RESTORED_VOLUME ((3*NUM_DAC_MODE_VOL_STEPS)/4)   
                             2365 ; 507  |
                             2366 ; 508  |
                             2367 ; 509  |//// Line In definitions (used for Line-In 1)
                             2368 ; 510  |//// 0dB point of the Line In
                             2369 ; 511  |#define MIX_LINE_NOM_VOL 0x8                  
                             2370 ; 512  |//// Minimum volume of Line In
                             2371 ; 513  |#define MIX_LINE_MIN_VOL 0x1F                 
                             2372 ; 514  |//// Maximum volume of Line In (can adjust extra gain)
                             2373 ; 515  |#define MIX_LINE_MAX_VOL 0x6                  
                             2374 ; 516  |#define NUM_LINE_ATT_STEPS (MIX_LINE_MIN_VOL-MIX_LINE_NOM_VOL+1)
                             2375 ; 517  |#define NUM_LINE_GAIN_STEPS (MIX_LINE_NOM_VOL-MIX_LINE_MAX_VOL)
                             2376 ; 518  |#define NUM_LINE_MODE_VOL_STEPS (NUM_LINE_ATT_STEPS+NUM_MSTR_ATT_STEPS+NUM_LINE_GAIN_STEPS
                                  +1)
                             2377 ; 519  |
                             2378 ; 520  |//// Line In definitions (used for FM tuner with 144 pin package)
                             2379 ; 521  |//// 0dB point of the Line In
                             2380 ; 522  |#define MIX_FM_NOM_VOL 0x8                  
                             2381 ; 523  |//// Minimum volume of Line In
                             2382 ; 524  |#define MIX_FM_MIN_VOL 0x1F                 
                             2383 ; 525  |//// Maximum volume of Line In (can adjust extra gain)
                             2384 ; 526  |#define MIX_FM_MAX_VOL 0x6                  
                             2385 ; 527  |#define NUM_FM_ATT_STEPS (MIX_FM_MIN_VOL-MIX_FM_NOM_VOL+1)
                             2386 ; 528  |#define NUM_FM_GAIN_STEPS (MIX_FM_NOM_VOL-MIX_FM_MAX_VOL)
                             2387 ; 529  |#define NUM_FM_MODE_VOL_STEPS (NUM_FM_ATT_STEPS+NUM_MSTR_ATT_STEPS+NUM_FM_GAIN_STEPS+1)
                             2388 ; 530  |
                             2389 ; 531  |/////////////////////////////////////////////////////////////////////////////////
                             2390 ; 532  |//// When enabled (1), periodically checks for one of several FM state machine invalid dea
                                  dlock states & recovers. 
                             2391 ; 533  |//// Define as 0 to disable FM-deadlock-state checking and recovery.
                             2392 ; 534  |#define FM_WATCHDOG_ENABLE 1
                             2393 ; 535  |
                             2394 ; 536  |#if !defined(STMP_BUILD_PLAYER)
                             2395 ; 537  |////
                             2396 ; 538  |////! This varible holds the lcd display state for the mtp project.
TASKING DSP2410 assembler v1.5r1 Build 138 SN 00100122
                                                                                                                            Page  41

M:ADDR CODE           CYCLES LINE SOURCELINE
                             2397 ; 539  |////
                             2398 ; 540  |///
                             2399 ; 541  |#include <types.h>
                             2400 ; 542  |extern volatile WORD g_wActivityState;
                             2401 ; 543  |#endif // if !@def('STMP_BUILD_PLAYER')
                             2402 ; 544  |
                             2403 ; 545  |void _reentrant Init5VSense(void);
                             2404 ; 546  |void _reentrant ServiceDCDC(void);
                             2405 ; 547  |
                             2406 ; 548  |////////////////////////////////////////////////////////////////////////////
                             2407 ; 549  |//// JPEG Thumbnail Mode Setting
                             2408 ; 550  |//// number of column in thumbnail mode
                             2409 ; 551  |#define THUMBNAIL_X 2           
                             2410 ; 552  |//// number of row in  thumbnail mode
                             2411 ; 553  |#define THUMBNAIL_Y 2           
                             2412 ; 554  |//// thumbnail boundary offset x
                             2413 ; 555  |#define THUMBNAIL_X_OFFSET 4            
                             2414 ; 556  |//// thumbnail boundary offset y
                             2415 ; 557  |#define THUMBNAIL_Y_OFFSET 4            
                             2416 ; 558  |
                             2417 ; 559  |#endif // if (!@def(_PROJECT_INC))
                             2418 ; 560  |
                             2419 
                             2421 
                             2422 ; 5    |
                             2423 ; 6    |#ifndef MAX_USB_STRINGS
                             2424 ; 7    |#define MAX_USB_STRINGS 9
                             2425 ; 8    |#endif
                             2426 ; 9    |
                             2427 ; 10   |
                             2428 ; 11   |#define  USB_SELF_POWERED                    (0x01)
                             2429 ; 12   |#define  USB_REMOTE_WAKEUP                   (0x02)
                             2430 ; 13   |
                             2431 ; 14   |#define MAX_DESC_SIZE       86      // (255/3)+1
                             2432 ; 15   |
                             2433 ; 16   |#define MS_OS_STRING_DESCRIPTOR_INDEX 0xEE
                             2434 ; 17   |#define MS_OS_STRING_DESCRIPTOR_INDEX_IN_ARRAY 7
                             2435 ; 18   |
                             2436 ; 19   |/* The USB Device State Structure */
                             2437 ; 20   |typedef struct {
                             2438 ; 21   |   BYTE         btSpeed;                // Speed of device when connected
                             2439 ; 22   |                                        // High Speed or Full Speed
                             2440 ; 23   |   BYTE         btCurConfig;            // Current configuration number (0 means not confi
                                  gured yet)
                             2441 ; 24   |                                        // or default interface
                             2442 ; 25   |   BYTE         btCurInterface;         // Current Alternate Interface (0 means not config
                                  ured yet)                                                         
                             2443 ; 26   |   BYTE         btAddress;              // USB device address
                             2444 ; 27   |   USHORT       usUsbState;             // State USB (UNKNOWN, POWERED, DEFAULT, ADDRESSED
                                  , CONFIGURED, SUSPENDED)
                             2445 ; 28   |   USHORT       usUsbStatePriorSusp;    // Ste USB prior a SUSPEND. This state needs to be
                                   restore
                             2446 ; 29   |                                        // once the USB resumes
                             2447 ; 30   |   USHORT       usUsbDeviceState;       // State of the device (SelfPowered, Remote Wakeup
                                  )
                             2448 ; 31   |   USHORT       usSofCount;
                             2449 ; 32   |   BYTE         btBusResetting;         // Set during a reset phase
                             2450 ; 33   |   BYTE         btServicesRegistered;   // Number of services registered
                             2451 ; 34   |   WORD         wError;                 // Increments each time a USB Error Interrupt occu
                                  rs
                             2452 ; 35   |   BOOL         bEnterTestMode;         // Set when entered in test mode. To clear the dev
                                  ice
TASKING DSP2410 assembler v1.5r1 Build 138 SN 00100122
                                                                                                                            Page  42

M:ADDR CODE           CYCLES LINE SOURCELINE
                             2453 ; 36   |                                        // must be powered down
                             2454 ; 37   |   USHORT       usConnectionState;      // State of the USB connection (CONNECTED, DISCONN
                                  ECTED, UNKNOWN)                                         
                             2455 ; 38   |} Dev_State_Struct;
                             2456 ; 39   |
                             2457 ; 40   |typedef struct xd_struct_type{
                             2458 ; 41   |   BYTE         btEndpointNum;          // Endpoint number 
                             2459 ; 42   |   BYTE         btDirection;            // Direction : Send/Receive
                             2460 ; 43   |   BYTE         btEndpointType;         // Type of the endpoint: Ctrl, Isoch, Bulk,Int 
                             2461 ; 44   |   BYTE         btStatus;               // Current transfer status 
                             2462 ; 45   |   WORD _X *    pbtStartAddressWord;    // Address of first byte (DSP Word address in STMP
                                   space)
                             2463 ; 46   |   BYTE         btStartOffsetByte;      // Address of first byte (Word Byte offset in STMP
                                   space)
                             2464 ; 47   |   USHORT       usTotalLength;          // Number of bytes to send/recv 
                             2465 ; 48   |   USHORT       usMaxPacketSize;        // Max Packet size 
                             2466 ; 49   |   BYTE         btDontZeroTerminate;
                             2467 ; 50   |   BOOL         bIsDataPhase;           // Set to TRUE if the transfer is data phase
                             2468 ; 51   |                                        // of a setup transfer
                             2469 ; 52   |   struct xd_struct_type _USB_MEM*pNext;     // pointer to the next xd_struct
                             2470 ; 53   |   WORD         wPrivateData;           //data to be passed to the service handler
                             2471 ; 54   |   USHORT       usBytesCopied;          //number of bytes copied so far
                             2472 ; 55   |   WORD         wCurrentOffsetByte;
                             2473 ; 56   |   WORD _X*    pbtCurrentAddressWord;
                             2474 ; 57   |} xd_struct;
                             2475 ; 58   |
                             2476 ; 59   |// If MAX_NUM_EP is not defined, default to 4
                             2477 ; 60   |// *** NOTE: if you change this definition, change the equate for MAX_NUM_EP in usb20ddmem
                                  .asm as well.
                             2478 ; 61   |// The two definitions must be equivalent for proper operation.
                             2479 ; 62   |#define MAX_NUM_EP  4
                             2480 
                             2496 
                             2497 ; 63   |
                             2498 ; 64   |extern Dev_State_Struct _USB_MEM stDeviceState;
                             2499 
                             2521 
                             2522 ; 65   |
                             2523 ; 66   |extern xd_struct _USB_MEM * g_dXD_Queues[MAX_NUM_EP][2];
                             2524 ; 67   |
                             2525 ; 68   |BYTE _reentrant usb_device_call_service(BYTE btType, BOOL bSetup, BYTE btDirection, WORD _
                                  X*ptbBuffer, WORD wLength, WORD wPrivateData);
                             2526 ; 69   |xd_struct _USB_MEM * GetEmptyXd(void);
                             2527 ; 70   |void FreeXd(xd_struct _USB_MEM * pTemp);
                             2528 ; 71   |void AddXdToQueue(xd_struct _USB_MEM *pHead,xd_struct _USB_MEM *pElement);
                             2529 ; 72   |void InitXdPool(void);
                             2530 ; 73   |_reentrant void usb_PackDescriptor(void* pDescriptor,void _X * pDestination, WORD startInd
                                  ex);
                             2531 ; 74   |_reentrant void parse_strings(void);
                             2532 ; 75   |
                             2533 ; 76   |
                             2534 ; 77   |    // Service structures.
                             2535 ; 78   |    // Those are the structures storing the function handler for a specific
                             2536 ; 79   |    // USB service.
                             2537 ; 80   |    // There is a service per Endpoint + Reset + Suspend + Start Of Frame
                             2538 ; 81   |    //                                 + Resume + Sleep + Speed Detection  
                             2539 ; 82   |    // The service structs are setup by the USB application using the device driver
                             2540 ; 83   |typedef struct {
                             2541 ; 84   |   BYTE             btType;     // Which service type
                             2542 ; 85   |                                // Pointer to the service function
                             2543 ; 86   |   void (* Service)(BOOL bSetup, BYTE btDirection, WORD _X* pbtBuffer, WORD wLength, WORD 
                                  wPrivateData);
TASKING DSP2410 assembler v1.5r1 Build 138 SN 00100122
                                                                                                                            Page  43

M:ADDR CODE           CYCLES LINE SOURCELINE
                             2544 ; 87   |} Service_Struct;
                             2545 ; 88   |
                             2546 ; 89   |
                             2547 ; 90   |#endif
                             2548 
                             2550 
                             2551 ; 11   |#include "..\..\usb_dci.h"
                             2552 
                             2554 
                             2555 ; 1    |#ifndef _USB_DCI_H
                             2556 ; 2    |#define _USB_DCI_H
                             2557 ; 3    |
                             2558 ; 4    |#include "types.h"
                             2559 
                             2561 
                             2562 ; 1    |////////////////////////////////////////////////////////////////////////////////
                             2563 ; 2    |// Copyright(C) SigmaTel, Inc. 2000-2004
                             2564 ; 3    |//
                             2565 ; 4    |// Filename: types.h
                             2566 ; 5    |// Description: Standard data types
                             2567 ; 6    |////////////////////////////////////////////////////////////////////////////////
                             2568 ; 7    |
                             2569 ; 8    |#ifndef _TYPES_H
                             2570 ; 9    |#define _TYPES_H
                             2571 ; 10   |
                             2572 ; 11   |// TODO:  move this outta here!
                             2573 ; 12   |#if !defined(NOERROR)
                             2574 ; 13   |#define NOERROR 0
                             2575 ; 14   |#define SUCCESS 0
                             2576 ; 15   |#endif 
                             2577 ; 16   |#if !defined(SUCCESS)
                             2578 ; 17   |#define SUCCESS  0
                             2579 ; 18   |#endif
                             2580 ; 19   |#if !defined(ERROR)
                             2581 ; 20   |#define ERROR   -1
                             2582 ; 21   |#endif
                             2583 ; 22   |#if !defined(FALSE)
                             2584 ; 23   |#define FALSE 0
                             2585 ; 24   |#endif
                             2586 ; 25   |#if !defined(TRUE)
                             2587 ; 26   |#define TRUE  1
                             2588 ; 27   |#endif
                             2589 ; 28   |
                             2590 ; 29   |#if !defined(NULL)
                             2591 ; 30   |#define NULL 0
                             2592 ; 31   |#endif
                             2593 ; 32   |
                             2594 ; 33   |#define MAX_INT     0x7FFFFF
                             2595 ; 34   |#define MAX_LONG    0x7FFFFFffffff
                             2596 ; 35   |        // max positive unsigned long value: -1 == 0xFFFFFFffffff
                             2597 ; 36   |#define MAX_ULONG   (-1) 
                             2598 ; 37   |
                             2599 ; 38   |#define WORD_SIZE   24              // word size in bits
                             2600 ; 39   |#define BYTES_PER_WORD 3            // 8 bit bytes
                             2601 ; 40   |
                             2602 ; 41   |
                             2603 ; 42   |#define BYTE    unsigned char       // btVarName
                             2604 ; 43   |#define CHAR    signed char         // cVarName
                             2605 ; 44   |#define USHORT  unsigned short      // usVarName
                             2606 ; 45   |#define SHORT   unsigned short      // sVarName
                             2607 ; 46   |#define WORD    unsigned int        // wVarName
                             2608 ; 47   |#define INT     signed int          // iVarName
TASKING DSP2410 assembler v1.5r1 Build 138 SN 00100122
                                                                                                                            Page  44

M:ADDR CODE           CYCLES LINE SOURCELINE
                             2609 ; 48   |#define DWORD   unsigned long       // dwVarName
                             2610 ; 49   |#define LONG    signed long         // lVarName
                             2611 ; 50   |#define BOOL    unsigned int        // bVarName
                             2612 ; 51   |#define FRACT   _fract              // frVarName
                             2613 ; 52   |#define LFRACT  long _fract         // lfrVarName
                             2614 ; 53   |#define CIRC    _circ               // cp<type prefix>VarName (see below)
                             2615 ; 54   |#define FLOAT   float               // fVarName
                             2616 ; 55   |#define DBL     double              // dVarName
                             2617 ; 56   |#define ENUM    enum                // eVarName
                             2618 ; 57   |#define CMX     _complex            // cmxVarName
                             2619 ; 58   |typedef WORD UCS3;                   // 
                             2620 ; 59   |
                             2621 ; 60   |#define UINT16  unsigned short
                             2622 ; 61   |#define UINT8   unsigned char   
                             2623 ; 62   |#define UINT32  unsigned long
                             2624 ; 63   |#define UINT64  unsigned long   // need to figure out how to do 64 bit values.  Or port ex
                                  isiting code to only use 48 bit
                             2625 ; 64   |#define INT64   unsigned long   // need to figure out how to do 64 bit values.  Or port ex
                                  isiting code to only use 48 bit
                             2626 ; 65   |#define WCHAR   UINT16
                             2627 ; 66   |
                             2628 ; 67   |//UINT128 is 16 bytes or 6 words
                             2629 ; 68   |typedef struct UINT128_3500 {   
                             2630 ; 69   |    int val[6];     
                             2631 ; 70   |} UINT128_3500;
                             2632 ; 71   |
                             2633 ; 72   |#define UINT128   UINT128_3500
                             2634 ; 73   |
                             2635 ; 74   |// Little endian word packed byte strings:   
                             2636 ; 75   |//      _packed BYTE bTextVarName[]="a string";  bText is a packed byte string prefix
                             2637 ; 76   |// Convert to big endian words by reordering bytes from high to low using swizzle.
                             2638 ; 77   |// Little endian word packed byte strings:   
                             2639 ; 78   |//      _packed BYTE bTextVarName[]="a string";  bText is a packed byte string prefix
                             2640 ; 79   |// Convert to big endian words by reordering bytes from high to low using swizzle.
                             2641 ; 80   |
                             2642 ; 81   |// Declare Memory Spaces To Use When Coding
                             2643 ; 82   |// A. Sector Buffers
                             2644 ; 83   |#define SECTOR_BUFFER_MEM_X _X
                             2645 ; 84   |#define SECTOR_BUFFER_MEM_Y _Y
                             2646 ; 85   |#define SECTOR_BUFFER_MEM SECTOR_BUFFER_MEM_X
                             2647 ; 86   |typedef WORD SECTOR_BUFFER_MEM SECTOR_BUFFER;
                             2648 ; 87   |typedef SECTOR_BUFFER * P_SECTOR_BUFFER;
                             2649 ; 88   |// B. Media DDI Memory
                             2650 ; 89   |#define MEDIA_DDI_MEM _Y
                             2651 ; 90   |
                             2652 ; 91   |
                             2653 ; 92   |
                             2654 ; 93   |// Pointers to linear structures are labeled as: p<type prefix>VarName
                             2655 ; 94   |// Examples of circular pointers:
                             2656 ; 95   |//    INT CIRC cpiVarName
                             2657 ; 96   |//    DWORD CIRC cpdwVarName
                             2658 ; 97   |
                             2659 ; 98   |#define RETCODE INT                 // rcVarName
                             2660 ; 99   |
                             2661 ; 100  |// generic bitfield structure
                             2662 ; 101  |struct Bitfield {
                             2663 ; 102  |    unsigned int B0  :1;
                             2664 ; 103  |    unsigned int B1  :1;
                             2665 ; 104  |    unsigned int B2  :1;
                             2666 ; 105  |    unsigned int B3  :1;
                             2667 ; 106  |    unsigned int B4  :1;
                             2668 ; 107  |    unsigned int B5  :1;
TASKING DSP2410 assembler v1.5r1 Build 138 SN 00100122
                                                                                                                            Page  45

M:ADDR CODE           CYCLES LINE SOURCELINE
                             2669 ; 108  |    unsigned int B6  :1;
                             2670 ; 109  |    unsigned int B7  :1;
                             2671 ; 110  |    unsigned int B8  :1;
                             2672 ; 111  |    unsigned int B9  :1;
                             2673 ; 112  |    unsigned int B10 :1;
                             2674 ; 113  |    unsigned int B11 :1;
                             2675 ; 114  |    unsigned int B12 :1;
                             2676 ; 115  |    unsigned int B13 :1;
                             2677 ; 116  |    unsigned int B14 :1;
                             2678 ; 117  |    unsigned int B15 :1;
                             2679 ; 118  |    unsigned int B16 :1;
                             2680 ; 119  |    unsigned int B17 :1;
                             2681 ; 120  |    unsigned int B18 :1;
                             2682 ; 121  |    unsigned int B19 :1;
                             2683 ; 122  |    unsigned int B20 :1;
                             2684 ; 123  |    unsigned int B21 :1;
                             2685 ; 124  |    unsigned int B22 :1;
                             2686 ; 125  |    unsigned int B23 :1;
                             2687 ; 126  |};
                             2688 ; 127  |
                             2689 ; 128  |union BitInt {
                             2690 ; 129  |        struct Bitfield B;
                             2691 ; 130  |        int        I;
                             2692 ; 131  |};
                             2693 ; 132  |
                             2694 ; 133  |#define MAX_MSG_LENGTH 10
                             2695 ; 134  |struct CMessage
                             2696 ; 135  |{
                             2697 ; 136  |        unsigned int m_uLength;
                             2698 ; 137  |        unsigned int m_uMsg[MAX_MSG_LENGTH];
                             2699 ; 138  |};
                             2700 ; 139  |
                             2701 ; 140  |typedef struct {
                             2702 ; 141  |    WORD m_wLength;
                             2703 ; 142  |    WORD m_wMessage;
                             2704 ; 143  |    WORD m_wParams[MAX_MSG_LENGTH];
                             2705 ; 144  |} Message;
                             2706 ; 145  |
                             2707 ; 146  |struct MessageQueueDescriptor
                             2708 ; 147  |{
                             2709 ; 148  |        int *m_pBase;
                             2710 ; 149  |        int m_iModulo;
                             2711 ; 150  |        int m_iSize;
                             2712 ; 151  |        int *m_pHead;
                             2713 ; 152  |        int *m_pTail;
                             2714 ; 153  |};
                             2715 ; 154  |
                             2716 ; 155  |struct ModuleEntry
                             2717 ; 156  |{
                             2718 ; 157  |    int m_iSignaledEventMask;
                             2719 ; 158  |    int m_iWaitEventMask;
                             2720 ; 159  |    int m_iResourceOfCode;
                             2721 ; 160  |    struct MessageQueueDescriptor *m_pMessageQueue;
                             2722 ; 161  |    int _asmfunc (*m_pProcessEntryPoint)(union WaitMask Signals,struct MessageQueueDescrip
                                  tor *);
                             2723 ; 162  |    int _asmfunc (*m_pInitFunction)(struct MessageQueueDescriptor *);
                             2724 ; 163  |    int m_uTimeOutHigh;
                             2725 ; 164  |    int m_uTimeOutLow;
                             2726 ; 165  |    int _asmfunc (*m_pBackgroundFunction)(struct MessageQueueDescriptor *);
                             2727 ; 166  |};
                             2728 ; 167  |
                             2729 ; 168  |union WaitMask{
TASKING DSP2410 assembler v1.5r1 Build 138 SN 00100122
                                                                                                                            Page  46

M:ADDR CODE           CYCLES LINE SOURCELINE
                             2730 ; 169  |    struct B{
                             2731 ; 170  |        unsigned int m_bNone     :1;
                             2732 ; 171  |        unsigned int m_bMessage  :1;
                             2733 ; 172  |        unsigned int m_bTimer    :1;
                             2734 ; 173  |        unsigned int m_bButton   :1;
                             2735 ; 174  |    } B;
                             2736 ; 175  |    int I;
                             2737 ; 176  |} ;
                             2738 ; 177  |
                             2739 ; 178  |
                             2740 ; 179  |struct Button {
                             2741 ; 180  |        WORD wButtonEvent;
                             2742 ; 181  |        WORD wUnused[MAX_MSG_LENGTH];   
                             2743 ; 182  |};
                             2744 ; 183  |
                             2745 ; 184  |struct Message {
                             2746 ; 185  |        WORD wMsgLength;
                             2747 ; 186  |        WORD wMsgCommand;
                             2748 ; 187  |        WORD wMsgParms[MAX_MSG_LENGTH-1];
                             2749 ; 188  |};
                             2750 ; 189  |
                             2751 ; 190  |union EventTypes {
                             2752 ; 191  |        struct CMessage msg;
                             2753 ; 192  |        struct Button Button ;
                             2754 ; 193  |        struct Message Message;
                             2755 ; 194  |};
                             2756 ; 195  |
                             2757 ; 196  |// next 2 used to get updater build to return correct protocol ver in scsi response.
                             2758 ; 197  |#define BUILD_TYPE_UPDATER  0x100
                             2759 ; 198  |#define BUILD_TYPE_HOSTLINK 0x101
                             2760 ; 199  |#define BUILD_TYPE_PLAYER   0x102
                             2761 ; 200  |
                             2762 ; 201  |// Resets part if RETAIL build. DEBUG build executes debug instruction to halt.
                             2763 ; 202  |#define SystemHalt() __asm(" include 'sysmacro.asm' \n error") 
                             2764 ; 203  |#define assert(x)    if(!(x)) __asm(" include 'sysmacro.asm' \n error")
                             2765 ; 204  |
                             2766 ; 205  |#if DEBUG
                             2767 ; 206  |// For DEBUG builds, DebugBuildAssert(condition) halts if condition evaluates to FALSE. 
                             2768 ; 207  |#define DebugBuildAssert(x)    if(!(x)) __asm(" debug ")
                             2769 ; 208  |#else 
                             2770 ; 209  |// For RETAIL builds, DebugBuildAssert(condition) does nothing & execution continues rathe
                                  r than halt or reset. 
                             2771 ; 210  |#define DebugBuildAssert(x)    
                             2772 ; 211  |#endif
                             2773 ; 212  |
                             2774 ; 213  |// Do this in your C files to make a reminder that's displayed during the build.
                             2775 ; 214  |//  #pragma asm
                             2776 ; 215  |//  WARN 'Note to builder: reminder to do this after verifying that'
                             2777 ; 216  |//  #pragma endasm
                             2778 ; 217  |
                             2779 ; 218  |
                             2780 ; 219  |#ifdef COLOR_262K
                             2781 ; 220  |#define RGB(r,g,b)    ((0x0000FC & (r)) << 10) | ((0x0000FC & (g)) << 4) | ((0x0000FC & (b
                                  )) >> 2)    //262k
                             2782 ; 221  |#elif defined(COLOR_65K)
                             2783 ; 222  |#define RGB(r,g,b)    ((0x0000F8 & (r)) << 8) | ((0x0000FC & (g)) << 3) | ((0x0000F8 & (b)
                                  ) >> 3)  //65k
                             2784 ; 223  |#else
                             2785 ; 224  |#define RGB(r,g,b)       ((0x0000F0 & (r)) << 4) | (0x0000F0 & (g)) | ((0x0000F0 & (b)) >>
                                   4)
                             2786 ; 225  |#endif
                             2787 ; 226  |    
TASKING DSP2410 assembler v1.5r1 Build 138 SN 00100122
                                                                                                                            Page  47

M:ADDR CODE           CYCLES LINE SOURCELINE
                             2788 ; 227  |#endif // #ifndef _TYPES_H
                             2789 
                             2791 
                             2792 ; 5    |#include "usb_internal.h"
                             2793 
                             2795 
                             2796 ; 1    |#ifndef _USB_INTERNAL_H
                             2797 ; 2    |#define _USB_INTERNAL_H
                             2798 ; 3    |
                             2799 ; 4    |#include "project.h"
                             2800 ; 5    |
                             2801 ; 6    |#ifndef MAX_USB_STRINGS
                             2802 ; 7    |#define MAX_USB_STRINGS 9
                             2803 ; 8    |#endif
                             2804 ; 9    |
                             2805 ; 10   |
                             2806 ; 11   |#define  USB_SELF_POWERED                    (0x01)
                             2807 ; 12   |#define  USB_REMOTE_WAKEUP                   (0x02)
                             2808 ; 13   |
                             2809 ; 14   |#define MAX_DESC_SIZE       86      // (255/3)+1
                             2810 ; 15   |
                             2811 ; 16   |#define MS_OS_STRING_DESCRIPTOR_INDEX 0xEE
                             2812 ; 17   |#define MS_OS_STRING_DESCRIPTOR_INDEX_IN_ARRAY 7
                             2813 ; 18   |
                             2814 ; 19   |/* The USB Device State Structure */
                             2815 ; 20   |typedef struct {
                             2816 ; 21   |   BYTE         btSpeed;                // Speed of device when connected
                             2817 ; 22   |                                        // High Speed or Full Speed
                             2818 ; 23   |   BYTE         btCurConfig;            // Current configuration number (0 means not confi
                                  gured yet)
                             2819 ; 24   |                                        // or default interface
                             2820 ; 25   |   BYTE         btCurInterface;         // Current Alternate Interface (0 means not config
                                  ured yet)                                                         
                             2821 ; 26   |   BYTE         btAddress;              // USB device address
                             2822 ; 27   |   USHORT       usUsbState;             // State USB (UNKNOWN, POWERED, DEFAULT, ADDRESSED
                                  , CONFIGURED, SUSPENDED)
                             2823 ; 28   |   USHORT       usUsbStatePriorSusp;    // Ste USB prior a SUSPEND. This state needs to be
                                   restore
                             2824 ; 29   |                                        // once the USB resumes
                             2825 ; 30   |   USHORT       usUsbDeviceState;       // State of the device (SelfPowered, Remote Wakeup
                                  )
                             2826 ; 31   |   USHORT       usSofCount;
                             2827 ; 32   |   BYTE         btBusResetting;         // Set during a reset phase
                             2828 ; 33   |   BYTE         btServicesRegistered;   // Number of services registered
                             2829 ; 34   |   WORD         wError;                 // Increments each time a USB Error Interrupt occu
                                  rs
                             2830 ; 35   |   BOOL         bEnterTestMode;         // Set when entered in test mode. To clear the dev
                                  ice
                             2831 ; 36   |                                        // must be powered down
                             2832 ; 37   |   USHORT       usConnectionState;      // State of the USB connection (CONNECTED, DISCONN
                                  ECTED, UNKNOWN)                                         
                             2833 ; 38   |} Dev_State_Struct;
                             2834 ; 39   |
                             2835 ; 40   |typedef struct xd_struct_type{
                             2836 ; 41   |   BYTE         btEndpointNum;          // Endpoint number 
                             2837 ; 42   |   BYTE         btDirection;            // Direction : Send/Receive
                             2838 ; 43   |   BYTE         btEndpointType;         // Type of the endpoint: Ctrl, Isoch, Bulk,Int 
                             2839 ; 44   |   BYTE         btStatus;               // Current transfer status 
                             2840 ; 45   |   WORD _X *    pbtStartAddressWord;    // Address of first byte (DSP Word address in STMP
                                   space)
                             2841 ; 46   |   BYTE         btStartOffsetByte;      // Address of first byte (Word Byte offset in STMP
                                   space)
TASKING DSP2410 assembler v1.5r1 Build 138 SN 00100122
                                                                                                                            Page  48

M:ADDR CODE           CYCLES LINE SOURCELINE
                             2842 ; 47   |   USHORT       usTotalLength;          // Number of bytes to send/recv 
                             2843 ; 48   |   USHORT       usMaxPacketSize;        // Max Packet size 
                             2844 ; 49   |   BYTE         btDontZeroTerminate;
                             2845 ; 50   |   BOOL         bIsDataPhase;           // Set to TRUE if the transfer is data phase
                             2846 ; 51   |                                        // of a setup transfer
                             2847 ; 52   |   struct xd_struct_type _USB_MEM*pNext;     // pointer to the next xd_struct
                             2848 ; 53   |   WORD         wPrivateData;           //data to be passed to the service handler
                             2849 ; 54   |   USHORT       usBytesCopied;          //number of bytes copied so far
                             2850 ; 55   |   WORD         wCurrentOffsetByte;
                             2851 ; 56   |   WORD _X*    pbtCurrentAddressWord;
                             2852 ; 57   |} xd_struct;
                             2853 ; 58   |
                             2854 ; 59   |// If MAX_NUM_EP is not defined, default to 4
                             2855 ; 60   |// *** NOTE: if you change this definition, change the equate for MAX_NUM_EP in usb20ddmem
                                  .asm as well.
                             2856 ; 61   |// The two definitions must be equivalent for proper operation.
                             2857 ; 62   |#define MAX_NUM_EP  4
                             2858 ; 63   |
                             2859 ; 64   |extern Dev_State_Struct _USB_MEM stDeviceState;
                             2860 ; 65   |
                             2861 ; 66   |extern xd_struct _USB_MEM * g_dXD_Queues[MAX_NUM_EP][2];
                             2862 ; 67   |
                             2863 ; 68   |BYTE _reentrant usb_device_call_service(BYTE btType, BOOL bSetup, BYTE btDirection, WORD _
                                  X*ptbBuffer, WORD wLength, WORD wPrivateData);
                             2864 ; 69   |xd_struct _USB_MEM * GetEmptyXd(void);
                             2865 ; 70   |void FreeXd(xd_struct _USB_MEM * pTemp);
                             2866 ; 71   |void AddXdToQueue(xd_struct _USB_MEM *pHead,xd_struct _USB_MEM *pElement);
                             2867 ; 72   |void InitXdPool(void);
                             2868 ; 73   |_reentrant void usb_PackDescriptor(void* pDescriptor,void _X * pDestination, WORD startInd
                                  ex);
                             2869 ; 74   |_reentrant void parse_strings(void);
                             2870 ; 75   |
                             2871 ; 76   |
                             2872 ; 77   |    // Service structures.
                             2873 ; 78   |    // Those are the structures storing the function handler for a specific
                             2874 ; 79   |    // USB service.
                             2875 ; 80   |    // There is a service per Endpoint + Reset + Suspend + Start Of Frame
                             2876 ; 81   |    //                                 + Resume + Sleep + Speed Detection  
                             2877 ; 82   |    // The service structs are setup by the USB application using the device driver
                             2878 ; 83   |typedef struct {
                             2879 ; 84   |   BYTE             btType;     // Which service type
                             2880 ; 85   |                                // Pointer to the service function
                             2881 ; 86   |   void (* Service)(BOOL bSetup, BYTE btDirection, WORD _X* pbtBuffer, WORD wLength, WORD 
                                  wPrivateData);
                             2882 ; 87   |} Service_Struct;
                             2883 ; 88   |
                             2884 ; 89   |
                             2885 ; 90   |#endif
                             2886 
                             2888 
                             2889 ; 6    |#include "usb_api.h"
                             2890 
                             2892 
                             2893 ; 1    |////////////////////////////////////////////////////////////////////////////////
                             2894 ; 2    |// Copyright(C) SigmaTel, Inc. 2002 - 2003
                             2895 ; 3    |//
                             2896 ; 4    |// File : USB_API.H
                             2897 ; 5    |// Description : USB_API.H defines and structures definition for USB device
                             2898 ; 6    |//               driver API.
                             2899 ; 7    |//               This 
                             2900 ; 8    |////////////////////////////////////////////////////////////////////////////////
                             2901 ; 9    |
TASKING DSP2410 assembler v1.5r1 Build 138 SN 00100122
                                                                                                                            Page  49

M:ADDR CODE           CYCLES LINE SOURCELINE
                             2902 ; 10   |#ifndef __usb_api_h__
                             2903 ; 11   |#define __usb_api_h__ 1
                             2904 ; 12   |
                             2905 ; 13   |#include "types.h"
                             2906 ; 14   |#include "project.h"
                             2907 ; 15   |
                             2908 ; 16   |#ifndef _USB_MEM
                             2909 ; 17   |//if not overwridden, default to the compiler default memory space
                             2910 ; 18   |#define _USB_MEM
                             2911 ; 19   |#endif
                             2912 ; 20   |
                             2913 ; 21   |#define USB_LANGUAGE_ENGLISH 0x0409
                             2914 ; 22   |#define USB_LANGUAGE_CHINESE_PRC 0x0804
                             2915 ; 23   |#define USB_LANGUAGE_CHINESE_TAIWAN 0x0404
                             2916 ; 24   |#define USB_LANGUAGE_JAPANESE 0x0411
                             2917 ; 25   |
                             2918 ; 26   |#define MAX_STRING 30
                             2919 ; 27   |
                             2920 ; 28   |#define  USB_SPEED_FULL                      (0)
                             2921 ; 29   |#define  USB_SPEED_LOW                       (1)
                             2922 ; 30   |#define  USB_SPEED_HIGH                      (2)
                             2923 ; 31   |
                             2924 ; 32   |#define EP_FS_MAX_PACKET_SIZE               (64)    
                             2925 ; 33   |
                             2926 ; 34   |#define EP_HS_MAX_PACKET_SIZE               (512)   
                             2927 ; 35   |
                             2928 ; 36   |// Data transferred to devices based on Sigmatel 3500 chip may sometimes be 
                             2929 ; 37   |// corrupted. The corruption occurs when device is connected in USB High Speed 
                             2930 ; 38   |// mode, and size of the transfer in bytes is divisible by 128, but not 
                             2931 ; 39   |// divisible by the packet size. The workaround is implemented in Microsoft MTP 
                             2932 ; 40   |// driver to allow support for those devices.
                             2933 ; 41   |
                             2934 ; 42   |// the bug can corrupt the end of data buffer. It occurs when host sends out a 
                             2935 ; 43   |// short packet that is multiple of 128 bytes. During this scenario the USB core
                             2936 ; 44   |// does writes that are voided (byte enable == all zero), which was an undefined 
                             2937 ; 45   |// capability and thus the gasket did not apply a proper response. This should 
                             2938 ; 46   |// not affect Mass Storage applications because data transfers are 512 bytes and 
                             2939 ; 47   |// scsi commands are < 16 bytes. Other applications with their own driver will
                             2940 ; 48   |// need to pad the packets if they fall into the error case. "What this basically 
                             2941 ; 49   |// boils down to is that any time the host sends a short packet of 128, 256 or
                             2942 ; 50   |// 384 bytes to a high-speed connected player a number of bytes will be corrupted.
                             2943 ; 51   |// This is easiest to reproduce in SendObject commands but can strike any of the 
                             2944 ; 52   |// commands that take an arbitrary amount of data.
                             2945 ; 53   |#define ARC_HS_128_MODULO_BUG               (128)
                             2946 ; 54   |
                             2947 ; 55   |
                             2948 ; 56   |/* Error codes */
                             2949 ; 57   |#define USB_OK                              (0x00)
                             2950 ; 58   |#define USBERR_REGISTER_SERVICE             (0x01)  // Failed to register a service
                             2951 ; 59   |#define USBERR_NO_SERVICE                   (0x02)  // No registered service found 
                             2952 ; 60   |#define USBERR_TX_FAILED                    (0x03)  // Fail to prepare XD descriptor
                             2953 ; 61   |#define USBERR_SIZE_TOO_LARGE               (0x04)  // Number of bytes to transfer is too 
                                  large
                             2954 ; 62   |#define USBERR_EP_INIT_FAILED               (0x05)  // Endpoint init fail
                             2955 ; 63   |#define USBERR_CONFIG_FAILED                (0x06)  // Error reported by the application
                             2956 ; 64   |                                                    // if the new config failed or not sup
                                  ported
                             2957 ; 65   |#define USBERR_DEVICE_NOT_CONFIGURED        (0x07)  // Error reported by the transfer func
                                  tion
                             2958 ; 66   |                                                    // if attempting to transfer while the
                                   device
                             2959 ; 67   |                                                    // is not configured
TASKING DSP2410 assembler v1.5r1 Build 138 SN 00100122
                                                                                                                            Page  50

M:ADDR CODE           CYCLES LINE SOURCELINE
                             2960 ; 68   |#define USBERR_INIT_FAILED                  (0x08)  // Fail to initialize the USB API
                             2961 ; 69   |
                             2962 ; 70   |
                             2963 ; 71   |/* Endpoint types */
                             2964 ; 72   |#define  USB_CONTROL_ENDPOINT             (0)
                             2965 ; 73   |#define  USB_ISOCHRONOUS_ENDPOINT         (1)
                             2966 ; 74   |#define  USB_BULK_ENDPOINT                (2)
                             2967 ; 75   |#define  USB_INTERRUPT_ENDPOINT           (3)
                             2968 ; 76   |
                             2969 ; 77   |/* End point direction */
                             2970 ; 78   |#define  USB_OUT                         (0)
                             2971 ; 79   |#define  USB_IN                          (1)
                             2972 ; 80   |
                             2973 ; 81   |/* End point packed size */
                             2974 ; 82   |#define  USB_FS_MAX_PACKET_SIZE           (64)
                             2975 ; 83   |#define  USB_HS_BULK_OUT_MAX_PACKET_SIZE  (256)
                             2976 ; 84   |#define  USB_HS_BULK_IN_MAX_PACKET_SIZE   (128)
                             2977 ; 85   |
                             2978 ; 86   |
                             2979 ; 87   |#define  USB_TEST_MODE_TEST_J             (0x01)
                             2980 ; 88   |#define  USB_TEST_MODE_TEST_K             (0x02)
                             2981 ; 89   |#define  USB_TEST_MODE_TEST_SE0_NAK       (0x03)
                             2982 ; 90   |#define  USB_TEST_MODE_TEST_PACKET        (0x04)
                             2983 ; 91   |
                             2984 ; 92   |/* Available service types */
                             2985 ; 93   |/* Services 0 through 15 are reserved for endpoints */
                             2986 ; 94   |#define  USB_SERVICE_EP0                  (0x00)
                             2987 ; 95   |#define  USB_SERVICE_EP1                  (0x01)
                             2988 ; 96   |#define  USB_SERVICE_EP2                  (0x02)
                             2989 ; 97   |#define  USB_SERVICE_EP3                  (0x03)
                             2990 ; 98   |#define  USB_SERVICE_EP4                  (0x04)
                             2991 ; 99   |#define  USB_SERVICE_EP5                  (0x05)
                             2992 ; 100  |#define  USB_SERVICE_EP6                  (0x06)
                             2993 ; 101  |#define  USB_SERVICE_EP7                  (0x07)
                             2994 ; 102  |#define  USB_SERVICE_EP8                  (0x08)
                             2995 ; 103  |#define  USB_SERVICE_EP9                  (0x09)
                             2996 ; 104  |#define  USB_SERVICE_EP10                 (0x0a)
                             2997 ; 105  |#define  USB_SERVICE_EP11                 (0x0b)
                             2998 ; 106  |#define  USB_SERVICE_EP12                 (0x0c)
                             2999 ; 107  |#define  USB_SERVICE_EP13                 (0x0d)
                             3000 ; 108  |#define  USB_SERVICE_EP14                 (0x0e)
                             3001 ; 109  |#define  USB_SERVICE_EP15                 (0x0f)
                             3002 ; 110  |#define  USB_SERVICE_BUS_RESET            (0x10)
                             3003 ; 111  |#define  USB_SERVICE_SUSPEND              (0x11)
                             3004 ; 112  |#define  USB_SERVICE_SOF                  (0x12)
                             3005 ; 113  |#define  USB_SERVICE_RESUME               (0x13)
                             3006 ; 114  |#define  USB_SERVICE_SLEEP                (0x14)
                             3007 ; 115  |#define  USB_SERVICE_SPEED_DETECTION      (0x15)
                             3008 ; 116  |#define  USB_SERVICE_TEST                 (0x16)
                             3009 ; 117  |#define  USB_SERVICE_CHANGE_CONFIG        (0x17)
                             3010 ; 118  |#define  USB_SERVICE_CHANGE_IFACE         (0x18)   
                             3011 ; 119  |#define  NON_EP_SERVICES                  (USB_SERVICE_SPEED_DETECTION - USB_SERVICE_EP15)
                                  
                             3012 ; 120  |
                             3013 ; 121  |// This is the maximum service structures allocated 
                             3014 ; 122  |// One for each End point + the common services (non endpoint services) 
                             3015 ; 123  |#define MAX_NUMBER_SERVICES               (MAX_NUM_EP + NON_EP_SERVICES)  
                             3016 ; 124  |
                             3017 ; 125  |#define NUMBER_BYTES_IN_SETUP               (8)
                             3018 ; 126  |
                             3019 ; 127  |// possible values of btStatus on the xd_struct
                             3020 ; 128  |#define  USB_STATUS_TRANSFER_IDLE           (0)
TASKING DSP2410 assembler v1.5r1 Build 138 SN 00100122
                                                                                                                            Page  51

M:ADDR CODE           CYCLES LINE SOURCELINE
                             3021 ; 129  |#define  USB_STATUS_TRANSFER_SUCCESS        (1)            
                             3022 ; 130  |#define  USB_STATUS_TRANSFER_ACCEPTED       (2)
                             3023 ; 131  |#define  USB_STATUS_TRANSFER_IN_PROGRESS    (3)
                             3024 ; 132  |#define  USB_STATUS_TRANSFER_ERROR          (4)
                             3025 ; 133  |
                             3026 ; 134  |// types of status set/returned by set_status() and get_status()
                             3027 ; 135  |#define  USB_STATUS_DEVICE_STATE          (0x01)
                             3028 ; 136  |#define  USB_STATUS_INTERFACE             (0x02)
                             3029 ; 137  |#define  USB_STATUS_ADDRESS               (0x03)
                             3030 ; 138  |#define  USB_STATUS_CURRENT_CONFIG        (0x04)
                             3031 ; 139  |#define  USB_STATUS_SOF_COUNT             (0x05)
                             3032 ; 140  |#define  USB_STATUS                       (0x06)
                             3033 ; 141  |#define  USB_STATUS_TEST_MODE             (0x07)
                             3034 ; 142  |#define  USB_STATUS_DEVICE_SPEED          (0x08)  
                             3035 ; 143  |#define  USB_STATUS_DEVICE_TEST           (0x09)  
                             3036 ; 144  |#define  USB_STATUS_CURRENT_IFACE         (0x0a)
                             3037 ; 145  |#define  USB_STATUS_CONNECTION            (0x0b)  
                             3038 ; 146  |// For status endpoint, the endpoint number is coded in the less significant nibble
                             3039 ; 147  |#define  USB_STATUS_ENDPOINT              (0x10)
                             3040 ; 148  |#define  USB_STATUS_ENDPOINT_NUMBER_MASK  (0x0F)
                             3041 ; 149  |
                             3042 ; 150  |#define USB_MAX_SIZE_PER_TRANSFER       (0x4000)    // This is the maximum size that
                             3043 ; 151  |                                                    // we allow per transfer
                             3044 ; 152  |
                             3045 ; 153  |//Possible states the device can be in
                             3046 ; 154  |#define  USB_STATE_UNKNOWN                   (0xff)
                             3047 ; 155  |#define  USB_STATE_UNPLUGGED                 (0x05) // USB Cable unplugged
                             3048 ; 156  |#define  USB_STATE_PLUGGED                   (0x04) // USB Cable inserted
                             3049 ; 157  |#define  USB_STATE_POWERED                   (0x03)
                             3050 ; 158  |#define  USB_STATE_DEFAULT                   (0x02)
                             3051 ; 159  |#define  USB_STATE_ADDRESSED                 (0x01)
                             3052 ; 160  |#define  USB_STATE_CONFIGURED                (0x00)
                             3053 ; 161  |#define  USB_STATE_SUSPENDED                 (0x80)
                             3054 ; 162  |
                             3055 ; 163  |// Possible states the connection can be in
                             3056 ; 164  |//#define USB_STATE_UNKNOWN                 (0xff)
                             3057 ; 165  |#define USB_CONNECTED                       (0x00)
                             3058 ; 166  |#define USB_DISCONNECTED                    (0x01)
                             3059 ; 167  |
                             3060 ; 168  |
                             3061 ; 169  |
                             3062 ; 170  |typedef union
                             3063 ; 171  |{
                             3064 ; 172  |    struct
                             3065 ; 173  |    {
                             3066 ; 174  |        int Recipient               : 5;
                             3067 ; 175  |        int Type                    : 2;
                             3068 ; 176  |        int DataTransferDirection   : 1;
                             3069 ; 177  |        int Request                 : 8;
                             3070 ; 178  |        int                         : 8;
                             3071 ; 179  |    } B;
                             3072 ; 180  |    
                             3073 ; 181  |    int I;
                             3074 ; 182  |} USBRequestType ;
                             3075 ; 183  |
                             3076 ; 184  |typedef struct {
                             3077 ; 185  |   BYTE     bValid;
                             3078 ; 186  |   USBRequestType RequestType;
                             3079 ; 187  |   BYTE     btRequest;
                             3080 ; 188  |   WORD     wValue;
                             3081 ; 189  |   WORD     wIndex;
                             3082 ; 190  |   WORD     wLength;
TASKING DSP2410 assembler v1.5r1 Build 138 SN 00100122
                                                                                                                            Page  52

M:ADDR CODE           CYCLES LINE SOURCELINE
                             3083 ; 191  |    } USB_SetupData;
                             3084 ; 192  |
                             3085 ; 193  |// Descriptor sizes in bytes
                             3086 ; 194  |#define SIZE_DEVICE_DESCRIPTOR_IN_BYTES     (18)
                             3087 ; 195  |#define SIZE_DEVICE_DESCRIPTOR_IN_WORDS     (6)
                             3088 ; 196  |#define SIZE_DEVICE_QUALIFIER_DESCRIPTOR_IN_BYTES   (10)
                             3089 ; 197  |#define SIZE_DEVICE_QUALIFIER_DESCRIPTOR_IN_WORDS   (4)
                             3090 ; 198  |#define SIZE_CONFIG_DESCRIPTOR_IN_BYTES     (9)
                             3091 ; 199  |#define SIZE_CONFIG_DESCRIPTOR_IN_WORDS     (3)
                             3092 ; 200  |#define SIZE_INTERFACE_DESCRIPTOR_IN_BYTES  (9)
                             3093 ; 201  |#define SIZE_INTERFACE_DESCRIPTOR_IN_WORDS  (3)
                             3094 ; 202  |#define SIZE_ENDPOINT_DESCRIPTOR_IN_BYTES   (7)
                             3095 ; 203  |
                             3096 ; 204  |
                             3097 ; 205  |// Descriptor types
                             3098 ; 206  |#define DESCRIPTOR_TYPE_DEVICE              (0x01)
                             3099 ; 207  |#define DESCRIPTOR_TYPE_CONFIG              (0x02)
                             3100 ; 208  |#define DESCRIPTOR_TYPE_STRING              (0x03)
                             3101 ; 209  |#define DESCRIPTOR_TYPE_INTERFACE           (0x04)
                             3102 ; 210  |#define DESCRIPTOR_TYPE_ENDPOINT            (0x05)
                             3103 ; 211  |#define DESCRIPTOR_TYPE_DEVICE_QUALIFIER    (0x06)
                             3104 ; 212  |#define DESCRIPTOR_TYPE_OTHER_SPEED_CONFIG  (0x07)
                             3105 ; 213  |#define DESCRIPTOR_TYPE_INTERFACE_POWER     (0x08)
                             3106 ; 214  |
                             3107 ; 215  |
                             3108 ; 216  |#define USB_REQUEST_DIRECTION_HOST_TO_DEVICE    ((WORD)0x000000)
                             3109 ; 217  |#define USB_REQUEST_DIRECTION_DEVICE_TO_HOST    ((WORD)0x000001)
                             3110 ; 218  |
                             3111 ; 219  |#define USB_REQUEST_TYPE_STANDARD               ((WORD)0x000000)
                             3112 ; 220  |#define USB_REQUEST_TYPE_CLASS                  ((WORD)0x000001)
                             3113 ; 221  |#define USB_REQUEST_TYPE_VENDOR                 ((WORD)0x000002)
                             3114 ; 222  |#define USB_REQUEST_TYPE_RESERVED               ((WORD)0x000003)
                             3115 ; 223  |
                             3116 ; 224  |#define USB_REQUEST_RECIPIENT_DEVICE            ((WORD)0x000000)
                             3117 ; 225  |#define USB_REQUEST_RECIPIENT_INTERFACE         ((WORD)0x000001)
                             3118 ; 226  |#define USB_REQUEST_RECIPIENT_ENDPOINT          ((WORD)0x000002)
                             3119 ; 227  |#define USB_REQUEST_RECIPIENT_OTHER             ((WORD)0x000003)
                             3120 ; 228  |
                             3121 ; 229  |#define USB_REQUEST_STANDARD_GET_STATUS         ((WORD)0x000000)
                             3122 ; 230  |#define USB_REQUEST_STANDARD_CLEAR_FEATURE      ((WORD)0x000001)
                             3123 ; 231  |#define USB_REQUEST_STANDARD_RESERVED_1         ((WORD)0x000002)
                             3124 ; 232  |#define USB_REQUEST_STANDARD_SET_FEATURE        ((WORD)0x000003)
                             3125 ; 233  |#define USB_REQUEST_STANDARD_RESERVED_2         ((WORD)0x000004)
                             3126 ; 234  |#define USB_REQUEST_STANDARD_SET_ADDRESS        ((WORD)0x000005)
                             3127 ; 235  |#define USB_REQUEST_STANDARD_GET_DESCRIPTOR     ((WORD)0x000006)
                             3128 ; 236  |#define USB_REQUEST_STANDARD_SET_DESCRIPTOR     ((WORD)0x000007)
                             3129 ; 237  |#define USB_REQUEST_STANDARD_GET_CONFIGURATION  ((WORD)0x000008)
                             3130 ; 238  |#define USB_REQUEST_STANDARD_SET_CONFIGURATION  ((WORD)0x000009)
                             3131 ; 239  |#define USB_REQUEST_STANDARD_GET_INTERFACE      ((WORD)0x00000A)
                             3132 ; 240  |#define USB_REQUEST_STANDARD_SET_INTERFACE      ((WORD)0x00000B)
                             3133 ; 241  |#define USB_REQUEST_STANDARD_SYNCH_FRAME        ((WORD)0x00000C)
                             3134 ; 242  |
                             3135 ; 243  |#define USB_CLEAR_FEATURE_ENDPOINT_HALT         (0)
                             3136 ; 244  |#define USB_CLEAR_FEATURE_REMOTE_WAKEUP         (1)
                             3137 ; 245  |
                             3138 ; 246  |
                             3139 ; 247  |// Struct Device Descriptor
                             3140 ; 248  |typedef struct {
                             3141 ; 249  |    BYTE    bLength;                // (0) Size of this descriptor in bytes (18)
                             3142 ; 250  |    BYTE    btDescriptorType;       // (1) Device descriptor type (1)
                             3143 ; 251  |    BYTE    btBcdUsbLsb;            // (2) USB specification release number (for version 2
                                  .00 0x00)
TASKING DSP2410 assembler v1.5r1 Build 138 SN 00100122
                                                                                                                            Page  53

M:ADDR CODE           CYCLES LINE SOURCELINE
                             3144 ; 252  |    BYTE    btBcdUsbMsb;            // (3)                                  (for version 2
                                  .00 0x02)     
                             3145 ; 253  |    BYTE    btDeviceClass;          // (4) Class code
                             3146 ; 254  |    BYTE    btDeviceSubclass;       // (5) Subclass code
                             3147 ; 255  |    BYTE    btDeviceProtocol;       // (6) Protocol code
                             3148 ; 256  |    BYTE    btMaxPacketSize0;       // (7) Maximum packet size for endpoint 0 (8, 16, 32 o
                                  r 64)
                             3149 ; 257  |    BYTE    btIdVendorLsb;          // (8) Vendor Id
                             3150 ; 258  |    BYTE    btIdVendorMsb;          // (9)
                             3151 ; 259  |    BYTE    btIdProductLsb;         // (10) Product Id
                             3152 ; 260  |    BYTE    btIdProductMsb;         // (11)
                             3153 ; 261  |    BYTE    btBcdReleaseLsb;        // (12) Device release number in BCD
                             3154 ; 262  |    BYTE    btBcdReleaseMsb;        // (13)
                             3155 ; 263  |    BYTE    btIndexManufacturer;    // (14) Index of string descriptor describing Manufact
                                  urer
                             3156 ; 264  |    BYTE    btIndexProduct;         // (15) Index of string descriptor describing Product
                             3157 ; 265  |    BYTE    btIndexSerialNumber;    // (16) Index of string descriptor describing Device S
                                  erial Number
                             3158 ; 266  |    BYTE    btNumConfigurations;    // (17) Number of possible configurations
                             3159 ; 267  |} Struct_Standard_Dev_Desc;
                             3160 ; 268  |
                             3161 ; 269  |// Struct Device Qualifier Descriptor
                             3162 ; 270  |typedef struct {
                             3163 ; 271  |    BYTE    bLength;                // (0) Size of this descriptor in bytes (10)
                             3164 ; 272  |    BYTE    btDescriptorType;       // (1) Device descriptor type (6)
                             3165 ; 273  |    BYTE    btBcdUsbLsb;            // (2) USB specification release number (for version 2
                                  .00 0x00)
                             3166 ; 274  |    BYTE    btBcdUsbMsb;            // (3)                                  (for version 2
                                  .00 0x02)     
                             3167 ; 275  |    BYTE    btDeviceClass;          // (4) Class code
                             3168 ; 276  |    BYTE    btDeviceSubclass;       // (5) Subclass code
                             3169 ; 277  |    BYTE    btDeviceProtocol;       // (6) Protocol code
                             3170 ; 278  |    BYTE    btMaxPacketSize0;       // (7) Maximum packet size for endpoint 0 other speed 
                                  (8, 16, 32 or 64)
                             3171 ; 279  |    BYTE    btNumConfigurations;    // (8) Number of other-speed possible configurations
                             3172 ; 280  |    BYTE    btReserved;             // (9) Reserved for future use, must be 0
                             3173 ; 281  |} Struct_Dev_Qualifier_Desc;
                             3174 ; 282  |
                             3175 ; 283  |// Struct Configuration Descriptor
                             3176 ; 284  |typedef struct {
                             3177 ; 285  |    BYTE    bLength;                // (0) Size of this descriptor in bytes (9)
                             3178 ; 286  |    BYTE    btDescriptorType;       // (1) Device descriptor type (2 or 7)
                             3179 ; 287  |    BYTE    btTotalLengthLsb;       // (2) Total length of data returned for this config.
                             3180 ; 288  |    BYTE    btTotalLengthMsb;       // (3)                                  
                             3181 ; 289  |    BYTE    btNumInterfaces;        // (4) Number of Interfaces supported by this configur
                                  ation
                             3182 ; 290  |    BYTE    btConfigurationValue;   // (5) Value to use as an argument to the SetConfigura
                                  tion() request
                             3183 ; 291  |    BYTE    btIndexConfiguration;   // (6) Index of string descriptor describing this conf
                                  iguration
                             3184 ; 292  |    BYTE    btBitMapAttributes;     // (7) Configuration Characteristics
                             3185 ; 293  |                                    //     D7:      Reserved (set to one)
                             3186 ; 294  |                                    //     D6:      Self-powered
                             3187 ; 295  |                                    //     D5:      Remote Wakeup
                             3188 ; 296  |                                    //     D4..0:   Reserved (reset to zero)        
                             3189 ; 297  |    BYTE    btMaxPower;             // (8) Maximum power consumption expressed in 2mA unit
                                  s.
                             3190 ; 298  |} Struct_Standard_Config_Desc, Struct_Other_Speed_Config_Desc;
                             3191 ; 299  |
                             3192 ; 300  |// Struct Interface Descriptor
                             3193 ; 301  |typedef struct {
                             3194 ; 302  |    BYTE    bLength;                // (0) Size of this descriptor in bytes (9)
TASKING DSP2410 assembler v1.5r1 Build 138 SN 00100122
                                                                                                                            Page  54

M:ADDR CODE           CYCLES LINE SOURCELINE
                             3195 ; 303  |    BYTE    btDescriptorType;       // (1) Device descriptor type (4)
                             3196 ; 304  |    BYTE    btInterfaceNum;         // (2) Number of this interface. Zero-based value.
                             3197 ; 305  |    BYTE    btAlternateSetting;     // (3)                                  
                             3198 ; 306  |    BYTE    btNumEndpoints;         // (4) Number of endpointsused by this interface (excl
                                  uding endpoint 0).
                             3199 ; 307  |    BYTE    btInterfaceClass;       // (5) Class code
                             3200 ; 308  |    BYTE    btInterfaceSubClass;    // (6) Sub Class code
                             3201 ; 309  |    BYTE    btInterfaceProtocol;    // (7) Protocol Code
                             3202 ; 310  |    BYTE    btIndexInterface;       // (8) Index of string descriptor describing this inte
                                  rface
                             3203 ; 311  |} Struct_Standard_Interface_Desc;
                             3204 ; 312  |
                             3205 ; 313  |// Struct Endpoint Descriptor
                             3206 ; 314  |typedef struct {
                             3207 ; 315  |    BYTE    bLength;                // (0) Size of this descriptor in bytes (7)
                             3208 ; 316  |    BYTE    btDescriptorType;       // (1) Device descriptor type (5)
                             3209 ; 317  |    BYTE    btEndpointAddress;      // (2) Address of the endpoint on the USB device descr
                                  ibed by this descriptor
                             3210 ; 318  |                                    //      Bit 3..0: Endpoint number
                             3211 ; 319  |                                    //      Bit 6..4: Reserved, reset to zero
                             3212 ; 320  |                                    //      Bit 7:    Direction. Ignored for control endpo
                                  ints (0 OUT, 1 IN)
                             3213 ; 321  |    BYTE    btBitMapAttributes;     // (3) Endpoint attributes
                             3214 ; 322  |                                    //      bits 1..0: Transfer Type (00 Control, 01 Iso, 
                                  10 Bulk, 11 Int)
                             3215 ; 323  |                                    //      bits 5..2: If not an iso endpoints, they are r
                                  eserved and must be reset to zero.
                             3216 ; 324  |                                    //      bits 7..6: Reserved bits, must be reset to zer
                                  o.                                    
                             3217 ; 325  |    BYTE    btMaxPacketSizeLsb;     // (4) Maximum packet size. Refer to standard for bits
                                   specification
                             3218 ; 326  |    BYTE    btMaxPacketSizeMsb;     // (5)
                             3219 ; 327  |    BYTE    btInterval;             // (6) Interval for polling endpoint for data transfer
                                  s (refer to standard)
                             3220 ; 328  |} Struct_Standard_Endpoint_Desc;
                             3221 ; 329  |
                             3222 ; 330  |typedef struct {
                             3223 ; 331  |    BYTE    btLength;                   // (0) Size of this descriptor in bytes (2*MAX_USB
                                  _LANG + 2)
                             3224 ; 332  |    BYTE    btDescriptorType;           // (1) String descriptor type (3)
                             3225 ; 333  |    BYTE    btString[MAX_STRING*2];       
                             3226 ; 334  |} Struct_String_Desc;
                             3227 ; 335  |
                             3228 ; 336  |//
                             3229 ; 337  |// Externals
                             3230 ; 338  |//
                             3231 ; 339  |extern void _reentrant usb_dci_chip_enable (void);
                             3232 ; 340  |extern void _reentrant usb_dci_shutdown(void);
                             3233 ; 341  |
                             3234 ; 342  |BYTE _reentrant usb_device_init(void);
                             3235 ; 343  |void _inline usb_device_shutdown(void)
                             3236 ; 344  |{
                             3237 ; 345  |    usb_dci_shutdown();
                             3238 ; 346  |}
                             3239 ; 347  |
                             3240 ; 348  |BYTE _reentrant usb_device_register_service(BYTE btType, void (* Service)(BOOL bSetup, BYT
                                  E btDirection, BYTE _USB_MEM * pbtBuffer, WORD wLength,WORD wPrivateData)); 
                             3241 ; 349  |//Remove unused function usb_device_get_service() to reclain _P memroy.
                             3242 ; 350  |//BYTE _reentrant usb_device_get_service(BYTE btType, void (* Service)(BOOL bSetup, BYTE b
                                  tDirection, BYTE _USB_MEM * pbtBuffer, WORD wLength)); 
                             3243 ; 351  |
TASKING DSP2410 assembler v1.5r1 Build 138 SN 00100122
                                                                                                                            Page  55

M:ADDR CODE           CYCLES LINE SOURCELINE
                             3244 ; 352  |BYTE _reentrant usb_device_init_endpoint(BYTE btEndpoint, USHORT usMaxPacketSize, BYTE btD
                                  irection, BYTE btType, BOOL bFlag);
                             3245 ; 353  |
                             3246 ; 354  |extern USB_SetupData *_reentrant usb_dci_get_setup_data(BYTE btEndpoint);
                             3247 ; 355  |#define usb_device_read_setup_data(btEndpoint) usb_dci_get_setup_data(btEndpoint)
                             3248 ; 356  |
                             3249 ; 357  |void _reentrant usb_device_get_status(BYTE btType, USHORT * pusStatus);
                             3250 ; 358  |void _reentrant usb_device_set_status(BYTE btType, USHORT usStatus);
                             3251 ; 359  |BYTE _reentrant usb_device_get_transfer_status(BYTE btEndpoint, BYTE btDirection);
                             3252 ; 360  |
                             3253 ; 361  |extern void _reentrant usb_dci_stall_endpoint(BYTE btEndpoint, BYTE btDirection);
                             3254 ; 362  |#define usb_device_stall_endpoint(btEndpoint, btDirection) usb_dci_stall_endpoint((btEndpo
                                  int), (btDirection))
                             3255 ; 363  |
                             3256 ; 364  |extern void _reentrant usb_dci_unstall_endpoint(BYTE btEndpoint, BYTE btDirection);
                             3257 ; 365  |#define usb_device_unstall_endpoint(btEndpoint, btDirection) usb_dci_unstall_endpoint((btE
                                  ndpoint), (btDirection))
                             3258 ; 366  |
                             3259 ; 367  |extern void _reentrant usb_dci_finish_transaction(BYTE btEndpoint);
                             3260 ; 368  |#define usb_device_finish_transaction(btEndpoint) usb_dci_finish_transaction(btEndpoint);
                             3261 ; 369  |
                             3262 ; 370  |////////////////////////////////////////////////////////////////////////////////
                             3263 ; 371  |//
                             3264 ; 372  |//>  Name:          usb_device_enable
                             3265 ; 373  |//
                             3266 ; 374  |//   Type:          Function
                             3267 ; 375  |//
                             3268 ; 376  |//   Description:   Enables the USB device for transfers
                             3269 ; 377  |//
                             3270 ; 378  |//   Inputs:        none
                             3271 ; 379  |//
                             3272 ; 380  |//   Outputs:       USB_OK or error code
                             3273 ; 381  |//
                             3274 ; 382  |//   Notes:         none
                             3275 ; 383  |//<
                             3276 ; 384  |////////////////////////////////////////////////////////////////////////////////
                             3277 ; 385  |void _inline usb_device_enable(void)
                             3278 ; 386  |{
                             3279 ; 387  |    usb_dci_chip_enable();
                             3280 ; 388  |}
                             3281 ; 389  |
                             3282 ; 390  |void _reentrant usb_device_release(void);
                             3283 ; 391  |void _reentrant usb_device_hold(void);
                             3284 ; 392  |BYTE _reentrant usb_device_is_hold(void);
                             3285 ; 393  |void _reentrant usb_device_data_phase_required(void);
                             3286 ; 394  |
                             3287 ; 395  |BOOL _reentrant usb_device_is_first_init(void);
                             3288 ; 396  |void _reentrant usb_device_set_first_init(void);
                             3289 ; 397  |void _reentrant usb_device_clear_first_init(void);
                             3290 ; 398  |
                             3291 ; 399  |WORD _reentrant usb_get_current_limit(void);
                             3292 ; 400  |RETCODE _reentrant usb_set_current_limit(WORD);
                             3293 ; 401  |
                             3294 ; 402  |////////////////////////////////////////////////////////////////////
                             3295 ; 403  |extern BYTE _reentrant usb_dci_get_endpoint_status(BYTE btEndpoint);
                             3296 ; 404  |#define usb_device_get_endpoint_status(btEndpoint) usb_dci_get_endpoint_status(btEndpoint)
                                  
                             3297 ; 405  |
                             3298 ; 406  |#define USB_ENDPOINT_STATUS_OK                          0
                             3299 ; 407  |#define USB_ENDPOINT_STATUS_STALLED                     1
                             3300 ; 408  |#define USB_ENDPOINT_STATUS_RECIEVED_UNSTALL_REQUEST    2
                             3301 ; 409  |// WHQL
TASKING DSP2410 assembler v1.5r1 Build 138 SN 00100122
                                                                                                                            Page  56

M:ADDR CODE           CYCLES LINE SOURCELINE
                             3302 ; 410  |#define USB_ENDPOINT_STATUS_HOST_STALLED                3
                             3303 ; 411  |////////////////////////////////////////////////////////////////////
                             3304 ; 412  |
                             3305 ; 413  |
                             3306 ; 414  |BYTE _reentrant usb_device_send_data(BYTE btEndpoint, WORD _X * pbtStmpWordAdd, BYTE btByt
                                  eOffset, USHORT usSize, WORD wPrivateData, BOOL bIsDataPhase);
                             3307 ; 415  |BYTE _reentrant usb_device_recv_data(BYTE btEndpoint, WORD _X * pbtStmpWordAdd, BYTE btByt
                                  eOffset, USHORT usSize, WORD wPrivateData, BOOL bIsDataPhase);
                             3308 ; 416  |void _reentrant ch9ServiceEp0(BOOL bSetup, BYTE btDirection, WORD _X *pbtBuffer, WORD wLen
                                  gth,WORD wPrivateData);
                             3309 ; 417  |BYTE _reentrant usb_device_transfer_data(BYTE btEndpoint, WORD _X* pbtStmpWordAdd, 
                             3310 ; 418  |                                         BYTE btByteOffset, USHORT usSize, WORD wPrivateDa
                                  ta, 
                             3311 ; 419  |                                         BOOL bIsDataPhase, WORD wDirection);
                             3312 ; 420  |
                             3313 ; 421  |#ifndef CUSTOMIZE_UNICODE
                             3314 ; 422  |extern const BYTE g_Manufacturer[];
                             3315 ; 423  |extern const BYTE g_ProductName[];
                             3316 ; 424  |extern const BYTE g_ConfigString[];
                             3317 ; 425  |extern const BYTE g_Interface0String[];
                             3318 ; 426  |extern const BYTE g_Interface1String[];
                             3319 ; 427  |extern const BYTE g_MSOSDescriptorString[];
                             3320 ; 428  |#else   // CUSTOMIZE_UNICODE
                             3321 ; 429  |extern const WORD g_Manufacturer[];
                             3322 ; 430  |extern const WORD g_ProductName[];
                             3323 ; 431  |extern const WORD g_ConfigString[];
                             3324 ; 432  |extern const WORD g_Interface0String[];
                             3325 ; 433  |extern const WORD g_Interface1String[];
                             3326 ; 434  |extern const WORD g_MSOSDescriptorString[];
                             3327 ; 435  |#endif
                             3328 ; 436  |extern WORD g_LanguageList[];
                             3329 ; 437  |
                             3330 ; 438  |extern const BYTE g_SCSIVendorID[];
                             3331 ; 439  |extern const BYTE g_SCSIProductID[];
                             3332 ; 440  |extern void *g_pStrings[];
                             3333 ; 441  |
                             3334 ; 442  |extern WORD g_wUSBVendorID;
                             3335 ; 443  |extern WORD g_wUSBProductID;
                             3336 ; 444  |extern WORD g_wUSBReleaseID;
                             3337 ; 445  |
                             3338 ; 446  |#endif
                             3339 ; 447  |/* EOF */
                             3340 ; 448  |
                             3341 
                             3343 
                             3344 ; 7    |
                             3345 ; 8    |
                             3346 ; 9    |BYTE _reentrant usb_dci_init                (Dev_State_Struct _USB_MEM * pStDeviceState);
                             3347 ; 10   |#define usb_dci_chip_init(pStDeviceState) /* Do Nothing */
                             3348 ; 11   |void _reentrant usb_dci_process_reset       (Dev_State_Struct _USB_MEM * pStDeviceState);
                             3349 ; 12   |void _reentrant usb_dci_process_tr_complete (Dev_State_Struct _USB_MEM * pStDeviceState);
                             3350 ; 13   |void _reentrant usb_dci_process_suspend     (Dev_State_Struct _USB_MEM * pStDeviceState);
                             3351 ; 14   |void _reentrant usb_dci_process_port_change (Dev_State_Struct _USB_MEM * pStDeviceState);
                             3352 ; 15   |BYTE _reentrant usb_dci_init_endpoint       (xd_struct _USB_MEM * pStXD);
                             3353 ; 16   |USB_SetupData *_reentrant usb_dci_get_setup_data(BYTE btEndpoint);
                             3354 ; 17   |BYTE _reentrant usb_dci_get_endpoint_status(BYTE btEndpoint);
                             3355 ; 18   |void _reentrant usb_dci_set_endpoint_status(BYTE btEndpoint, USHORT usStatus);
                             3356 ; 19   |void _reentrant usb_dci_set_address(BYTE btAddress);
                             3357 ; 20   |BYTE _reentrant usb_dci_get_transfer_status(BYTE btEndpoint, BYTE btDirection);
                             3358 ; 21   |void _reentrant usb_dci_stall_endpoint(BYTE btEndpoint, BYTE btDirection);
                             3359 ; 22   |void _reentrant usb_dci_host_stall_endpoint(BYTE btEndpoint, BYTE btDirection);
                             3360 ; 23   |void _reentrant usb_dci_unstall_endpoint(BYTE btEndpoint, BYTE btDirection);
TASKING DSP2410 assembler v1.5r1 Build 138 SN 00100122
                                                                                                                            Page  57

M:ADDR CODE           CYCLES LINE SOURCELINE
                             3361 ; 24   |void _reentrant usb_dci_init_data_toggle_endpoint(BYTE btEndpoint);
                             3362 ; 25   |BYTE _reentrant usb_dci_transfer_data(xd_struct _USB_MEM * pStXd);
                             3363 ; 26   |void _reentrant usb_dci_finish_transaction(BYTE btEndpoint);
                             3364 ; 27   |void _reentrant usb_dci_update_connection_status(void);
                             3365 ; 28   |void _reentrant usb_dci_shutdown(void);
                             3366 ; 29   |void _reentrant usb_dci_set_test_mode(USHORT usTest); 
                             3367 ; 30   |
                             3368 ; 31   |void _reentrant usb_dci_chip_enable (void);
                             3369 ; 32   |#endif
                             3370 
                             3372 
                             3373 ; 12   |#include "..\usb20ch9.h"
                             3374 
                             3376 
                             3377 ; 1    |////////////////////////////////////////////////////////////////////////////////
                             3378 ; 2    |// Copyright(C) SigmaTel, Inc. 2002 - 2003
                             3379 ; 3    |//
                             3380 ; 4    |// File : usb20ch9.h
                             3381 ; 5    |// Description : USB2.0 Chapter Application skeleton header file
                             3382 ; 6    |////////////////////////////////////////////////////////////////////////////////
                             3383 ; 7    |
                             3384 ; 8    |#ifndef __ch9_h__
                             3385 ; 9    |#define __ch9_h__
                             3386 ; 10   |
                             3387 ; 11   |void _reentrant ch9ServiceEp0(BOOL bSetup, BYTE btDirection, WORD _X *pbtBuffer, WORD wLen
                                  gth,WORD wPrivateData);
                             3388 ; 12   |/*
                             3389 ; 13   |void _reentrant ch9GetStatus(BYTE bSetup, dQH_Struct_Setup _X * pStLocalSetup);
                             3390 ; 14   |void _reentrant ch9ClearFeature(BYTE bSetup, dQH_Struct_Setup _X * pStLocalSetup);
                             3391 ; 15   |void _reentrant ch9SetFeature(BYTE bSetup, dQH_Struct_Setup _X * pStLocalSetup); 
                             3392 ; 16   |void _reentrant ch9SetAddress(BYTE bSetup, dQH_Struct_Setup _X * pStLocalSetup); 
                             3393 ; 17   |void _reentrant ch9GetDescription(BYTE bSetup, dQH_Struct_Setup _X * pStLocalSetup);
                             3394 ; 18   |void _reentrant ch9SetDescription(BYTE bSetup, dQH_Struct_Setup _X * pStLocalSetup);
                             3395 ; 19   |void _reentrant ch9GetConfig(BYTE bSetup, dQH_Struct_Setup _X * pStLocalSetup); 
                             3396 ; 20   |void _reentrant ch9SetConfig(BYTE bSetup, dQH_Struct_Setup _X * pStLocalSetup);
                             3397 ; 21   |void _reentrant ch9GetInterface(BYTE bSetup, dQH_Struct_Setup _X * pStLocalSetup);
                             3398 ; 22   |void _reentrant ch9SetInterface(BYTE bSetup, dQH_Struct_Setup _X * pStLocalSetup);
                             3399 ; 23   |void _reentrant ch9SynchFrame(BYTE bSetup, dQH_Struct_Setup _X * pStLocalSetup); 
                             3400 ; 24   |*/
                             3401 ; 25   |
                             3402 ; 26   |extern BYTE _X * _reentrant GetDescriptor(BYTE btDescType, BYTE btDevSpeed, BYTE btIndex);
                                  
                             3403 ; 27   |#endif
                             3404 ; 28   |
                             3405 
                             3407 
                             3408 ; 13   |
                             3409 ; 14   |#pragma optimize 1
                             3411 ; 15   |
                             3412 ; 16   |SHORT _X usDataToSend;
                             3413 ; 17   |BYTE _X btStatus;
                             3414 ; 18   |
                             3415 ; 19   |// Global variable definitions
                             3416 ; 20   |volatile USHORT usTestModeIndex;
                             3417 ; 21   |
                             3418 ; 22   |extern USB_SetupData g_SetupData[];
                             3419 ; 23   |
                             3420 ; 24   |////////////////////////////////////////////////////////////////////////////////
                             3421 ; 25   |//
                             3422 ; 26   |//>  Name:          ch9GetStatus
                             3423 ; 27   |//
                             3424 ; 28   |//   Type:          Function
TASKING DSP2410 assembler v1.5r1 Build 138 SN 00100122
                                                                                                                            Page  58

M:ADDR CODE           CYCLES LINE SOURCELINE
                             3425 ; 29   |//
                             3426 ; 30   |//   Description:   Chapter 9 get status command
                             3427 ; 31   |//
                             3428 ; 32   |//   Inputs:        
                             3429 ; 33   |//                  bSetup : TRUE if setup phase
                             3430 ; 34   |//                  pSetup : pointer to the setup packet (8 bytes)
                             3431 ; 35   |//   Outputs:       None
                             3432 ; 36   |//
                             3433 ; 37   |//   Notes:         
                             3434 ; 38   |//<
                             3435 ; 39   |////////////////////////////////////////////////////////////////////////////////
                             3436 ; 40   |void _reentrant ch9GetStatus(BYTE bSetup, USB_SetupData * pSetup) 
                             3437 ; 41   |{ /* Body */
                             3438 
P:0000                       3439         org     p,".ptextusb20ch9":
                             3446 Fch9GetStatus:
                             3462 
                             3463 ; 42   |    
                             3464 ; 43   |    USHORT usStatus;
                             3465 ; 44   |    BYTE btIndex;
                             3466 ; 45   |    BOOL bRequestValid;
                             3467 ; 46   |
                             3468 ; 47   |    // If we are in the setup phase, return the descriptor
                             3469 ; 48   |    // otherwise do nothing ....
                             3470 ; 49   |    if (bSetup)
                             3471 
P:0000 055F7C         2    2 3447         movec   ssh,y:(r7)+
P:0001 2A0000         2    4 3473         move    #0,a2
P:0002 205F03         2    6 3474         tst     a	                (r7)+
P:0003 205F00         2    8 3451         move    (r7)+
P:0004 0AF0AA rrrrrr  6   14 3475         jeq     L28
                             3476 
                             3477 ; 50   |    {
                             3478 ; 51   |        switch (pSetup->RequestType.B.Recipient)
                             3479 
P:0006 44F400 000001  3   17 3487         move    #>1,x0
P:0008 205800         2   19 3481         move    (r0)+
P:0009 4ED000         2   21 3482         move    y:(r0)-,y0
P:000A 0105E8         2   23 3483         mpy     y0,#5,b
P:000B 212600         2   25 3484         move    b0,y0
P:000C 0113E8         2   27 3485         mpy     y0,#19,b
P:000D 21AF00         2   29 3486         move    b1,b
P:000E 44F44D 000002  3   32 3488         cmp     x0,b    #>2,x0
P:0010 0AF0AA rrrrrr  6   38 3489         jeq     L17
P:0012 20004D         2   40 3490         cmp     x0,b
P:0013 0AF0AA rrrrrr  6   46 3491         jeq     L18
P:0015 20000B         2   48 3492         tst     b
P:0016 0AF0AA rrrrrr  6   54 3493         jeq     L24
P:0018 0AF080 rrrrrr  6   60 3494         jmp     L23
                             3495 
                             3496 ; 52   |        {
                             3497 ; 53   |
                             3498 ; 54   |            case USB_REQUEST_RECIPIENT_DEVICE:
                             3499 ; 55   |                // Device status request
                             3500 ; 56   |                usb_device_get_status((BYTE)USB_STATUS_DEVICE_STATE, &usStatus);
                             3501 ; 57   |
                             3502 ; 58   |                // Clear any undesired bits
                             3503 ; 59   |                usDataToSend = usStatus;
                             3504 ; 60   |                
                             3505 ; 61   |                usDataToSend &= 0x0003;
                             3506 ; 62   |                
TASKING DSP2410 assembler v1.5r1 Build 138 SN 00100122
                                                                                                                            Page  59

M:ADDR CODE           CYCLES LINE SOURCELINE
                             3507 ; 63   |                // Send the data
                             3508 ; 64   |                usb_device_send_data(0, (WORD _X *)&usDataToSend, 0, (USHORT)2, TRUE,0); 
                             3509 ; 65   |                break;
                             3510 ; 66   |
                             3511 ; 67   |            case USB_REQUEST_RECIPIENT_INTERFACE:
                             3512 ; 68   |                // Interace status request
                             3513 ; 69   |                usDataToSend = 0x0000;
                             3514 
                             3516 L17:
                             3518 
                             3519 ; 70   |
                             3520 ; 71   |                // Send the data
                             3521 ; 72   |                usb_device_send_data(0, (WORD _X *)&usDataToSend, 0, (USHORT)2, TRUE,0); 
                             3522 
P:001A 3D0000         2   62 3516         move    #0,n5
P:001B 757000 rrrrrr  3   65 3517         move    n5,x:FusDataToSend
P:001D 0AF080 rrrrrr  6   71 3524         jmp     L26
                             3525 
                             3526 ; 73   |                break;
                             3527 ; 74   |
                             3528 ; 75   |            case USB_REQUEST_RECIPIENT_ENDPOINT:
                             3529 
                             3531 L18:
                             3536 
                             3537 ; 76   |                // Endpoint status request
                             3538 ; 77   |                usb_device_get_status(USB_STATUS, &usStatus);
                             3539 
P:001F 045FA0         2   73 3531         movec   m0,n7
P:0020 56F400 000006  3   76 3545         move    #>6,a
P:0022 686F00         4   80 3533         move    r0,y:(r7+n7)
P:0023 77F400 FFFFFE  3   83 3541         move    #-2,n7
P:0025 000000         2   85 3541         nop             ; (inserted)
P:0026 044F15         4   89 3543         lua     (r7)+n7,r5
P:0027 22B000         2   91 3544         move    r5,r0
P:0028 0BF080 rrrrrr  6   97 3546         jsr     Fusb_device_get_status
                             3548 
                             3549 ; 78   |                
                             3550 ; 79   |                btIndex = pSetup->wIndex & 0x0f; 
                             3551 
                             3565 
                             3566 ; 80   |                bRequestValid = FALSE;
                             3567 
                             3571 
                             3572 ; 81   |
                             3573 ; 82   |                if(btIndex == 0)
                             3574 
P:002A 3E0400         2   99 3553         move    #4,n6
P:002B 045FA0         2  101 3554         movec   m0,n7
P:002C 46F400 00000F  3  104 3561         move    #>15,y0
P:002E 6EEF00         4  108 3556         move    y:(r7+n7),r6
P:002F 000000         2  110 3556         nop             ; (inserted)
P:0030 5FEE00         4  114 3558         move    y:(r6+n6),b
P:0031 20005E         2  116 3562         and     y0,b
P:0032 21B513         2  118 3569         clr     a	                b1,r5
P:0033 22AF00         2  120 3576         move    r5,b
P:0034 2B0000         2  122 3577         move    #0,b2
P:0035 20000B         2  124 3578         tst     b
P:0036 0AF0AA rrrrrr  6  130 3579         jeq     L19
                             3580 
                             3581 ; 83   |                    bRequestValid = TRUE;
                             3582 ; 84   |                else if((btIndex < MAX_NUM_EP) && (usStatus == USB_STATE_CONFIGURED))
TASKING DSP2410 assembler v1.5r1 Build 138 SN 00100122
                                                                                                                            Page  60

M:ADDR CODE           CYCLES LINE SOURCELINE
                             3583 
P:0038 45F400 000004  3  133 3585         move    #>4,x1
P:003A 20006D         2  135 3586         cmp     x1,b
P:003B 0AF0A1 rrrrrr  6  141 3587         jge     L21
P:003D 77F400 FFFFFE  3  144 3588         move    #-2,n7
P:003F 000000         2  146 3588         nop             ; (inserted)
P:0040 5FEF00         4  150 3590         move    y:(r7+n7),b
P:0041 2B0000         2  152 3591         move    #0,b2
P:0042 20000B         2  154 3592         tst     b
P:0043 0AF0A2 rrrrrr  6  160 3593         jne     L21
                             3594 
                             3595 ; 85   |                    bRequestValid = TRUE;
                             3596 
                             3598 L19:
                             3599 
                             3600 ; 86   |
                             3601 ; 87   |                if(bRequestValid == TRUE)
                             3602 
P:0045 56F400 000001  3  163 3598         move    #>1,a
                             3604 L21:
P:0047 2A0000         2  165 3605         move    #0,a2
P:0048 45F400 000001  3  168 3604         move    #>1,x1
P:004A 200065         2  170 3606         cmp     x1,a
P:004B 0AF0A2 rrrrrr  6  176 3607         jne     L23
                             3608 
                             3609 ; 88   |                {
                             3610 ; 89   |                    // Get endpoint status
                             3611 ; 90   |                    usb_device_get_status((USB_STATUS_ENDPOINT + btIndex), &usStatus);
                             3612 
P:004D 77F400 FFFFFE  3  179 3620         move    #-2,n7
P:004F 56F400 000010  3  182 3615         move    #>16,a
P:0051 044F10         4  186 3622         lua     (r7)+n7,r0
P:0052 22A600         2  188 3614         move    r5,y0
P:0053 200050         2  190 3616         add     y0,a
P:0054 0BF080 rrrrrr  6  196 3623         jsr     Fusb_device_get_status
                             3626 
                             3627 ; 91   |
                             3628 ; 92   |                    // Clear undesried bits
                             3629 ; 93   |                    usDataToSend = usStatus;
                             3630 
                             3635 
                             3636 ; 94   |                    
                             3637 ; 95   |                    usDataToSend &= 0x0001;
                             3638 
                             3643 
                             3644 ; 96   |
                             3645 ; 97   |                    // Prepare to send data
                             3646 ; 98   |                    usb_device_send_data(0, (WORD _X *)&usDataToSend, 0, (USHORT)2, TRUE,0
                                  );
                             3647 
P:0056 77F400 FFFFFE  3  199 3632         move    #-2,n7
P:0058 47F400 000001  3  202 3640         move    #>1,y1
P:005A 5FEF00         4  206 3634         move    y:(r7+n7),b
P:005B 20007E         2  208 3641         and     y1,b
P:005C 557000 rrrrrr  3  211 3642         move    b1,x:FusDataToSend
P:005E 0AF080 rrrrrr  6  217 3649         jmp     L26
                             3650 
                             3651 ; 99   |                }
                             3652 ; 100  |                else
                             3653 ; 101  |                {
                             3654 ; 102  |                    usb_device_stall_endpoint(0, USB_IN);
                             3655 ; 103  |                    return;
TASKING DSP2410 assembler v1.5r1 Build 138 SN 00100122
                                                                                                                            Page  61

M:ADDR CODE           CYCLES LINE SOURCELINE
                             3656 ; 104  |                }
                             3657 ; 105  |
                             3658 ; 106  |                break;  
                             3659 ; 107  |
                             3660 ; 108  |            default:
                             3661 ; 109  |                // Unknown request
                             3662 ; 110  |                usb_device_stall_endpoint(0, USB_IN);
                             3663 
                             3665 L23:
P:0060 57F413 000001  3  220 3666         clr     a	                #>1,b
P:0062 0BF080 rrrrrr  6  226 3667         jsr     Fusb_dci_stall_endpoint
                             3668 
                             3669 ; 111  |                return;
                             3670 
P:0064 0AF080 rrrrrr  6  232 3672         jmp     L28
P:0066 77F400 FFFFFE  3  235 3674 L24:    move    #-2,n7
P:0068 56F400 000001  3  238 3677         move    #>1,a
P:006A 044F10         4  242 3676         lua     (r7)+n7,r0
P:006B 0BF080 rrrrrr  6  248 3678         jsr     Fusb_device_get_status
P:006D 77F400 FFFFFE  3  251 3680         move    #-2,n7
P:006F 46F400 000003  3  254 3684         move    #>3,y0
P:0071 5DEF00         4  258 3682         move    y:(r7+n7),b1
P:0072 20005E         2  260 3685         and     y0,b
P:0073 557000 rrrrrr  3  263 3686         move    b1,x:FusDataToSend
                             3688 L26:
P:0075 60F400 rrrrrr  3  266 3692         move    #FusDataToSend,r0
P:0077 250013         2  268 3688         clr     a	                #0,x1
P:0078 46F400 000001  3  271 3693         move    #>1,y0
P:007A 44F41B 000002  3  274 3689         clr     b	                #>2,x0
P:007C 0BF080 rrrrrr  6  280 3694         jsr     Fusb_device_send_data
                             3695 
                             3696 ; 112  |      } /* Endswitch */
                             3697 ; 113  |      
                             3698 ; 114  |        // Prepare dTD for the status phase
                             3699 ; 115  |        usb_device_recv_data(0, 0, 0, 0, FALSE,0);
                             3700 
P:007E 250013         2  282 3704         clr     a	                #0,x1
P:007F 300069         2  284 3705         tfr     x1,b	                #0,r0
P:0080 20A400         2  286 3706         move    x1,x0
P:0081 20A600         2  288 3707         move    x1,y0
P:0082 0BF080 rrrrrr  6  294 3708         jsr     Fusb_device_recv_data
                             3709 
                             3710 ; 116  |    } /* Endif */
                             3711 ; 117  |
                             3712 ; 118  |    return;
                             3713 ; 119  |} /* Endbody */
                             3714 
                             3716 L28:
P:0084 205700         2  296 3716         move    (r7)-
P:0085 205700         2  298 3717         move    (r7)-
P:0086 05FF7C         4  302 3719         movec   y:-(r7),ssh
P:0087 000000         2  304 3719         nop             ; (inserted)
P:0088 00000C         4  308 3723         rts
                             3725 
                             3726 ; 120  |
                             3727 ; 121  |
                             3728 ; 122  |
TASKING DSP2410 assembler v1.5r1 Build 138 SN 00100122
                                                                                                                            Page  62

M:ADDR CODE           CYCLES LINE SOURCELINE
                             3729 ; 123  |
                             3730 ; 124  |
                             3731 ; 125  |////////////////////////////////////////////////////////////////////////////////
                             3732 ; 126  |//
                             3733 ; 127  |//>  Name:          ch9ClearFeature
                             3734 ; 128  |//
                             3735 ; 129  |//   Type:          Function
                             3736 ; 130  |//
                             3737 ; 131  |//   Description:   Chapter 9 clear feature command
                             3738 ; 132  |//
                             3739 ; 133  |//   Inputs:        
                             3740 ; 134  |//                  bSetup : TRUE if setup phase
                             3741 ; 135  |//                  pSetup : pointer to the setup packet (8 bytes)
                             3742 ; 136  |//   Outputs:       None
                             3743 ; 137  |//
                             3744 ; 138  |//   Notes:         
                             3745 ; 139  |//<
                             3746 ; 140  |////////////////////////////////////////////////////////////////////////////////
                             3747 ; 141  |//#define USBTEST_FOR_USBCV_1_3
                             3748 ; 142  |#ifdef USBTEST_FOR_USBCV_1_3
                             3749 ; 143  |#include "usbmsc.h"
                             3750 ; 144  |extern BOOL Need_Stall_Buck_EP_For_Waiting_MSC_Reset;
                             3751 ; 145  |#endif
                             3752 ; 146  |void _reentrant ch9ClearFeature(BYTE bSetup, USB_SetupData * pSetup) 
                             3753 ; 147  |{ /* Body */
                             3754 
                             3759 Fch9ClearFeature:
                             3775 
                             3776 ; 148  |    BYTE btIndex, btDirection = USB_OUT, i;
                             3777 
                             3786 
                             3787 ; 149  |    BOOL bRequestValid;
                             3788 ; 150  |    USHORT usStatus;
                             3789 ; 151  |
                             3790 ; 152  |    // If we are in the setup phase, return the descriptor
                             3791 ; 153  |    // otherwise do nothing ....
                             3792 ; 154  |    if (bSetup) 
                             3793 
P:0089 055F7C         2  310 3760         movec   ssh,y:(r7)+
P:008A 310000         2  312 3779         move    #0,r1
P:008B 2A0000         2  314 3795         move    #0,a2
P:008C 3F0403         2  316 3796         tst     a	                #4,n7
P:008D 000000         2  318 3796         nop             ; (inserted)
P:008E 204F00         2  320 3765         move    (r7)+n7
P:008F 0AF0AA rrrrrr  6  326 3797         jeq     L62
                             3798 
                             3799 ; 155  |    {
                             3800 ; 156  |        switch (pSetup->RequestType.B.Recipient)
                             3801 
P:0091 44F400 000002  3  329 3810         move    #>2,x0
P:0093 205800         2  331 3804         move    (r0)+
P:0094 4FD000         2  333 3805         move    y:(r0)-,y1
P:0095 0105C8         2  335 3806         mpy     y1,#5,b
P:0096 212700         2  337 3807         move    b0,y1
P:0097 0113C8         2  339 3808         mpy     y1,#19,b
P:0098 21AF00         2  341 3809         move    b1,b
P:0099 46F44D 000001  3  344 3811         cmp     x0,b	                #>1,y0
P:009B 0AF0AA rrrrrr  6  350 3812         jeq     L48
P:009D 20000B         2  352 3813         tst     b
P:009E 0AF0A2 rrrrrr  6  358 3814         jne     L57
TASKING DSP2410 assembler v1.5r1 Build 138 SN 00100122
                                                                                                                            Page  63

M:ADDR CODE           CYCLES LINE SOURCELINE
                             3815 
                             3816 ; 157  |        {
                             3817 ; 158  |            case USB_REQUEST_RECIPIENT_DEVICE:
                             3818 ; 159  |                // Clear feature device
                             3819 ; 160  |                if (pSetup->wValue == 1)
                             3820 
P:00A0 3E0300         2  360 3822         move    #3,n6
P:00A1 221600         2  362 3823         move    r0,r6
P:00A2 000000         2  364 3823         nop             ; (inserted)
P:00A3 5FEE00         4  368 3825         move    y:(r6+n6),b
P:00A4 2B0000         2  370 3828         move    #0,b2
P:00A5 20005D         2  372 3829         cmp     y0,b
P:00A6 0AF0AA rrrrrr  6  378 3830         jeq     L58
                             3831 
                             3832 ; 161  |                {
                             3833 ; 162  |                    // clear remote wakeup 
                             3834 ; 163  |                    
                             3835 ; 164  |                    // Get the state of the device
                             3836 ; 165  |                    usb_device_get_status((BYTE)USB_STATUS_DEVICE_STATE, &usStatus);
                             3837 ; 166  |
                             3838 ; 167  |                    // Set the remote feature
                             3839 ; 168  |                    usStatus &= ~USB_REMOTE_WAKEUP;
                             3840 ; 169  |                    usb_device_set_status((BYTE)USB_STATUS_DEVICE_STATE, usStatus);
                             3841 ; 170  |                } /* Endif */
                             3842 ; 171  |                else
                             3843 ; 172  |                {
                             3844 ; 173  |                    usb_device_stall_endpoint(0, USB_IN);
                             3845 
P:00A8 0AF080 rrrrrr  6  384 3847         jmp     L57
                             3848 
                             3849 ; 174  |                    return;
                             3850 ; 175  |                }
                             3851 ; 176  |                break;
                             3852 ; 177  |         
                             3853 ; 178  |            case USB_REQUEST_RECIPIENT_ENDPOINT:
                             3854 
                             3856 L48:
                             3869 
                             3870 ; 179  |                usb_device_get_status(USB_STATUS, &usStatus);
                             3871 
P:00AA 77F400 FFFFFE  3  387 3859         move    #-2,n7
P:00AC 56F400 000006  3  390 3876         move    #>6,a
P:00AE 696F00         4  394 3861         move    r1,y:(r7+n7)
P:00AF 77F400 FFFFFD  3  397 3864         move    #-3,n7
P:00B1 000000         2  399 3864         nop             ; (inserted)
P:00B2 686F00         4  403 3866         move    r0,y:(r7+n7)
P:00B3 77F400 FFFFFC  3  406 3873         move    #-4,n7
P:00B5 000000         2  408 3873         nop             ; (inserted)
P:00B6 044F10         4  412 3875         lua     (r7)+n7,r0
P:00B7 0BF080 rrrrrr  6  418 3877         jsr     Fusb_device_get_status
                             3879 
                             3880 ; 180  |
                             3881 ; 181  |                if(pSetup->wIndex & 0x80)
                             3882 
P:00B9 3E0400         2  420 3884         move    #4,n6
P:00BA 77F400 FFFFFD  3  423 3885         move    #-3,n7
P:00BC 000000         2  425 3885         nop             ; (inserted)
P:00BD 6EEF00         4  429 3887         move    y:(r7+n7),r6
P:00BE 000000         2  431 3887         nop             ; (inserted)
P:00BF 5FEE00         4  435 3889         move    y:(r6+n6),b
P:00C0 0ACD07 rrrrrr  6  441 3892         jclr    #7,b1,L49
                             3893 
TASKING DSP2410 assembler v1.5r1 Build 138 SN 00100122
                                                                                                                            Page  64

M:ADDR CODE           CYCLES LINE SOURCELINE
                             3894 ; 182  |                {
                             3895 ; 183  |                    btDirection = USB_IN;
                             3896 
                             3906 
                             3907 ; 184  |                }
                             3908 ; 185  |                
                             3909 ; 186  |                btIndex = pSetup->wIndex & 0x0f; 
                             3910 
P:00C2 340100         2  443 3898         move    #1,r4
P:00C3 77F400 FFFFFE  3  446 3901         move    #-2,n7
P:00C5 000000         2  448 3901         nop             ; (inserted)
P:00C6 6C6F00         4  452 3903         move    r4,y:(r7+n7)
                             3912 L49:
                             3916 
                             3917 ; 187  |
                             3918 ; 188  |                bRequestValid = FALSE;
                             3919 
                             3923 
                             3924 ; 189  |
                             3925 ; 190  |                if(btIndex == 0)
                             3926 
P:00C7 44F400 00000F  3  455 3912         move    #>15,x0
P:00C9 25004E         2  457 3913         and     x0,b	                #0,x1
P:00CA 21AE00         2  459 3914         move    b1,a
P:00CB 2A0000         2  461 3928         move    #0,a2
P:00CC 200003         2  463 3929         tst     a
P:00CD 0AF0AA rrrrrr  6  469 3930         jeq     L50
                             3931 
                             3932 ; 191  |                    bRequestValid = TRUE;
                             3933 ; 192  |                else if((btIndex < MAX_NUM_EP) && (usStatus == USB_STATE_CONFIGURED))
                             3934 
P:00CF 218F00         2  471 3936         move    a1,b
P:00D0 47F400 000004  3  474 3937         move    #>4,y1
P:00D2 20007D         2  476 3938         cmp     y1,b
P:00D3 0AF0A1 rrrrrr  6  482 3939         jge     L52
P:00D5 77F400 FFFFFC  3  485 3940         move    #-4,n7
P:00D7 000000         2  487 3940         nop             ; (inserted)
P:00D8 5FEF00         4  491 3942         move    y:(r7+n7),b
P:00D9 2B0000         2  493 3943         move    #0,b2
P:00DA 20000B         2  495 3944         tst     b
P:00DB 0AF0A2 rrrrrr  6  501 3945         jne     L52
                             3946 
                             3947 ; 193  |                    bRequestValid = TRUE;
                             3948 
                             3950 L50:
                             3951 
                             3952 ; 194  |
                             3953 ; 195  |
                             3954 ; 196  |                if(bRequestValid == TRUE)
                             3955 
P:00DD 45F400 000001  3  504 3950         move    #>1,x1
                             3957 L52:
P:00DF 46F469 000001  3  507 3957         tfr     x1,b	                #>1,y0
P:00E1 2B0000         2  509 3959         move    #0,b2
P:00E2 20005D         2  511 3960         cmp     y0,b
P:00E3 0AF0A2 rrrrrr  6  517 3963         jne     L57
                             3964 
                             3965 ; 197  |                {
                             3966 ; 198  |                    // STMP3747 - latest FW hangs Mac - an error would stall the endpoint.
                                    Instead of
TASKING DSP2410 assembler v1.5r1 Build 138 SN 00100122
                                                                                                                            Page  65

M:ADDR CODE           CYCLES LINE SOURCELINE
                             3967 ; 199  |                    // clearing only the stalled endpoint, the Mac is sending a clear Endp
                                  oint 0 command.
                             3968 ; 200  |                    // We'll assume that 0 means all devices so we'll cycle through all th
                                  e endpoints and 
                             3969 ; 201  |                    // if an endpoint is stalled, we'll set the appropriate bClearFeature 
                                  flag.
                             3970 ; 202  |                    if(btIndex == 0)
                             3971 
P:00E5 2A0000         2  519 3973         move    #0,a2
P:00E6 200003         2  521 3974         tst     a
P:00E7 0AF0A2 rrrrrr  6  527 3975         jne     L54
                             3976 
                             3977 ; 203  |                    {
                             3978 ; 204  |                        for(i=0; i<MAX_NUM_EP; i++)
                             3979 
                             3983 
                             3984 ; 205  |                        {
                             3985 ; 206  |                            usb_device_unstall_endpoint(i, USB_IN); 
                             3986 
P:00E9 2E0000         2  529 3981         move    #0,a
                             3988 L53:
P:00EA 045FA0         2  531 3988         movec   m0,n7
P:00EB 57F400 000001  3  534 3996         move    #>1,b
P:00ED 5C6F00         4  538 3990         move    a1,y:(r7+n7)
P:00EE 0BF080 rrrrrr  6  544 3998         jsr     Fusb_dci_unstall_endpoint
                             4008 
                             4009 ; 207  |                            usb_device_unstall_endpoint(i, USB_OUT); 
                             4010 
P:00F0 045FA0         2  546 4002         movec   m0,n7
P:00F1 2F0000         2  548 4007         move    #0,b
P:00F2 5EEF00         4  552 4004         move    y:(r7+n7),a
P:00F3 0BF080 rrrrrr  6  558 4012         jsr     Fusb_dci_unstall_endpoint
P:00F5 045FA0         2  560 4016         movec   m0,n7
P:00F6 46F400 000001  3  563 4019         move    #>1,y0
P:00F8 5FEF00         4  567 4018         move    y:(r7+n7),b
P:00F9 45F458 000004  3  570 4020         add     y0,b	                #>4,x1
P:00FB 21AE00         2  572 4024         move    b1,a
P:00FC 218F00         2  574 4026         move    a1,b
P:00FD 20006D         2  576 4028         cmp     x1,b
P:00FE 0AF0A9 rrrrrr  6  582 4029         jlt     L53
                             4030 
                             4031 ; 208  |                        }
                             4032 ; 209  |                    }
                             4033 
P:0100 0AF080 rrrrrr  6  588 4035         jmp     L60
                             4036 
                             4037 ; 210  |                    else
                             4038 ; 211  |                    {
                             4039 ; 212  |#ifdef USBTEST_FOR_USBCV_1_3
                             4040 ; 213  |                        if(TRUE == Need_Stall_Buck_EP_For_Waiting_MSC_Reset)
                             4041 ; 214  |                        {
                             4042 ; 215  |                            if((btIndex == UsbMscDevice[0].wBulkOutEndpointNum) || (btInde
                                  x == UsbMscDevice[0].wBulkInEndpointNum))
                             4043 ; 216  |                                break;
                             4044 ; 217  |                        }
                             4045 ; 218  |#endif
                             4046 ; 219  |                        usb_device_unstall_endpoint(btIndex, btDirection); 
                             4047 
                             4049 L54:
P:0102 77F400 FFFFFE  3  591 4052         move    #-2,n7
P:0104 000000         2  593 4052         nop             ; (inserted)
TASKING DSP2410 assembler v1.5r1 Build 138 SN 00100122
                                                                                                                            Page  66

M:ADDR CODE           CYCLES LINE SOURCELINE
P:0105 5FEF00         4  597 4054         move    y:(r7+n7),b
P:0106 0BF080 rrrrrr  6  603 4055         jsr     Fusb_dci_unstall_endpoint
                             4060 
                             4061 ; 220  |                    }
                             4062 ; 221  |                }    
                             4063 ; 222  |                else
                             4064 ; 223  |                {
                             4065 ; 224  |                    usb_device_stall_endpoint(0, USB_IN);
                             4066 ; 225  |                    return;
                             4067 ; 226  |                }
                             4068 ; 227  |
                             4069 ; 228  |                break;
                             4070 
P:0108 0AF080 rrrrrr  6  609 4072         jmp     L60
                             4073 
                             4074 ; 229  |
                             4075 ; 230  |            default:
                             4076 ; 231  |                // Unknown request
                             4077 ; 232  |                usb_device_stall_endpoint(0, USB_IN);
                             4078 
P:010A 20CF13         2  611 4080 L57:    clr     a	                y0,b
P:010B 0BF080 rrrrrr  6  617 4082         jsr     Fusb_dci_stall_endpoint
                             4083 
                             4084 ; 233  |                return;
                             4085 
P:010D 0AF080 rrrrrr  6  623 4087         jmp     L62
                             4089 L58:
P:010F 77F451 FFFFFC  3  626 4092         tfr     y0,a	                #-4,n7
P:0111 000000         2  628 4092         nop             ; (inserted)
P:0112 044F10         4  632 4091         lua     (r7)+n7,r0
P:0113 0BF080 rrrrrr  6  638 4093         jsr     Fusb_device_get_status
P:0115 77F400 FFFFFC  3  641 4095         move    #-4,n7
P:0117 56F400 000001  3  644 4100         move    #>1,a
P:0119 0A6F41         6  650 4097         bclr    #1,y:(r7+n7)
P:011A 5FEF00         4  654 4099         move    y:(r7+n7),b
P:011B 0BF080 rrrrrr  6  660 4101         jsr     Fusb_device_set_status
                             4102 
                             4103 ; 234  |
                             4104 ; 235  |        } /* Endswitch */
                             4105 ; 236  |      
                             4106 ; 237  |        // Prepare dTD for the status phase
                             4107 ; 238  |        usb_device_send_data(0, 0, 0, 0, FALSE,0);
                             4108 
                             4110 L60:
P:011D 250013         2  662 4112         clr     a	                #0,x1
P:011E 300069         2  664 4113         tfr     x1,b	                #0,r0
P:011F 20A400         2  666 4114         move    x1,x0
P:0120 20A600         2  668 4115         move    x1,y0
P:0121 0BF080 rrrrrr  6  674 4116         jsr     Fusb_device_send_data
                             4117 
                             4118 ; 239  |    } /* Endif */
                             4119 ; 240  |
                             4120 ; 241  |    return;
                             4121 ; 242  |} /* Endbody */
                             4122 
                             4124 L62:
P:0123 77F400 FFFFFB  3  677 4124         move    #-5,n7
P:0125 000000         2  679 4124         nop             ; (inserted)
TASKING DSP2410 assembler v1.5r1 Build 138 SN 00100122
                                                                                                                            Page  67

M:ADDR CODE           CYCLES LINE SOURCELINE
P:0126 05EF7C         4  683 4126         movec   y:(r7+n7),ssh
P:0127 204F00         2  685 4128         move    (r7)+n7
P:0128 00000C         4  689 4130         rts
                             4132 
                             4133 ; 243  |
                             4134 ; 244  |
                             4135 ; 245  |
                             4136 ; 246  |
                             4137 ; 247  |
                             4138 ; 248  |////////////////////////////////////////////////////////////////////////////////
                             4139 ; 249  |//
                             4140 ; 250  |//>  Name:          ch9SetFeature
                             4141 ; 251  |//
                             4142 ; 252  |//   Type:          Function
                             4143 ; 253  |//
                             4144 ; 254  |//   Description:   Chapter 9 set feature command
                             4145 ; 255  |//
                             4146 ; 256  |//   Inputs:        
                             4147 ; 257  |//                  bSetup : TRUE if setup phase
                             4148 ; 258  |//                  pSetup : pointer to the setup packet (8 bytes)
                             4149 ; 259  |//   Outputs:       None
                             4150 ; 260  |//
                             4151 ; 261  |//   Notes:         
                             4152 ; 262  |//<
                             4153 ; 263  |////////////////////////////////////////////////////////////////////////////////
                             4154 ; 264  |void _reentrant ch9SetFeature(BYTE bSetup, USB_SetupData * pSetup) 
                             4155 ; 265  |{ /* Body */
                             4156 
                             4161 Fch9SetFeature:
                             4179 
                             4180 ; 266  |    USHORT usStatus;
                             4181 ; 267  |    USHORT usDeviceState;
                             4182 ; 268  |    BYTE btIndex, btDirection = USB_OUT;
                             4183 
                             4205 
                             4206 ; 269  |    BOOL bRequestValid;
                             4207 ; 270  |    
                             4208 ; 271  |    // Get the device status
                             4209 ; 272  |    usDeviceState = 0;
                             4210 
                             4215 
                             4216 ; 273  |    usb_device_get_status(USB_STATUS, &usDeviceState);
                             4217 
P:0129 055F7C         2  691 4162         movec   ssh,y:(r7)+
P:012A 3F061B         2  693 4195         clr     b	                #6,n7
P:012B 350000         2  695 4196         move    #0,r5
P:012C 204F00         2  697 4167         move    (r7)+n7
P:012D 77F400 FFFFFD  3  700 4185         move    #-3,n7
P:012F 000000         2  702 4185         nop             ; (inserted)
P:0130 686F00         4  706 4187         move    r0,y:(r7+n7)
P:0131 77F400 FFFFFC  3  709 4190         move    #-4,n7
P:0133 000000         2  711 4190         nop             ; (inserted)
P:0134 5C6F00         4  715 4192         move    a1,y:(r7+n7)
P:0135 77F400 FFFFFE  3  718 4198         move    #-2,n7
P:0137 56F400 000006  3  721 4221         move    #>6,a
P:0139 6D6F00         4  725 4200         move    r5,y:(r7+n7)
P:013A 77F400 FFFFFA  3  728 4212         move    #-6,n7
P:013C 000000         2  730 4212         nop             ; (inserted)
P:013D 044F12         4  734 4219         lua     (r7)+n7,r2
P:013E 225000         2  736 4220         move    r2,r0
P:013F 5D6F00         4  740 4214         move    b1,y:(r7+n7)
TASKING DSP2410 assembler v1.5r1 Build 138 SN 00100122
                                                                                                                            Page  68

M:ADDR CODE           CYCLES LINE SOURCELINE
P:0140 0BF080 rrrrrr  6  746 4222         jsr     Fusb_device_get_status
                             4223 
                             4224 ; 274  |
                             4225 ; 275  |    // If we are in the setup phase, return the descriptor
                             4226 ; 276  |    // otherwise do nothing ....
                             4227 ; 277  |    if (bSetup)
                             4228 
P:0142 77F400 FFFFFC  3  749 4230         move    #-4,n7
P:0144 000000         2  751 4230         nop             ; (inserted)
P:0145 5FEF00         4  755 4232         move    y:(r7+n7),b
P:0146 2B0000         2  757 4233         move    #0,b2
P:0147 20000B         2  759 4234         tst     b
P:0148 0AF0AA rrrrrr  6  765 4237         jeq     L106
                             4238 
                             4239 ; 278  |    {
                             4240 ; 279  |        switch (pSetup->RequestType.B.Recipient)
                             4241 
P:014A 77F400 FFFFFD  3  768 4243         move    #-3,n7
P:014C 000000         2  770 4243         nop             ; (inserted)
P:014D 6EEF00         4  774 4245         move    y:(r7+n7),r6
P:014E 000000         2  776 4245         nop             ; (inserted)
P:014F 205E00         2  778 4247         move    (r6)+
P:0150 4ED600         2  780 4248         move    y:(r6)-,y0
P:0151 0105E8         2  782 4251         mpy     y0,#5,b
P:0152 212600         2  784 4252         move    b0,y0
P:0153 0113E8         2  786 4253         mpy     y0,#19,b
P:0154 21AF00         2  788 4255         move    b1,b
P:0155 46F400 000002  3  791 4256         move    #>2,y0
P:0157 20005D         2  793 4257         cmp     y0,b
P:0158 0AF0AA rrrrrr  6  799 4258         jeq     L91
P:015A 20000B         2  801 4259         tst     b
P:015B 0AF0A2 rrrrrr  6  807 4260         jne     L100
                             4261 
                             4262 ; 280  |        {
                             4263 ; 281  |            case USB_REQUEST_RECIPIENT_DEVICE:
                             4264 ; 282  |                // Set feature device
                             4265 ; 283  |                switch (pSetup->wValue)
                             4266 
P:015D 3E0351         2  809 4271         tfr     y0,a	                #3,n6
P:015E 000000         2  811 4271         nop             ; (inserted)
P:015F 5FEE00         4  815 4270         move    y:(r6+n6),b
P:0160 2B0000         2  817 4272         move    #0,b2
P:0161 56F40D 000001  3  820 4273         cmp     a,b     #>1,a
P:0163 0AF0AA rrrrrr  6  826 4274         jeq     L89
P:0165 20000D         2  828 4275         cmp     a,b
P:0166 0AF0AA rrrrrr  6  834 4276         jeq     L90
P:0168 0AF080 rrrrrr  6  840 4277         jmp     L100
                             4278 
                             4279 ; 284  |                {
                             4280 ; 285  |                    case 1:
                             4281 ; 286  |                    // Set remote wakeup                    
                             4282 ; 287  |
                             4283 ; 288  |                    // Get the state of the device
                             4284 ; 289  |                    usb_device_get_status((BYTE)USB_STATUS_DEVICE_STATE, &usStatus);
                             4285 ; 290  |
                             4286 ; 291  |                    // Set the remote feature
                             4287 ; 292  |                    usStatus |= USB_REMOTE_WAKEUP;
                             4288 ; 293  |                    usb_device_set_status((BYTE)USB_STATUS_DEVICE_STATE, usStatus);
                             4289 ; 294  |
                             4290 ; 295  |                    break;
                             4291 ; 296  |                    
TASKING DSP2410 assembler v1.5r1 Build 138 SN 00100122
                                                                                                                            Page  69

M:ADDR CODE           CYCLES LINE SOURCELINE
                             4292 ; 297  |                    case 2:
                             4293 
                             4295 L89:
                             4298 
                             4299 ; 298  |                    // Test mode
                             4300 ; 299  |                    
                             4301 ; 300  |                        usb_device_get_status((BYTE)USB_STATUS_DEVICE_SPEED, &usStatus);
                             4302 
P:016A 56F400 000008  3  843 4307         move    #>8,a
P:016C 6E6F00         4  847 4295         move    r6,y:(r7+n7)
P:016D 77F400 FFFFFB  3  850 4304         move    #-5,n7
P:016F 000000         2  852 4304         nop             ; (inserted)
P:0170 044F10         4  856 4306         lua     (r7)+n7,r0
P:0171 0BF080 rrrrrr  6  862 4308         jsr     Fusb_device_get_status
                             4309 
                             4310 ; 301  |               
                             4311 ; 302  |                        
                             4312 ; 303  |                        if(((pSetup->wIndex) & 0xFF) || (usStatus != (USHORT)USB_SPEED_HIG
                                  H)) 
                             4313 
P:0173 3D0400         2  864 4315         move    #4,n5
P:0174 77F400 FFFFFD  3  867 4316         move    #-3,n7
P:0176 46F400 0000FF  3  870 4324         move    #>$FF,y0
P:0178 6DEF00         4  874 4318         move    y:(r7+n7),r5
P:0179 000000         2  876 4318         nop             ; (inserted)
P:017A 044D16         4  880 4320         lua     (r5)+n5,r6
P:017B 5FED00         4  884 4323         move    y:(r5+n5),b
P:017C 2B005E         2  886 4325         and     y0,b	                #0,b2
P:017D 20000B         2  888 4327         tst     b
P:017E 0AF0A2 rrrrrr  6  894 4328         jne     L100
P:0180 77F400 FFFFFB  3  897 4329         move    #-5,n7
P:0182 45F400 000002  3  900 4332         move    #>2,x1
P:0184 5FEF00         4  904 4331         move    y:(r7+n7),b
P:0185 20006D         2  906 4333         cmp     x1,b
P:0186 0AF0A2 rrrrrr  6  912 4334         jne     L100
                             4335 
                             4336 ; 304  |                        { // Test mode incorrect
                             4337 ; 305  |                            usb_device_stall_endpoint(0, USB_IN);
                             4338 ; 306  |                            return;
                             4339 ; 307  |                        } /* Endif */
                             4340 ; 308  |
                             4341 ; 309  |                        if ((usDeviceState == USB_STATE_CONFIGURED) || 
                             4342 ; 310  |                            (usDeviceState == USB_STATE_ADDRESSED) || 
                             4343 ; 311  |                            (usDeviceState == USB_STATE_DEFAULT)) 
                             4344 
P:0188 77F400 FFFFFA  3  915 4346         move    #-6,n7
P:018A 000000         2  917 4346         nop             ; (inserted)
P:018B 5FEF00         4  921 4348         move    y:(r7+n7),b
P:018C 2B0000         2  923 4349         move    #0,b2
P:018D 20000B         2  925 4350         tst     b
P:018E 0AF0AA rrrrrr  6  931 4351         jeq     L103
P:0190 56F400 000001  3  934 4352         move    #>1,a
P:0192 20000D         2  936 4353         cmp     a,b
P:0193 0AF0AA rrrrrr  6  942 4354         jeq     L103
P:0195 20006D         2  944 4355         cmp     x1,b
P:0196 0AF0AA rrrrrr  6  950 4356         jeq     L103
                             4357 
                             4358 ; 312  |                        {
                             4359 ; 313  |                            // Do not switch to test mode yet.
                             4360 ; 314  |                            // The switch must happen after the status phase.
                             4361 ; 315  |                            usb_device_set_status(USB_STATUS_DEVICE_TEST, (USHORT)TRUE);
TASKING DSP2410 assembler v1.5r1 Build 138 SN 00100122
                                                                                                                            Page  70

M:ADDR CODE           CYCLES LINE SOURCELINE
                             4362 ; 316  |                            usTestModeIndex = ((pSetup->wIndex)>>8) & 0xFF;
                             4363 ; 317  |                        }
                             4364 ; 318  |                        else
                             4365 ; 319  |                        {
                             4366 ; 320  |                            usb_device_stall_endpoint(0, USB_IN);
                             4367 ; 321  |                            return;
                             4368 ; 322  |                        } /* Endif */
                             4369 ; 323  |                        break;
                             4370 ; 324  |
                             4371 ; 325  |                default:
                             4372 ; 326  |                    usb_device_stall_endpoint(0, USB_IN);
                             4373 
P:0198 0AF080 rrrrrr  6  956 4375         jmp     L100
P:019A 77F400 FFFFFB  3  959 4377 L90:    move    #-5,n7
P:019C 000000         2  961 4377         nop             ; (inserted)
P:019D 044F10         4  965 4379         lua     (r7)+n7,r0
P:019E 0BF080 rrrrrr  6  971 4380         jsr     Fusb_device_get_status
P:01A0 77F400 FFFFFB  3  974 4383         move    #-5,n7
P:01A2 56F400 000001  3  977 4388         move    #>1,a
P:01A4 0A6F61         6  983 4385         bset    #1,y:(r7+n7)
P:01A5 5FEF00         4  987 4387         move    y:(r7+n7),b
P:01A6 0BF080 rrrrrr  6  993 4389         jsr     Fusb_device_set_status
                             4390 
                             4391 ; 327  |                    return;
                             4392 ; 328  |            } /* Endswitch */
                             4393 ; 329  |            break;
                             4394 
P:01A8 0AF080 rrrrrr  6  999 4396         jmp     L105
                             4397 
                             4398 ; 330  |            
                             4399 ; 331  |            case USB_REQUEST_RECIPIENT_ENDPOINT:
                             4400 ; 332  |
                             4401 ; 333  |                if(pSetup->wIndex & 0x80)
                             4402 
                             4404 L91:
P:01AA 3E0400         2 1001 4406         move    #4,n6
P:01AB 000000         2 1003 4406         nop             ; (inserted)
P:01AC 5FEE00         4 1007 4408         move    y:(r6+n6),b
P:01AD 0ACD07 rrrrrr  6 1013 4409         jclr    #7,b1,L92
                             4410 
                             4411 ; 334  |                {
                             4412 ; 335  |                    btDirection = USB_IN;
                             4413 
                             4423 
                             4424 ; 336  |                }
                             4425 ; 337  |
                             4426 ; 338  |                btIndex = pSetup->wIndex & 0x0f; 
                             4427 
P:01AF 320100         2 1015 4415         move    #1,r2
P:01B0 77F400 FFFFFE  3 1018 4418         move    #-2,n7
P:01B2 000000         2 1020 4418         nop             ; (inserted)
P:01B3 6A6F00         4 1024 4420         move    r2,y:(r7+n7)
                             4429 L92:
                             4433 
                             4434 ; 339  |
                             4435 ; 340  |                bRequestValid = FALSE;
                             4436 
                             4440 
                             4441 ; 341  |
                             4442 ; 342  |                if((btIndex < MAX_NUM_EP) && (usDeviceState == USB_STATE_CONFIGURED))
                             4443 
P:01B4 46F400 00000F  3 1027 4429         move    #>15,y0
TASKING DSP2410 assembler v1.5r1 Build 138 SN 00100122
                                                                                                                            Page  71

M:ADDR CODE           CYCLES LINE SOURCELINE
P:01B6 47F45E 000004  3 1030 4430         and     y0,b	                #>4,y1
P:01B8 21AE00         2 1032 4431         move    b1,a
P:01B9 218F00         2 1034 4445         move    a1,b
P:01BA 26007D         2 1036 4447         cmp     y1,b	                #0,y0
P:01BB 0AF0A1 rrrrrr  6 1042 4448         jge     L94
P:01BD 77F400 FFFFFA  3 1045 4449         move    #-6,n7
P:01BF 000000         2 1047 4449         nop             ; (inserted)
P:01C0 5FEF00         4 1051 4451         move    y:(r7+n7),b
P:01C1 2B0000         2 1053 4452         move    #0,b2
P:01C2 20000B         2 1055 4453         tst     b
P:01C3 0AF0A2 rrrrrr  6 1061 4454         jne     L94
                             4455 
                             4456 ; 343  |                    bRequestValid = TRUE;
                             4457 
                             4460 
                             4461 ; 344  |
                             4462 ; 345  |                if(bRequestValid == TRUE)
                             4463 
P:01C5 46F400 000001  3 1064 4459         move    #>1,y0
                             4465 L94:
P:01C7 44F459 000001  3 1067 4465         tfr     y0,b	                #>1,x0
P:01C9 2B0000         2 1069 4467         move    #0,b2
P:01CA 20004D         2 1071 4468         cmp     x0,b
P:01CB 0AF0A2 rrrrrr  6 1077 4471         jne     L100
                             4472 
                             4473 ; 346  |                {
                             4474 ; 347  |                    usb_device_stall_endpoint(btIndex, btDirection); 
                             4475 
P:01CD 77F400 FFFFFE  3 1080 4477         move    #-2,n7
P:01CF 000000         2 1082 4477         nop             ; (inserted)
P:01D0 5FEF00         4 1086 4479         move    y:(r7+n7),b
P:01D1 0BF080 rrrrrr  6 1092 4480         jsr     Fusb_dci_stall_endpoint
                             4487 
                             4488 ; 348  |                }                    
                             4489 ; 349  |                else
                             4490 ; 350  |                {
                             4491 ; 351  |                    usb_device_stall_endpoint(0, USB_IN);
                             4492 ; 352  |                    return;
                             4493 ; 353  |                }
                             4494 ; 354  |
                             4495 ; 355  |                break;
                             4496 
P:01D3 0AF080 rrrrrr  6 1098 4498         jmp     L105
                             4499 
                             4500 ; 356  |
                             4501 ; 357  |            default:
                             4502 ; 358  |                usb_device_stall_endpoint(0, USB_IN);
                             4503 
P:01D5 57F413 000001  3 1101 4505 L100:   clr     a	                #>1,b
P:01D7 0BF080 rrrrrr  6 1107 4507         jsr     Fusb_dci_stall_endpoint
                             4508 
                             4509 ; 359  |                return;
                             4510 
P:01D9 0AF080 rrrrrr  6 1113 4512         jmp     L109
                             4514 L103:
P:01DB 045FA0         2 1115 4514         movec   m0,n7
P:01DC 56F400 000009  3 1118 4518         move    #>9,a
P:01DE 57F400 000001  3 1121 4519         move    #>1,b
TASKING DSP2410 assembler v1.5r1 Build 138 SN 00100122
                                                                                                                            Page  72

M:ADDR CODE           CYCLES LINE SOURCELINE
P:01E0 6E6F00         4 1125 4516         move    r6,y:(r7+n7)
P:01E1 0BF080 rrrrrr  6 1131 4520         jsr     Fusb_device_set_status
P:01E3 045FA0         2 1133 4522         movec   m0,n7
P:01E4 000000         2 1135 4522         nop             ; (inserted)
P:01E5 6EEF00         4 1139 4524         move    y:(r7+n7),r6
P:01E6 000000         2 1141 4524         nop             ; (inserted)
P:01E7 5FE600         2 1143 4526         move    y:(r6),b
P:01E8 20002B         2 1145 4529         lsr     b
P:01E9 20002B         2 1147 4529         lsr     b
P:01EA 20002B         2 1149 4529         lsr     b
P:01EB 20002B         2 1151 4529         lsr     b
P:01EC 20002B         2 1153 4529         lsr     b
P:01ED 20002B         2 1155 4529         lsr     b
P:01EE 20002B         2 1157 4529         lsr     b
P:01EF 20002B         2 1159 4529         lsr     b
                             4531 L110:
                             4536 
                             4537 ; 360  |        } /* Endswitch */
                             4538 ; 361  |      
                             4539 ; 362  |        // Prepare dTD for the status phase
                             4540 ; 363  |        usb_device_send_data(0, 0, 0, 0, FALSE,0);
                             4541 
P:01F0 44F400 0000FF  3 1162 4533         move    #>$FF,x0
P:01F2 20004E         2 1164 4534         and     x0,b
P:01F3 5D7000 rrrrrr  3 1167 4535         move    b1,y:FusTestModeIndex
                             4543 L105:
P:01F5 250013         2 1169 4545         clr     a	                #0,x1
P:01F6 300069         2 1171 4546         tfr     x1,b	                #0,r0
P:01F7 20A400         2 1173 4547         move    x1,x0
P:01F8 20A600         2 1175 4548         move    x1,y0
P:01F9 0BF080 rrrrrr  6 1181 4549         jsr     Fusb_device_send_data
                             4550 
                             4551 ; 364  |    }
                             4552 
P:01FB 0AF080 rrrrrr  6 1187 4554         jmp     L109
                             4555 
                             4556 ; 365  |    else 
                             4557 ; 366  |    {
                             4558 ; 367  |        usb_device_get_status(USB_STATUS_DEVICE_TEST, &usDeviceState);
                             4559 
                             4561 L106:
P:01FD 77F400 FFFFFA  3 1190 4562         move    #-6,n7
P:01FF 56F400 000009  3 1193 4561         move    #>9,a
P:0201 044F10         4 1197 4564         lua     (r7)+n7,r0
P:0202 0BF080 rrrrrr  6 1203 4565         jsr     Fusb_device_get_status
                             4566 
                             4567 ; 368  |        
                             4568 ; 369  |        if (usDeviceState == (USHORT)TRUE) 
                             4569 
P:0204 77F400 FFFFFA  3 1206 4571         move    #-6,n7
P:0206 45F400 000001  3 1209 4574         move    #>1,x1
P:0208 5FEF00         4 1213 4573         move    y:(r7+n7),b
P:0209 20006D         2 1215 4575         cmp     x1,b
P:020A 0AF0A2 rrrrrr  6 1221 4576         jne     L109
                             4577 
                             4578 ; 370  |        {
                             4579 ; 371  |            // Now enter test mode
                             4580 ; 372  |            usb_device_set_status(USB_STATUS_TEST_MODE, usTestModeIndex);
                             4581 
P:020C 5FF000 rrrrrr  3 1224 4583         move    y:FusTestModeIndex,b
TASKING DSP2410 assembler v1.5r1 Build 138 SN 00100122
                                                                                                                            Page  73

M:ADDR CODE           CYCLES LINE SOURCELINE
P:020E 56F400 000007  3 1227 4584         move    #>7,a
P:0210 0BF080 rrrrrr  6 1233 4585         jsr     Fusb_device_set_status
                             4586 
                             4587 ; 373  |            
                             4588 ; 374  |            // Inform Application
                             4589 ; 375  |            usb_device_call_service(USB_SERVICE_TEST, FALSE, 0, 0, 0,0);
                             4590 
P:0212 300000         2 1235 4594         move    #0,r0
P:0213 25001B         2 1237 4593         clr     b	                #0,x1
P:0214 56F400 000016  3 1240 4597         move    #>22,a
P:0216 20A400         2 1242 4595         move    x1,x0
P:0217 20A600         2 1244 4596         move    x1,y0
P:0218 0BF080 rrrrrr  6 1250 4598         jsr     Fusb_device_call_service
                             4599 
                             4600 ; 376  |            
                             4601 ; 377  |        } 
                             4602 ; 378  |    } 
                             4603 ; 379  |    
                             4604 ; 380  |    return;
                             4605 ; 381  |} /* Endbody */
                             4606 
                             4608 L109:
P:021A 77F400 FFFFF9  3 1253 4608         move    #-7,n7
P:021C 000000         2 1255 4608         nop             ; (inserted)
P:021D 05EF7C         4 1259 4610         movec   y:(r7+n7),ssh
P:021E 204F00         2 1261 4612         move    (r7)+n7
P:021F 00000C         4 1265 4614         rts
                             4616 
                             4617 ; 382  |
                             4618 ; 383  |
                             4619 ; 384  |
                             4620 ; 385  |////////////////////////////////////////////////////////////////////////////////
                             4621 ; 386  |//
                             4622 ; 387  |//>  Name:          ch9SetAddress
                             4623 ; 388  |//
                             4624 ; 389  |//   Type:          Function
                             4625 ; 390  |//
                             4626 ; 391  |//   Description:   Chapter 9 set address command
                             4627 ; 392  |//
                             4628 ; 393  |//   Inputs:        
                             4629 ; 394  |//                  bSetup : TRUE if setup phase
                             4630 ; 395  |//                  pSetup : pointer to the setup packet (8 bytes)
                             4631 ; 396  |//   Outputs:       None
                             4632 ; 397  |//
                             4633 ; 398  |//   Notes:         
                             4634 ; 399  |//      The 1st time we enter in this function, the bSetup flag should be TRUE.
                             4635 ; 400  |//      Therefore we save the address locally and prepare a dTD for the status phase
                             4636 ; 401  |//      (TX packet of 0 length).
                             4637 ; 402  |//      The 2nd time we enter the function, due to the status phase OUT packet completed
                             4638 ; 403  |//      the bSetup flag should be clear. Therefore we save the new address, and so on ...
                             4639 ; 404  |//<
                             4640 ; 405  |////////////////////////////////////////////////////////////////////////////////
                             4641 ; 406  |void _reentrant ch9SetAddress(BYTE bSetup, USB_SetupData * pSetup) 
                             4642 ; 407  |{ /* Body */
                             4643 
                             4645 
Y:0000                       4646         org     y,".ybssusb20ch9",bss:
Y:0000 RESERVED              4647 L111:   ds      1
Y:0000
                             4648 
P:0220                       4649         org     p,".ptextusb20ch9":
TASKING DSP2410 assembler v1.5r1 Build 138 SN 00100122
                                                                                                                            Page  74

M:ADDR CODE           CYCLES LINE SOURCELINE
                             4653 Fch9SetAddress:
                             4662 
                             4663 ; 408  |    static BYTE btNewAddress;
                             4664 ; 409  |
                             4665 ; 410  |    if (bSetup)
                             4666 
P:0220 055F7C         2 1267 4654         movec   ssh,y:(r7)+
P:0221 2A0000         2 1269 4668         move    #0,a2
P:0222 200003         2 1271 4669         tst     a
P:0223 0AF0AA rrrrrr  6 1277 4670         jeq     L112
                             4671 
                             4672 ; 411  |    {   // Setup phase
                             4673 ; 412  |
                             4674 ; 413  |        // Get the address from the setup buffer 
                             4675 ; 414  |        btNewAddress = pSetup->wValue;
                             4676 
                             4685 
                             4686 ; 415  |      
                             4687 ; 416  |        // Prepare the status phase
                             4688 ; 417  |        usDataToSend = 0x00;
                             4689 
                             4693 
                             4694 ; 418  |        
                             4695 ; 419  |        usb_device_send_data((BYTE)0, (WORD _X *)&usDataToSend, (BYTE)0, 0, FALSE,0);
                             4696 
P:0225 250000         2 1279 4691         move    #0,x1
P:0226 3E0361         2 1281 4698         tfr     x1,a	                #3,n6
P:0227 221669         2 1283 4700         tfr     x1,b	                r0,r6
P:0228 60F400 rrrrrr  3 1286 4703         move    #FusDataToSend,r0
P:022A 457000 rrrrrr  3 1289 4692         move    x1,x:FusDataToSend
P:022C 20A400         2 1291 4701         move    x1,x0
P:022D 4EEE00         4 1295 4681         move    y:(r6+n6),y0
P:022E 4E7000 rrrrrr  3 1298 4684         move    y0,y:L111
P:0230 20A600         2 1300 4702         move    x1,y0
P:0231 0BF080 rrrrrr  6 1306 4704         jsr     Fusb_device_send_data
                             4706 
                             4707 ; 420  |    } 
                             4708 
P:0233 0AF080 rrrrrr  6 1312 4710         jmp     L115
                             4711 
                             4712 ; 421  |    else
                             4713 ; 422  |    {   // Status phase
                             4714 ; 423  |        
                             4715 ; 424  |        // Program the new address
                             4716 ; 425  |        usb_device_set_status((BYTE)USB_STATUS_ADDRESS, (USHORT)btNewAddress);
                             4717 
P:0235 5FF000 rrrrrr  3 1315 4719 L112:   move    y:L111,b
P:0237 56F400 000003  3 1318 4720         move    #>3,a
P:0239 0BF080 rrrrrr  6 1324 4721         jsr     Fusb_device_set_status
                             4722 
                             4723 ; 426  |        
                             4724 ; 427  |        if(btNewAddress != 0)       // if address not 0, then set device state to addresse
                                  d
                             4725 
P:023B 5FF000 rrrrrr  3 1327 4727         move    y:L111,b
P:023D 2B0000         2 1329 4728         move    #0,b2
P:023E 20000B         2 1331 4729         tst     b
P:023F 0AF0AA rrrrrr  6 1337 4730         jeq     L113
                             4731 
                             4732 ; 428  |            usb_device_set_status((BYTE)USB_STATUS, (USHORT)USB_STATE_ADDRESSED);
TASKING DSP2410 assembler v1.5r1 Build 138 SN 00100122
                                                                                                                            Page  75

M:ADDR CODE           CYCLES LINE SOURCELINE
                             4733 
P:0241 57F400 000001  3 1340 4735         move    #>1,b
P:0243 56F400 000006  3 1343 4736         move    #>6,a
P:0245 0BF080 rrrrrr  6 1349 4737         jsr     Fusb_device_set_status
P:0247 0AF080 rrrrrr  6 1355 4738         jmp     L115
                             4739 
                             4740 ; 429  |        else                        // if address is 0 then set device state to default
                             4741 ; 430  |                                    // per USB specs   
                             4742 ; 431  |            usb_device_set_status((BYTE)USB_STATUS, USB_STATE_DEFAULT);
                             4743 
P:0249 57F400 000002  3 1358 4745 L113:   move    #>2,b
P:024B 56F400 000006  3 1361 4746         move    #>6,a
P:024D 0BF080 rrrrrr  6 1367 4747         jsr     Fusb_device_set_status
                             4748 
                             4749 ; 432  |    }   // Endif            
                             4750 
                             4752 L115:
                             4753 
                             4754 ; 433  |} /* Endbody */
                             4755 
P:024F 05FF7C         4 1371 4757         movec   y:-(r7),ssh
P:0250 000000         2 1373 4757         nop             ; (inserted)
P:0251 00000C         4 1377 4761         rts
                             4763 
                             4764 ; 434  |
                             4765 ; 435  |
                             4766 ; 436  |
                             4767 ; 437  |////////////////////////////////////////////////////////////////////////////////
                             4768 ; 438  |//
                             4769 ; 439  |//>  Name:          ch9GetDescription
                             4770 ; 440  |//
                             4771 ; 441  |//   Type:          Function
                             4772 ; 442  |//
                             4773 ; 443  |//   Description:   Chapter 9 get descriptor command
                             4774 ; 444  |//
                             4775 ; 445  |//   Inputs:        
                             4776 ; 446  |//                  bSetup : TRUE if setup phase
                             4777 ; 447  |//                  pSetup : pointer to the setup packet (8 bytes)
                             4778 ; 448  |//   Outputs:       None
                             4779 ; 449  |//
                             4780 ; 450  |//   Notes:         
                             4781 ; 451  |//     The Device Request can ask for Device/Config/string/interface/endpoint
                             4782 ; 452  |//     descriptors (via wValue). We then post an IN response to return the
                             4783 ; 453  |//     requested descriptor.
                             4784 ; 454  |//     And then wait for the OUT which terminates the control transfer.
                             4785 ; 455  |//<
                             4786 ; 456  |////////////////////////////////////////////////////////////////////////////////
                             4787 ; 457  |void _reentrant ch9GetDescription(BYTE bSetup, USB_SetupData * pSetup) 
                             4788 ; 458  |{ /* Body */
                             4789 
                             4794 Fch9GetDescription:
                             4819 
                             4820 ; 459  |   USHORT   usLength, usDescLength;
                             4821 ; 460  |   USHORT   usSpeed;
                             4822 ; 461  |   BYTE _X * pbtDesc;
                             4823 ; 462  |   WORD wDescriptorType;
                             4824 ; 463  |   WORD wDescriptorIndex;
                             4825 ; 464  |   
                             4826 ; 465  |
                             4827 ; 466  |   wDescriptorType = (pSetup->wValue&0xff00)>>8;
                             4828 
P:0252 055F7C         2 1379 4795         movec   ssh,y:(r7)+
TASKING DSP2410 assembler v1.5r1 Build 138 SN 00100122
                                                                                                                            Page  76

M:ADDR CODE           CYCLES LINE SOURCELINE
P:0253 3E0300         2 1381 4830         move    #3,n6
P:0254 3F0400         2 1383 4798         move    #4,n7
P:0255 221600         2 1385 4831         move    r0,r6
P:0256 000000         2 1387 4831         nop             ; (inserted)
P:0257 4FEE00         4 1391 4833         move    y:(r6+n6),y1
P:0258 46F479 00FF00  3 1394 4835         tfr     y1,b	                #$FF00,y0
P:025A 204F5E         2 1396 4836         and     y0,b	                (r7)+n7
P:025B 20002B         2 1398 4839         lsr     b
P:025C 20002B         2 1400 4839         lsr     b
P:025D 20002B         2 1402 4839         lsr     b
P:025E 20002B         2 1404 4839         lsr     b
P:025F 20002B         2 1406 4839         lsr     b
P:0260 20002B         2 1408 4839         lsr     b
P:0261 20002B         2 1410 4839         lsr     b
P:0262 20002B         2 1412 4839         lsr     b
                             4841 L134:
                             4844 
                             4845 ; 467  |   wDescriptorIndex= (pSetup->wValue&0xff);
                             4846 
                             4854 
                             4855 ; 468  |    // If we are in the setup phase, return the descriptor
                             4856 ; 469  |    // otherwise do nothing ....
                             4857 ; 470  |    if (bSetup) 
                             4858 
P:0263 21A679         2 1414 4848         tfr     y1,b	                b1,y0
P:0264 44F400 0000FF  3 1417 4850         move    #>$FF,x0
P:0266 2A004E         2 1419 4851         and     x0,b	                #0,a2
P:0267 21A703         2 1421 4861         tst     a	                b1,y1
P:0268 0AF0AA rrrrrr  6 1427 4862         jeq     L133
                             4863 
                             4864 ; 471  |    {        
                             4865 ; 472  |        // Load the appropriate string depending on the descriptor requested.
                             4866 ; 473  |        switch (wDescriptorType)
                             4867 
P:026A 57F451 000001  3 1430 4869         tfr     y0,a	                #>1,b
P:026C 2A0000         2 1432 4871         move    #0,a2
P:026D 66F414 rrrrrr  3 1435 4872         sub     b,a     #L135,r6
P:026F 0AF0A8 rrrrrr  6 1441 4873         jcs     L126
P:0271 57F400 000006  3 1444 4874         move    #>6,b
P:0273 21DE05         2 1446 4875         cmp     b,a     a,n6
P:0274 0AF0A7 rrrrrr  6 1452 4876         jgt     L126
P:0276 07EE96         8 1460 4877         movem   p:(r6+n6),r6
P:0277 000000         2 1462 4877         nop             ; (inserted)
P:0278 0AE680         4 1466 4879         jmp     (r6)
                             4880 
P:0279 rrrrrr                4881 L135:   dc      L120    ; case 1:
P:027A rrrrrr                4882         dc      L120    ; case 2:
P:027B rrrrrr                4883         dc      L120    ; case 3:
P:027C rrrrrr                4884         dc      L126    ; default:
P:027D rrrrrr                4885         dc      L126    ; default:
P:027E rrrrrr                4886         dc      L120    ; case 6:
P:027F rrrrrr                4887         dc      L120    ; case 7:
                             4888 
                             4889 
                             4890 ; 474  |        {
                             4891 ; 475  |
TASKING DSP2410 assembler v1.5r1 Build 138 SN 00100122
                                                                                                                            Page  77

M:ADDR CODE           CYCLES LINE SOURCELINE
                             4892 ; 476  |            case DESCRIPTOR_TYPE_STRING:
                             4893 ; 477  |
                             4894 ; 478  |            case DESCRIPTOR_TYPE_DEVICE:
                             4895 ; 479  |            // Prepare Device descriptor transfer
                             4896 ; 480  |            
                             4897 ; 481  |            case DESCRIPTOR_TYPE_CONFIG:
                             4898 ; 482  |            // Prepare Configuration Descriptor transfer.
                             4899 ; 483  |            // A configuration descriptor includes all related interfaces descriptor (1 or
                                   more per configuration)
                             4900 ; 484  |            // and all related endpoints (1 or more per interface)
                             4901 ; 485  |                            
                             4902 ; 486  |            case DESCRIPTOR_TYPE_DEVICE_QUALIFIER:
                             4903 ; 487  |
                             4904 ; 488  |            case DESCRIPTOR_TYPE_OTHER_SPEED_CONFIG:      
                             4905 
                             4907 L120:
                             4922 
                             4923 ; 489  |
                             4924 ; 490  |                usb_device_get_status(USB_STATUS_DEVICE_SPEED, &usSpeed);
                             4925 
P:0280 77F400 FFFFFE  3 1469 4907         move    #-2,n7
P:0282 56F400 000008  3 1472 4930         move    #>8,a
P:0284 4E6F00         4 1476 4909         move    y0,y:(r7+n7)
P:0285 045FA0         2 1478 4912         movec   m0,n7
P:0286 000000         2 1480 4912         nop             ; (inserted)
P:0287 4F6F00         4 1484 4914         move    y1,y:(r7+n7)
P:0288 77F400 FFFFFD  3 1487 4917         move    #-3,n7
P:028A 000000         2 1489 4917         nop             ; (inserted)
P:028B 686F00         4 1493 4919         move    r0,y:(r7+n7)
P:028C 77F400 FFFFFC  3 1496 4927         move    #-4,n7
P:028E 000000         2 1498 4927         nop             ; (inserted)
P:028F 044F10         4 1502 4929         lua     (r7)+n7,r0
P:0290 0BF080 rrrrrr  6 1508 4931         jsr     Fusb_device_get_status
                             4933 
                             4934 ; 491  |                
                             4935 ; 492  |                pbtDesc = GetDescriptor(wDescriptorType, (BYTE)usSpeed, wDescriptorIndex);
                                  
                             4936 
P:0292 77F400 FFFFFE  3 1511 4938         move    #-2,n7
P:0294 000000         2 1513 4938         nop             ; (inserted)
P:0295 5EEF00         4 1517 4940         move    y:(r7+n7),a
P:0296 045FA0         2 1519 4941         movec   m0,n7
P:0297 000000         2 1521 4941         nop             ; (inserted)
P:0298 4CEF00         4 1525 4943         move    y:(r7+n7),x0
P:0299 77F400 FFFFFC  3 1528 4944         move    #-4,n7
P:029B 000000         2 1530 4944         nop             ; (inserted)
P:029C 5FEF00         4 1534 4946         move    y:(r7+n7),b
P:029D 0BF080 rrrrrr  6 1540 4947         jsr     FGetDescriptor
                             4952 
                             4953 ; 493  |               
                             4954 ; 494  |                if(pbtDesc)     // If Descriptor exists
                             4955 
P:029F 220F00         2 1542 4957         move    r0,b
P:02A0 20000B         2 1544 4958         tst     b
P:02A1 0AF0AA rrrrrr  6 1550 4959         jeq     L129
                             4960 
                             4961 ; 495  |                {                
                             4962 ; 496  |                    usLength = pSetup->wLength;
                             4963 
                             4974 
                             4975 ; 497  |                    if(!usLength)
                             4976 
TASKING DSP2410 assembler v1.5r1 Build 138 SN 00100122
                                                                                                                            Page  78

M:ADDR CODE           CYCLES LINE SOURCELINE
P:02A3 3E0500         2 1552 4965         move    #5,n6
P:02A4 77F400 FFFFFD  3 1555 4966         move    #-3,n7
P:02A6 000000         2 1557 4966         nop             ; (inserted)
P:02A7 6EEF00         4 1561 4968         move    y:(r7+n7),r6
P:02A8 000000         2 1563 4968         nop             ; (inserted)
P:02A9 4CEE00         4 1567 4970         move    y:(r6+n6),x0
P:02AA 208F00         2 1569 4978         move    x0,b
P:02AB 2B0000         2 1571 4979         move    #0,b2
P:02AC 20000B         2 1573 4980         tst     b
P:02AD 0AF0AA rrrrrr  6 1579 4981         jeq     L127
                             4982 
                             4983 ; 498  |                    {
                             4984 ; 499  |                        usb_device_stall_endpoint(0, USB_IN);
                             4985 ; 500  |                    }
                             4986 ; 501  |                    else
                             4987 ; 502  |                    {
                             4988 ; 503  |                        if( (wDescriptorType == DESCRIPTOR_TYPE_OTHER_SPEED_CONFIG) ||
                             4989 ; 504  |                            (wDescriptorType == DESCRIPTOR_TYPE_CONFIG) )
                             4990 
P:02AF 77F400 FFFFFE  3 1582 4993         move    #-2,n7
P:02B1 46F400 000007  3 1585 4992         move    #>7,y0
P:02B3 5FEF00         4 1589 4995         move    y:(r7+n7),b
P:02B4 2B0000         2 1591 4996         move    #0,b2
P:02B5 20005D         2 1593 4997         cmp     y0,b
P:02B6 0AF0AA rrrrrr  6 1599 5000         jeq     L121
P:02B8 47F400 000002  3 1602 5001         move    #>2,y1
P:02BA 20007D         2 1604 5002         cmp     y1,b
P:02BB 0AF0A2 rrrrrr  6 1610 5003         jne     L122
                             5004 
                             5005 ; 505  |                        {
                             5006 ; 506  |                            usDescLength = ((pbtDesc[0] & 0xff0000) >> 16)  + ((pbtDesc[1]
                                   & 0x0000ff) >> 16);
                             5007 
                             5009 L121:
P:02BD 26FF00         2 1612 5011         move    #<$FF,y0
P:02BE 57E000         2 1614 5009         move    x:(r0),b
P:02BF 20005E         2 1616 5012         and     y0,b
P:02C0 0610A0         4 1620 5013         rep     #16     
P:02C1 20002B         2 1622 5015         lsr     b
                             5017 L136:
P:02C2 46F400 0000FF  3 1625 5021         move    #>$FF,y0
P:02C4 205800         2 1627 5019         move    (r0)+
P:02C5 56D000         2 1629 5020         move    x:(r0)-,a
P:02C6 200056         2 1631 5022         and     y0,a
P:02C7 218E00         2 1633 5023         move    a1,a
P:02C8 0610A0         4 1637 5024         rep     #16     
P:02C9 200022         2 1639 5026         asr     a
                             5028 L137:
                             5033 
                             5034 ; 507  |
                             5035 ; 508  |                            if(usLength > usDescLength)
                             5036 
P:02CA 218700         2 1641 5030         move    a1,y1
P:02CB 200078         2 1643 5031         add     y1,b
P:02CC 21A641         2 1645 5038         tfr     x0,a	                b1,y0
P:02CD 200055         2 1647 5040         cmp     y0,a
P:02CE 0AF0AF rrrrrr  6 1653 5041         jle     L125
                             5042 
                             5043 ; 509  |                                usLength = usDescLength;
                             5044 
                             5047 
TASKING DSP2410 assembler v1.5r1 Build 138 SN 00100122
                                                                                                                            Page  79

M:ADDR CODE           CYCLES LINE SOURCELINE
                             5048 ; 510  |                        }
                             5049 
P:02D0 21A400         2 1655 5046         move    b1,x0
P:02D1 0AF080 rrrrrr  6 1661 5051         jmp     L125
                             5052 
                             5053 ; 511  |
                             5054 ; 512  |                        else
                             5055 ; 513  |
                             5056 ; 514  |                        {                          
                             5057 ; 515  |                            if(usLength > (pbtDesc[0] & 0x0000ff))
                             5058 
                             5060 L122:
P:02D3 46F400 0000FF  3 1664 5063         move    #>$FF,y0
P:02D5 57E041         2 1666 5060         tfr     x0,a	                x:(r0),b
P:02D6 20005E         2 1668 5064         and     y0,b
P:02D7 21AF00         2 1670 5065         move    b1,b
P:02D8 200005         2 1672 5066         cmp     b,a
P:02D9 0AF0AF rrrrrr  6 1678 5067         jle     L125
                             5068 
                             5069 ; 516  |                                usLength = (BYTE)(pbtDesc[0] & 0x0000ff);  
                             5070 
                             5073 
                             5074 ; 517  |                        }                            
                             5075 ; 518  |
                             5076 ; 519  |                        usb_device_send_data(0, (void _X* ) pbtDesc, 0, usLength, TRUE,0);
                                  
                             5077 
P:02DB 21E400         2 1680 5072         move    b,x0
                             5079 L125:
P:02DC 250013         2 1682 5082         clr     a	                #0,x1
P:02DD 46F469 000001  3 1685 5083         tfr     x1,b	                #>1,y0
P:02DF 0BF080 rrrrrr  6 1691 5085         jsr     Fusb_device_send_data
                             5088 
                             5089 ; 520  |                    }
                             5090 ; 521  |                }
                             5091 ; 522  |
                             5092 ; 523  |                break;
                             5093 
P:02E1 0AF080 rrrrrr  6 1697 5095         jmp     L129
                             5096 
                             5097 ; 524  |
                             5098 ; 525  |            default:
                             5099 ; 526  |                usb_device_stall_endpoint(0, USB_IN);
                             5100 
                             5102 L126:
P:02E3 57F413 000001  3 1700 5103         clr     a	                #>1,b
P:02E5 0BF080 rrrrrr  6 1706 5104         jsr     Fusb_dci_stall_endpoint
                             5105 
                             5106 ; 527  |                return;
                             5107 
P:02E7 0AF080 rrrrrr  6 1712 5109         jmp     L133
                             5111 L127:
P:02E9 57F413 000001  3 1715 5112         clr     a	                #>1,b
P:02EB 0BF080 rrrrrr  6 1721 5113         jsr     Fusb_dci_stall_endpoint
                             5114 
                             5115 ; 528  |
                             5116 ; 529  |        } /* Endswitch */
TASKING DSP2410 assembler v1.5r1 Build 138 SN 00100122
                                                                                                                            Page  80

M:ADDR CODE           CYCLES LINE SOURCELINE
                             5117 ; 530  |
                             5118 ; 531  |
                             5119 ; 532  |        // Sometimes, we need to physically hold the usb device 
                             5120 ; 533  |        // we do this by not sending the data phase here.
                             5121 ; 534  |        // EP0 will NAK until we release the device again.
                             5122 ; 535  |        if(usb_device_is_hold() == FALSE)
                             5123 
P:02ED 0BF080 rrrrrr  6 1727 5125 L129:   jsr     Fusb_device_is_hold
P:02EF 2A0000         2 1729 5126         move    #0,a2
P:02F0 200003         2 1731 5127         tst     a
P:02F1 0AF0A2 rrrrrr  6 1737 5128         jne     L130
                             5129 
                             5130 ; 536  |        {
                             5131 ; 537  |            // Prepare dTD for the status phase
                             5132 ; 538  |            usb_device_recv_data(0, 0, 0, 0, FALSE,0);
                             5133 
P:02F3 250013         2 1739 5137         clr     a	                #0,x1
P:02F4 300069         2 1741 5138         tfr     x1,b	                #0,r0
P:02F5 20A400         2 1743 5139         move    x1,x0
P:02F6 20A600         2 1745 5140         move    x1,y0
P:02F7 0BF080 rrrrrr  6 1751 5141         jsr     Fusb_device_recv_data
                             5142 
                             5143 ; 539  |            
                             5144 ; 540  |        }
                             5145 
P:02F9 0AF080 rrrrrr  6 1757 5147         jmp     L133
                             5148 
                             5149 ; 541  |        else
                             5150 ; 542  |        {
                             5151 ; 543  |            // We hold off a data phase, therefore we flagged it
                             5152 ; 544  |            // the usb_device_release() function will take care of sending it
                             5153 ; 545  |            usb_device_data_phase_required();
                             5154 
P:02FB 0BF080 rrrrrr  6 1763 5156 L130:   jsr     Fusb_device_data_phase_required
                             5157 
                             5158 ; 546  |        }
                             5159 ; 547  |            
                             5160 ; 548  |    } /* Endif */
                             5161 ; 549  |    
                             5162 ; 550  |    return;
                             5163 ; 551  |} /* Endbody */
                             5164 
                             5166 L133:
P:02FD 77F400 FFFFFB  3 1766 5166         move    #-5,n7
P:02FF 000000         2 1768 5166         nop             ; (inserted)
P:0300 05EF7C         4 1772 5168         movec   y:(r7+n7),ssh
P:0301 204F00         2 1774 5170         move    (r7)+n7
P:0302 00000C         4 1778 5172         rts
                             5174 
                             5175 ; 552  |
                             5176 ; 553  |
                             5177 ; 554  |
                             5178 ; 555  |
                             5179 ; 556  |
                             5180 ; 557  |////////////////////////////////////////////////////////////////////////////////
                             5181 ; 558  |//
                             5182 ; 559  |//>  Name:          ch9SetDescription
                             5183 ; 560  |//
                             5184 ; 561  |//   Type:          Function
                             5185 ; 562  |//
TASKING DSP2410 assembler v1.5r1 Build 138 SN 00100122
                                                                                                                            Page  81

M:ADDR CODE           CYCLES LINE SOURCELINE
                             5186 ; 563  |//   Description:   Chapter 9 set descriptor command
                             5187 ; 564  |//
                             5188 ; 565  |//   Inputs:        
                             5189 ; 566  |//                  bSetup : TRUE if setup phase
                             5190 ; 567  |//                  pSetup : pointer to the setup packet (8 bytes)
                             5191 ; 568  |//   Outputs:       None
                             5192 ; 569  |//
                             5193 ; 570  |//   Notes:         
                             5194 ; 571  |//     The Device Request can ask for Device/Config/string/interface/endpoint
                             5195 ; 572  |//     descriptors (via wValue). We then post an IN response to return the
                             5196 ; 573  |//     requested descriptor.
                             5197 ; 574  |//     And then wait for the OUT which terminates the control transfer.
                             5198 ; 575  |//<
                             5199 ; 576  |////////////////////////////////////////////////////////////////////////////////
                             5200 ; 577  |void _reentrant ch9SetDescription(BYTE bSetup, USB_SetupData * pSetup) 
                             5201 ; 578  |{ /* Body */
                             5202 
                             5207 Fch9SetDescription:
                             5215 
                             5216 ; 579  |    usb_device_stall_endpoint(0, USB_IN);
                             5217 
P:0303 055F7C         2 1780 5208         movec   ssh,y:(r7)+
P:0304 57F413 000001  3 1783 5219         clr     a	                #>1,b
P:0306 0BF080 rrrrrr  6 1789 5221         jsr     Fusb_dci_stall_endpoint
                             5224 
                             5225 ; 580  |    return;
                             5226 ; 581  |} /* Endbody */
                             5227 
P:0308 05FF7C         4 1793 5229         movec   y:-(r7),ssh
P:0309 000000         2 1795 5229         nop             ; (inserted)
P:030A 00000C         4 1799 5233         rts
                             5235 
                             5236 ; 582  |
                             5237 ; 583  |
                             5238 ; 584  |
                             5239 ; 585  |
                             5240 ; 586  |
                             5241 ; 587  |////////////////////////////////////////////////////////////////////////////////
                             5242 ; 588  |//
                             5243 ; 589  |//>  Name:          ch9GetConfig
                             5244 ; 590  |//
                             5245 ; 591  |//   Type:          Function
                             5246 ; 592  |//
                             5247 ; 593  |//   Description:   Chapter 9 get configuration command
                             5248 ; 594  |//
                             5249 ; 595  |//   Inputs:        
                             5250 ; 596  |//                  bSetup : TRUE if setup phase
                             5251 ; 597  |//                  pSetup : pointer to the setup packet (8 bytes)
                             5252 ; 598  |//   Outputs:       None
                             5253 ; 599  |//
                             5254 ; 600  |//   Notes:         
                             5255 ; 601  |//<
                             5256 ; 602  |////////////////////////////////////////////////////////////////////////////////
                             5257 ; 603  |void _reentrant ch9GetConfig(BYTE bSetup, USB_SetupData * pSetup) 
                             5258 ; 604  |{ /* Body */
                             5259 
                             5264 Fch9GetConfig:
                             5275 
                             5276 ; 605  |    USHORT usStatus;
                             5277 ; 606  |
                             5278 ; 607  |    // If we are in the setup phase, return the descriptor
TASKING DSP2410 assembler v1.5r1 Build 138 SN 00100122
                                                                                                                            Page  82

M:ADDR CODE           CYCLES LINE SOURCELINE
                             5279 ; 608  |    // otherwise do nothing ....
                             5280 ; 609  |    if (bSetup) 
                             5281 
P:030B 055F7C         2 1801 5265         movec   ssh,y:(r7)+
P:030C 2A0000         2 1803 5283         move    #0,a2
P:030D 205F03         2 1805 5284         tst     a	                (r7)+
P:030E 0AF0AA rrrrrr  6 1811 5285         jeq     L140
                             5286 
                             5287 ; 610  |    {    
                             5288 ; 611  |        // Get the device status
                             5289 ; 612  |        usb_device_get_status(USB_STATUS, &usStatus);
                             5290 
P:0310 045715         4 1815 5292         lua     (r7)-,r5
P:0311 22B000         2 1817 5293         move    r5,r0
P:0312 56F400 000006  3 1820 5295         move    #>6,a
P:0314 0BF080 rrrrrr  6 1826 5296         jsr     Fusb_device_get_status
                             5298 
                             5299 ; 613  |        
                             5300 ; 614  |        if(usStatus != USB_STATE_CONFIGURED)
                             5301 
P:0316 045FA0         2 1828 5303         movec   m0,n7
P:0317 000000         2 1830 5303         nop             ; (inserted)
P:0318 5FEF00         4 1834 5305         move    y:(r7+n7),b
P:0319 2B0000         2 1836 5306         move    #0,b2
P:031A 20000B         2 1838 5307         tst     b
P:031B 0AF0AA rrrrrr  6 1844 5308         jeq     L138
                             5309 
                             5310 ; 615  |            usDataToSend = 0x00;                // Return config 0
                             5311 
P:031D 3D0000         2 1846 5313         move    #0,n5
P:031E 757000 rrrrrr  3 1849 5314         move    n5,x:FusDataToSend
P:0320 0AF080 rrrrrr  6 1855 5315         jmp     L139
                             5316 
                             5317 ; 616  |        else
                             5318 ; 617  |        {        
                             5319 ; 618  |            usb_device_get_status(USB_STATUS_CURRENT_CONFIG, &usStatus);
                             5320 
P:0322 045710         4 1859 5322 L138:   lua     (r7)-,r0
P:0323 56F400 000004  3 1862 5323         move    #>4,a
P:0325 0BF080 rrrrrr  6 1868 5324         jsr     Fusb_device_get_status
                             5325 
                             5326 ; 619  |            usDataToSend = usStatus;
                             5327 
                             5333 
                             5334 ; 620  |        }
                             5335 ; 621  |        
                             5336 ; 622  |        // Send the data
                             5337 ; 623  |        usb_device_send_data(0, (WORD _X *)&usDataToSend, 0, (USHORT)1, TRUE,0); 
                             5338 
P:0327 045FA0         2 1870 5329         movec   m0,n7
P:0328 000000         2 1872 5329         nop             ; (inserted)
P:0329 6BEF00         4 1876 5331         move    y:(r7+n7),r3
P:032A 637000 rrrrrr  3 1879 5332         move    r3,x:FusDataToSend
                             5340 L139:
P:032C 60F400 rrrrrr  3 1882 5345         move    #FusDataToSend,r0
P:032E 46F413 000001  3 1885 5340         clr     a	                #>1,y0
P:0330 25001B         2 1887 5343         clr     b	                #0,x1
P:0331 20C400         2 1889 5342         move    y0,x0
P:0332 0BF080 rrrrrr  6 1895 5346         jsr     Fusb_device_send_data
TASKING DSP2410 assembler v1.5r1 Build 138 SN 00100122
                                                                                                                            Page  83

M:ADDR CODE           CYCLES LINE SOURCELINE
                             5347 
                             5348 ; 624  |
                             5349 ; 625  |        // Prepare dTD for the status phase
                             5350 ; 626  |        usb_device_recv_data(0, 0, 0, 0, FALSE,0);
                             5351 
P:0334 250013         2 1897 5355         clr     a	                #0,x1
P:0335 300069         2 1899 5356         tfr     x1,b	                #0,r0
P:0336 20A400         2 1901 5357         move    x1,x0
P:0337 20A600         2 1903 5358         move    x1,y0
P:0338 0BF080 rrrrrr  6 1909 5359         jsr     Fusb_device_recv_data
                             5360 
                             5361 ; 627  |    } /* Endif */
                             5362 ; 628  |    
                             5363 ; 629  |    return;
                             5364 ; 630  |} /* Endbody */
                             5365 
                             5367 L140:
P:033A 205700         2 1911 5367         move    (r7)-
P:033B 05FF7C         4 1915 5369         movec   y:-(r7),ssh
P:033C 000000         2 1917 5369         nop             ; (inserted)
P:033D 00000C         4 1921 5373         rts
                             5375 
                             5376 ; 631  |
                             5377 ; 632  |
                             5378 ; 633  |
                             5379 ; 634  |
                             5380 ; 635  |
                             5381 ; 636  |
                             5382 ; 637  |////////////////////////////////////////////////////////////////////////////////
                             5383 ; 638  |//
                             5384 ; 639  |//>  Name:          ch9SetConfig
                             5385 ; 640  |//
                             5386 ; 641  |//   Type:          Function
                             5387 ; 642  |//
                             5388 ; 643  |//   Description:   Chapter 9 set configuration command
                             5389 ; 644  |//
                             5390 ; 645  |//   Inputs:        
                             5391 ; 646  |//                  bSetup : TRUE if setup phase
                             5392 ; 647  |//                  pSetup : pointer to the setup packet (8 bytes)
                             5393 ; 648  |//   Outputs:       None
                             5394 ; 649  |//
                             5395 ; 650  |//   Notes:         
                             5396 ; 651  |//<
                             5397 ; 652  |////////////////////////////////////////////////////////////////////////////////
                             5398 ; 653  |
                             5399 ; 654  |BOOL g_bUsbConfigured = FALSE;
                             5400 
                             5401 
Y:0000                       5402         org     y,".ydatausb20ch9",init:
                             5403 Fg_bUsbConfigured:
Y:0000 000000                5404         dc      $000000
                             5407 
                             5408 ; 655  |
                             5409 ; 656  |void _reentrant ch9SetConfig(BYTE bSetup, USB_SetupData * pSetup) 
                             5410 ; 657  |{ /* Body */
                             5411 
P:033E                       5412         org     p,".ptextusb20ch9":
                             5417 Fch9SetConfig:
                             5432 
                             5433 ; 658  |    USHORT  usStatus;
TASKING DSP2410 assembler v1.5r1 Build 138 SN 00100122
                                                                                                                            Page  84

M:ADDR CODE           CYCLES LINE SOURCELINE
                             5434 ; 659  |    INT     i;
                             5435 
                             5447 
                             5448 ; 660  |    
                             5449 ; 661  |    // Get the device status
                             5450 ; 662  |    usb_device_get_status(USB_STATUS, &usStatus);
                             5451 
P:033E 055F7C         2 1923 5418         movec   ssh,y:(r7)+
P:033F 3F0500         2 1925 5421         move    #5,n7
P:0340 000000         2 1927 5421         nop             ; (inserted)
P:0341 204F00         2 1929 5423         move    (r7)+n7
P:0342 77F400 FFFFFD  3 1932 5437         move    #-3,n7
P:0344 000000         2 1934 5437         nop             ; (inserted)
P:0345 686F00         4 1938 5439         move    r0,y:(r7+n7)
P:0346 77F400 FFFFFC  3 1941 5442         move    #-4,n7
P:0348 000000         2 1943 5442         nop             ; (inserted)
P:0349 5C6F00         4 1947 5444         move    a1,y:(r7+n7)
P:034A 77F400 FFFFFB  3 1950 5453         move    #-5,n7
P:034C 56F400 000006  3 1953 5457         move    #>6,a
P:034E 044F14         4 1957 5455         lua     (r7)+n7,r4
P:034F 229000         2 1959 5456         move    r4,r0
P:0350 0BF080 rrrrrr  6 1965 5458         jsr     Fusb_device_get_status
                             5459 
                             5460 ; 663  |
                             5461 ; 664  |    // If we are in the setup phase, return the descriptor
                             5462 ; 665  |    // otherwise do nothing ....
                             5463 ; 666  |    if(bSetup)
                             5464 
P:0352 77F400 FFFFFC  3 1968 5466         move    #-4,n7
P:0354 000000         2 1970 5466         nop             ; (inserted)
P:0355 5FEF00         4 1974 5468         move    y:(r7+n7),b
P:0356 2B0000         2 1976 5469         move    #0,b2
P:0357 20000B         2 1978 5470         tst     b
P:0358 0AF0AA rrrrrr  6 1984 5473         jeq     L159
                             5474 
                             5475 ; 667  |    {
                             5476 ; 668  |        if((usStatus == USB_STATE_CONFIGURED) || (usStatus == USB_STATE_ADDRESSED))
                             5477 
P:035A 77F400 FFFFFB  3 1987 5479         move    #-5,n7
P:035C 000000         2 1989 5479         nop             ; (inserted)
P:035D 5FEF00         4 1993 5481         move    y:(r7+n7),b
P:035E 2B0000         2 1995 5482         move    #0,b2
P:035F 20000B         2 1997 5483         tst     b
P:0360 0AF0AA rrrrrr  6 2003 5484         jeq     L151
P:0362 46F401 000001  3 2006 5485         tfr     b,a	                #>1,y0
P:0364 200055         2 2008 5487         cmp     y0,a
P:0365 0AF0A2 rrrrrr  6 2014 5488         jne     L157
                             5489 
                             5490 ; 669  |        {
                             5491 ; 670  |            // Unstall all stall endpoints per ch9 specs
                             5492 ; 671  |            for(i=0 ; i < MAX_NUM_EP ; i++)
                             5493 
                             5495 L151:
                             5498 
                             5499 ; 672  |            {
                             5500 ; 673  |                usb_device_get_status((USB_STATUS_ENDPOINT + i), &usStatus);
                             5501 
P:0367 46F413 000001  3 2017 5495         clr     a	                #>1,y0
                             5503 L152:
P:0369 77F400 FFFFFE  3 2020 5504         move    #-2,n7
TASKING DSP2410 assembler v1.5r1 Build 138 SN 00100122
                                                                                                                            Page  85

M:ADDR CODE           CYCLES LINE SOURCELINE
P:036B 57F400 000010  3 2023 5503         move    #>16,b
P:036D 5C6F18         4 2027 5507         add     a,b	                a1,y:(r7+n7)
P:036E 77F401 FFFFFB  3 2030 5511         tfr     b,a	                #-5,n7
P:0370 000000         2 2032 5511         nop             ; (inserted)
P:0371 044F10         4 2036 5514         lua     (r7)+n7,r0
P:0372 045FA0         2 2038 5515         movec   m0,n7
P:0373 000000         2 2040 5515         nop             ; (inserted)
P:0374 5C6F00         4 2044 5517         move    a1,y:(r7+n7)
P:0375 0BF080 rrrrrr  6 2050 5518         jsr     Fusb_device_get_status
                             5522 
                             5523 ; 674  |                if(usStatus == (USHORT)TRUE)
                             5524 
P:0377 045FA0         2 2052 5519         movec   m0,n7
P:0378 45F400 000001  3 2055 5529         move    #>1,x1
P:037A 5EEF00         4 2059 5521         move    y:(r7+n7),a
P:037B 77F400 FFFFFB  3 2062 5526         move    #-5,n7
P:037D 000000         2 2064 5526         nop             ; (inserted)
P:037E 5FEF00         4 2068 5528         move    y:(r7+n7),b
P:037F 20006D         2 2070 5530         cmp     x1,b
P:0380 0AF0A2 rrrrrr  6 2076 5531         jne     L153
                             5533 
                             5534 ; 675  |                    usb_device_set_status((USB_STATUS_ENDPOINT + i), FALSE);
                             5535 
P:0382 2F0000         2 2078 5532         move    #0,b
P:0383 0BF080 rrrrrr  6 2084 5537         jsr     Fusb_device_set_status
                             5538 L153:
P:0385 77F400 FFFFFE  3 2087 5540         move    #-2,n7
P:0387 46F400 000001  3 2090 5543         move    #>1,y0
P:0389 5EEF00         4 2094 5542         move    y:(r7+n7),a
P:038A 47F450 000004  3 2097 5544         add     y0,a	                #>4,y1
P:038C 200075         2 2099 5548         cmp     y1,a
P:038D 0AF0A9 rrrrrr  6 2105 5549         jlt     L152
                             5550 
                             5551 ; 676  |            }                    
                             5552 ; 677  |            
                             5553 ; 678  |            if(pSetup->wValue == 0)
                             5554 
P:038F 3E0300         2 2107 5556         move    #3,n6
P:0390 77F400 FFFFFD  3 2110 5557         move    #-3,n7
P:0392 000000         2 2112 5557         nop             ; (inserted)
P:0393 6EEF00         4 2116 5559         move    y:(r7+n7),r6
P:0394 000000         2 2118 5559         nop             ; (inserted)
P:0395 204E00         2 2120 5561         move    (r6)+n6
P:0396 5EE600         2 2122 5564         move    y:(r6),a
P:0397 2A0000         2 2124 5566         move    #0,a2
P:0398 200003         2 2126 5567         tst     a
P:0399 0AF0A2 rrrrrr  6 2132 5568         jne     L154
                             5569 
                             5570 ; 679  |            { // If configuration value is 0, then go to ADDRESS State
                             5571 ; 680  |#ifdef  USBTEST_FOR_USBCV_1_3
                             5572 ; 681  |                //after this command  sould cancel the MSC bulk out request for CBW
                             5573 ; 682  |                g_bUsbConfigured = FALSE;
                             5574 ; 683  |#endif
                             5575 ; 684  |                // Inform Application
                             5576 ; 685  |                usb_device_call_service(USB_SERVICE_CHANGE_CONFIG, FALSE, 0, (WORD _X*)&bt
                                  Status, (USHORT)pSetup->wValue,0);
                             5577 
P:039B 60F400 rrrrrr  3 2135 5583         move    #FbtStatus,r0
TASKING DSP2410 assembler v1.5r1 Build 138 SN 00100122
                                                                                                                            Page  86

M:ADDR CODE           CYCLES LINE SOURCELINE
P:039D 25001B         2 2137 5579         clr     b	                #0,x1
P:039E 240000         2 2139 5581         move    #0,x0
P:039F 218600         2 2141 5580         move    a1,y0
P:03A0 56F400 000017  3 2144 5584         move    #>23,a
P:03A2 0BF080 rrrrrr  6 2150 5585         jsr     Fusb_device_call_service
                             5588 
                             5589 ; 686  |                
                             5590 ; 687  |                // Clear the current config value
                             5591 ; 688  |                usb_device_set_status(USB_STATUS_CURRENT_CONFIG, 0);
                             5592 
P:03A4 56F41B 000004  3 2153 5587         clr     b	                #>4,a
P:03A6 0BF080 rrrrrr  6 2159 5595         jsr     Fusb_device_set_status
                             5596 
                             5597 ; 689  |                
                             5598 ; 690  |                // Set the device state to ADDRESS State
                             5599 ; 691  |                usb_device_set_status(USB_STATUS, USB_STATE_ADDRESSED);
                             5600 
                             5604 
                             5605 ; 692  |                
                             5606 ; 693  |                // Prepare status phase
                             5607 ; 694  |                usb_device_send_data(0, 0, 0, 0, FALSE,0);
                             5608 
P:03A8 56F400 000006  3 2162 5602         move    #>6,a
P:03AA 57F400 000001  3 2165 5603         move    #>1,b
P:03AC 0AF080 rrrrrr  6 2171 5610         jmp     L155
                             5611 
                             5612 ; 695  |#ifdef USBTEST_FOR_USBCV_1_3
                             5613 ; 696  |                //release to UsbMscCbwProcessor() event
                             5614 ; 697  |                ISRReleaseObject(&(UsbMscDevice[0].TransferObject));
                             5615 ; 698  |#endif
                             5616 ; 699  |            }
                             5617 ; 700  |            else
                             5618 ; 701  |            {
                             5619 ; 702  |                
                             5620 ; 703  |                // Inform Application
                             5621 ; 704  |                btStatus = USB_OK;              // By default request is accepted
                             5622 
                             5624 L154:
                             5626 
                             5627 ; 705  |                usb_device_call_service(USB_SERVICE_CHANGE_CONFIG, FALSE, 0, (WORD _X*)&bt
                                  Status, (USHORT)pSetup->wValue,0);
                             5628 
P:03AE 77F413 FFFFFE  3 2174 5624         clr     a	                #-2,n7
P:03B0 60F400 rrrrrr  3 2177 5637         move    #FbtStatus,r0
P:03B2 250000         2 2179 5636         move    #0,x1
P:03B3 567009 rrrrrr  3 2182 5630         tfr     a,b	                a,x:FbtStatus
P:03B5 6E6F00         4 2186 5633         move    r6,y:(r7+n7)
P:03B6 12F400 000017  3 2189 5635         move    a,x0	                #>23,a
P:03B8 4EE600         2 2191 5634         move    y:(r6),y0
P:03B9 0BF080 rrrrrr  6 2197 5639         jsr     Fusb_device_call_service
                             5640 
                             5641 ; 706  |                
                             5642 ; 707  |                if(btStatus == USB_OK)
                             5643 
P:03BB 57F000 rrrrrr  3 2200 5645         move    x:FbtStatus,b
P:03BD 2B0000         2 2202 5646         move    #0,b2
P:03BE 20000B         2 2204 5647         tst     b
TASKING DSP2410 assembler v1.5r1 Build 138 SN 00100122
                                                                                                                            Page  87

M:ADDR CODE           CYCLES LINE SOURCELINE
P:03BF 0AF0A2 rrrrrr  6 2210 5648         jne     L157
                             5649 
                             5650 ; 708  |                {                
                             5651 ; 709  |                
                             5652 ; 710  |                    // Set the confing value
                             5653 ; 711  |                    usb_device_set_status(USB_STATUS_CURRENT_CONFIG, (USHORT)pSetup->wValu
                                  e);
                             5654 
P:03C1 77F400 FFFFFE  3 2213 5656         move    #-2,n7
P:03C3 56F400 000004  3 2216 5661         move    #>4,a
P:03C5 6EEF00         4 2220 5658         move    y:(r7+n7),r6
P:03C6 000000         2 2222 5658         nop             ; (inserted)
P:03C7 5FE600         2 2224 5660         move    y:(r6),b
P:03C8 0BF080 rrrrrr  6 2230 5662         jsr     Fusb_device_set_status
                             5663 
                             5664 ; 712  |            
                             5665 ; 713  |                    g_bUsbConfigured = TRUE;
                             5666 
                             5671 
                             5672 ; 714  |                    
                             5673 ; 715  |                    // Set the device state to CONFIG State
                             5674 ; 716  |                    usb_device_set_status(USB_STATUS, USB_STATE_CONFIGURED);
                             5675 
                             5678 
                             5679 ; 717  |
                             5680 ; 718  |                    // Prepare status phase
                             5681 ; 719  |                    usb_device_send_data(0, 0, 0, 0, FALSE,0);
                             5682 
P:03CA 56F41B 000001  3 2233 5670         clr     b	                #>1,a
P:03CC 5C7000 rrrrrr  3 2236 5669         move    a1,y:Fg_bUsbConfigured
P:03CE 56F400 000006  3 2239 5677         move    #>6,a
                             5684 L155:
P:03D0 0BF080 rrrrrr  6 2245 5686         jsr     Fusb_device_set_status
P:03D2 250013         2 2247 5690         clr     a	                #0,x1
P:03D3 300069         2 2249 5691         tfr     x1,b	                #0,r0
P:03D4 20A400         2 2251 5692         move    x1,x0
P:03D5 20A600         2 2253 5693         move    x1,y0
P:03D6 0BF080 rrrrrr  6 2259 5694         jsr     Fusb_device_send_data
                             5695 
                             5696 ; 720  |                }                    
                             5697 
P:03D8 0AF080 rrrrrr  6 2265 5699         jmp     L159
                             5700 
                             5701 ; 721  |                else
                             5702 ; 722  |                {                
                             5703 ; 723  |                    // Invalid request
                             5704 ; 724  |                    usb_device_stall_endpoint(0, USB_IN);
                             5705 ; 725  |                }                    
                             5706 ; 726  |            
                             5707 ; 727  |            }
                             5708 ; 728  |        }
                             5709 ; 729  |        else
                             5710 ; 730  |            // Invalid request
                             5711 ; 731  |            usb_device_stall_endpoint(0, USB_IN);
                             5712 
P:03DA 57F413 000001  3 2268 5714 L157:   clr     a	                #>1,b
P:03DC 0BF080 rrrrrr  6 2274 5716         jsr     Fusb_dci_stall_endpoint
                             5717 
TASKING DSP2410 assembler v1.5r1 Build 138 SN 00100122
                                                                                                                            Page  88

M:ADDR CODE           CYCLES LINE SOURCELINE
                             5718 ; 732  |    }    
                             5719 ; 733  |    return;
                             5720 ; 734  |} /* Endbody */
                             5721 
                             5723 L159:
P:03DE 77F400 FFFFFA  3 2277 5723         move    #-6,n7
P:03E0 000000         2 2279 5723         nop             ; (inserted)
P:03E1 05EF7C         4 2283 5725         movec   y:(r7+n7),ssh
P:03E2 204F00         2 2285 5727         move    (r7)+n7
P:03E3 00000C         4 2289 5729         rts
                             5731 
                             5732 ; 735  |
                             5733 ; 736  |
                             5734 ; 737  |
                             5735 ; 738  |
                             5736 ; 739  |
                             5737 ; 740  |
                             5738 ; 741  |////////////////////////////////////////////////////////////////////////////////
                             5739 ; 742  |//
                             5740 ; 743  |//>  Name:          ch9GetInterface
                             5741 ; 744  |//
                             5742 ; 745  |//   Type:          Function
                             5743 ; 746  |//
                             5744 ; 747  |//   Description:   Chapter 9 get interface command
                             5745 ; 748  |//
                             5746 ; 749  |//   Inputs:        
                             5747 ; 750  |//                  bSetup : TRUE if setup phase
                             5748 ; 751  |//                  pSetup : pointer to the setup packet (8 bytes)
                             5749 ; 752  |//   Outputs:       None
                             5750 ; 753  |//
                             5751 ; 754  |//   Notes:         
                             5752 ; 755  |//<
                             5753 ; 756  |////////////////////////////////////////////////////////////////////////////////
                             5754 ; 757  |void _reentrant ch9GetInterface(BYTE bSetup, USB_SetupData * pSetup) 
                             5755 ; 758  |{ /* Body */
                             5756 
                             5761 Fch9GetInterface:
                             5773 
                             5774 ; 759  |    USHORT usStatus;
                             5775 
                             5782 
                             5783 ; 760  |
                             5784 ; 761  |    // Get the device status
                             5785 ; 762  |    usb_device_get_status(USB_STATUS, &usStatus);
                             5786 
P:03E4 055F7C         2 2291 5762         movec   ssh,y:(r7)+
P:03E5 045FA0         2 2293 5777         movec   m0,n7
P:03E6 205F00         2 2295 5765         move    (r7)+
P:03E7 205F00         2 2297 5766         move    (r7)+
P:03E8 5C6F00         4 2301 5779         move    a1,y:(r7+n7)
P:03E9 77F400 FFFFFE  3 2304 5788         move    #-2,n7
P:03EB 56F400 000006  3 2307 5793         move    #>6,a
P:03ED 044F1D         4 2311 5790         lua     (r7)+n7,n5
P:03EE 23B000         2 2313 5791         move    n5,r0
P:03EF 0BF080 rrrrrr  6 2319 5794         jsr     Fusb_device_get_status
                             5795 
                             5796 ; 763  |
                             5797 ; 764  |    if (usStatus != USB_STATE_CONFIGURED)
                             5798 
P:03F1 77F400 FFFFFE  3 2322 5800         move    #-2,n7
P:03F3 000000         2 2324 5800         nop             ; (inserted)
P:03F4 5FEF00         4 2328 5802         move    y:(r7+n7),b
TASKING DSP2410 assembler v1.5r1 Build 138 SN 00100122
                                                                                                                            Page  89

M:ADDR CODE           CYCLES LINE SOURCELINE
P:03F5 2B0000         2 2330 5803         move    #0,b2
P:03F6 20000B         2 2332 5804         tst     b
P:03F7 0AF0AA rrrrrr  6 2338 5805         jeq     L160
                             5806 
                             5807 ; 765  |    {
                             5808 ; 766  |        usb_device_stall_endpoint(0, USB_IN);
                             5809 
P:03F9 57F413 000001  3 2341 5812         clr     a	                #>1,b
P:03FB 0BF080 rrrrrr  6 2347 5813         jsr     Fusb_dci_stall_endpoint
                             5814 
                             5815 ; 767  |        return;
                             5816 
P:03FD 0AF080 rrrrrr  6 2353 5818         jmp     L162
                             5819 
                             5820 ; 768  |    } /* Endif */
                             5821 ; 769  |
                             5822 ; 770  |    // If we are in the setup phase, return the descriptor
                             5823 ; 771  |    // otherwise do nothing ....
                             5824 ; 772  |    if(bSetup)
                             5825 
                             5827 L160:
P:03FF 045FA0         2 2355 5827         movec   m0,n7
P:0400 000000         2 2357 5827         nop             ; (inserted)
P:0401 5FEF00         4 2361 5829         move    y:(r7+n7),b
P:0402 2B0000         2 2363 5830         move    #0,b2
P:0403 20000B         2 2365 5831         tst     b
P:0404 0AF0AA rrrrrr  6 2371 5834         jeq     L162
                             5835 
                             5836 ; 773  |    {    
                             5837 ; 774  |        usb_device_get_status(USB_STATUS_CURRENT_IFACE, &usStatus);
                             5838 
P:0406 77F400 FFFFFE  3 2374 5840         move    #-2,n7
P:0408 56F400 00000A  3 2377 5843         move    #>10,a
P:040A 044F10         4 2381 5842         lua     (r7)+n7,r0
P:040B 0BF080 rrrrrr  6 2387 5844         jsr     Fusb_device_get_status
                             5846 
                             5847 ; 775  |
                             5848 ; 776  |        usDataToSend = usStatus;
                             5849 
                             5855 
                             5856 ; 777  |
                             5857 ; 778  |        usb_device_send_data(0, (WORD _X *)&usDataToSend, 0, (USHORT)1, TRUE,0); 
                             5858 
P:040D 77F413 FFFFFE  3 2390 5860         clr     a	                #-2,n7
P:040F 60F400 rrrrrr  3 2393 5865         move    #FusDataToSend,r0
P:0411 7DEF00         4 2397 5853         move    y:(r7+n7),n5
P:0412 46F400 000001  3 2400 5861         move    #>1,y0
P:0414 25001B         2 2402 5863         clr     b	                #0,x1
P:0415 757000 rrrrrr  3 2405 5854         move    n5,x:FusDataToSend
P:0417 20C400         2 2407 5862         move    y0,x0
P:0418 0BF080 rrrrrr  6 2413 5866         jsr     Fusb_device_send_data
                             5867 
                             5868 ; 779  |
                             5869 ; 780  |        // Prepare dTD for the status phase
                             5870 ; 781  |        usb_device_recv_data(0, 0, 0, 0, FALSE,0);
                             5871 
P:041A 250013         2 2415 5875         clr     a	                #0,x1
TASKING DSP2410 assembler v1.5r1 Build 138 SN 00100122
                                                                                                                            Page  90

M:ADDR CODE           CYCLES LINE SOURCELINE
P:041B 300069         2 2417 5876         tfr     x1,b	                #0,r0
P:041C 20A400         2 2419 5877         move    x1,x0
P:041D 20A600         2 2421 5878         move    x1,y0
P:041E 0BF080 rrrrrr  6 2427 5879         jsr     Fusb_device_recv_data
                             5880 
                             5881 ; 782  |    } /* Endif */
                             5882 ; 783  |
                             5883 ; 784  |    return;
                             5884 ; 785  |} /* Endbody */
                             5885 
                             5887 L162:
P:0420 205700         2 2429 5887         move    (r7)-
P:0421 205700         2 2431 5888         move    (r7)-
P:0422 05FF7C         4 2435 5890         movec   y:-(r7),ssh
P:0423 000000         2 2437 5890         nop             ; (inserted)
P:0424 00000C         4 2441 5894         rts
                             5896 
                             5897 ; 786  |
                             5898 ; 787  |
                             5899 ; 788  |
                             5900 ; 789  |
                             5901 ; 790  |
                             5902 ; 791  |////////////////////////////////////////////////////////////////////////////////
                             5903 ; 792  |//
                             5904 ; 793  |//>  Name:          ch9SetInterface
                             5905 ; 794  |//
                             5906 ; 795  |//   Type:          Function
                             5907 ; 796  |//
                             5908 ; 797  |//   Description:   Chapter 9 set interface command
                             5909 ; 798  |//
                             5910 ; 799  |//   Inputs:        
                             5911 ; 800  |//                  bSetup : TRUE if setup phase
                             5912 ; 801  |//                  pSetup : pointer to the setup packet (8 bytes)
                             5913 ; 802  |//   Outputs:       None
                             5914 ; 803  |//
                             5915 ; 804  |//   Notes:         
                             5916 ; 805  |//<
                             5917 ; 806  |////////////////////////////////////////////////////////////////////////////////
                             5918 ; 807  |void _reentrant ch9SetInterface(BYTE bSetup, USB_SetupData * pSetup) 
                             5919 ; 808  |{ /* Body */
                             5920 
                             5925 Fch9SetInterface:
                             5940 
                             5941 ; 809  |
                             5942 ; 810  |    USHORT usStatus;
                             5943 ; 811  |    INT     i;
                             5944 
                             5956 
                             5957 ; 812  |    
                             5958 ; 813  |    // Get the device status
                             5959 ; 814  |    usb_device_get_status(USB_STATUS, &usStatus);
                             5960 
P:0425 055F7C         2 2443 5926         movec   ssh,y:(r7)+
P:0426 3F0500         2 2445 5929         move    #5,n7
P:0427 000000         2 2447 5929         nop             ; (inserted)
P:0428 204F00         2 2449 5931         move    (r7)+n7
P:0429 77F400 FFFFFD  3 2452 5946         move    #-3,n7
P:042B 000000         2 2454 5946         nop             ; (inserted)
P:042C 686F00         4 2458 5948         move    r0,y:(r7+n7)
P:042D 77F400 FFFFFC  3 2461 5951         move    #-4,n7
P:042F 000000         2 2463 5951         nop             ; (inserted)
TASKING DSP2410 assembler v1.5r1 Build 138 SN 00100122
                                                                                                                            Page  91

M:ADDR CODE           CYCLES LINE SOURCELINE
P:0430 5C6F00         4 2467 5953         move    a1,y:(r7+n7)
P:0431 77F400 FFFFFB  3 2470 5962         move    #-5,n7
P:0433 56F400 000006  3 2473 5966         move    #>6,a
P:0435 044F13         4 2477 5964         lua     (r7)+n7,r3
P:0436 227000         2 2479 5965         move    r3,r0
P:0437 0BF080 rrrrrr  6 2485 5967         jsr     Fusb_device_get_status
                             5968 
                             5969 ; 815  |
                             5970 ; 816  |    if(usStatus != USB_STATE_CONFIGURED)
                             5971 
P:0439 77F400 FFFFFB  3 2488 5973         move    #-5,n7
P:043B 000000         2 2490 5973         nop             ; (inserted)
P:043C 5FEF00         4 2494 5975         move    y:(r7+n7),b
P:043D 2B0000         2 2496 5976         move    #0,b2
P:043E 20000B         2 2498 5977         tst     b
P:043F 0AF0A2 rrrrrr  6 2504 5978         jne     L173
                             5979 
                             5980 ; 817  |    {
                             5981 ; 818  |       usb_device_stall_endpoint(0, USB_IN);
                             5982 ; 819  |       return;
                             5983 ; 820  |    } /* Endif */
                             5984 ; 821  |
                             5985 ; 822  |    // If we are in the setup phase, return the descriptor
                             5986 ; 823  |    // otherwise do nothing ....
                             5987 ; 824  |    if(bSetup) 
                             5988 
P:0441 77F400 FFFFFC  3 2507 5990         move    #-4,n7
P:0443 000000         2 2509 5990         nop             ; (inserted)
P:0444 5FEF00         4 2513 5992         move    y:(r7+n7),b
P:0445 2B0000         2 2515 5993         move    #0,b2
P:0446 20000B         2 2517 5994         tst     b
P:0447 0AF0AA rrrrrr  6 2523 5997         jeq     L175
                             5998 
                             5999 ; 825  |    {
                             6000 ; 826  |
                             6001 ; 827  |        // Unstall all stall endpoints per ch9 specs
                             6002 ; 828  |        for(i=0 ; i < MAX_NUM_EP ; i++)
                             6003 
                             6008 
                             6009 ; 829  |        {
                             6010 ; 830  |            usb_device_get_status((USB_STATUS_ENDPOINT + i), &usStatus);
                             6011 
P:0449 44F413 000001  3 2526 6005         clr     a	                #>1,x0
                             6013 L170:
P:044B 77F400 FFFFFE  3 2529 6014         move    #-2,n7
P:044D 57F400 000010  3 2532 6013         move    #>16,b
P:044F 5C6F18         4 2536 6017         add     a,b	                a1,y:(r7+n7)
P:0450 77F401 FFFFFB  3 2539 6021         tfr     b,a	                #-5,n7
P:0452 000000         2 2541 6021         nop             ; (inserted)
P:0453 044F10         4 2545 6024         lua     (r7)+n7,r0
P:0454 045FA0         2 2547 6025         movec   m0,n7
P:0455 000000         2 2549 6025         nop             ; (inserted)
P:0456 5C6F00         4 2553 6027         move    a1,y:(r7+n7)
P:0457 0BF080 rrrrrr  6 2559 6028         jsr     Fusb_device_get_status
                             6032 
                             6033 ; 831  |            if(usStatus == (USHORT)TRUE)
                             6034 
P:0459 045FA0         2 2561 6029         movec   m0,n7
P:045A 46F400 000001  3 2564 6039         move    #>1,y0
TASKING DSP2410 assembler v1.5r1 Build 138 SN 00100122
                                                                                                                            Page  92

M:ADDR CODE           CYCLES LINE SOURCELINE
P:045C 5EEF00         4 2568 6031         move    y:(r7+n7),a
P:045D 77F400 FFFFFB  3 2571 6036         move    #-5,n7
P:045F 000000         2 2573 6036         nop             ; (inserted)
P:0460 5FEF00         4 2577 6038         move    y:(r7+n7),b
P:0461 20005D         2 2579 6040         cmp     y0,b
P:0462 0AF0A2 rrrrrr  6 2585 6041         jne     L171
                             6043 
                             6044 ; 832  |                usb_device_set_status((USB_STATUS_ENDPOINT + i), FALSE);
                             6045 
P:0464 2F0000         2 2587 6042         move    #0,b
P:0465 0BF080 rrrrrr  6 2593 6047         jsr     Fusb_device_set_status
                             6048 L171:
P:0467 77F400 FFFFFE  3 2596 6050         move    #-2,n7
P:0469 44F400 000001  3 2599 6053         move    #>1,x0
P:046B 5EEF00         4 2603 6052         move    y:(r7+n7),a
P:046C 45F440 000004  3 2606 6054         add     x0,a	                #>4,x1
P:046E 200065         2 2608 6058         cmp     x1,a
P:046F 0AF0A9 rrrrrr  6 2614 6059         jlt     L170
                             6060 
                             6061 ; 833  |        }                    
                             6062 ; 834  |        
                             6063 ; 835  |        // Informs the  Application
                             6064 ; 836  |        btStatus = USB_OK;              // By default request is accepted
                             6065 
                             6070 
                             6071 ; 837  |        usb_device_call_service(USB_SERVICE_CHANGE_IFACE, FALSE, 0, (void _X*)&btStatus, (
                                  USHORT)pSetup->wValue,0);
                             6072 
P:0471 3E0313         2 2616 6067         clr     a	                #3,n6
P:0472 60F400 rrrrrr  3 2619 6075         move    #FbtStatus,r0
P:0474 250000         2 2621 6084         move    #0,x1
P:0475 7E6F09         4 2625 6074         tfr     a,b	                n6,y:(r7+n7)
P:0476 77F400 FFFFFD  3 2628 6078         move    #-3,n7
P:0478 567000 rrrrrr  3 2631 6068         move    a,x:FbtStatus
P:047A 6EEF00         4 2635 6080         move    y:(r7+n7),r6
P:047B 12F400 000018  3 2638 6083         move    a,x0	                #>24,a
P:047D 4EEE00         4 2642 6082         move    y:(r6+n6),y0
P:047E 0BF080 rrrrrr  6 2648 6086         jsr     Fusb_device_call_service
                             6087 
                             6088 ; 838  |        
                             6089 ; 839  |        if(btStatus == USB_OK)
                             6090 
P:0480 56F000 rrrrrr  3 2651 6092         move    x:FbtStatus,a
P:0482 2A0000         2 2653 6093         move    #0,a2
P:0483 200003         2 2655 6094         tst     a
P:0484 0AF0A2 rrrrrr  6 2661 6095         jne     L173
                             6096 
                             6097 ; 840  |        {                
                             6098 ; 841  |            // Set the interface value
                             6099 ; 842  |            usb_device_set_status(USB_STATUS_CURRENT_IFACE, (USHORT)pSetup->wValue);
                             6100 
P:0486 77F400 FFFFFE  3 2664 6102         move    #-2,n7
P:0488 56F400 00000A  3 2667 6112         move    #>10,a
P:048A 7EEF00         4 2671 6104         move    y:(r7+n7),n6
P:048B 77F400 FFFFFD  3 2674 6105         move    #-3,n7
P:048D 000000         2 2676 6105         nop             ; (inserted)
P:048E 6EEF00         4 2680 6107         move    y:(r7+n7),r6
P:048F 000000         2 2682 6107         nop             ; (inserted)
TASKING DSP2410 assembler v1.5r1 Build 138 SN 00100122
                                                                                                                            Page  93

M:ADDR CODE           CYCLES LINE SOURCELINE
P:0490 5FEE00         4 2686 6109         move    y:(r6+n6),b
P:0491 0BF080 rrrrrr  6 2692 6113         jsr     Fusb_device_set_status
                             6115 
                             6116 ; 843  |
                             6117 ; 844  |            // Prepare status phase
                             6118 ; 845  |            usb_device_send_data(0, 0, 0, 0, FALSE,0);
                             6119 
P:0493 250013         2 2694 6123         clr     a	                #0,x1
P:0494 300069         2 2696 6124         tfr     x1,b	                #0,r0
P:0495 20A400         2 2698 6125         move    x1,x0
P:0496 20A600         2 2700 6126         move    x1,y0
P:0497 0BF080 rrrrrr  6 2706 6127         jsr     Fusb_device_send_data
                             6128 
                             6129 ; 846  |        }
                             6130 
P:0499 0AF080 rrrrrr  6 2712 6132         jmp     L175
                             6133 
                             6134 ; 847  |        else
                             6135 ; 848  |        {
                             6136 ; 849  |            usb_device_stall_endpoint(0, USB_IN);
                             6137 
P:049B 57F413 000001  3 2715 6139 L173:   clr     a	                #>1,b
P:049D 0BF080 rrrrrr  6 2721 6141         jsr     Fusb_dci_stall_endpoint
                             6142 
                             6143 ; 850  |        }
                             6144 ; 851  |                        
                             6145 ; 852  |
                             6146 ; 853  |    } /* Endif */
                             6147 ; 854  |
                             6148 ; 855  |    return;
                             6149 ; 856  |} /* Endbody */
                             6150 
                             6152 L175:
P:049F 77F400 FFFFFA  3 2724 6152         move    #-6,n7
P:04A1 000000         2 2726 6152         nop             ; (inserted)
P:04A2 05EF7C         4 2730 6154         movec   y:(r7+n7),ssh
P:04A3 204F00         2 2732 6156         move    (r7)+n7
P:04A4 00000C         4 2736 6158         rts
                             6160 
                             6161 ; 857  |
                             6162 ; 858  |
                             6163 ; 859  |
                             6164 ; 860  |
                             6165 ; 861  |////////////////////////////////////////////////////////////////////////////////
                             6166 ; 862  |//
                             6167 ; 863  |//>  Name:          ch9SynchFrame
                             6168 ; 864  |//
                             6169 ; 865  |//   Type:          Function
                             6170 ; 866  |//
                             6171 ; 867  |//   Description:   Chapter 9 synch frame command
                             6172 ; 868  |//
                             6173 ; 869  |//   Inputs:        
                             6174 ; 870  |//                  bSetup : TRUE if setup phase
                             6175 ; 871  |//                  pSetup : pointer to the setup packet (8 bytes)
                             6176 ; 872  |//   Outputs:       None
                             6177 ; 873  |//
                             6178 ; 874  |//   Notes:         
                             6179 ; 875  |//<
                             6180 ; 876  |////////////////////////////////////////////////////////////////////////////////
TASKING DSP2410 assembler v1.5r1 Build 138 SN 00100122
                                                                                                                            Page  94

M:ADDR CODE           CYCLES LINE SOURCELINE
                             6181 ; 877  |void _reentrant ch9SynchFrame(BYTE bSetup, USB_SetupData* pSetup) 
                             6182 ; 878  |{ /* Body */
                             6183 
                             6188 Fch9SynchFrame:
                             6196 
                             6197 ; 879  |   
                             6198 ; 880  |    // None of our endpoints support this type of request
                             6199 ; 881  |    if (bSetup) 
                             6200 
P:04A5 055F7C         2 2738 6189         movec   ssh,y:(r7)+
P:04A6 2A0000         2 2740 6202         move    #0,a2
P:04A7 200003         2 2742 6203         tst     a
P:04A8 0AF0AA rrrrrr  6 2748 6204         jeq     L176
                             6205 
                             6206 ; 882  |    {
                             6207 ; 883  |        usb_device_stall_endpoint(0, USB_IN);
                             6208 
P:04AA 57F413 000001  3 2751 6211         clr     a	                #>1,b
P:04AC 0BF080 rrrrrr  6 2757 6212         jsr     Fusb_dci_stall_endpoint
                             6215 
                             6216 ; 884  |        return;
                             6217 ; 885  |    }        
                             6218 ; 886  |
                             6219 ; 887  |    return;
                             6220 ; 888  |} /* Endbody */
                             6221 
                             6223 L176:
P:04AE 05FF7C         4 2761 6223         movec   y:-(r7),ssh
P:04AF 000000         2 2763 6223         nop             ; (inserted)
P:04B0 00000C         4 2767 6227         rts
                             6229 
                             6230 ; 889  |
                             6231 ; 890  |
                             6232 ; 891  |////////////////////////////////////////////////////////////////////////////////
                             6233 ; 892  |//
                             6234 ; 893  |//>  Name:          ch9ServiceEp0
                             6235 ; 894  |//
                             6236 ; 895  |//   Type:          Function
                             6237 ; 896  |//
                             6238 ; 897  |//   Description:   Handles completed transfers on endpoint 0
                             6239 ; 898  |//
                             6240 ; 899  |//   Inputs:        
                             6241 ; 900  |//                  Not used
                             6242 ; 901  |//   Outputs:       None
                             6243 ; 902  |//
                             6244 ; 903  |//   Notes:         
                             6245 ; 904  |//                  The input parameters are here only to respect the Service
                             6246 ; 905  |//                  function declaration in the service structure
                             6247 ; 906  |//                  
                             6248 ; 907  |//<
                             6249 ; 908  |////////////////////////////////////////////////////////////////////////////////
                             6250 ; 909  |
                             6251 ; 910  |void _reentrant ch9ServiceEp0(BOOL bSetup, BYTE btDirection, WORD _X *pbtBuffer, WORD wLen
                                  gth, WORD wPrivateData)
                             6252 ; 911  |{ /* Body */
                             6253 
                             6258 Fch9ServiceEp0:
                             6277 
                             6278 ; 912  |
                             6279 ; 913  |    USB_SetupData * pSetup =  &g_SetupData[0];
                             6280 
TASKING DSP2410 assembler v1.5r1 Build 138 SN 00100122
                                                                                                                            Page  95

M:ADDR CODE           CYCLES LINE SOURCELINE
                             6287 
                             6288 ; 914  |    
                             6289 ; 915  |    // Is this the setup phase
                             6290 ; 916  |    if (bSetup)
                             6291 
P:04B1 055F7C         2 2769 6259         movec   ssh,y:(r7)+
P:04B2 75F400 rrrrrr  3 2772 6282         move    #Fg_SetupData,n5
P:04B4 045FA0         2 2774 6283         movec   m0,n7
P:04B5 2A0000         2 2776 6296         move    #0,a2
P:04B6 205F00         2 2778 6262         move    (r7)+
P:04B7 205F00         2 2780 6263         move    (r7)+
P:04B8 7D6F00         4 2784 6285         move    n5,y:(r7+n7)
P:04B9 77F403 FFFFFE  3 2787 6297         tst     a	                #-2,n7
P:04BB 000000         2 2789 6297         nop             ; (inserted)
P:04BC 5C6F00         4 2793 6295         move    a1,y:(r7+n7)
P:04BD 0AF0AA rrrrrr  6 2799 6300         jeq     L204
                             6301 
                             6302 ; 917  |    {
                             6303 ; 918  |        usb_device_read_setup_data(0);
                             6304 
P:04BF 200013         2 2801 6306         clr     a   
P:04C0 0BF080 rrrrrr  6 2807 6307         jsr     Fusb_dci_get_setup_data
                             6312 
                             6313 ; 919  |        
                             6314 ; 920  |        // This is to accomodate USB1.1 Stack on the STMP3410. This stack has no
                             6315 ; 921  |        // means to know that the phase is a SETUP phase. Therefore, every 1st
                             6316 ; 922  |        // rx on endpoint 0 is considered to be a SETUP phase and after the 
                             6317 ; 923  |        // status phase a this function is called to finish the request.
                             6318 ; 924  |        // In our case we finich the request as soon as we copied the setup bytes
                             6319 ; 925  |        // from the dQH into the setup buffer.
                             6320 ; 926  |        usb_dci_finish_transaction(0);
                             6321 
P:04C2 200013         2 2809 6323         clr     a   
P:04C3 0BF080 rrrrrr  6 2815 6324         jsr     Fusb_dci_finish_transaction
                             6325 
                             6326 ; 927  |    }
                             6327 ; 928  |
                             6328 ; 929  |    // Process the setup request
                             6329 ; 930  |    switch (pSetup->RequestType.B.Type)
                             6330 
                             6332 L204:
P:04C5 045FA0         2 2817 6332         movec   m0,n7
P:04C6 000000         2 2819 6332         nop             ; (inserted)
P:04C7 68EF00         4 2823 6334         move    y:(r7+n7),r0
P:04C8 000000         2 2825 6334         nop             ; (inserted)
P:04C9 205800         2 2827 6336         move    (r0)+
P:04CA 4ED000         2 2829 6337         move    y:(r0)-,y0
P:04CB 0107E8         2 2831 6340         mpy     y0,#7,b
P:04CC 212600         2 2833 6341         move    b0,y0
P:04CD 0116E8         2 2835 6342         mpy     y0,#22,b
P:04CE 21AF00         2 2837 6343         move    b1,b
P:04CF 20000B         2 2839 6344         tst     b
P:04D0 0AF0A2 rrrrrr  6 2845 6345         jne     L218
                             6346 
                             6347 ; 931  |    {
                             6348 ; 932  |        // case standard request
                             6349 ; 933  |        case USB_REQUEST_TYPE_STANDARD:
                             6350 ; 934  |            switch (pSetup->btRequest) 
                             6351 
P:04D2 3E0200         2 2847 6353         move    #2,n6
P:04D3 61F400 rrrrrr  3 2850 6357         move    #L230,r1
TASKING DSP2410 assembler v1.5r1 Build 138 SN 00100122
                                                                                                                            Page  96

M:ADDR CODE           CYCLES LINE SOURCELINE
P:04D5 221600         2 2852 6354         move    r0,r6
P:04D6 56F400 00000C  3 2855 6359         move    #>12,a
P:04D8 5FEE00         4 2859 6356         move    y:(r6+n6),b
P:04D9 2B0000         2 2861 6358         move    #0,b2
P:04DA 21F90D         2 2863 6360         cmp     a,b     b,n1
P:04DB 0AF0A7 rrrrrr  6 2869 6361         jgt     L218
P:04DD 07E991         8 2877 6362         movem   p:(r1+n1),r1
P:04DE 000000         2 2879 6362         nop             ; (inserted)
P:04DF 0AE180         4 2883 6364         jmp     (r1)
                             6365 
P:04E0 rrrrrr                6366 L230:   dc      L206    ; case 0:
P:04E1 rrrrrr                6367         dc      L207    ; case 1:
P:04E2 rrrrrr                6368         dc      L218    ; default:
P:04E3 rrrrrr                6369         dc      L208    ; case 3:
P:04E4 rrrrrr                6370         dc      L218    ; default:
P:04E5 rrrrrr                6371         dc      L209    ; case 5:
P:04E6 rrrrrr                6372         dc      L210    ; case 6:
P:04E7 rrrrrr                6373         dc      L211    ; case 7:
P:04E8 rrrrrr                6374         dc      L212    ; case 8:
P:04E9 rrrrrr                6375         dc      L213    ; case 9:
P:04EA rrrrrr                6376         dc      L214    ; case 10:
P:04EB rrrrrr                6377         dc      L215    ; case 11:
P:04EC rrrrrr                6378         dc      L216    ; case 12:
                             6379 
                             6380 
                             6381 ; 935  |            {
                             6382 ; 936  |                case USB_REQUEST_STANDARD_GET_STATUS:
                             6383 ; 937  |                    ch9GetStatus(bSetup, pSetup);
                             6384 
P:04ED 77F400 FFFFFE  3 2886 6386 L206:   move    #-2,n7
P:04EF 000000         2 2888 6386         nop             ; (inserted)
P:04F0 5EEF00         4 2892 6388         move    y:(r7+n7),a
P:04F1 0BF080 rrrrrr  6 2898 6389         jsr     Fch9GetStatus
                             6394 
                             6395 ; 938  |                    break;
                             6396 
P:04F3 0AF080 rrrrrr  6 2904 6398         jmp     L229
                             6399 
                             6400 ; 939  |
                             6401 ; 940  |                case USB_REQUEST_STANDARD_CLEAR_FEATURE:
                             6402 ; 941  |                    ch9ClearFeature(bSetup, pSetup);
                             6403 
                             6405 L207:
P:04F5 77F400 FFFFFE  3 2907 6408         move    #-2,n7
P:04F7 000000         2 2909 6408         nop             ; (inserted)
P:04F8 5EEF00         4 2913 6410         move    y:(r7+n7),a
P:04F9 0BF080 rrrrrr  6 2919 6411         jsr     Fch9ClearFeature
                             6416 
                             6417 ; 942  |                    break;
                             6418 
P:04FB 0AF080 rrrrrr  6 2925 6420         jmp     L229
                             6421 
                             6422 ; 943  |
                             6423 ; 944  |                case USB_REQUEST_STANDARD_SET_FEATURE:
                             6424 ; 945  |                    ch9SetFeature(bSetup, pSetup);
                             6425 
                             6427 L208:
P:04FD 77F400 FFFFFE  3 2928 6430         move    #-2,n7
P:04FF 000000         2 2930 6430         nop             ; (inserted)
P:0500 5EEF00         4 2934 6432         move    y:(r7+n7),a
P:0501 0BF080 rrrrrr  6 2940 6433         jsr     Fch9SetFeature
                             6438 
TASKING DSP2410 assembler v1.5r1 Build 138 SN 00100122
                                                                                                                            Page  97

M:ADDR CODE           CYCLES LINE SOURCELINE
                             6439 ; 946  |                    break;
                             6440 
P:0503 0AF080 rrrrrr  6 2946 6442         jmp     L229
                             6443 
                             6444 ; 947  |
                             6445 ; 948  |                case USB_REQUEST_STANDARD_SET_ADDRESS:
                             6446 ; 949  |                    ch9SetAddress(bSetup, pSetup);
                             6447 
                             6449 L209:
P:0505 77F400 FFFFFE  3 2949 6452         move    #-2,n7
P:0507 000000         2 2951 6452         nop             ; (inserted)
P:0508 5EEF00         4 2955 6454         move    y:(r7+n7),a
P:0509 0BF080 rrrrrr  6 2961 6455         jsr     Fch9SetAddress
                             6460 
                             6461 ; 950  |                    break;
                             6462 
P:050B 0AF080 rrrrrr  6 2967 6464         jmp     L229
                             6465 
                             6466 ; 951  |
                             6467 ; 952  |                case USB_REQUEST_STANDARD_GET_DESCRIPTOR:
                             6468 ; 953  |                    ch9GetDescription(bSetup, pSetup);
                             6469 
                             6471 L210:
P:050D 77F400 FFFFFE  3 2970 6474         move    #-2,n7
P:050F 000000         2 2972 6474         nop             ; (inserted)
P:0510 5EEF00         4 2976 6476         move    y:(r7+n7),a
P:0511 0BF080 rrrrrr  6 2982 6477         jsr     Fch9GetDescription
                             6482 
                             6483 ; 954  |                    break;
                             6484 
P:0513 0AF080 rrrrrr  6 2988 6486         jmp     L229
                             6487 
                             6488 ; 955  |
                             6489 ; 956  |                case USB_REQUEST_STANDARD_SET_DESCRIPTOR:
                             6490 ; 957  |                    ch9SetDescription(bSetup, pSetup);
                             6491 
                             6493 L211:
P:0515 77F400 FFFFFE  3 2991 6496         move    #-2,n7
P:0517 000000         2 2993 6496         nop             ; (inserted)
P:0518 5EEF00         4 2997 6498         move    y:(r7+n7),a
P:0519 0BF080 rrrrrr  6 3003 6499         jsr     Fch9SetDescription
                             6504 
                             6505 ; 958  |                    break;
                             6506 
P:051B 0AF080 rrrrrr  6 3009 6508         jmp     L229
                             6509 
                             6510 ; 959  |
                             6511 ; 960  |                case USB_REQUEST_STANDARD_GET_CONFIGURATION:
                             6512 ; 961  |                    ch9GetConfig(bSetup, pSetup);
                             6513 
                             6515 L212:
P:051D 77F400 FFFFFE  3 3012 6518         move    #-2,n7
P:051F 000000         2 3014 6518         nop             ; (inserted)
P:0520 5EEF00         4 3018 6520         move    y:(r7+n7),a
P:0521 0BF080 rrrrrr  6 3024 6521         jsr     Fch9GetConfig
                             6526 
                             6527 ; 962  |                    break;
                             6528 
P:0523 0AF080 rrrrrr  6 3030 6530         jmp     L229
                             6531 
                             6532 ; 963  |
                             6533 ; 964  |                case USB_REQUEST_STANDARD_SET_CONFIGURATION:
TASKING DSP2410 assembler v1.5r1 Build 138 SN 00100122
                                                                                                                            Page  98

M:ADDR CODE           CYCLES LINE SOURCELINE
                             6534 ; 965  |                    ch9SetConfig(bSetup, pSetup);
                             6535 
                             6537 L213:
P:0525 77F400 FFFFFE  3 3033 6540         move    #-2,n7
P:0527 000000         2 3035 6540         nop             ; (inserted)
P:0528 5EEF00         4 3039 6542         move    y:(r7+n7),a
P:0529 0BF080 rrrrrr  6 3045 6543         jsr     Fch9SetConfig
                             6548 
                             6549 ; 966  |                    break;
                             6550 
P:052B 0AF080 rrrrrr  6 3051 6552         jmp     L229
                             6553 
                             6554 ; 967  |
                             6555 ; 968  |                case USB_REQUEST_STANDARD_GET_INTERFACE:
                             6556 ; 969  |                    ch9GetInterface(bSetup, pSetup);
                             6557 
                             6559 L214:
P:052D 77F400 FFFFFE  3 3054 6562         move    #-2,n7
P:052F 000000         2 3056 6562         nop             ; (inserted)
P:0530 5EEF00         4 3060 6564         move    y:(r7+n7),a
P:0531 0BF080 rrrrrr  6 3066 6565         jsr     Fch9GetInterface
                             6570 
                             6571 ; 970  |                    break;
                             6572 
P:0533 0AF080 rrrrrr  6 3072 6574         jmp     L229
                             6575 
                             6576 ; 971  |
                             6577 ; 972  |                case USB_REQUEST_STANDARD_SET_INTERFACE:
                             6578 ; 973  |                    ch9SetInterface(bSetup, pSetup);
                             6579 
                             6581 L215:
P:0535 77F400 FFFFFE  3 3075 6584         move    #-2,n7
P:0537 000000         2 3077 6584         nop             ; (inserted)
P:0538 5EEF00         4 3081 6586         move    y:(r7+n7),a
P:0539 0BF080 rrrrrr  6 3087 6587         jsr     Fch9SetInterface
                             6592 
                             6593 ; 974  |                    break;
                             6594 
P:053B 0AF080 rrrrrr  6 3093 6596         jmp     L229
                             6597 
                             6598 ; 975  |
                             6599 ; 976  |                case USB_REQUEST_STANDARD_SYNCH_FRAME:
                             6600 ; 977  |                    ch9SynchFrame(bSetup, pSetup);
                             6601 
                             6603 L216:
P:053D 77F400 FFFFFE  3 3096 6606         move    #-2,n7
P:053F 000000         2 3098 6606         nop             ; (inserted)
P:0540 5EEF00         4 3102 6608         move    y:(r7+n7),a
P:0541 0BF080 rrrrrr  6 3108 6609         jsr     Fch9SynchFrame
                             6614 
                             6615 ; 978  |                    break;
                             6616 
P:0543 0AF080 rrrrrr  6 3114 6618         jmp     L229
                             6619 
                             6620 ; 979  |
                             6621 ; 980  |                default:
                             6622 ; 981  |                    usb_device_stall_endpoint(0, USB_OUT);
                             6623 ; 982  |                    break;
                             6624 ; 983  |
                             6625 ; 984  |            } /* Endswitch */
                             6626 ; 985  |         
                             6627 ; 986  |        break;
TASKING DSP2410 assembler v1.5r1 Build 138 SN 00100122
                                                                                                                            Page  99

M:ADDR CODE           CYCLES LINE SOURCELINE
                             6628 ; 987  |
                             6629 ; 988  |        default:
                             6630 ; 989  |            usb_device_stall_endpoint(0, USB_OUT);
                             6631 
                             6633 L218:
P:0545 2F0013         2 3116 6634         clr     a	                #0,b
P:0546 0BF080 rrrrrr  6 3122 6635         jsr     Fusb_dci_stall_endpoint
                             6636 
                             6637 ; 990  |            break;
                             6638 ; 991  |         
                             6639 ; 992  |   } /* Endswitch */
                             6640 ; 993  |   
                             6641 ; 994  |   return;
                             6642 ; 995  |} /* Endbody */
                             6643 
                             6645 L229:
P:0548 205700         2 3124 6645         move    (r7)-
P:0549 205700         2 3126 6646         move    (r7)-
P:054A 05FF7C         4 3130 6648         movec   y:-(r7),ssh
P:054B 000000         2 3132 6648         nop             ; (inserted)
P:054C 00000C         4 3136 6652         rts
                             6654 
                             6655 ; 996  |
                             6656 ; 997  |
                             6657 ; 998  |
                             6658 ; 999  |
                             6659 ; 1000 |
                             6660 ; 1001 |
                             6661 
                             6687 
                             6690 
X:0000                       6691         org     x,".xbssusb20ch9",bss:
                             6692 FbtStatus:
X:0000 RESERVED              6693         ds      1
X:0000
                             6700 FusDataToSend:
X:0001 RESERVED              6701         ds      1
X:0001
                             6704 
Y:0001                       6705         org     y,".ybssusb20ch9",bss:
                             6706 FusTestModeIndex:
Y:0001 RESERVED              6707         ds      1
Y:0001
                             6708 
                             6709         extern  FGetDescriptor, y:Fg_SetupData, Fusb_dci_finish_transaction
                             6710         extern  Fusb_dci_get_setup_data, Fusb_dci_stall_endpoint
                             6711         extern  Fusb_dci_unstall_endpoint, Fusb_device_call_service
                             6712         extern  Fusb_device_data_phase_required, Fusb_device_get_status
                             6713         extern  Fusb_device_is_hold, Fusb_device_recv_data
                             6714         extern  Fusb_device_send_data, Fusb_device_set_status
                             6715 
                             6716         global  FbtStatus, Fch9ClearFeature, Fch9GetConfig
                             6717         global  Fch9GetDescription, Fch9GetInterface, Fch9GetStatus
                             6718         global  Fch9ServiceEp0, Fch9SetAddress, Fch9SetConfig
                             6719         global  Fch9SetDescription, Fch9SetFeature, Fch9SetInterface
                             6720         global  Fch9SynchFrame, Fg_bUsbConfigured, FusDataToSend
                             6721         global  FusTestModeIndex
                             6722 
                             6723         local   L17, L18, L19, L21, L23, L24, L26, L28, L48, L49, L50, L52
                             6724         local   L53, L54, L57, L58, L60, L62, L89, L90, L91, L92, L94, L100
                             6725         local   L103, L105, L106, L109, L110, L111, L112, L113, L115, L120
TASKING DSP2410 assembler v1.5r1 Build 138 SN 00100122
                                                                                                                            Page 100

M:ADDR CODE           CYCLES LINE SOURCELINE
                             6726         local   L121, L122, L125, L126, L127, L129, L130, L133, L134, L135
                             6727         local   L136, L137, L138, L139, L140, L151, L152, L153, L154, L155
                             6728         local   L157, L159, L160, L162, L170, L171, L173, L175, L176, L204
                             6729         local   L206, L207, L208, L209, L210, L211, L212, L213, L214, L215
                             6730         local   L216, L218, L229, L230
                             6731 
                             6732         calls   "ch9ClearFeature", "usb_dci_stall_endpoint"
                             6733         calls   "ch9ClearFeature", "usb_dci_unstall_endpoint"
                             6734         calls   "ch9ClearFeature", "usb_device_get_status"
                             6735         calls   "ch9ClearFeature", "usb_device_send_data"
                             6736         calls   "ch9ClearFeature", "usb_device_set_status"
                             6737         calls   "ch9GetConfig", "usb_device_get_status"
                             6738         calls   "ch9GetConfig", "usb_device_recv_data"
                             6739         calls   "ch9GetConfig", "usb_device_send_data"
                             6740         calls   "ch9GetDescription", "GetDescriptor"
                             6741         calls   "ch9GetDescription", "usb_dci_stall_endpoint"
                             6742         calls   "ch9GetDescription", "usb_device_data_phase_required"
                             6743         calls   "ch9GetDescription", "usb_device_get_status"
                             6744         calls   "ch9GetDescription", "usb_device_is_hold"
                             6745         calls   "ch9GetDescription", "usb_device_recv_data"
                             6746         calls   "ch9GetDescription", "usb_device_send_data"
                             6747         calls   "ch9GetInterface", "usb_dci_stall_endpoint"
                             6748         calls   "ch9GetInterface", "usb_device_get_status"
                             6749         calls   "ch9GetInterface", "usb_device_recv_data"
                             6750         calls   "ch9GetInterface", "usb_device_send_data"
                             6751         calls   "ch9GetStatus", "usb_dci_stall_endpoint"
                             6752         calls   "ch9GetStatus", "usb_device_get_status"
                             6753         calls   "ch9GetStatus", "usb_device_recv_data"
                             6754         calls   "ch9GetStatus", "usb_device_send_data"
                             6755         calls   "ch9ServiceEp0", "ch9ClearFeature", "ch9GetConfig"
                             6756         calls   "ch9ServiceEp0", "ch9GetDescription", "ch9GetInterface"
                             6757         calls   "ch9ServiceEp0", "ch9GetStatus", "ch9SetAddress"
                             6758         calls   "ch9ServiceEp0", "ch9SetConfig", "ch9SetDescription"
                             6759         calls   "ch9ServiceEp0", "ch9SetFeature", "ch9SetInterface"
                             6760         calls   "ch9ServiceEp0", "ch9SynchFrame"
                             6761         calls   "ch9ServiceEp0", "usb_dci_finish_transaction"
                             6762         calls   "ch9ServiceEp0", "usb_dci_get_setup_data"
                             6763         calls   "ch9ServiceEp0", "usb_dci_stall_endpoint"
                             6764         calls   "ch9SetAddress", "usb_device_send_data"
                             6765         calls   "ch9SetAddress", "usb_device_set_status"
                             6766         calls   "ch9SetConfig", "usb_dci_stall_endpoint"
                             6767         calls   "ch9SetConfig", "usb_device_call_service"
                             6768         calls   "ch9SetConfig", "usb_device_get_status"
                             6769         calls   "ch9SetConfig", "usb_device_send_data"
                             6770         calls   "ch9SetConfig", "usb_device_set_status"
                             6771         calls   "ch9SetDescription", "usb_dci_stall_endpoint"
                             6772         calls   "ch9SetFeature", "usb_dci_stall_endpoint"
                             6773         calls   "ch9SetFeature", "usb_device_call_service"
                             6774         calls   "ch9SetFeature", "usb_device_get_status"
                             6775         calls   "ch9SetFeature", "usb_device_send_data"
                             6776         calls   "ch9SetFeature", "usb_device_set_status"
                             6777         calls   "ch9SetInterface", "usb_dci_stall_endpoint"
                             6778         calls   "ch9SetInterface", "usb_device_call_service"
                             6779         calls   "ch9SetInterface", "usb_device_get_status"
                             6780         calls   "ch9SetInterface", "usb_device_send_data"
                             6781         calls   "ch9SetInterface", "usb_device_set_status"
                             6782         calls   "ch9SynchFrame", "usb_dci_stall_endpoint"
                             6783 
