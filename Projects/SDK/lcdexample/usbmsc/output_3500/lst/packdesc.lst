TASKING DSP2410 assembler v1.5r1 Build 138 SN 00100122
                                                                                                                            Page   1
C:\STMP3XXX_SDK_FIRMWARE_320_finalfix\Projects\SDK\lcdexample\usbmsc\Make\cc871d9b.src
M:ADDR CODE           CYCLES LINE SOURCELINE
                                1 ; TASKING DSP2410 C compiler v1.5r1 Build 208 SN 00100122
                                2 ; options: -OG -si -w68 -w66 -I..\output_3500\include
                                3 ;          -I..\..\..\..\..\Projects\sdk\lcdexample\usbmsc -I -I..\..
                                4 ;          -I..\..\..\..\..\inc -I..\..\..\..\..\System\Common
                                5 ;          -I..\..\..\..\..\System\Common\symbols -I
                                6 ;          -I..\..\..\..\..\Algorithms\DRM\janus\src\h
                                7 ;          -I..\..\..\..\..\devicedriver\media\ddildl
                                8 ;          -I..\..\..\..\..\devicedriver\media\ddildl\include
                                9 ;          -I..\..\..\..\..\devicedriver\media\MediaTypeMMC\DDI\include
                               10 ;          -I..\..\..\..\..\devicedriver\media\ddildl\include
                               11 ;          -I..\..\..\..\..\devicedriver\media\MediaTypeMMC\DDI\include
                               12 ;          -I..\..\..\..\..\devicedriver\media\MediaTypeMMC\DDI\Media
                               13 ;          -I..\..\..\..\..\devicedriver\media\MediaTypeMMC\HAL\include
                               14 ;          -I..\..\..\..\..\devicedriver\media\MediaTypeRAM\include
                               15 ;          -I..\..\..\..\..\devicedriver\media\MediaTypeRAM\DDI\DataDrive\include
                               16 ;          -I..\..\..\..\..\devicedriver\media\MediaTypeRAM\DDI\include
                               17 ;          -I..\..\..\..\..\devicedriver\media\MediaTypeRAM\HAL\include
                               18 ;          -I..\..\..\..\..\devicedriver\media\MediaTypeRAM\DDI\DataDrive
                               19 ;          -I..\..\..\..\..\devicedriver\media\MediaTypeRAM\include
                               20 ;          -I..\..\..\..\..\devicedriver\media\MediaTypeRAM\DDI\SystemDrive\include
                               21 ;          -I..\..\..\..\..\devicedriver\media\MediaTypeRAM\DDI\include
                               22 ;          -I..\..\..\..\..\devicedriver\media\MediaTypeRAM\HAL\include
                               23 ;          -I..\..\..\..\..\devicedriver\media\MediaTypeRAM\DDI\SystemDrive
                               24 ;          -I..\..\..\..\..\devicedriver\media\MediaTypeRAM\include
                               25 ;          -I..\..\..\..\..\devicedriver\media\MediaTypeRAM\DDI\Media\include
                               26 ;          -I..\..\..\..\..\devicedriver\media\MediaTypeRAM\DDI\include
                               27 ;          -I..\..\..\..\..\devicedriver\media\MediaTypeRAM\HAL\include
                               28 ;          -I..\..\..\..\..\devicedriver\media\MediaTypeRAM\DDI\Media
                               29 ;          -I..\..\..\..\..\devicedriver\media\MediaTypeRAM\include
                               30 ;          -I..\..\..\..\..\devicedriver\media\MediaTypeRAM\DDI\include
                               31 ;          -I..\..\..\..\..\devicedriver\media\MediaTypeRAM\HAL\include
                               32 ;          -I..\..\..\..\..\devicedriver\media\MediaTypeNAND\include
                               33 ;          -I..\..\..\..\..\devicedriver\media\MediaTypeNAND\DDI\DataDrive\include
                               34 ;          -I..\..\..\..\..\devicedriver\media\MediaTypeNAND\DDI\include
                               35 ;          -I..\..\..\..\..\devicedriver\media\MediaTypeNAND\HAL\include
                               36 ;          -I..\..\..\..\..\devicedriver\media\MediaTypeNAND\DDI\DataDrive
                               37 ;          -I..\..\..\..\..\devicedriver\media\ddildl\include -I
                               38 ;          -I..\..\..\..\..\FileSystem\Fat32\cmp\cmp_stdtype
                               39 ;          -I..\..\..\..\..\FileSystem\Fat32\cmp\cmp_debug
                               40 ;          -I..\..\..\..\..\FileSystem\Fat32\cmp\cmp_file_system
                               41 ;          -I..\..\..\..\..\DeviceDriver\Media\cmp\cmp_media_nand
                               42 ;          -I..\..\..\..\..\devicedriver\media\MediaTypeNAND\include
                               43 ;          -I..\..\..\..\..\devicedriver\media\MediaTypeNAND\DDI\Common\include
                               44 ;          -I..\..\..\..\..\devicedriver\media\MediaTypeNAND\DDI\include
                               45 ;          -I..\..\..\..\..\devicedriver\media\MediaTypeNAND\HAL\include
                               46 ;          -I..\..\..\..\..\devicedriver\media\MediaTypeNAND\DDI\Common
                               47 ;          -I..\..\..\..\..\devicedriver\media\MediaTypeNAND\include
                               48 ;          -I..\..\..\..\..\devicedriver\media\MediaTypeNAND\DDI\SystemDrive\include
                               49 ;          -I..\..\..\..\..\devicedriver\media\MediaTypeNAND\DDI\include
                               50 ;          -I..\..\..\..\..\devicedriver\media\MediaTypeNAND\HAL\include
                               51 ;          -I..\..\..\..\..\devicedriver\media\MediaTypeNAND\DDI\SystemDrive
                               52 ;          -I..\..\..\..\..\devicedriver\media\MediaTypeNAND\include
                               53 ;          -I..\..\..\..\..\devicedriver\media\MediaTypeNAND\DDI\Media\include
                               54 ;          -I..\..\..\..\..\devicedriver\media\MediaTypeNAND\DDI\include
                               55 ;          -I..\..\..\..\..\devicedriver\media\MediaTypeNAND\HAL\include
                               56 ;          -I..\..\..\..\..\devicedriver\media\MediaTypeNAND\DDI\Media
                               57 ;          -I..\..\..\..\..\devicedriver\media\include
                               58 ;          -I..\..\..\..\..\devicedriver\media\ddildl
                               59 ;          -I..\..\..\..\..\devicedriver\media\ddildl\include
                               60 ;          -I..\..\..\..\..\devicedriver\media\MediaTypeNAND\DDI\Common\include
                               61 ;          -I..\..\..\..\..\devicedriver\media\MediaTypeNAND\DDI\include
                               62 ;          -I..\..\..\..\..\DeviceDriver\Media\MediaTypeNAND\HAL
TASKING DSP2410 assembler v1.5r1 Build 138 SN 00100122
                                                                                                                            Page   2

M:ADDR CODE           CYCLES LINE SOURCELINE
                               63 ;          -I..\..\..\..\..\DeviceDriver\Media\MediaTypeNAND\HAL\include
                               64 ;          -I..\..\..\..\..\DeviceDriver\Media\include
                               65 ;          -I..\..\..\..\..\DeviceDriver\Media\PortHIL\GPFlash\include
                               66 ;          -I..\..\..\..\..\DeviceDriver\Media\PortHIL\GPFlash
                               67 ;          -I..\..\..\..\..\system\common\resourcemanager -I..\..\..\..\..\inc
                               68 ;          -I..\..\..\..\..\DeviceDriver\Media\usb\Ch9
                               69 ;          -I..\..\..\..\..\DeviceDriver\Media\scsi
                               70 ;          -I..\..\..\..\..\DeviceDriver\Media\usbmsc
                               71 ;          -I..\..\..\..\..\DeviceDriver\Media\mtp
                               72 ;          -I..\..\..\..\..\System\Common\updater
                               73 ;          -I..\..\..\..\..\libsource\sysserialnumber -DALL -DD3500 -DMMC
                               74 ;          -DLIION -DTUNER_STFM1000 -DSTFM1000_LCD=TRUE -DDCDC_POWER_TRANSFER
                               75 ;          -DBACKLIGHT -DWMAAPI_NO_DRM -DREVB_ENGR_BD -DSED15XX_LCD -DFAT16
                               76 ;          -DDEVICE_3500 -DENGR_BD -DUSBMSC_BUILD -DBATTERY_TYPE_LI_ION
                               77 ;          -DBATTERY_CHARGE -DUSE_PLAYLIST3_HOST -DASCII_ONLY -DRETAIL
                               78 ;          -DDEVICE_3500 -DMMC -Dk_opt_performance_enhancement
                               79 ;          -I..\..\..\..\..\devicedriver\display
                               80 ;          -I..\..\..\..\..\System\MsgModules\Hardware\Display -g -O2 -R -Cs
                               81 ;          -MmyL
                               82 
                               90 
                               91 ;     packdesc.c:
                               92 ; 1    |////////////////////////////////////////////////////////////////////////////////
                               93 ; 2    |// Copyright(C) SigmaTel, Inc. 2003
                               94 ; 3    |//
                               95 ; 4    |// File : PackDesc.c
                               96 ; 5    |// Description : 
                               97 ; 6    |////////////////////////////////////////////////////////////////////////////////
                               98 ; 7    |#include "types.h"
                               99 
                              101 
                              102 ; 1    |////////////////////////////////////////////////////////////////////////////////
                              103 ; 2    |// Copyright(C) SigmaTel, Inc. 2000-2004
                              104 ; 3    |//
                              105 ; 4    |// Filename: types.h
                              106 ; 5    |// Description: Standard data types
                              107 ; 6    |////////////////////////////////////////////////////////////////////////////////
                              108 ; 7    |
                              109 ; 8    |#ifndef _TYPES_H
                              110 ; 9    |#define _TYPES_H
                              111 ; 10   |
                              112 ; 11   |// TODO:  move this outta here!
                              113 ; 12   |#if !defined(NOERROR)
                              114 ; 13   |#define NOERROR 0
                              115 ; 14   |#define SUCCESS 0
                              116 ; 15   |#endif 
                              117 ; 16   |#if !defined(SUCCESS)
                              118 ; 17   |#define SUCCESS  0
                              119 ; 18   |#endif
                              120 ; 19   |#if !defined(ERROR)
                              121 ; 20   |#define ERROR   -1
                              122 ; 21   |#endif
                              123 ; 22   |#if !defined(FALSE)
                              124 ; 23   |#define FALSE 0
                              125 ; 24   |#endif
                              126 ; 25   |#if !defined(TRUE)
                              127 ; 26   |#define TRUE  1
                              128 ; 27   |#endif
                              129 ; 28   |
                              130 ; 29   |#if !defined(NULL)
                              131 ; 30   |#define NULL 0
                              132 ; 31   |#endif
TASKING DSP2410 assembler v1.5r1 Build 138 SN 00100122
                                                                                                                            Page   3

M:ADDR CODE           CYCLES LINE SOURCELINE
                              133 ; 32   |
                              134 ; 33   |#define MAX_INT     0x7FFFFF
                              135 ; 34   |#define MAX_LONG    0x7FFFFFffffff
                              136 ; 35   |        // max positive unsigned long value: -1 == 0xFFFFFFffffff
                              137 ; 36   |#define MAX_ULONG   (-1) 
                              138 ; 37   |
                              139 ; 38   |#define WORD_SIZE   24              // word size in bits
                              140 ; 39   |#define BYTES_PER_WORD 3            // 8 bit bytes
                              141 ; 40   |
                              142 ; 41   |
                              143 ; 42   |#define BYTE    unsigned char       // btVarName
                              144 ; 43   |#define CHAR    signed char         // cVarName
                              145 ; 44   |#define USHORT  unsigned short      // usVarName
                              146 ; 45   |#define SHORT   unsigned short      // sVarName
                              147 ; 46   |#define WORD    unsigned int        // wVarName
                              148 ; 47   |#define INT     signed int          // iVarName
                              149 ; 48   |#define DWORD   unsigned long       // dwVarName
                              150 ; 49   |#define LONG    signed long         // lVarName
                              151 ; 50   |#define BOOL    unsigned int        // bVarName
                              152 ; 51   |#define FRACT   _fract              // frVarName
                              153 ; 52   |#define LFRACT  long _fract         // lfrVarName
                              154 ; 53   |#define CIRC    _circ               // cp<type prefix>VarName (see below)
                              155 ; 54   |#define FLOAT   float               // fVarName
                              156 ; 55   |#define DBL     double              // dVarName
                              157 ; 56   |#define ENUM    enum                // eVarName
                              158 ; 57   |#define CMX     _complex            // cmxVarName
                              159 ; 58   |typedef WORD UCS3;                   // 
                              160 ; 59   |
                              161 ; 60   |#define UINT16  unsigned short
                              162 ; 61   |#define UINT8   unsigned char   
                              163 ; 62   |#define UINT32  unsigned long
                              164 ; 63   |#define UINT64  unsigned long   // need to figure out how to do 64 bit values.  Or port ex
                                  isiting code to only use 48 bit
                              165 ; 64   |#define INT64   unsigned long   // need to figure out how to do 64 bit values.  Or port ex
                                  isiting code to only use 48 bit
                              166 ; 65   |#define WCHAR   UINT16
                              167 ; 66   |
                              168 ; 67   |//UINT128 is 16 bytes or 6 words
                              169 ; 68   |typedef struct UINT128_3500 {   
                              170 ; 69   |    int val[6];     
                              171 ; 70   |} UINT128_3500;
                              172 ; 71   |
                              173 ; 72   |#define UINT128   UINT128_3500
                              174 ; 73   |
                              175 ; 74   |// Little endian word packed byte strings:   
                              176 ; 75   |//      _packed BYTE bTextVarName[]="a string";  bText is a packed byte string prefix
                              177 ; 76   |// Convert to big endian words by reordering bytes from high to low using swizzle.
                              178 ; 77   |// Little endian word packed byte strings:   
                              179 ; 78   |//      _packed BYTE bTextVarName[]="a string";  bText is a packed byte string prefix
                              180 ; 79   |// Convert to big endian words by reordering bytes from high to low using swizzle.
                              181 ; 80   |
                              182 ; 81   |// Declare Memory Spaces To Use When Coding
                              183 ; 82   |// A. Sector Buffers
                              184 ; 83   |#define SECTOR_BUFFER_MEM_X _X
                              185 ; 84   |#define SECTOR_BUFFER_MEM_Y _Y
                              186 ; 85   |#define SECTOR_BUFFER_MEM SECTOR_BUFFER_MEM_X
                              187 ; 86   |typedef WORD SECTOR_BUFFER_MEM SECTOR_BUFFER;
                              188 
                              190 
                              191 ; 87   |typedef SECTOR_BUFFER * P_SECTOR_BUFFER;
                              192 ; 88   |// B. Media DDI Memory
                              193 ; 89   |#define MEDIA_DDI_MEM _Y
TASKING DSP2410 assembler v1.5r1 Build 138 SN 00100122
                                                                                                                            Page   4

M:ADDR CODE           CYCLES LINE SOURCELINE
                              194 ; 90   |
                              195 ; 91   |
                              196 ; 92   |
                              197 ; 93   |// Pointers to linear structures are labeled as: p<type prefix>VarName
                              198 ; 94   |// Examples of circular pointers:
                              199 ; 95   |//    INT CIRC cpiVarName
                              200 ; 96   |//    DWORD CIRC cpdwVarName
                              201 ; 97   |
                              202 ; 98   |#define RETCODE INT                 // rcVarName
                              203 ; 99   |
                              204 ; 100  |// generic bitfield structure
                              205 ; 101  |struct Bitfield {
                              206 ; 102  |    unsigned int B0  :1;
                              207 ; 103  |    unsigned int B1  :1;
                              208 ; 104  |    unsigned int B2  :1;
                              209 ; 105  |    unsigned int B3  :1;
                              210 ; 106  |    unsigned int B4  :1;
                              211 ; 107  |    unsigned int B5  :1;
                              212 ; 108  |    unsigned int B6  :1;
                              213 ; 109  |    unsigned int B7  :1;
                              214 ; 110  |    unsigned int B8  :1;
                              215 ; 111  |    unsigned int B9  :1;
                              216 ; 112  |    unsigned int B10 :1;
                              217 ; 113  |    unsigned int B11 :1;
                              218 ; 114  |    unsigned int B12 :1;
                              219 ; 115  |    unsigned int B13 :1;
                              220 ; 116  |    unsigned int B14 :1;
                              221 ; 117  |    unsigned int B15 :1;
                              222 ; 118  |    unsigned int B16 :1;
                              223 ; 119  |    unsigned int B17 :1;
                              224 ; 120  |    unsigned int B18 :1;
                              225 ; 121  |    unsigned int B19 :1;
                              226 ; 122  |    unsigned int B20 :1;
                              227 ; 123  |    unsigned int B21 :1;
                              228 ; 124  |    unsigned int B22 :1;
                              229 ; 125  |    unsigned int B23 :1;
                              230 ; 126  |};
                              231 ; 127  |
                              232 ; 128  |union BitInt {
                              233 ; 129  |        struct Bitfield B;
                              234 ; 130  |        int        I;
                              235 ; 131  |};
                              236 ; 132  |
                              237 ; 133  |#define MAX_MSG_LENGTH 10
                              238 ; 134  |struct CMessage
                              239 ; 135  |{
                              240 ; 136  |        unsigned int m_uLength;
                              241 ; 137  |        unsigned int m_uMsg[MAX_MSG_LENGTH];
                              242 ; 138  |};
                              243 ; 139  |
                              244 ; 140  |typedef struct {
                              245 ; 141  |    WORD m_wLength;
                              246 ; 142  |    WORD m_wMessage;
                              247 ; 143  |    WORD m_wParams[MAX_MSG_LENGTH];
                              248 ; 144  |} Message;
                              249 ; 145  |
                              250 ; 146  |struct MessageQueueDescriptor
                              251 ; 147  |{
                              252 ; 148  |        int *m_pBase;
                              253 ; 149  |        int m_iModulo;
                              254 ; 150  |        int m_iSize;
                              255 ; 151  |        int *m_pHead;
TASKING DSP2410 assembler v1.5r1 Build 138 SN 00100122
                                                                                                                            Page   5

M:ADDR CODE           CYCLES LINE SOURCELINE
                              256 ; 152  |        int *m_pTail;
                              257 ; 153  |};
                              258 ; 154  |
                              259 ; 155  |struct ModuleEntry
                              260 ; 156  |{
                              261 ; 157  |    int m_iSignaledEventMask;
                              262 ; 158  |    int m_iWaitEventMask;
                              263 ; 159  |    int m_iResourceOfCode;
                              264 ; 160  |    struct MessageQueueDescriptor *m_pMessageQueue;
                              265 ; 161  |    int _asmfunc (*m_pProcessEntryPoint)(union WaitMask Signals,struct MessageQueueDescrip
                                  tor *);
                              266 ; 162  |    int _asmfunc (*m_pInitFunction)(struct MessageQueueDescriptor *);
                              267 ; 163  |    int m_uTimeOutHigh;
                              268 ; 164  |    int m_uTimeOutLow;
                              269 ; 165  |    int _asmfunc (*m_pBackgroundFunction)(struct MessageQueueDescriptor *);
                              270 ; 166  |};
                              271 ; 167  |
                              272 ; 168  |union WaitMask{
                              273 ; 169  |    struct B{
                              274 ; 170  |        unsigned int m_bNone     :1;
                              275 ; 171  |        unsigned int m_bMessage  :1;
                              276 ; 172  |        unsigned int m_bTimer    :1;
                              277 ; 173  |        unsigned int m_bButton   :1;
                              278 ; 174  |    } B;
                              279 ; 175  |    int I;
                              280 ; 176  |} ;
                              281 ; 177  |
                              282 ; 178  |
                              283 ; 179  |struct Button {
                              284 ; 180  |        WORD wButtonEvent;
                              285 ; 181  |        WORD wUnused[MAX_MSG_LENGTH];   
                              286 ; 182  |};
                              287 ; 183  |
                              288 ; 184  |struct Message {
                              289 ; 185  |        WORD wMsgLength;
                              290 ; 186  |        WORD wMsgCommand;
                              291 ; 187  |        WORD wMsgParms[MAX_MSG_LENGTH-1];
                              292 ; 188  |};
                              293 ; 189  |
                              294 ; 190  |union EventTypes {
                              295 ; 191  |        struct CMessage msg;
                              296 ; 192  |        struct Button Button ;
                              297 ; 193  |        struct Message Message;
                              298 ; 194  |};
                              299 ; 195  |
                              300 ; 196  |// next 2 used to get updater build to return correct protocol ver in scsi response.
                              301 ; 197  |#define BUILD_TYPE_UPDATER  0x100
                              302 ; 198  |#define BUILD_TYPE_HOSTLINK 0x101
                              303 ; 199  |#define BUILD_TYPE_PLAYER   0x102
                              304 ; 200  |
                              305 ; 201  |// Resets part if RETAIL build. DEBUG build executes debug instruction to halt.
                              306 ; 202  |#define SystemHalt() __asm(" include 'sysmacro.asm' \n error") 
                              307 ; 203  |#define assert(x)    if(!(x)) __asm(" include 'sysmacro.asm' \n error")
                              308 ; 204  |
                              309 ; 205  |#if DEBUG
                              310 ; 206  |// For DEBUG builds, DebugBuildAssert(condition) halts if condition evaluates to FALSE. 
                              311 ; 207  |#define DebugBuildAssert(x)    if(!(x)) __asm(" debug ")
                              312 ; 208  |#else 
                              313 ; 209  |// For RETAIL builds, DebugBuildAssert(condition) does nothing & execution continues rathe
                                  r than halt or reset. 
                              314 ; 210  |#define DebugBuildAssert(x)    
                              315 ; 211  |#endif
TASKING DSP2410 assembler v1.5r1 Build 138 SN 00100122
                                                                                                                            Page   6

M:ADDR CODE           CYCLES LINE SOURCELINE
                              316 ; 212  |
                              317 ; 213  |// Do this in your C files to make a reminder that's displayed during the build.
                              318 ; 214  |//  #pragma asm
                              319 ; 215  |//  WARN 'Note to builder: reminder to do this after verifying that'
                              320 ; 216  |//  #pragma endasm
                              321 ; 217  |
                              322 ; 218  |
                              323 ; 219  |#ifdef COLOR_262K
                              324 ; 220  |#define RGB(r,g,b)    ((0x0000FC & (r)) << 10) | ((0x0000FC & (g)) << 4) | ((0x0000FC & (b
                                  )) >> 2)    //262k
                              325 ; 221  |#elif defined(COLOR_65K)
                              326 ; 222  |#define RGB(r,g,b)    ((0x0000F8 & (r)) << 8) | ((0x0000FC & (g)) << 3) | ((0x0000F8 & (b)
                                  ) >> 3)  //65k
                              327 ; 223  |#else
                              328 ; 224  |#define RGB(r,g,b)       ((0x0000F0 & (r)) << 4) | (0x0000F0 & (g)) | ((0x0000F0 & (b)) >>
                                   4)
                              329 ; 225  |#endif
                              330 ; 226  |    
                              331 ; 227  |#endif // #ifndef _TYPES_H
                              332 
                              334 
                              335 ; 8    |#include "usb_api.h"
                              336 
                              338 
                              339 ; 1    |////////////////////////////////////////////////////////////////////////////////
                              340 ; 2    |// Copyright(C) SigmaTel, Inc. 2002 - 2003
                              341 ; 3    |//
                              342 ; 4    |// File : USB_API.H
                              343 ; 5    |// Description : USB_API.H defines and structures definition for USB device
                              344 ; 6    |//               driver API.
                              345 ; 7    |//               This 
                              346 ; 8    |////////////////////////////////////////////////////////////////////////////////
                              347 ; 9    |
                              348 ; 10   |#ifndef __usb_api_h__
                              349 ; 11   |#define __usb_api_h__ 1
                              350 ; 12   |
                              351 ; 13   |#include "types.h"
                              352 
                              354 
                              355 ; 1    |////////////////////////////////////////////////////////////////////////////////
                              356 ; 2    |// Copyright(C) SigmaTel, Inc. 2000-2004
                              357 ; 3    |//
                              358 ; 4    |// Filename: types.h
                              359 ; 5    |// Description: Standard data types
                              360 ; 6    |////////////////////////////////////////////////////////////////////////////////
                              361 ; 7    |
                              362 ; 8    |#ifndef _TYPES_H
                              363 ; 9    |#define _TYPES_H
                              364 ; 10   |
                              365 ; 11   |// TODO:  move this outta here!
                              366 ; 12   |#if !defined(NOERROR)
                              367 ; 13   |#define NOERROR 0
                              368 ; 14   |#define SUCCESS 0
                              369 ; 15   |#endif 
                              370 ; 16   |#if !defined(SUCCESS)
                              371 ; 17   |#define SUCCESS  0
                              372 ; 18   |#endif
                              373 ; 19   |#if !defined(ERROR)
                              374 ; 20   |#define ERROR   -1
                              375 ; 21   |#endif
                              376 ; 22   |#if !defined(FALSE)
                              377 ; 23   |#define FALSE 0
TASKING DSP2410 assembler v1.5r1 Build 138 SN 00100122
                                                                                                                            Page   7

M:ADDR CODE           CYCLES LINE SOURCELINE
                              378 ; 24   |#endif
                              379 ; 25   |#if !defined(TRUE)
                              380 ; 26   |#define TRUE  1
                              381 ; 27   |#endif
                              382 ; 28   |
                              383 ; 29   |#if !defined(NULL)
                              384 ; 30   |#define NULL 0
                              385 ; 31   |#endif
                              386 ; 32   |
                              387 ; 33   |#define MAX_INT     0x7FFFFF
                              388 ; 34   |#define MAX_LONG    0x7FFFFFffffff
                              389 ; 35   |        // max positive unsigned long value: -1 == 0xFFFFFFffffff
                              390 ; 36   |#define MAX_ULONG   (-1) 
                              391 ; 37   |
                              392 ; 38   |#define WORD_SIZE   24              // word size in bits
                              393 ; 39   |#define BYTES_PER_WORD 3            // 8 bit bytes
                              394 ; 40   |
                              395 ; 41   |
                              396 ; 42   |#define BYTE    unsigned char       // btVarName
                              397 ; 43   |#define CHAR    signed char         // cVarName
                              398 ; 44   |#define USHORT  unsigned short      // usVarName
                              399 ; 45   |#define SHORT   unsigned short      // sVarName
                              400 ; 46   |#define WORD    unsigned int        // wVarName
                              401 ; 47   |#define INT     signed int          // iVarName
                              402 ; 48   |#define DWORD   unsigned long       // dwVarName
                              403 ; 49   |#define LONG    signed long         // lVarName
                              404 ; 50   |#define BOOL    unsigned int        // bVarName
                              405 ; 51   |#define FRACT   _fract              // frVarName
                              406 ; 52   |#define LFRACT  long _fract         // lfrVarName
                              407 ; 53   |#define CIRC    _circ               // cp<type prefix>VarName (see below)
                              408 ; 54   |#define FLOAT   float               // fVarName
                              409 ; 55   |#define DBL     double              // dVarName
                              410 ; 56   |#define ENUM    enum                // eVarName
                              411 ; 57   |#define CMX     _complex            // cmxVarName
                              412 ; 58   |typedef WORD UCS3;                   // 
                              413 ; 59   |
                              414 ; 60   |#define UINT16  unsigned short
                              415 ; 61   |#define UINT8   unsigned char   
                              416 ; 62   |#define UINT32  unsigned long
                              417 ; 63   |#define UINT64  unsigned long   // need to figure out how to do 64 bit values.  Or port ex
                                  isiting code to only use 48 bit
                              418 ; 64   |#define INT64   unsigned long   // need to figure out how to do 64 bit values.  Or port ex
                                  isiting code to only use 48 bit
                              419 ; 65   |#define WCHAR   UINT16
                              420 ; 66   |
                              421 ; 67   |//UINT128 is 16 bytes or 6 words
                              422 ; 68   |typedef struct UINT128_3500 {   
                              423 ; 69   |    int val[6];     
                              424 ; 70   |} UINT128_3500;
                              425 ; 71   |
                              426 ; 72   |#define UINT128   UINT128_3500
                              427 ; 73   |
                              428 ; 74   |// Little endian word packed byte strings:   
                              429 ; 75   |//      _packed BYTE bTextVarName[]="a string";  bText is a packed byte string prefix
                              430 ; 76   |// Convert to big endian words by reordering bytes from high to low using swizzle.
                              431 ; 77   |// Little endian word packed byte strings:   
                              432 ; 78   |//      _packed BYTE bTextVarName[]="a string";  bText is a packed byte string prefix
                              433 ; 79   |// Convert to big endian words by reordering bytes from high to low using swizzle.
                              434 ; 80   |
                              435 ; 81   |// Declare Memory Spaces To Use When Coding
                              436 ; 82   |// A. Sector Buffers
                              437 ; 83   |#define SECTOR_BUFFER_MEM_X _X
TASKING DSP2410 assembler v1.5r1 Build 138 SN 00100122
                                                                                                                            Page   8

M:ADDR CODE           CYCLES LINE SOURCELINE
                              438 ; 84   |#define SECTOR_BUFFER_MEM_Y _Y
                              439 ; 85   |#define SECTOR_BUFFER_MEM SECTOR_BUFFER_MEM_X
                              440 ; 86   |typedef WORD SECTOR_BUFFER_MEM SECTOR_BUFFER;
                              441 ; 87   |typedef SECTOR_BUFFER * P_SECTOR_BUFFER;
                              442 ; 88   |// B. Media DDI Memory
                              443 ; 89   |#define MEDIA_DDI_MEM _Y
                              444 ; 90   |
                              445 ; 91   |
                              446 ; 92   |
                              447 ; 93   |// Pointers to linear structures are labeled as: p<type prefix>VarName
                              448 ; 94   |// Examples of circular pointers:
                              449 ; 95   |//    INT CIRC cpiVarName
                              450 ; 96   |//    DWORD CIRC cpdwVarName
                              451 ; 97   |
                              452 ; 98   |#define RETCODE INT                 // rcVarName
                              453 ; 99   |
                              454 ; 100  |// generic bitfield structure
                              455 ; 101  |struct Bitfield {
                              456 ; 102  |    unsigned int B0  :1;
                              457 ; 103  |    unsigned int B1  :1;
                              458 ; 104  |    unsigned int B2  :1;
                              459 ; 105  |    unsigned int B3  :1;
                              460 ; 106  |    unsigned int B4  :1;
                              461 ; 107  |    unsigned int B5  :1;
                              462 ; 108  |    unsigned int B6  :1;
                              463 ; 109  |    unsigned int B7  :1;
                              464 ; 110  |    unsigned int B8  :1;
                              465 ; 111  |    unsigned int B9  :1;
                              466 ; 112  |    unsigned int B10 :1;
                              467 ; 113  |    unsigned int B11 :1;
                              468 ; 114  |    unsigned int B12 :1;
                              469 ; 115  |    unsigned int B13 :1;
                              470 ; 116  |    unsigned int B14 :1;
                              471 ; 117  |    unsigned int B15 :1;
                              472 ; 118  |    unsigned int B16 :1;
                              473 ; 119  |    unsigned int B17 :1;
                              474 ; 120  |    unsigned int B18 :1;
                              475 ; 121  |    unsigned int B19 :1;
                              476 ; 122  |    unsigned int B20 :1;
                              477 ; 123  |    unsigned int B21 :1;
                              478 ; 124  |    unsigned int B22 :1;
                              479 ; 125  |    unsigned int B23 :1;
                              480 ; 126  |};
                              481 ; 127  |
                              482 ; 128  |union BitInt {
                              483 ; 129  |        struct Bitfield B;
                              484 ; 130  |        int        I;
                              485 ; 131  |};
                              486 ; 132  |
                              487 ; 133  |#define MAX_MSG_LENGTH 10
                              488 ; 134  |struct CMessage
                              489 ; 135  |{
                              490 ; 136  |        unsigned int m_uLength;
                              491 ; 137  |        unsigned int m_uMsg[MAX_MSG_LENGTH];
                              492 ; 138  |};
                              493 ; 139  |
                              494 ; 140  |typedef struct {
                              495 ; 141  |    WORD m_wLength;
                              496 ; 142  |    WORD m_wMessage;
                              497 ; 143  |    WORD m_wParams[MAX_MSG_LENGTH];
                              498 ; 144  |} Message;
                              499 ; 145  |
TASKING DSP2410 assembler v1.5r1 Build 138 SN 00100122
                                                                                                                            Page   9

M:ADDR CODE           CYCLES LINE SOURCELINE
                              500 ; 146  |struct MessageQueueDescriptor
                              501 ; 147  |{
                              502 ; 148  |        int *m_pBase;
                              503 ; 149  |        int m_iModulo;
                              504 ; 150  |        int m_iSize;
                              505 ; 151  |        int *m_pHead;
                              506 ; 152  |        int *m_pTail;
                              507 ; 153  |};
                              508 ; 154  |
                              509 ; 155  |struct ModuleEntry
                              510 ; 156  |{
                              511 ; 157  |    int m_iSignaledEventMask;
                              512 ; 158  |    int m_iWaitEventMask;
                              513 ; 159  |    int m_iResourceOfCode;
                              514 ; 160  |    struct MessageQueueDescriptor *m_pMessageQueue;
                              515 ; 161  |    int _asmfunc (*m_pProcessEntryPoint)(union WaitMask Signals,struct MessageQueueDescrip
                                  tor *);
                              516 ; 162  |    int _asmfunc (*m_pInitFunction)(struct MessageQueueDescriptor *);
                              517 ; 163  |    int m_uTimeOutHigh;
                              518 ; 164  |    int m_uTimeOutLow;
                              519 ; 165  |    int _asmfunc (*m_pBackgroundFunction)(struct MessageQueueDescriptor *);
                              520 ; 166  |};
                              521 ; 167  |
                              522 ; 168  |union WaitMask{
                              523 ; 169  |    struct B{
                              524 ; 170  |        unsigned int m_bNone     :1;
                              525 ; 171  |        unsigned int m_bMessage  :1;
                              526 ; 172  |        unsigned int m_bTimer    :1;
                              527 ; 173  |        unsigned int m_bButton   :1;
                              528 ; 174  |    } B;
                              529 ; 175  |    int I;
                              530 ; 176  |} ;
                              531 ; 177  |
                              532 ; 178  |
                              533 ; 179  |struct Button {
                              534 ; 180  |        WORD wButtonEvent;
                              535 ; 181  |        WORD wUnused[MAX_MSG_LENGTH];   
                              536 ; 182  |};
                              537 ; 183  |
                              538 ; 184  |struct Message {
                              539 ; 185  |        WORD wMsgLength;
                              540 ; 186  |        WORD wMsgCommand;
                              541 ; 187  |        WORD wMsgParms[MAX_MSG_LENGTH-1];
                              542 ; 188  |};
                              543 ; 189  |
                              544 ; 190  |union EventTypes {
                              545 ; 191  |        struct CMessage msg;
                              546 ; 192  |        struct Button Button ;
                              547 ; 193  |        struct Message Message;
                              548 ; 194  |};
                              549 ; 195  |
                              550 ; 196  |// next 2 used to get updater build to return correct protocol ver in scsi response.
                              551 ; 197  |#define BUILD_TYPE_UPDATER  0x100
                              552 ; 198  |#define BUILD_TYPE_HOSTLINK 0x101
                              553 ; 199  |#define BUILD_TYPE_PLAYER   0x102
                              554 ; 200  |
                              555 ; 201  |// Resets part if RETAIL build. DEBUG build executes debug instruction to halt.
                              556 ; 202  |#define SystemHalt() __asm(" include 'sysmacro.asm' \n error") 
                              557 ; 203  |#define assert(x)    if(!(x)) __asm(" include 'sysmacro.asm' \n error")
                              558 ; 204  |
                              559 ; 205  |#if DEBUG
                              560 ; 206  |// For DEBUG builds, DebugBuildAssert(condition) halts if condition evaluates to FALSE. 
TASKING DSP2410 assembler v1.5r1 Build 138 SN 00100122
                                                                                                                            Page  10

M:ADDR CODE           CYCLES LINE SOURCELINE
                              561 ; 207  |#define DebugBuildAssert(x)    if(!(x)) __asm(" debug ")
                              562 ; 208  |#else 
                              563 ; 209  |// For RETAIL builds, DebugBuildAssert(condition) does nothing & execution continues rathe
                                  r than halt or reset. 
                              564 ; 210  |#define DebugBuildAssert(x)    
                              565 ; 211  |#endif
                              566 ; 212  |
                              567 ; 213  |// Do this in your C files to make a reminder that's displayed during the build.
                              568 ; 214  |//  #pragma asm
                              569 ; 215  |//  WARN 'Note to builder: reminder to do this after verifying that'
                              570 ; 216  |//  #pragma endasm
                              571 ; 217  |
                              572 ; 218  |
                              573 ; 219  |#ifdef COLOR_262K
                              574 ; 220  |#define RGB(r,g,b)    ((0x0000FC & (r)) << 10) | ((0x0000FC & (g)) << 4) | ((0x0000FC & (b
                                  )) >> 2)    //262k
                              575 ; 221  |#elif defined(COLOR_65K)
                              576 ; 222  |#define RGB(r,g,b)    ((0x0000F8 & (r)) << 8) | ((0x0000FC & (g)) << 3) | ((0x0000F8 & (b)
                                  ) >> 3)  //65k
                              577 ; 223  |#else
                              578 ; 224  |#define RGB(r,g,b)       ((0x0000F0 & (r)) << 4) | (0x0000F0 & (g)) | ((0x0000F0 & (b)) >>
                                   4)
                              579 ; 225  |#endif
                              580 ; 226  |    
                              581 ; 227  |#endif // #ifndef _TYPES_H
                              582 
                              584 
                              585 ; 14   |#include "project.h"
                              586 
                              588 
                              589 ; 1    |/////////////////////////////////////////////////////////////////////////////////
                              590 ; 2    |//  Copyright(C) SigmaTel, Inc. 2000-2004
                              591 ; 3    |//  Filename: project.inc
                              592 ; 4    |//  Description: 
                              593 ; 5    |/////////////////////////////////////////////////////////////////////////////////
                              594 ; 6    |
                              595 ; 7    |#if (!defined(_PROJECT_INC))
                              596 ; 8    |#define _PROJECT_INC 1
                              597 ; 9    |
                              598 ; 10   |#if defined(STMP_BUILD_PLAYER)
                              599 ; 11   |#include "hwequ.h"
                              600 ; 12   |#else 
                              601 ; 13   |//include "regscodec.inc"
                              602 ; 14   |#endif
                              603 ; 15   |
                              604 ; 16   |//////////////////////////////////////////////////////////////////////////////////
                              605 ; 17   |// Uncomment next define to allow player boot if you have stfm1000 macro enabled (defaults
                                   ON) & 
                              606 ; 18   |// your board crystal is not able to output nominal voltage range. Used in player main.asm
                                  . STMP00012148
                              607 ; 19   |// Defining this will result in lower battery life (price of using a lower quality crystal
                                  ). 
                              608 ; 20   |// Those that want to save battery life and have good crystals that meet our HW team's spe
                                  cs can 
                              609 ; 21   |// comment out this line to reduce crystal bias current and so battery current in player m
                                  ode.  
                              610 ; 22   |#define SUPPORT_MARGINAL_XTALS 1
                              611 ; 23   |
                              612 ; 24   |/////////////////////////////////////////////////////////////////////////////////
                              613 ; 25   |// BOOT SPEED CONFIG & ASSOCIATED BATTERY VOLTAGE CHECK ENABLE
                              614 ; 26   |/////////////////////////////////////////////////////////////////////////////////
TASKING DSP2410 assembler v1.5r1 Build 138 SN 00100122
                                                                                                                            Page  11

M:ADDR CODE           CYCLES LINE SOURCELINE
                              615 ; 27   |// Users can enable one of ATTEMPT_FAST_BOOT or FASTEST boot or neither project define bel
                                  ow by defining
                              616 ; 28   |// values as 0 or 1, else it defaults to the boot speed used in previous SDKs.
                              617 ; 29   |#define ATTEMPT_FAST_BOOT 1
                              618 ; 30   |#define ATTEMPT_FASTEST_BOOT 0   
                              619 ; 31   |// Changing this define to 0 removes Vbat threshholding & unconditionally gives fast boot 
                                  config above- 
                              620 ; 32   |// disabling this check is suggested for profiling if you want to try to tweak down thresh
                                  holds by maybe 50mV.
                              621 ; 33   |// Also the tests should clear the fast boot config defines to link & boot at normal speed
                                  .
                              622 ; 34   |#define SPEED_BOOT_BATTERY_CHECK 1
                              623 ; 35   |
                              624 ; 36   |/////////////////////////////////////////////////////////////////////////////////
                              625 ; 37   |// MEDIA DEFINITIONS
                              626 ; 38   |/////////////////////////////////////////////////////////////////////////////////
                              627 ; 39   |
                              628 ; 40   |/////////////////////////////////////////////////////////////////////////////////
                              629 ; 41   |// MNAND - Number of chips forming the internal physical device (i.e. # of NANDs)
                              630 ; 42   |#if defined(NAND1)
                              631 ; 43   |#define SM_INTERNAL_CHIPS 1
                              632 ; 44   |#else 
                              633 ; 45   |#if defined(NAND2)
                              634 ; 46   |#define SM_INTERNAL_CHIPS 2
                              635 ; 47   |#else 
                              636 ; 48   |#if defined(NAND3)
                              637 ; 49   |#define SM_INTERNAL_CHIPS 3
                              638 ; 50   |#else 
                              639 ; 51   |#if defined(NAND4)
                              640 ; 52   |#define SM_INTERNAL_CHIPS 4
                              641 ; 53   |#else 
                              642 ; 54   |#define SM_INTERNAL_CHIPS 1
                              643 ; 55   |#endif
                              644 ; 56   |#endif
                              645 ; 57   |#endif
                              646 ; 58   |#endif
                              647 ; 59   |
                              648 ; 60   |/////////////////////////////////////////////////////////////////////////////////
                              649 ; 61   |// If SMARTMEDIA_DETECT_ACTIVE_HIGH is defined:
                              650 ; 62   |//   SmartMedia will be detected as inserted if the GPIO pin reads 1 and removed if it rea
                                  ds 0.  
                              651 ; 63   |// If SMARTMEDIA_DETECT_ACTIVE_HIGH is not defined ** comment out next line **
                              652 ; 64   |//   SmartMedia will be detected as inserted if the GPIO pin reads 0 and removed if it rea
                                  ds 1.
                              653 ; 65   |//*** comment out if active high ****
                              654 ; 66   |//SMARTMEDIA_DETECT_ACTIVE_HIGH  equ     1
                              655 ; 67   |
                              656 ; 68   |#if defined(SMEDIA)
                              657 ; 69   |#define NUM_REMOVABLE_MEDIA 1
                              658 ; 70   |#define NUM_SM_EXTERNAL 1
                              659 ; 71   |#define MMC_MAX_PHYSICAL_DEVICES 0
                              660 ; 72   |#define SM_MAX_LOGICAL_DEVICES 2
                              661 ; 73   |#else 
                              662 ; 74   |#if defined(MMC)
                              663 ; 75   |#define NUM_REMOVABLE_MEDIA 1
                              664 ; 76   |#define NUM_SM_EXTERNAL 0
                              665 ; 77   |#define MMC_MAX_PHYSICAL_DEVICES 1
                              666 ; 78   |#define SM_MAX_LOGICAL_DEVICES 1
                              667 ; 79   |#else 
                              668 ; 80   |#define NUM_REMOVABLE_MEDIA 0
                              669 ; 81   |#define NUM_SM_EXTERNAL 0
                              670 ; 82   |#define MMC_MAX_PHYSICAL_DEVICES 0
TASKING DSP2410 assembler v1.5r1 Build 138 SN 00100122
                                                                                                                            Page  12

M:ADDR CODE           CYCLES LINE SOURCELINE
                              671 ; 83   |#define SM_MAX_LOGICAL_DEVICES 1
                              672 ; 84   |#endif
                              673 ; 85   |#endif
                              674 ; 86   |
                              675 ; 87   |/////////////////////////////////////////////////////////////////////////////////
                              676 ; 88   |// Mass Storage Class definitions
                              677 ; 89   |/////////////////////////////////////////////////////////////////////////////////
                              678 ; 90   |// Set to 0 if Composite Device build is desired.    
                              679 ; 91   |#define MULTI_LUN_BUILD 1   
                              680 ; 92   |
                              681 ; 93   |////////////////////////////////////////////////////////////////////////////////
                              682 ; 94   |//  SCSI
                              683 ; 95   |#if (MULTI_LUN_BUILD==0)
                              684 ; 96   |  #if (NUM_REMOVABLE_MEDIA == 1)
                              685 ; 97   |    #define SCSI_NUM_TARGETS                        2
                              686 ; 98   |    #define SCSI_DEVICE_NUM_LUNS_DEV_0              1
                              687 ; 99   |    #define SCSI_DEVICE_NUM_LUNS_DEV_1              1
                              688 ; 100  |  #else
                              689 ; 101  |    #define SCSI_NUM_TARGETS                        1
                              690 ; 102  |    #define SCSI_DEVICE_NUM_LUNS_DEV_0              1
                              691 ; 103  |  #endif
                              692 ; 104  |#else
                              693 ; 105  |    #define SCSI_NUM_TARGETS                        1
                              694 ; 106  |  #if (NUM_REMOVABLE_MEDIA == 1)
                              695 ; 107  |    #define SCSI_DEVICE_NUM_LUNS_DEV_0              2
                              696 ; 108  |  #else
                              697 ; 109  |    #define SCSI_DEVICE_NUM_LUNS_DEV_0              1  
                              698 ; 110  |  #endif
                              699 ; 111  |#endif
                              700 ; 112  |
                              701 ; 113  |
                              702 ; 114  |#define USBMSC_NUM_DEVICES                      SCSI_NUM_TARGETS
                              703 ; 115  |
                              704 ; 116  |
                              705 ; 117  |////////////////////////////////////////////////////////////////////////////////
                              706 ; 118  |// Define number of logical medias and drives for three builds (MTP, USBMSC, and Player)
                              707 ; 119  |////////////////////////////////////////////////////////////////////////////////
                              708 ; 120  |#ifdef MMC
                              709 ; 121  |#ifdef MTP_BUILD
                              710 ; 122  |// --------------------
                              711 ; 123  |// MTP and MMC
                              712 ; 124  |// --------------------
                              713 ; 125  |#define NUM_LOGICAL_MEDIA       2
                              714 ; 126  |#define NUM_LOGICAL_DRIVES      8
                              715 ; 127  |#else  // ifndef MTP_BUILD
                              716 ; 128  |#ifdef STMP_BUILD_PLAYER
                              717 ; 129  |// --------------------
                              718 ; 130  |// Player and MMC
                              719 ; 131  |// --------------------
                              720 ; 132  |#else
                              721 ; 133  |// --------------------
                              722 ; 134  |// USBMSC and MMC
                              723 ; 135  |// --------------------
                              724 ; 136  |#define NUM_LOGICAL_MEDIA       3
                              725 ; 137  |#define NUM_LOGICAL_DRIVES      8
                              726 ; 138  |#endif // ifdef STMP_BUILD_PLAYER
                              727 ; 139  |#endif // ifdef MTP_BUILD
                              728 ; 140  |#else  // ifndef MMC
                              729 ; 141  |#ifdef MTP_BUILD
                              730 ; 142  |// --------------------
                              731 ; 143  |// MTP and NAND only
                              732 ; 144  |// --------------------
TASKING DSP2410 assembler v1.5r1 Build 138 SN 00100122
                                                                                                                            Page  13

M:ADDR CODE           CYCLES LINE SOURCELINE
                              733 ; 145  |#define NUM_LOGICAL_MEDIA       1
                              734 ; 146  |#define NUM_LOGICAL_DRIVES      7
                              735 ; 147  |#else  // ifndef MTP_BUILD
                              736 ; 148  |#ifdef STMP_BUILD_PLAYER
                              737 ; 149  |// --------------------
                              738 ; 150  |// Player and NAND only
                              739 ; 151  |// --------------------
                              740 ; 152  |#else
                              741 ; 153  |// --------------------
                              742 ; 154  |// USBMSC and NAND only
                              743 ; 155  |// --------------------
                              744 ; 156  |#define NUM_LOGICAL_MEDIA       2
                              745 ; 157  |#define NUM_LOGICAL_DRIVES      7
                              746 ; 158  |#endif // ifdef STMP_BUILD_PLAYER
                              747 ; 159  |#endif // ifdef MTP_BUILD
                              748 ; 160  |#endif // ifdef MMC 
                              749 ; 161  |
                              750 ; 162  |// If we are in an MTP build then we don't use as many transfers buffers.
                              751 ; 163  |#if (defined(MTP_BUILD))
                              752 ; 164  |#define MAX_USB_TRANSFERS_QUEUED 16
                              753 ; 165  |
                              754 ; 166  |////!
                              755 ; 167  |////! This varible holds the watchdog count for the store flush.
                              756 ; 168  |////!
                              757 ; 169  |///
                              758 ; 170  |#include <types.h>
                              759 ; 171  |extern volatile INT g_StoreWatchDogCount;
                              760 ; 172  |extern const INT g_StoreWatchDogTimeout;
                              761 ; 173  |#endif
                              762 ; 174  |
                              763 ; 175  |////////////////////////////////////////////////////////////////////////////////
                              764 ; 176  |// These are needed here for Mass Storage Class
                              765 ; 177  |// Needs to be cleaned up
                              766 ; 178  |////////////////////////////////////////////////////////////////////////////////
                              767 ; 179  |#if (!defined(STMP_BUILD_PLAYER))
                              768 ; 180  |#define SCRATCH_USER_Y_SIZE 512
                              769 ; 181  |#define SCRATCH_USER_X_SIZE 512
                              770 ; 182  |
                              771 ; 183  |#define BROWNOUT_LEVEL1_DETECTED                0x000001
                              772 ; 184  |
                              773 ; 185  |#endif
                              774 ; 186  |
                              775 ; 187  |
                              776 ; 188  |/////////////////////////////////////////////////////////////////////////////////
                              777 ; 189  |// SmartMedia/NAND defs
                              778 ; 190  |#define SM_MAX_PHYSICAL_DEVICES SM_INTERNAL_CHIPS+NUM_SM_EXTERNAL
                              779 ; 191  |#define SM_REMOVABLE_DEVICE_NUM SM_INTERNAL_CHIPS
                              780 ; 192  |
                              781 ; 193  |/////////////////////////////////////////////////////////////////////////////////
                              782 ; 194  |// Sysloadresources defs
                              783 ; 195  |#define SM_MAX_RESOURCE_DEVICES SM_INTERNAL_CHIPS+NUM_SM_EXTERNAL
                              784 ; 196  |
                              785 ; 197  |/////////////////////////////////////////////////////////////////////////////////
                              786 ; 198  |// MMC defs
                              787 ; 199  |#define MMC_MAX_PARTITIONS 1
                              788 ; 200  |#define MMC_MAX_LOGICAL_DEVICES MMC_MAX_PHYSICAL_DEVICES*MMC_MAX_PARTITIONS
                              789 ; 201  |
                              790 ; 202  |/////////////////////////////////////////////////////////////////////////////////
                              791 ; 203  |// SPI defs
                              792 ; 204  |#define SPI_MAX_DEVICES MMC_MAX_PHYSICAL_DEVICES
                              793 ; 205  |
                              794 ; 206  |/////////////////////////////////////////////////////////////////////////////////
TASKING DSP2410 assembler v1.5r1 Build 138 SN 00100122
                                                                                                                            Page  14

M:ADDR CODE           CYCLES LINE SOURCELINE
                              795 ; 207  |// Global media defs
                              796 ; 208  |#define MAX_PHYSICAL_DEVICES SM_MAX_PHYSICAL_DEVICES+MMC_MAX_PHYSICAL_DEVICES
                              797 ; 209  |#define MAX_LOGICAL_DEVICES SM_MAX_LOGICAL_DEVICES+MMC_MAX_LOGICAL_DEVICES
                              798 ; 210  |
                              799 ; 211  |/////////////////////////////////////////////////////////////////////////////////
                              800 ; 212  |// DO NOT CHANGE THESE!!!
                              801 ; 213  |#define SM_MAX_PARTITIONS 4
                              802 ; 214  |#define MAX_HANDLES 2
                              803 ; 215  |/////////////////////////////////////////////////////////////////////////////////
                              804 ; 216  |
                              805 ; 217  |
                              806 ; 218  |/////////////////////////////////////////////////////////////////////////////////
                              807 ; 219  |// Battery LRADC Values 
                              808 ; 220  |/////////////////////////////////////////////////////////////////////////////////
                              809 ; 221  |// brownout trip point in mV (moved by RS)
                              810 ; 222  |// BATT_SAFETY_MARGIN:  percentage value used by:
                              811 ; 223  |//   * SysSaveSettings to determine if enough power is left to attempt a settings save. 
                              812 ; 224  |//   * Recorder to conditionally prevent the start or continuation of 
                              813 ; 225  |//     audio recording to media.
                              814 ; 226  |#define BATT_SAFETY_MARGIN 10
                              815 ; 227  |
                              816 ; 228  |//; player resource drive refresh allowed only when battery usable % is above this value. 
                                  
                              817 ; 229  |//; 50% of usable range [0.9V to 1.5V] is around 1.2V This is the safe target alkaline vol
                                  tage to do a refresh.
                              818 ; 230  |//; LIION will also require 50% which will work but that could be changed in the future. 
                              819 ; 231  |//RESOURCE_REFRESH_MIN_BATT_PCT equ 50
                              820 ; 232  |
                              821 ; 233  |// stmp00005071 adds these for mp3 encode stability at low battery per battery type & mmc 
                                  presence.
                              822 ; 234  |
                              823 ; 235  |//// Vbat threshholds empirically tuned by profiling max bat current for 3 HW cases: 
                              824 ; 236  |//// 1 GigaByte MMC, NAND flash only, & LiIon Buck mode. See voicemenu pre-encode Vbat che
                                  ck.
                              825 ; 237  |#if (!defined(CLCD))
                              826 ; 238  |#define MP3_ENC_MMC_MIN_V_BAT_MV 1100
                              827 ; 239  |#define MP3_ENC_NANDONLY_MIN_V_BAT_MV 1000
                              828 ; 240  |#else 
                              829 ; 241  |#define MP3_ENC_MMC_MIN_V_BAT_MV 1250
                              830 ; 242  |#define MP3_ENC_NANDONLY_MIN_V_BAT_MV 1150
                              831 ; 243  |#endif
                              832 ; 244  |#define MP3_ENC_BUCKMODE_MIN_V_BAT_MV 3300
                              833 ; 245  |
                              834 ; 246  |// These Vbat use-range-percentages are derived to correspond with target battery 
                              835 ; 247  |// voltages of 1.10V for MMC, 1.0V for nand only (alkaline or nimh), and 3.3V for any LiIo
                                  n.
                              836 ; 248  |// See mp3 encoder overlay.
                              837 ; 249  |#define MP3_ENC_MMC_MIN_V_BAT_RANGE_PCT 33
                              838 ; 250  |#define MP3_ENC_NANDONLY_MIN_V_BAT_RANGE_PCT 17
                              839 ; 251  |#define MP3_ENC_BUCKMODE_MIN_V_BAT_RANGE_PCT 25
                              840 ; 252  |
                              841 ; 253  |/////////////////////////////////////////////////////////////////////////////////
                              842 ; 254  |// Voice recording filenames
                              843 ; 255  |// number of digits in filename Vxxx.wav
                              844 ; 256  |/////////////////////////////////////////////////////////////////////////////////
                              845 ; 257  |#define DIGITS_IN_VOICE_FILENAME 3   
                              846 ; 258  |
                              847 ; 259  |/////////////////////////////////////////////////////////////////////////////////
                              848 ; 260  |// Mic Bias: Set this enable to 1 to internally generate mic bias voltage. 
                              849 ; 261  |// Also below, must configure internal resistor value and pin to use for DC bias. 
                              850 ; 262  |// Can set to 0 to disable internally generated mic bias voltage at pin lradc1/2.
                              851 ; 263  |#if defined(DEVICE_3500)
TASKING DSP2410 assembler v1.5r1 Build 138 SN 00100122
                                                                                                                            Page  15

M:ADDR CODE           CYCLES LINE SOURCELINE
                              852 ; 264  |#define ENABLE_INTERNALLY_GENERATED_MICBIAS 1 
                              853 ; 265  |// MIC BIAS circuit source selection: use Low Resolution ADC pin 2 or 1 to bias mic. 
                              854 ; 266  |// Per your layout: select LRADC 2 or 1 below 
                              855 ; 267  |//   (pin LRADC 2 for 35xx cpu card revB, LRADC 1 for 35xx cpu card revC, ref schematics, 
                                  & demo player)
                              856 ; 268  |#define LRADC_NUM_FOR_MIC_BIAS 1 
                              857 ; 269  |// Sets internal mic bias R to value 2, 4, or 8 (in kOhms).
                              858 ; 270  |#define MICBIAS_CONFIGURED_RESISTOR_KOHMS 8
                              859 ; 271  |
                              860 ; 272  |// Allows mic bias to settle before sampling. This delay currently unused. For rec btn whe
                                  n bias not yet ready.
                              861 ; 273  |#define REC_BTN_INTERNAL_MIC_BIAS_SETTLING_DELAY_MS 400 
                              862 ; 274  |// Option always keeps bias enabled after mainmenu init. This allows for start pop prevent
                                  ion if you use rec button from outside voice menu.
                              863 ; 275  |// This selection costs 1 mWatt but gains the desired low record button to sampling latenc
                                  y in the record-from-music-menu use-case.
                              864 ; 276  |#define KEEP_MIC_BIAS_ENABLED 0
                              865 ; 277  |
                              866 ; 278  |#else 
                              867 ; 279  |// STMP3410
                              868 ; 280  |#define ENABLE_INTERNALLY_GENERATED_MICBIAS 0
                              869 ; 281  |#define LRADC_NUM_FOR_MIC_BIAS 1 
                              870 ; 282  |#define MICBIAS_CONFIGURED_RESISTOR_KOHMS 2
                              871 ; 283  |#endif
                              872 ; 284  |
                              873 ; 285  |/////////////////////////////////////////////////////////////////////////////////
                              874 ; 286  |// Number of available soft timers
                              875 ; 287  |/////////////////////////////////////////////////////////////////////////////////
                              876 ; 288  |#if defined(SYNC_LYRICS)
                              877 ; 289  |#define SOFT_TIMERS 10
                              878 ; 290  |#else 
                              879 ; 291  |#if defined(JPEG_DECODER)
                              880 ; 292  |#define SOFT_TIMERS 10
                              881 ; 293  |#else 
                              882 ; 294  |#define SOFT_TIMERS 9
                              883 ; 295  |#endif
                              884 ; 296  |#endif
                              885 ; 297  |
                              886 ; 298  |/////////////////////////////////////////////////////////////////////////////////
                              887 ; 299  |//  sizes
                              888 ; 300  |/////////////////////////////////////////////////////////////////////////////////
                              889 ; 301  |#if defined(MMC)
                              890 ; 302  |#if defined(USE_PLAYLIST5)
                              891 ; 303  |#define MENU_STACK_SIZE 1500
                              892 ; 304  |#else 
                              893 ; 305  |#define MENU_STACK_SIZE 1250
                              894 ; 306  |#endif //if @def('USE_PLAYLIST5')
                              895 ; 307  |#else 
                              896 ; 308  |#if defined(USE_PLAYLIST5)
                              897 ; 309  |#define MENU_STACK_SIZE 1500
                              898 ; 310  |#else 
                              899 ; 311  |#define MENU_STACK_SIZE 1250
                              900 ; 312  |#endif //if @def('USE_PLAYLIST5')
                              901 ; 313  |#endif //if @def('MMC')
                              902 ; 314  |
                              903 ; 315  |// NOTE: SDK2.6 USED 550 FOR NEXT LINE, BUT SDK3.0BETA USED 750. Should it be ifdef MTP 75
                                  0 else 550 for other builds? TOVERIFY. MYALLOC
                              904 ; 316  |// 
                              905 ; 317  |#define STACK_L1_SIZE 750
                              906 ; 318  |#define STACK_L2_SIZE 100
                              907 ; 319  |#define STACK_L3_SIZE 160
                              908 ; 320  |
TASKING DSP2410 assembler v1.5r1 Build 138 SN 00100122
                                                                                                                            Page  16

M:ADDR CODE           CYCLES LINE SOURCELINE
                              909 ; 321  |// If we are in MTP mode the overlay task stack can shrink.
                              910 ; 322  |// TODO shrink this stack for MTP, I will leave it at 500 until we verify that it 
                              911 ; 323  |// is ok with switching code.
                              912 ; 324  |#if defined(MTP_BUILD)
                              913 ; 325  |#define OVERLAY_MANAGER_STACK_SIZE 300
                              914 ; 326  |#endif
                              915 ; 327  |
                              916 ; 328  |/////////////////////////////////////////////////////////////////////////////////
                              917 ; 329  |// maximum number of nested funclets 
                              918 ; 330  |/////////////////////////////////////////////////////////////////////////////////
                              919 ; 331  |#define MAX_NESTED_FUNCLET 6 
                              920 ; 332  |
                              921 ; 333  |/////////////////////////////////////////////////////////////////////////////////
                              922 ; 334  |//    LCD DEFINITIONS
                              923 ; 335  |/////////////////////////////////////////////////////////////////////////////////
                              924 ; 336  |
                              925 ; 337  |#define SPACE_CHAR 0x000020          
                              926 ; 338  |#define ZERO_CHAR 0x000030
                              927 ; 339  |#define COLON_CHAR 0x00003A
                              928 ; 340  |#define PERIOD_CHAR 0x00002E
                              929 ; 341  |
                              930 ; 342  |#if (defined(S6B33B0A_LCD))
                              931 ; 343  |#define LCD_X_SIZE 128
                              932 ; 344  |#define LCD_Y_SIZE 159
                              933 ; 345  |#endif
                              934 ; 346  |
                              935 ; 347  |#if (defined(SED15XX_LCD))
                              936 ; 348  |#define LCD_X_SIZE 128
                              937 ; 349  |#define LCD_Y_SIZE 64
                              938 ; 350  |#endif
                              939 ; 351  |
                              940 ; 352  |
                              941 ; 353  |//////////////////////////////////////////////////////////////////////////////////
                              942 ; 354  |//   Details on Customizing Contrast
                              943 ; 355  |/////////////////////////////////////////////////////////////////////////////////
                              944 ; 356  |//   Max supported LCD range is 0 - 3F; however due to hardware/voltage differences
                              945 ; 357  |//   the range of visibility is usually smaller than this.  It is important to 
                              946 ; 358  |//   calibrate the visible range, because the contrast setting is saved.
                              947 ; 359  |//   If the user shuts off the player while lcd is not visible, the player is useless
                              948 ; 360  |//   unless the ezact sequence is remembered.
                              949 ; 361  |//   To find out what range your player supports: 
                              950 ; 362  |//   change these equs to full range or comment out (full range is default)
                              951 ; 363  |//;;;;;;
                              952 ; 364  |// uncomment the line below to build code that will provide raw contrast value
                              953 ; 365  |// recommended calibration using player -- uncomment 
                              954 ; 366  |//;;;;;;
                              955 ; 367  |//CONTRAST_CALIBRATION    equ  1
                              956 ; 368  |////////////////////////////
                              957 ; 369  |#if (defined(DEMO_HW))
                              958 ; 370  |// this is the setting for ET301 demos; Next 2 line have not been updated for new Shingyi 
                                  LCD (June6'05)
                              959 ; 371  |#define LCD_MAX_CONTRAST 0x32 
                              960 ; 372  |#define LCD_MIN_CONTRAST 0x1E
                              961 ; 373  |#else 
                              962 ; 374  |
                              963 ; 375  |#if (defined(S6B33B0A_LCD))
                              964 ; 376  |#define LCD_MAX_CONTRAST 210
                              965 ; 377  |#define LCD_MIN_CONTRAST 160    
                              966 ; 378  |#endif
                              967 ; 379  |
                              968 ; 380  |#if (defined(SED15XX_LCD))
                              969 ; 381  |// Next 3 line comment was for OLD shingyi LCD: (default LCD before sdk2.6)
TASKING DSP2410 assembler v1.5r1 Build 138 SN 00100122
                                                                                                                            Page  17

M:ADDR CODE           CYCLES LINE SOURCELINE
                              970 ; 382  |// Engineering board regs support range [17-37].
                              971 ; 383  |//   Engineering board DC/DC support range [24-46]. 
                              972 ; 384  |//   One default contrast range [24-42] works for both.
                              973 ; 385  |// The 3 sets of contrast ranges below are updated for SDK2.6 to support either 
                              974 ; 386  |// new or old ShingYih LCDs. "File" refers to \resource\shingyih\system_lcd_init_seq.src
                              975 ; 387  |// 3/10/05 - Use one of the 2 next contrast ranges depending on which
                              976 ; 388  |// ShingYih LCD you have.  See \resources\shingyi\readme.txt 
                              977 ; 389  |// Optimal for NEW LCD with NEW file (SDK2.6 default)  
                              978 ; 390  |// G098064-41 LCD module (present on engr board revH LCD card)
                              979 ; 391  |
                              980 ; 392  |#if (defined(NEWSHINGYIH))
                              981 ; 393  |#define LCD_MAX_CONTRAST 250
                              982 ; 394  |#define LCD_MIN_CONTRAST 0
                              983 ; 395  |#else 
                              984 ; 396  |//-----
                              985 ; 397  |// Near optimal for OLD LCD with NEW file. 
                              986 ; 398  |// NOT optimal for the new lcd but pretty good. So u may use this if u want 1 build for bo
                                  th LCDs.
                              987 ; 399  |#define LCD_MAX_CONTRAST 250
                              988 ; 400  |#define LCD_MIN_CONTRAST 0
                              989 ; 401  |
                              990 ; 402  |//=====
                              991 ; 403  |// Optimal for OLD ShingYih LCD with OLD file (as sdk2.521)
                              992 ; 404  |// Suggest going with default new init file & values above for your LCD instead of this hi
                                  storic ver.
                              993 ; 405  |//LCD_MAX_CONTRAST equ 42
                              994 ; 406  |//LCD_MIN_CONTRAST equ 24 
                              995 ; 407  |
                              996 ; 408  |#endif
                              997 ; 409  |#endif
                              998 ; 410  |
                              999 ; 411  |#endif
                             1000 ; 412  |
                             1001 ; 413  |//////////////////////////////////////////////////////////////////////////////////
                             1002 ; 414  |// The default value of the lcd contrast in % of range
                             1003 ; 415  |//   the default value is used when no settings.dat is available
                             1004 ; 416  |//////////////////////////////////////////////////////////////////////////////////
                             1005 ; 417  |
                             1006 ; 418  |#if (defined(S6B33B0A_LCD))
                             1007 ; 419  |// 60% of range is default value
                             1008 ; 420  |#define DEFAULT_CONTRAST 50 
                             1009 ; 421  |#endif
                             1010 ; 422  |
                             1011 ; 423  |#if (defined(SED15XX_LCD))
                             1012 ; 424  |// % of range is default value (was 60%)
                             1013 ; 425  |#define DEFAULT_CONTRAST 50 
                             1014 ; 426  |#endif
                             1015 ; 427  |
                             1016 ; 428  |
                             1017 ; 429  |// percentage change per increment/decrement message (LCD_DEC_CONTRAST/LCD_INC_CONTRAST)
                             1018 ; 430  |// make lower when doing calibration
                             1019 ; 431  |#define LCD_STEPSIZE_CONTRAST 10  
                             1020 ; 432  |
                             1021 ; 433  |
                             1022 ; 434  |/////////////////////////////////////////////////////////////////////////////////
                             1023 ; 435  |// For FFWD and RWND
                             1024 ; 436  |/////////////////////////////////////////////////////////////////////////////////
                             1025 ; 437  |#define SECONDS_TO_SKIP 1
                             1026 ; 438  |#define SECONDS_TO_SKIP1 3
                             1027 ; 439  |#define SECONDS_TO_SKIP2 6
                             1028 ; 440  |// number of seconds to cause reset to begin of song for PREV push
                             1029 ; 441  |#define PREV_SONG_THRESHOLD 5  
TASKING DSP2410 assembler v1.5r1 Build 138 SN 00100122
                                                                                                                            Page  18

M:ADDR CODE           CYCLES LINE SOURCELINE
                             1030 ; 442  |// number of 300 mSec periods before the numbers of seconds to skip increases
                             1031 ; 443  |#define FIRST_TIME_BOUNDARY 15 
                             1032 ; 444  |// number of 300 mSec periods before the numbers of seconds to skip increases
                             1033 ; 445  |#define SECOND_TIME_BOUNDARY 30 
                             1034 ; 446  |
                             1035 ; 447  |// For audible FFW/RWD
                             1036 ; 448  |#define SECONDS_TO_SKIP_FOR_3X_RATE 1
                             1037 ; 449  |#define SECONDS_TO_SKIP_FOR_60X_RATE 18
                             1038 ; 450  |#define SECONDS_TO_SKIP_FOR_600X_RATE 180
                             1039 ; 451  |#define SECONDS_TO_SKIP_FOR_1800X_RATE 540
                             1040 ; 452  |// number of 300 mSec periods before the numbers of seconds to skip increases
                             1041 ; 453  |#define LEVEL1_BOUNDARY 17 
                             1042 ; 454  |// number of 300 mSec periods before the numbers of seconds to skip increases
                             1043 ; 455  |#define LEVEL2_BOUNDARY 33 
                             1044 ; 456  |// number of 300 mSec periods before the numbers of seconds to skip increases
                             1045 ; 457  |#define LEVEL3_BOUNDARY 50 
                             1046 ; 458  |// Stmp00010296 Ticket #71685:  for song shorter than the min. skip size
                             1047 ; 459  |// if song_time < skip_size, bCurrentSongShort=>TRUE (ignore FWD/RWD commands)
                             1048 ; 460  |// Short Song Time, songs too short to play.
                             1049 ; 461  |#define SHORT_SONG_TIME SECONDS_TO_SKIP         
                             1050 ; 462  |
                             1051 ; 463  |/////////////////////////////////////////////////////////////////////////////////
                             1052 ; 464  |// MP3 Sync Values
                             1053 ; 465  |/////////////////////////////////////////////////////////////////////////////////
                             1054 ; 466  |// # bytes to look for sync before marking it bad
                             1055 ; 467  |#define MP3_SYNC_THRESHOLD 70000 
                             1056 ; 468  |// # bytes to look for sync before slowing decoder isr frequency (to let menus run)
                             1057 ; 469  |#define MP3_SYNC_THRESHOLD1 10000 
                             1058 ; 470  |// once we have sync'd, the isr should be called this frequently
                             1059 ; 471  |#define MP3_DECODERISR_FAST 7500  
                             1060 ; 472  |// if decoder is having difficulty syncing, switch isr to be called less frequently
                             1061 ; 473  |#define MP3_DECODERISR_SLOW 50000 
                             1062 ; 474  |
                             1063 ; 475  |
                             1064 ; 476  |/////////////////////////////////////////////////////////////////////////////////
                             1065 ; 477  |//// Multi-Stage Volume Control Definitions
                             1066 ; 478  |/////////////////////////////////////////////////////////////////////////////////
                             1067 ; 479  |//// Use Multi-Stage Volume
                             1068 ; 480  |#define MULTI_STAGE_VOLUME 0x1                  
                             1069 ; 481  |
                             1070 ; 482  |//// Master Volume definitions
                             1071 ; 483  |#define MIX_MSTR_MAX_VOL 0x0
                             1072 ; 484  |#define NUM_MSTR_ATT_STEPS (0x1F-MIX_MSTR_MAX_VOL)
                             1073 ; 485  |
                             1074 ; 486  |//// DAC-Mode definitions
                             1075 ; 487  |//// Adjusts 0dB point
                             1076 ; 488  |#define MIX_DAC_NOM_VOL 0x6                  
                             1077 ; 489  |#define MIX_DAC_MIN_VOL 0x1F
                             1078 ; 490  |// For minimum clipping: Set MIX_DAC_MAX_VOL below to match MIX_DAC_NOM_VOL value 2 lines 
                                  above.
                             1079 ; 491  |// For additional gain (with possible clipping): Set MIX_DAC_MAX_VOL in range below. 
                             1080 ; 492  |//                                               Each integer below MIX_DAC_NOM_VOL provid
                                  es 1.5 dB gain on Stmp34x0; 
                             1081 ; 493  |//                                               Max gain possible: 8 step diff would prov
                                  ide +12dB gain.   
                             1082 ; 494  |// range: [0 to MIX_DAC_NOM_VOL] (0 for loudest volume)
                             1083 ; 495  |#define MIX_DAC_MAX_VOL 0x0  
                             1084 ; 496  |
                             1085 ; 497  |#define NUM_DAC_ATT_STEPS (MIX_DAC_MIN_VOL-MIX_DAC_NOM_VOL+1)
                             1086 ; 498  |#define NUM_DAC_GAIN_STEPS (MIX_DAC_NOM_VOL-MIX_DAC_MAX_VOL)
                             1087 ; 499  |#define NUM_DAC_MODE_VOL_STEPS (NUM_DAC_ATT_STEPS+NUM_MSTR_ATT_STEPS+NUM_DAC_GAIN_STEPS+1)
                                  
TASKING DSP2410 assembler v1.5r1 Build 138 SN 00100122
                                                                                                                            Page  19

M:ADDR CODE           CYCLES LINE SOURCELINE
                             1088 ; 500  |
                             1089 ; 501  |//// If there is no stored volume, set to 50% of DAC-Mode max; change if DAC Mode is not t
                                  he default
                             1090 ; 502  |//// STMP35xx has 2dB attenuation per step so default needs a few more steps above midpoin
                                  t.
                             1091 ; 503  |#define DEFAULT_VOLUME ((NUM_DAC_MODE_VOL_STEPS/2)+6)         
                             1092 ; 504  |
                             1093 ; 505  |//// Set maximum restored volume to 75% of DAC-Mode max; change if DAC Mode is not the def
                                  ault
                             1094 ; 506  |#define MAX_RESTORED_VOLUME ((3*NUM_DAC_MODE_VOL_STEPS)/4)   
                             1095 ; 507  |
                             1096 ; 508  |
                             1097 ; 509  |//// Line In definitions (used for Line-In 1)
                             1098 ; 510  |//// 0dB point of the Line In
                             1099 ; 511  |#define MIX_LINE_NOM_VOL 0x8                  
                             1100 ; 512  |//// Minimum volume of Line In
                             1101 ; 513  |#define MIX_LINE_MIN_VOL 0x1F                 
                             1102 ; 514  |//// Maximum volume of Line In (can adjust extra gain)
                             1103 ; 515  |#define MIX_LINE_MAX_VOL 0x6                  
                             1104 ; 516  |#define NUM_LINE_ATT_STEPS (MIX_LINE_MIN_VOL-MIX_LINE_NOM_VOL+1)
                             1105 ; 517  |#define NUM_LINE_GAIN_STEPS (MIX_LINE_NOM_VOL-MIX_LINE_MAX_VOL)
                             1106 ; 518  |#define NUM_LINE_MODE_VOL_STEPS (NUM_LINE_ATT_STEPS+NUM_MSTR_ATT_STEPS+NUM_LINE_GAIN_STEPS
                                  +1)
                             1107 ; 519  |
                             1108 ; 520  |//// Line In definitions (used for FM tuner with 144 pin package)
                             1109 ; 521  |//// 0dB point of the Line In
                             1110 ; 522  |#define MIX_FM_NOM_VOL 0x8                  
                             1111 ; 523  |//// Minimum volume of Line In
                             1112 ; 524  |#define MIX_FM_MIN_VOL 0x1F                 
                             1113 ; 525  |//// Maximum volume of Line In (can adjust extra gain)
                             1114 ; 526  |#define MIX_FM_MAX_VOL 0x6                  
                             1115 ; 527  |#define NUM_FM_ATT_STEPS (MIX_FM_MIN_VOL-MIX_FM_NOM_VOL+1)
                             1116 ; 528  |#define NUM_FM_GAIN_STEPS (MIX_FM_NOM_VOL-MIX_FM_MAX_VOL)
                             1117 ; 529  |#define NUM_FM_MODE_VOL_STEPS (NUM_FM_ATT_STEPS+NUM_MSTR_ATT_STEPS+NUM_FM_GAIN_STEPS+1)
                             1118 ; 530  |
                             1119 ; 531  |/////////////////////////////////////////////////////////////////////////////////
                             1120 ; 532  |//// When enabled (1), periodically checks for one of several FM state machine invalid dea
                                  dlock states & recovers. 
                             1121 ; 533  |//// Define as 0 to disable FM-deadlock-state checking and recovery.
                             1122 ; 534  |#define FM_WATCHDOG_ENABLE 1
                             1123 ; 535  |
                             1124 ; 536  |#if !defined(STMP_BUILD_PLAYER)
                             1125 ; 537  |////
                             1126 ; 538  |////! This varible holds the lcd display state for the mtp project.
                             1127 ; 539  |////
                             1128 ; 540  |///
                             1129 ; 541  |#include <types.h>
                             1130 
                             1132 
                             1133 ; 1    |////////////////////////////////////////////////////////////////////////////////
                             1134 ; 2    |// Copyright(C) SigmaTel, Inc. 2000-2004
                             1135 ; 3    |//
                             1136 ; 4    |// Filename: types.h
                             1137 ; 5    |// Description: Standard data types
                             1138 ; 6    |////////////////////////////////////////////////////////////////////////////////
                             1139 ; 7    |
                             1140 ; 8    |#ifndef _TYPES_H
                             1141 ; 9    |#define _TYPES_H
                             1142 ; 10   |
                             1143 ; 11   |// TODO:  move this outta here!
                             1144 ; 12   |#if !defined(NOERROR)
                             1145 ; 13   |#define NOERROR 0
TASKING DSP2410 assembler v1.5r1 Build 138 SN 00100122
                                                                                                                            Page  20

M:ADDR CODE           CYCLES LINE SOURCELINE
                             1146 ; 14   |#define SUCCESS 0
                             1147 ; 15   |#endif 
                             1148 ; 16   |#if !defined(SUCCESS)
                             1149 ; 17   |#define SUCCESS  0
                             1150 ; 18   |#endif
                             1151 ; 19   |#if !defined(ERROR)
                             1152 ; 20   |#define ERROR   -1
                             1153 ; 21   |#endif
                             1154 ; 22   |#if !defined(FALSE)
                             1155 ; 23   |#define FALSE 0
                             1156 ; 24   |#endif
                             1157 ; 25   |#if !defined(TRUE)
                             1158 ; 26   |#define TRUE  1
                             1159 ; 27   |#endif
                             1160 ; 28   |
                             1161 ; 29   |#if !defined(NULL)
                             1162 ; 30   |#define NULL 0
                             1163 ; 31   |#endif
                             1164 ; 32   |
                             1165 ; 33   |#define MAX_INT     0x7FFFFF
                             1166 ; 34   |#define MAX_LONG    0x7FFFFFffffff
                             1167 ; 35   |        // max positive unsigned long value: -1 == 0xFFFFFFffffff
                             1168 ; 36   |#define MAX_ULONG   (-1) 
                             1169 ; 37   |
                             1170 ; 38   |#define WORD_SIZE   24              // word size in bits
                             1171 ; 39   |#define BYTES_PER_WORD 3            // 8 bit bytes
                             1172 ; 40   |
                             1173 ; 41   |
                             1174 ; 42   |#define BYTE    unsigned char       // btVarName
                             1175 ; 43   |#define CHAR    signed char         // cVarName
                             1176 ; 44   |#define USHORT  unsigned short      // usVarName
                             1177 ; 45   |#define SHORT   unsigned short      // sVarName
                             1178 ; 46   |#define WORD    unsigned int        // wVarName
                             1179 ; 47   |#define INT     signed int          // iVarName
                             1180 ; 48   |#define DWORD   unsigned long       // dwVarName
                             1181 ; 49   |#define LONG    signed long         // lVarName
                             1182 ; 50   |#define BOOL    unsigned int        // bVarName
                             1183 ; 51   |#define FRACT   _fract              // frVarName
                             1184 ; 52   |#define LFRACT  long _fract         // lfrVarName
                             1185 ; 53   |#define CIRC    _circ               // cp<type prefix>VarName (see below)
                             1186 ; 54   |#define FLOAT   float               // fVarName
                             1187 ; 55   |#define DBL     double              // dVarName
                             1188 ; 56   |#define ENUM    enum                // eVarName
                             1189 ; 57   |#define CMX     _complex            // cmxVarName
                             1190 ; 58   |typedef WORD UCS3;                   // 
                             1191 ; 59   |
                             1192 ; 60   |#define UINT16  unsigned short
                             1193 ; 61   |#define UINT8   unsigned char   
                             1194 ; 62   |#define UINT32  unsigned long
                             1195 ; 63   |#define UINT64  unsigned long   // need to figure out how to do 64 bit values.  Or port ex
                                  isiting code to only use 48 bit
                             1196 ; 64   |#define INT64   unsigned long   // need to figure out how to do 64 bit values.  Or port ex
                                  isiting code to only use 48 bit
                             1197 ; 65   |#define WCHAR   UINT16
                             1198 ; 66   |
                             1199 ; 67   |//UINT128 is 16 bytes or 6 words
                             1200 ; 68   |typedef struct UINT128_3500 {   
                             1201 ; 69   |    int val[6];     
                             1202 ; 70   |} UINT128_3500;
                             1203 ; 71   |
                             1204 ; 72   |#define UINT128   UINT128_3500
                             1205 ; 73   |
TASKING DSP2410 assembler v1.5r1 Build 138 SN 00100122
                                                                                                                            Page  21

M:ADDR CODE           CYCLES LINE SOURCELINE
                             1206 ; 74   |// Little endian word packed byte strings:   
                             1207 ; 75   |//      _packed BYTE bTextVarName[]="a string";  bText is a packed byte string prefix
                             1208 ; 76   |// Convert to big endian words by reordering bytes from high to low using swizzle.
                             1209 ; 77   |// Little endian word packed byte strings:   
                             1210 ; 78   |//      _packed BYTE bTextVarName[]="a string";  bText is a packed byte string prefix
                             1211 ; 79   |// Convert to big endian words by reordering bytes from high to low using swizzle.
                             1212 ; 80   |
                             1213 ; 81   |// Declare Memory Spaces To Use When Coding
                             1214 ; 82   |// A. Sector Buffers
                             1215 ; 83   |#define SECTOR_BUFFER_MEM_X _X
                             1216 ; 84   |#define SECTOR_BUFFER_MEM_Y _Y
                             1217 ; 85   |#define SECTOR_BUFFER_MEM SECTOR_BUFFER_MEM_X
                             1218 ; 86   |typedef WORD SECTOR_BUFFER_MEM SECTOR_BUFFER;
                             1219 ; 87   |typedef SECTOR_BUFFER * P_SECTOR_BUFFER;
                             1220 ; 88   |// B. Media DDI Memory
                             1221 ; 89   |#define MEDIA_DDI_MEM _Y
                             1222 ; 90   |
                             1223 ; 91   |
                             1224 ; 92   |
                             1225 ; 93   |// Pointers to linear structures are labeled as: p<type prefix>VarName
                             1226 ; 94   |// Examples of circular pointers:
                             1227 ; 95   |//    INT CIRC cpiVarName
                             1228 ; 96   |//    DWORD CIRC cpdwVarName
                             1229 ; 97   |
                             1230 ; 98   |#define RETCODE INT                 // rcVarName
                             1231 ; 99   |
                             1232 ; 100  |// generic bitfield structure
                             1233 ; 101  |struct Bitfield {
                             1234 ; 102  |    unsigned int B0  :1;
                             1235 ; 103  |    unsigned int B1  :1;
                             1236 ; 104  |    unsigned int B2  :1;
                             1237 ; 105  |    unsigned int B3  :1;
                             1238 ; 106  |    unsigned int B4  :1;
                             1239 ; 107  |    unsigned int B5  :1;
                             1240 ; 108  |    unsigned int B6  :1;
                             1241 ; 109  |    unsigned int B7  :1;
                             1242 ; 110  |    unsigned int B8  :1;
                             1243 ; 111  |    unsigned int B9  :1;
                             1244 ; 112  |    unsigned int B10 :1;
                             1245 ; 113  |    unsigned int B11 :1;
                             1246 ; 114  |    unsigned int B12 :1;
                             1247 ; 115  |    unsigned int B13 :1;
                             1248 ; 116  |    unsigned int B14 :1;
                             1249 ; 117  |    unsigned int B15 :1;
                             1250 ; 118  |    unsigned int B16 :1;
                             1251 ; 119  |    unsigned int B17 :1;
                             1252 ; 120  |    unsigned int B18 :1;
                             1253 ; 121  |    unsigned int B19 :1;
                             1254 ; 122  |    unsigned int B20 :1;
                             1255 ; 123  |    unsigned int B21 :1;
                             1256 ; 124  |    unsigned int B22 :1;
                             1257 ; 125  |    unsigned int B23 :1;
                             1258 ; 126  |};
                             1259 ; 127  |
                             1260 ; 128  |union BitInt {
                             1261 ; 129  |        struct Bitfield B;
                             1262 ; 130  |        int        I;
                             1263 ; 131  |};
                             1264 ; 132  |
                             1265 ; 133  |#define MAX_MSG_LENGTH 10
                             1266 ; 134  |struct CMessage
                             1267 ; 135  |{
TASKING DSP2410 assembler v1.5r1 Build 138 SN 00100122
                                                                                                                            Page  22

M:ADDR CODE           CYCLES LINE SOURCELINE
                             1268 ; 136  |        unsigned int m_uLength;
                             1269 ; 137  |        unsigned int m_uMsg[MAX_MSG_LENGTH];
                             1270 ; 138  |};
                             1271 ; 139  |
                             1272 ; 140  |typedef struct {
                             1273 ; 141  |    WORD m_wLength;
                             1274 ; 142  |    WORD m_wMessage;
                             1275 ; 143  |    WORD m_wParams[MAX_MSG_LENGTH];
                             1276 ; 144  |} Message;
                             1277 ; 145  |
                             1278 ; 146  |struct MessageQueueDescriptor
                             1279 ; 147  |{
                             1280 ; 148  |        int *m_pBase;
                             1281 ; 149  |        int m_iModulo;
                             1282 ; 150  |        int m_iSize;
                             1283 ; 151  |        int *m_pHead;
                             1284 ; 152  |        int *m_pTail;
                             1285 ; 153  |};
                             1286 ; 154  |
                             1287 ; 155  |struct ModuleEntry
                             1288 ; 156  |{
                             1289 ; 157  |    int m_iSignaledEventMask;
                             1290 ; 158  |    int m_iWaitEventMask;
                             1291 ; 159  |    int m_iResourceOfCode;
                             1292 ; 160  |    struct MessageQueueDescriptor *m_pMessageQueue;
                             1293 ; 161  |    int _asmfunc (*m_pProcessEntryPoint)(union WaitMask Signals,struct MessageQueueDescrip
                                  tor *);
                             1294 ; 162  |    int _asmfunc (*m_pInitFunction)(struct MessageQueueDescriptor *);
                             1295 ; 163  |    int m_uTimeOutHigh;
                             1296 ; 164  |    int m_uTimeOutLow;
                             1297 ; 165  |    int _asmfunc (*m_pBackgroundFunction)(struct MessageQueueDescriptor *);
                             1298 ; 166  |};
                             1299 ; 167  |
                             1300 ; 168  |union WaitMask{
                             1301 ; 169  |    struct B{
                             1302 ; 170  |        unsigned int m_bNone     :1;
                             1303 ; 171  |        unsigned int m_bMessage  :1;
                             1304 ; 172  |        unsigned int m_bTimer    :1;
                             1305 ; 173  |        unsigned int m_bButton   :1;
                             1306 ; 174  |    } B;
                             1307 ; 175  |    int I;
                             1308 ; 176  |} ;
                             1309 ; 177  |
                             1310 ; 178  |
                             1311 ; 179  |struct Button {
                             1312 ; 180  |        WORD wButtonEvent;
                             1313 ; 181  |        WORD wUnused[MAX_MSG_LENGTH];   
                             1314 ; 182  |};
                             1315 ; 183  |
                             1316 ; 184  |struct Message {
                             1317 ; 185  |        WORD wMsgLength;
                             1318 ; 186  |        WORD wMsgCommand;
                             1319 ; 187  |        WORD wMsgParms[MAX_MSG_LENGTH-1];
                             1320 ; 188  |};
                             1321 ; 189  |
                             1322 ; 190  |union EventTypes {
                             1323 ; 191  |        struct CMessage msg;
                             1324 ; 192  |        struct Button Button ;
                             1325 ; 193  |        struct Message Message;
                             1326 ; 194  |};
                             1327 ; 195  |
                             1328 ; 196  |// next 2 used to get updater build to return correct protocol ver in scsi response.
TASKING DSP2410 assembler v1.5r1 Build 138 SN 00100122
                                                                                                                            Page  23

M:ADDR CODE           CYCLES LINE SOURCELINE
                             1329 ; 197  |#define BUILD_TYPE_UPDATER  0x100
                             1330 ; 198  |#define BUILD_TYPE_HOSTLINK 0x101
                             1331 ; 199  |#define BUILD_TYPE_PLAYER   0x102
                             1332 ; 200  |
                             1333 ; 201  |// Resets part if RETAIL build. DEBUG build executes debug instruction to halt.
                             1334 ; 202  |#define SystemHalt() __asm(" include 'sysmacro.asm' \n error") 
                             1335 ; 203  |#define assert(x)    if(!(x)) __asm(" include 'sysmacro.asm' \n error")
                             1336 ; 204  |
                             1337 ; 205  |#if DEBUG
                             1338 ; 206  |// For DEBUG builds, DebugBuildAssert(condition) halts if condition evaluates to FALSE. 
                             1339 ; 207  |#define DebugBuildAssert(x)    if(!(x)) __asm(" debug ")
                             1340 ; 208  |#else 
                             1341 ; 209  |// For RETAIL builds, DebugBuildAssert(condition) does nothing & execution continues rathe
                                  r than halt or reset. 
                             1342 ; 210  |#define DebugBuildAssert(x)    
                             1343 ; 211  |#endif
                             1344 ; 212  |
                             1345 ; 213  |// Do this in your C files to make a reminder that's displayed during the build.
                             1346 ; 214  |//  #pragma asm
                             1347 ; 215  |//  WARN 'Note to builder: reminder to do this after verifying that'
                             1348 ; 216  |//  #pragma endasm
                             1349 ; 217  |
                             1350 ; 218  |
                             1351 ; 219  |#ifdef COLOR_262K
                             1352 ; 220  |#define RGB(r,g,b)    ((0x0000FC & (r)) << 10) | ((0x0000FC & (g)) << 4) | ((0x0000FC & (b
                                  )) >> 2)    //262k
                             1353 ; 221  |#elif defined(COLOR_65K)
                             1354 ; 222  |#define RGB(r,g,b)    ((0x0000F8 & (r)) << 8) | ((0x0000FC & (g)) << 3) | ((0x0000F8 & (b)
                                  ) >> 3)  //65k
                             1355 ; 223  |#else
                             1356 ; 224  |#define RGB(r,g,b)       ((0x0000F0 & (r)) << 4) | (0x0000F0 & (g)) | ((0x0000F0 & (b)) >>
                                   4)
                             1357 ; 225  |#endif
                             1358 ; 226  |    
                             1359 ; 227  |#endif // #ifndef _TYPES_H
                             1360 
                             1362 
                             1363 ; 542  |extern volatile WORD g_wActivityState;
                             1364 ; 543  |#endif // if !@def('STMP_BUILD_PLAYER')
                             1365 ; 544  |
                             1366 ; 545  |void _reentrant Init5VSense(void);
                             1367 ; 546  |void _reentrant ServiceDCDC(void);
                             1368 ; 547  |
                             1369 ; 548  |////////////////////////////////////////////////////////////////////////////
                             1370 ; 549  |//// JPEG Thumbnail Mode Setting
                             1371 ; 550  |//// number of column in thumbnail mode
                             1372 ; 551  |#define THUMBNAIL_X 2           
                             1373 ; 552  |//// number of row in  thumbnail mode
                             1374 ; 553  |#define THUMBNAIL_Y 2           
                             1375 ; 554  |//// thumbnail boundary offset x
                             1376 ; 555  |#define THUMBNAIL_X_OFFSET 4            
                             1377 ; 556  |//// thumbnail boundary offset y
                             1378 ; 557  |#define THUMBNAIL_Y_OFFSET 4            
                             1379 ; 558  |
                             1380 ; 559  |#endif // if (!@def(_PROJECT_INC))
                             1381 ; 560  |
                             1382 
                             1384 
                             1385 ; 15   |
                             1386 ; 16   |#ifndef _USB_MEM
                             1387 ; 17   |//if not overwridden, default to the compiler default memory space
                             1388 ; 18   |#define _USB_MEM
TASKING DSP2410 assembler v1.5r1 Build 138 SN 00100122
                                                                                                                            Page  24

M:ADDR CODE           CYCLES LINE SOURCELINE
                             1389 ; 19   |#endif
                             1390 ; 20   |
                             1391 ; 21   |#define USB_LANGUAGE_ENGLISH 0x0409
                             1392 ; 22   |#define USB_LANGUAGE_CHINESE_PRC 0x0804
                             1393 ; 23   |#define USB_LANGUAGE_CHINESE_TAIWAN 0x0404
                             1394 ; 24   |#define USB_LANGUAGE_JAPANESE 0x0411
                             1395 ; 25   |
                             1396 ; 26   |#define MAX_STRING 30
                             1397 ; 27   |
                             1398 ; 28   |#define  USB_SPEED_FULL                      (0)
                             1399 ; 29   |#define  USB_SPEED_LOW                       (1)
                             1400 ; 30   |#define  USB_SPEED_HIGH                      (2)
                             1401 ; 31   |
                             1402 ; 32   |#define EP_FS_MAX_PACKET_SIZE               (64)    
                             1403 ; 33   |
                             1404 ; 34   |#define EP_HS_MAX_PACKET_SIZE               (512)   
                             1405 ; 35   |
                             1406 ; 36   |// Data transferred to devices based on Sigmatel 3500 chip may sometimes be 
                             1407 ; 37   |// corrupted. The corruption occurs when device is connected in USB High Speed 
                             1408 ; 38   |// mode, and size of the transfer in bytes is divisible by 128, but not 
                             1409 ; 39   |// divisible by the packet size. The workaround is implemented in Microsoft MTP 
                             1410 ; 40   |// driver to allow support for those devices.
                             1411 ; 41   |
                             1412 ; 42   |// the bug can corrupt the end of data buffer. It occurs when host sends out a 
                             1413 ; 43   |// short packet that is multiple of 128 bytes. During this scenario the USB core
                             1414 ; 44   |// does writes that are voided (byte enable == all zero), which was an undefined 
                             1415 ; 45   |// capability and thus the gasket did not apply a proper response. This should 
                             1416 ; 46   |// not affect Mass Storage applications because data transfers are 512 bytes and 
                             1417 ; 47   |// scsi commands are < 16 bytes. Other applications with their own driver will
                             1418 ; 48   |// need to pad the packets if they fall into the error case. "What this basically 
                             1419 ; 49   |// boils down to is that any time the host sends a short packet of 128, 256 or
                             1420 ; 50   |// 384 bytes to a high-speed connected player a number of bytes will be corrupted.
                             1421 ; 51   |// This is easiest to reproduce in SendObject commands but can strike any of the 
                             1422 ; 52   |// commands that take an arbitrary amount of data.
                             1423 ; 53   |#define ARC_HS_128_MODULO_BUG               (128)
                             1424 ; 54   |
                             1425 ; 55   |
                             1426 ; 56   |/* Error codes */
                             1427 ; 57   |#define USB_OK                              (0x00)
                             1428 ; 58   |#define USBERR_REGISTER_SERVICE             (0x01)  // Failed to register a service
                             1429 ; 59   |#define USBERR_NO_SERVICE                   (0x02)  // No registered service found 
                             1430 ; 60   |#define USBERR_TX_FAILED                    (0x03)  // Fail to prepare XD descriptor
                             1431 ; 61   |#define USBERR_SIZE_TOO_LARGE               (0x04)  // Number of bytes to transfer is too 
                                  large
                             1432 ; 62   |#define USBERR_EP_INIT_FAILED               (0x05)  // Endpoint init fail
                             1433 ; 63   |#define USBERR_CONFIG_FAILED                (0x06)  // Error reported by the application
                             1434 ; 64   |                                                    // if the new config failed or not sup
                                  ported
                             1435 ; 65   |#define USBERR_DEVICE_NOT_CONFIGURED        (0x07)  // Error reported by the transfer func
                                  tion
                             1436 ; 66   |                                                    // if attempting to transfer while the
                                   device
                             1437 ; 67   |                                                    // is not configured
                             1438 ; 68   |#define USBERR_INIT_FAILED                  (0x08)  // Fail to initialize the USB API
                             1439 ; 69   |
                             1440 ; 70   |
                             1441 ; 71   |/* Endpoint types */
                             1442 ; 72   |#define  USB_CONTROL_ENDPOINT             (0)
                             1443 ; 73   |#define  USB_ISOCHRONOUS_ENDPOINT         (1)
                             1444 ; 74   |#define  USB_BULK_ENDPOINT                (2)
                             1445 ; 75   |#define  USB_INTERRUPT_ENDPOINT           (3)
                             1446 ; 76   |
TASKING DSP2410 assembler v1.5r1 Build 138 SN 00100122
                                                                                                                            Page  25

M:ADDR CODE           CYCLES LINE SOURCELINE
                             1447 ; 77   |/* End point direction */
                             1448 ; 78   |#define  USB_OUT                         (0)
                             1449 ; 79   |#define  USB_IN                          (1)
                             1450 ; 80   |
                             1451 ; 81   |/* End point packed size */
                             1452 ; 82   |#define  USB_FS_MAX_PACKET_SIZE           (64)
                             1453 ; 83   |#define  USB_HS_BULK_OUT_MAX_PACKET_SIZE  (256)
                             1454 ; 84   |#define  USB_HS_BULK_IN_MAX_PACKET_SIZE   (128)
                             1455 ; 85   |
                             1456 ; 86   |
                             1457 ; 87   |#define  USB_TEST_MODE_TEST_J             (0x01)
                             1458 ; 88   |#define  USB_TEST_MODE_TEST_K             (0x02)
                             1459 ; 89   |#define  USB_TEST_MODE_TEST_SE0_NAK       (0x03)
                             1460 ; 90   |#define  USB_TEST_MODE_TEST_PACKET        (0x04)
                             1461 ; 91   |
                             1462 ; 92   |/* Available service types */
                             1463 ; 93   |/* Services 0 through 15 are reserved for endpoints */
                             1464 ; 94   |#define  USB_SERVICE_EP0                  (0x00)
                             1465 ; 95   |#define  USB_SERVICE_EP1                  (0x01)
                             1466 ; 96   |#define  USB_SERVICE_EP2                  (0x02)
                             1467 ; 97   |#define  USB_SERVICE_EP3                  (0x03)
                             1468 ; 98   |#define  USB_SERVICE_EP4                  (0x04)
                             1469 ; 99   |#define  USB_SERVICE_EP5                  (0x05)
                             1470 ; 100  |#define  USB_SERVICE_EP6                  (0x06)
                             1471 ; 101  |#define  USB_SERVICE_EP7                  (0x07)
                             1472 ; 102  |#define  USB_SERVICE_EP8                  (0x08)
                             1473 ; 103  |#define  USB_SERVICE_EP9                  (0x09)
                             1474 ; 104  |#define  USB_SERVICE_EP10                 (0x0a)
                             1475 ; 105  |#define  USB_SERVICE_EP11                 (0x0b)
                             1476 ; 106  |#define  USB_SERVICE_EP12                 (0x0c)
                             1477 ; 107  |#define  USB_SERVICE_EP13                 (0x0d)
                             1478 ; 108  |#define  USB_SERVICE_EP14                 (0x0e)
                             1479 ; 109  |#define  USB_SERVICE_EP15                 (0x0f)
                             1480 ; 110  |#define  USB_SERVICE_BUS_RESET            (0x10)
                             1481 ; 111  |#define  USB_SERVICE_SUSPEND              (0x11)
                             1482 ; 112  |#define  USB_SERVICE_SOF                  (0x12)
                             1483 ; 113  |#define  USB_SERVICE_RESUME               (0x13)
                             1484 ; 114  |#define  USB_SERVICE_SLEEP                (0x14)
                             1485 ; 115  |#define  USB_SERVICE_SPEED_DETECTION      (0x15)
                             1486 ; 116  |#define  USB_SERVICE_TEST                 (0x16)
                             1487 ; 117  |#define  USB_SERVICE_CHANGE_CONFIG        (0x17)
                             1488 ; 118  |#define  USB_SERVICE_CHANGE_IFACE         (0x18)   
                             1489 ; 119  |#define  NON_EP_SERVICES                  (USB_SERVICE_SPEED_DETECTION - USB_SERVICE_EP15)
                                  
                             1490 ; 120  |
                             1491 ; 121  |// This is the maximum service structures allocated 
                             1492 ; 122  |// One for each End point + the common services (non endpoint services) 
                             1493 ; 123  |#define MAX_NUMBER_SERVICES               (MAX_NUM_EP + NON_EP_SERVICES)  
                             1494 ; 124  |
                             1495 ; 125  |#define NUMBER_BYTES_IN_SETUP               (8)
                             1496 ; 126  |
                             1497 ; 127  |// possible values of btStatus on the xd_struct
                             1498 ; 128  |#define  USB_STATUS_TRANSFER_IDLE           (0)
                             1499 ; 129  |#define  USB_STATUS_TRANSFER_SUCCESS        (1)            
                             1500 ; 130  |#define  USB_STATUS_TRANSFER_ACCEPTED       (2)
                             1501 ; 131  |#define  USB_STATUS_TRANSFER_IN_PROGRESS    (3)
                             1502 ; 132  |#define  USB_STATUS_TRANSFER_ERROR          (4)
                             1503 ; 133  |
                             1504 ; 134  |// types of status set/returned by set_status() and get_status()
                             1505 ; 135  |#define  USB_STATUS_DEVICE_STATE          (0x01)
                             1506 ; 136  |#define  USB_STATUS_INTERFACE             (0x02)
                             1507 ; 137  |#define  USB_STATUS_ADDRESS               (0x03)
TASKING DSP2410 assembler v1.5r1 Build 138 SN 00100122
                                                                                                                            Page  26

M:ADDR CODE           CYCLES LINE SOURCELINE
                             1508 ; 138  |#define  USB_STATUS_CURRENT_CONFIG        (0x04)
                             1509 ; 139  |#define  USB_STATUS_SOF_COUNT             (0x05)
                             1510 ; 140  |#define  USB_STATUS                       (0x06)
                             1511 ; 141  |#define  USB_STATUS_TEST_MODE             (0x07)
                             1512 ; 142  |#define  USB_STATUS_DEVICE_SPEED          (0x08)  
                             1513 ; 143  |#define  USB_STATUS_DEVICE_TEST           (0x09)  
                             1514 ; 144  |#define  USB_STATUS_CURRENT_IFACE         (0x0a)
                             1515 ; 145  |#define  USB_STATUS_CONNECTION            (0x0b)  
                             1516 ; 146  |// For status endpoint, the endpoint number is coded in the less significant nibble
                             1517 ; 147  |#define  USB_STATUS_ENDPOINT              (0x10)
                             1518 ; 148  |#define  USB_STATUS_ENDPOINT_NUMBER_MASK  (0x0F)
                             1519 ; 149  |
                             1520 ; 150  |#define USB_MAX_SIZE_PER_TRANSFER       (0x4000)    // This is the maximum size that
                             1521 ; 151  |                                                    // we allow per transfer
                             1522 ; 152  |
                             1523 ; 153  |//Possible states the device can be in
                             1524 ; 154  |#define  USB_STATE_UNKNOWN                   (0xff)
                             1525 ; 155  |#define  USB_STATE_UNPLUGGED                 (0x05) // USB Cable unplugged
                             1526 ; 156  |#define  USB_STATE_PLUGGED                   (0x04) // USB Cable inserted
                             1527 ; 157  |#define  USB_STATE_POWERED                   (0x03)
                             1528 ; 158  |#define  USB_STATE_DEFAULT                   (0x02)
                             1529 ; 159  |#define  USB_STATE_ADDRESSED                 (0x01)
                             1530 ; 160  |#define  USB_STATE_CONFIGURED                (0x00)
                             1531 ; 161  |#define  USB_STATE_SUSPENDED                 (0x80)
                             1532 ; 162  |
                             1533 ; 163  |// Possible states the connection can be in
                             1534 ; 164  |//#define USB_STATE_UNKNOWN                 (0xff)
                             1535 ; 165  |#define USB_CONNECTED                       (0x00)
                             1536 ; 166  |#define USB_DISCONNECTED                    (0x01)
                             1537 ; 167  |
                             1538 ; 168  |
                             1539 ; 169  |
                             1540 ; 170  |typedef union
                             1541 ; 171  |{
                             1542 ; 172  |    struct
                             1543 ; 173  |    {
                             1544 ; 174  |        int Recipient               : 5;
                             1545 ; 175  |        int Type                    : 2;
                             1546 ; 176  |        int DataTransferDirection   : 1;
                             1547 ; 177  |        int Request                 : 8;
                             1548 ; 178  |        int                         : 8;
                             1549 ; 179  |    } B;
                             1550 ; 180  |    
                             1551 ; 181  |    int I;
                             1552 ; 182  |} USBRequestType ;
                             1553 
                             1567 
                             1568 ; 183  |
                             1569 ; 184  |typedef struct {
                             1570 ; 185  |   BYTE     bValid;
                             1571 ; 186  |   USBRequestType RequestType;
                             1572 ; 187  |   BYTE     btRequest;
                             1573 ; 188  |   WORD     wValue;
                             1574 ; 189  |   WORD     wIndex;
                             1575 ; 190  |   WORD     wLength;
                             1576 ; 191  |    } USB_SetupData;
                             1577 ; 192  |
                             1578 ; 193  |// Descriptor sizes in bytes
                             1579 ; 194  |#define SIZE_DEVICE_DESCRIPTOR_IN_BYTES     (18)
                             1580 ; 195  |#define SIZE_DEVICE_DESCRIPTOR_IN_WORDS     (6)
                             1581 ; 196  |#define SIZE_DEVICE_QUALIFIER_DESCRIPTOR_IN_BYTES   (10)
                             1582 ; 197  |#define SIZE_DEVICE_QUALIFIER_DESCRIPTOR_IN_WORDS   (4)
TASKING DSP2410 assembler v1.5r1 Build 138 SN 00100122
                                                                                                                            Page  27

M:ADDR CODE           CYCLES LINE SOURCELINE
                             1583 ; 198  |#define SIZE_CONFIG_DESCRIPTOR_IN_BYTES     (9)
                             1584 ; 199  |#define SIZE_CONFIG_DESCRIPTOR_IN_WORDS     (3)
                             1585 ; 200  |#define SIZE_INTERFACE_DESCRIPTOR_IN_BYTES  (9)
                             1586 ; 201  |#define SIZE_INTERFACE_DESCRIPTOR_IN_WORDS  (3)
                             1587 ; 202  |#define SIZE_ENDPOINT_DESCRIPTOR_IN_BYTES   (7)
                             1588 ; 203  |
                             1589 ; 204  |
                             1590 ; 205  |// Descriptor types
                             1591 ; 206  |#define DESCRIPTOR_TYPE_DEVICE              (0x01)
                             1592 ; 207  |#define DESCRIPTOR_TYPE_CONFIG              (0x02)
                             1593 ; 208  |#define DESCRIPTOR_TYPE_STRING              (0x03)
                             1594 ; 209  |#define DESCRIPTOR_TYPE_INTERFACE           (0x04)
                             1595 ; 210  |#define DESCRIPTOR_TYPE_ENDPOINT            (0x05)
                             1596 ; 211  |#define DESCRIPTOR_TYPE_DEVICE_QUALIFIER    (0x06)
                             1597 ; 212  |#define DESCRIPTOR_TYPE_OTHER_SPEED_CONFIG  (0x07)
                             1598 ; 213  |#define DESCRIPTOR_TYPE_INTERFACE_POWER     (0x08)
                             1599 ; 214  |
                             1600 ; 215  |
                             1601 ; 216  |#define USB_REQUEST_DIRECTION_HOST_TO_DEVICE    ((WORD)0x000000)
                             1602 ; 217  |#define USB_REQUEST_DIRECTION_DEVICE_TO_HOST    ((WORD)0x000001)
                             1603 ; 218  |
                             1604 ; 219  |#define USB_REQUEST_TYPE_STANDARD               ((WORD)0x000000)
                             1605 ; 220  |#define USB_REQUEST_TYPE_CLASS                  ((WORD)0x000001)
                             1606 ; 221  |#define USB_REQUEST_TYPE_VENDOR                 ((WORD)0x000002)
                             1607 ; 222  |#define USB_REQUEST_TYPE_RESERVED               ((WORD)0x000003)
                             1608 ; 223  |
                             1609 ; 224  |#define USB_REQUEST_RECIPIENT_DEVICE            ((WORD)0x000000)
                             1610 ; 225  |#define USB_REQUEST_RECIPIENT_INTERFACE         ((WORD)0x000001)
                             1611 ; 226  |#define USB_REQUEST_RECIPIENT_ENDPOINT          ((WORD)0x000002)
                             1612 ; 227  |#define USB_REQUEST_RECIPIENT_OTHER             ((WORD)0x000003)
                             1613 ; 228  |
                             1614 ; 229  |#define USB_REQUEST_STANDARD_GET_STATUS         ((WORD)0x000000)
                             1615 ; 230  |#define USB_REQUEST_STANDARD_CLEAR_FEATURE      ((WORD)0x000001)
                             1616 ; 231  |#define USB_REQUEST_STANDARD_RESERVED_1         ((WORD)0x000002)
                             1617 ; 232  |#define USB_REQUEST_STANDARD_SET_FEATURE        ((WORD)0x000003)
                             1618 ; 233  |#define USB_REQUEST_STANDARD_RESERVED_2         ((WORD)0x000004)
                             1619 ; 234  |#define USB_REQUEST_STANDARD_SET_ADDRESS        ((WORD)0x000005)
                             1620 ; 235  |#define USB_REQUEST_STANDARD_GET_DESCRIPTOR     ((WORD)0x000006)
                             1621 ; 236  |#define USB_REQUEST_STANDARD_SET_DESCRIPTOR     ((WORD)0x000007)
                             1622 ; 237  |#define USB_REQUEST_STANDARD_GET_CONFIGURATION  ((WORD)0x000008)
                             1623 ; 238  |#define USB_REQUEST_STANDARD_SET_CONFIGURATION  ((WORD)0x000009)
                             1624 ; 239  |#define USB_REQUEST_STANDARD_GET_INTERFACE      ((WORD)0x00000A)
                             1625 ; 240  |#define USB_REQUEST_STANDARD_SET_INTERFACE      ((WORD)0x00000B)
                             1626 ; 241  |#define USB_REQUEST_STANDARD_SYNCH_FRAME        ((WORD)0x00000C)
                             1627 ; 242  |
                             1628 ; 243  |#define USB_CLEAR_FEATURE_ENDPOINT_HALT         (0)
                             1629 ; 244  |#define USB_CLEAR_FEATURE_REMOTE_WAKEUP         (1)
                             1630 ; 245  |
                             1631 ; 246  |
                             1632 ; 247  |// Struct Device Descriptor
                             1633 ; 248  |typedef struct {
                             1634 ; 249  |    BYTE    bLength;                // (0) Size of this descriptor in bytes (18)
                             1635 ; 250  |    BYTE    btDescriptorType;       // (1) Device descriptor type (1)
                             1636 ; 251  |    BYTE    btBcdUsbLsb;            // (2) USB specification release number (for version 2
                                  .00 0x00)
                             1637 ; 252  |    BYTE    btBcdUsbMsb;            // (3)                                  (for version 2
                                  .00 0x02)     
                             1638 ; 253  |    BYTE    btDeviceClass;          // (4) Class code
                             1639 ; 254  |    BYTE    btDeviceSubclass;       // (5) Subclass code
                             1640 ; 255  |    BYTE    btDeviceProtocol;       // (6) Protocol code
                             1641 ; 256  |    BYTE    btMaxPacketSize0;       // (7) Maximum packet size for endpoint 0 (8, 16, 32 o
                                  r 64)
TASKING DSP2410 assembler v1.5r1 Build 138 SN 00100122
                                                                                                                            Page  28

M:ADDR CODE           CYCLES LINE SOURCELINE
                             1642 ; 257  |    BYTE    btIdVendorLsb;          // (8) Vendor Id
                             1643 ; 258  |    BYTE    btIdVendorMsb;          // (9)
                             1644 ; 259  |    BYTE    btIdProductLsb;         // (10) Product Id
                             1645 ; 260  |    BYTE    btIdProductMsb;         // (11)
                             1646 ; 261  |    BYTE    btBcdReleaseLsb;        // (12) Device release number in BCD
                             1647 ; 262  |    BYTE    btBcdReleaseMsb;        // (13)
                             1648 ; 263  |    BYTE    btIndexManufacturer;    // (14) Index of string descriptor describing Manufact
                                  urer
                             1649 ; 264  |    BYTE    btIndexProduct;         // (15) Index of string descriptor describing Product
                             1650 ; 265  |    BYTE    btIndexSerialNumber;    // (16) Index of string descriptor describing Device S
                                  erial Number
                             1651 ; 266  |    BYTE    btNumConfigurations;    // (17) Number of possible configurations
                             1652 ; 267  |} Struct_Standard_Dev_Desc;
                             1653 ; 268  |
                             1654 ; 269  |// Struct Device Qualifier Descriptor
                             1655 ; 270  |typedef struct {
                             1656 ; 271  |    BYTE    bLength;                // (0) Size of this descriptor in bytes (10)
                             1657 ; 272  |    BYTE    btDescriptorType;       // (1) Device descriptor type (6)
                             1658 ; 273  |    BYTE    btBcdUsbLsb;            // (2) USB specification release number (for version 2
                                  .00 0x00)
                             1659 ; 274  |    BYTE    btBcdUsbMsb;            // (3)                                  (for version 2
                                  .00 0x02)     
                             1660 ; 275  |    BYTE    btDeviceClass;          // (4) Class code
                             1661 ; 276  |    BYTE    btDeviceSubclass;       // (5) Subclass code
                             1662 ; 277  |    BYTE    btDeviceProtocol;       // (6) Protocol code
                             1663 ; 278  |    BYTE    btMaxPacketSize0;       // (7) Maximum packet size for endpoint 0 other speed 
                                  (8, 16, 32 or 64)
                             1664 ; 279  |    BYTE    btNumConfigurations;    // (8) Number of other-speed possible configurations
                             1665 ; 280  |    BYTE    btReserved;             // (9) Reserved for future use, must be 0
                             1666 ; 281  |} Struct_Dev_Qualifier_Desc;
                             1667 ; 282  |
                             1668 ; 283  |// Struct Configuration Descriptor
                             1669 ; 284  |typedef struct {
                             1670 ; 285  |    BYTE    bLength;                // (0) Size of this descriptor in bytes (9)
                             1671 ; 286  |    BYTE    btDescriptorType;       // (1) Device descriptor type (2 or 7)
                             1672 ; 287  |    BYTE    btTotalLengthLsb;       // (2) Total length of data returned for this config.
                             1673 ; 288  |    BYTE    btTotalLengthMsb;       // (3)                                  
                             1674 ; 289  |    BYTE    btNumInterfaces;        // (4) Number of Interfaces supported by this configur
                                  ation
                             1675 ; 290  |    BYTE    btConfigurationValue;   // (5) Value to use as an argument to the SetConfigura
                                  tion() request
                             1676 ; 291  |    BYTE    btIndexConfiguration;   // (6) Index of string descriptor describing this conf
                                  iguration
                             1677 ; 292  |    BYTE    btBitMapAttributes;     // (7) Configuration Characteristics
                             1678 ; 293  |                                    //     D7:      Reserved (set to one)
                             1679 ; 294  |                                    //     D6:      Self-powered
                             1680 ; 295  |                                    //     D5:      Remote Wakeup
                             1681 ; 296  |                                    //     D4..0:   Reserved (reset to zero)        
                             1682 ; 297  |    BYTE    btMaxPower;             // (8) Maximum power consumption expressed in 2mA unit
                                  s.
                             1683 ; 298  |} Struct_Standard_Config_Desc, Struct_Other_Speed_Config_Desc;
                             1684 ; 299  |
                             1685 ; 300  |// Struct Interface Descriptor
                             1686 ; 301  |typedef struct {
                             1687 ; 302  |    BYTE    bLength;                // (0) Size of this descriptor in bytes (9)
                             1688 ; 303  |    BYTE    btDescriptorType;       // (1) Device descriptor type (4)
                             1689 ; 304  |    BYTE    btInterfaceNum;         // (2) Number of this interface. Zero-based value.
                             1690 ; 305  |    BYTE    btAlternateSetting;     // (3)                                  
                             1691 ; 306  |    BYTE    btNumEndpoints;         // (4) Number of endpointsused by this interface (excl
                                  uding endpoint 0).
                             1692 ; 307  |    BYTE    btInterfaceClass;       // (5) Class code
                             1693 ; 308  |    BYTE    btInterfaceSubClass;    // (6) Sub Class code
TASKING DSP2410 assembler v1.5r1 Build 138 SN 00100122
                                                                                                                            Page  29

M:ADDR CODE           CYCLES LINE SOURCELINE
                             1694 ; 309  |    BYTE    btInterfaceProtocol;    // (7) Protocol Code
                             1695 ; 310  |    BYTE    btIndexInterface;       // (8) Index of string descriptor describing this inte
                                  rface
                             1696 ; 311  |} Struct_Standard_Interface_Desc;
                             1697 ; 312  |
                             1698 ; 313  |// Struct Endpoint Descriptor
                             1699 ; 314  |typedef struct {
                             1700 ; 315  |    BYTE    bLength;                // (0) Size of this descriptor in bytes (7)
                             1701 ; 316  |    BYTE    btDescriptorType;       // (1) Device descriptor type (5)
                             1702 ; 317  |    BYTE    btEndpointAddress;      // (2) Address of the endpoint on the USB device descr
                                  ibed by this descriptor
                             1703 ; 318  |                                    //      Bit 3..0: Endpoint number
                             1704 ; 319  |                                    //      Bit 6..4: Reserved, reset to zero
                             1705 ; 320  |                                    //      Bit 7:    Direction. Ignored for control endpo
                                  ints (0 OUT, 1 IN)
                             1706 ; 321  |    BYTE    btBitMapAttributes;     // (3) Endpoint attributes
                             1707 ; 322  |                                    //      bits 1..0: Transfer Type (00 Control, 01 Iso, 
                                  10 Bulk, 11 Int)
                             1708 ; 323  |                                    //      bits 5..2: If not an iso endpoints, they are r
                                  eserved and must be reset to zero.
                             1709 ; 324  |                                    //      bits 7..6: Reserved bits, must be reset to zer
                                  o.                                    
                             1710 ; 325  |    BYTE    btMaxPacketSizeLsb;     // (4) Maximum packet size. Refer to standard for bits
                                   specification
                             1711 ; 326  |    BYTE    btMaxPacketSizeMsb;     // (5)
                             1712 ; 327  |    BYTE    btInterval;             // (6) Interval for polling endpoint for data transfer
                                  s (refer to standard)
                             1713 ; 328  |} Struct_Standard_Endpoint_Desc;
                             1714 ; 329  |
                             1715 ; 330  |typedef struct {
                             1716 ; 331  |    BYTE    btLength;                   // (0) Size of this descriptor in bytes (2*MAX_USB
                                  _LANG + 2)
                             1717 ; 332  |    BYTE    btDescriptorType;           // (1) String descriptor type (3)
                             1718 ; 333  |    BYTE    btString[MAX_STRING*2];       
                             1719 ; 334  |} Struct_String_Desc;
                             1720 ; 335  |
                             1721 ; 336  |//
                             1722 ; 337  |// Externals
                             1723 ; 338  |//
                             1724 ; 339  |extern void _reentrant usb_dci_chip_enable (void);
                             1725 ; 340  |extern void _reentrant usb_dci_shutdown(void);
                             1726 ; 341  |
                             1727 ; 342  |BYTE _reentrant usb_device_init(void);
                             1728 ; 343  |void _inline usb_device_shutdown(void)
                             1729 ; 344  |{
                             1730 ; 345  |    usb_dci_shutdown();
                             1731 ; 346  |}
                             1732 ; 347  |
                             1733 ; 348  |BYTE _reentrant usb_device_register_service(BYTE btType, void (* Service)(BOOL bSetup, BYT
                                  E btDirection, BYTE _USB_MEM * pbtBuffer, WORD wLength,WORD wPrivateData)); 
                             1734 ; 349  |//Remove unused function usb_device_get_service() to reclain _P memroy.
                             1735 ; 350  |//BYTE _reentrant usb_device_get_service(BYTE btType, void (* Service)(BOOL bSetup, BYTE b
                                  tDirection, BYTE _USB_MEM * pbtBuffer, WORD wLength)); 
                             1736 ; 351  |
                             1737 ; 352  |BYTE _reentrant usb_device_init_endpoint(BYTE btEndpoint, USHORT usMaxPacketSize, BYTE btD
                                  irection, BYTE btType, BOOL bFlag);
                             1738 ; 353  |
                             1739 ; 354  |extern USB_SetupData *_reentrant usb_dci_get_setup_data(BYTE btEndpoint);
                             1740 
                             1749 
                             1750 ; 355  |#define usb_device_read_setup_data(btEndpoint) usb_dci_get_setup_data(btEndpoint)
                             1751 ; 356  |
TASKING DSP2410 assembler v1.5r1 Build 138 SN 00100122
                                                                                                                            Page  30

M:ADDR CODE           CYCLES LINE SOURCELINE
                             1752 ; 357  |void _reentrant usb_device_get_status(BYTE btType, USHORT * pusStatus);
                             1753 ; 358  |void _reentrant usb_device_set_status(BYTE btType, USHORT usStatus);
                             1754 ; 359  |BYTE _reentrant usb_device_get_transfer_status(BYTE btEndpoint, BYTE btDirection);
                             1755 ; 360  |
                             1756 ; 361  |extern void _reentrant usb_dci_stall_endpoint(BYTE btEndpoint, BYTE btDirection);
                             1757 ; 362  |#define usb_device_stall_endpoint(btEndpoint, btDirection) usb_dci_stall_endpoint((btEndpo
                                  int), (btDirection))
                             1758 ; 363  |
                             1759 ; 364  |extern void _reentrant usb_dci_unstall_endpoint(BYTE btEndpoint, BYTE btDirection);
                             1760 ; 365  |#define usb_device_unstall_endpoint(btEndpoint, btDirection) usb_dci_unstall_endpoint((btE
                                  ndpoint), (btDirection))
                             1761 ; 366  |
                             1762 ; 367  |extern void _reentrant usb_dci_finish_transaction(BYTE btEndpoint);
                             1763 ; 368  |#define usb_device_finish_transaction(btEndpoint) usb_dci_finish_transaction(btEndpoint);
                             1764 ; 369  |
                             1765 ; 370  |////////////////////////////////////////////////////////////////////////////////
                             1766 ; 371  |//
                             1767 ; 372  |//>  Name:          usb_device_enable
                             1768 ; 373  |//
                             1769 ; 374  |//   Type:          Function
                             1770 ; 375  |//
                             1771 ; 376  |//   Description:   Enables the USB device for transfers
                             1772 ; 377  |//
                             1773 ; 378  |//   Inputs:        none
                             1774 ; 379  |//
                             1775 ; 380  |//   Outputs:       USB_OK or error code
                             1776 ; 381  |//
                             1777 ; 382  |//   Notes:         none
                             1778 ; 383  |//<
                             1779 ; 384  |////////////////////////////////////////////////////////////////////////////////
                             1780 ; 385  |void _inline usb_device_enable(void)
                             1781 ; 386  |{
                             1782 ; 387  |    usb_dci_chip_enable();
                             1783 ; 388  |}
                             1784 ; 389  |
                             1785 ; 390  |void _reentrant usb_device_release(void);
                             1786 ; 391  |void _reentrant usb_device_hold(void);
                             1787 ; 392  |BYTE _reentrant usb_device_is_hold(void);
                             1788 ; 393  |void _reentrant usb_device_data_phase_required(void);
                             1789 ; 394  |
                             1790 ; 395  |BOOL _reentrant usb_device_is_first_init(void);
                             1791 ; 396  |void _reentrant usb_device_set_first_init(void);
                             1792 ; 397  |void _reentrant usb_device_clear_first_init(void);
                             1793 ; 398  |
                             1794 ; 399  |WORD _reentrant usb_get_current_limit(void);
                             1795 ; 400  |RETCODE _reentrant usb_set_current_limit(WORD);
                             1796 ; 401  |
                             1797 ; 402  |////////////////////////////////////////////////////////////////////
                             1798 ; 403  |extern BYTE _reentrant usb_dci_get_endpoint_status(BYTE btEndpoint);
                             1799 ; 404  |#define usb_device_get_endpoint_status(btEndpoint) usb_dci_get_endpoint_status(btEndpoint)
                                  
                             1800 ; 405  |
                             1801 ; 406  |#define USB_ENDPOINT_STATUS_OK                          0
                             1802 ; 407  |#define USB_ENDPOINT_STATUS_STALLED                     1
                             1803 ; 408  |#define USB_ENDPOINT_STATUS_RECIEVED_UNSTALL_REQUEST    2
                             1804 ; 409  |// WHQL
                             1805 ; 410  |#define USB_ENDPOINT_STATUS_HOST_STALLED                3
                             1806 ; 411  |////////////////////////////////////////////////////////////////////
                             1807 ; 412  |
                             1808 ; 413  |
                             1809 ; 414  |BYTE _reentrant usb_device_send_data(BYTE btEndpoint, WORD _X * pbtStmpWordAdd, BYTE btByt
                                  eOffset, USHORT usSize, WORD wPrivateData, BOOL bIsDataPhase);
TASKING DSP2410 assembler v1.5r1 Build 138 SN 00100122
                                                                                                                            Page  31

M:ADDR CODE           CYCLES LINE SOURCELINE
                             1810 ; 415  |BYTE _reentrant usb_device_recv_data(BYTE btEndpoint, WORD _X * pbtStmpWordAdd, BYTE btByt
                                  eOffset, USHORT usSize, WORD wPrivateData, BOOL bIsDataPhase);
                             1811 ; 416  |void _reentrant ch9ServiceEp0(BOOL bSetup, BYTE btDirection, WORD _X *pbtBuffer, WORD wLen
                                  gth,WORD wPrivateData);
                             1812 ; 417  |BYTE _reentrant usb_device_transfer_data(BYTE btEndpoint, WORD _X* pbtStmpWordAdd, 
                             1813 ; 418  |                                         BYTE btByteOffset, USHORT usSize, WORD wPrivateDa
                                  ta, 
                             1814 ; 419  |                                         BOOL bIsDataPhase, WORD wDirection);
                             1815 ; 420  |
                             1816 ; 421  |#ifndef CUSTOMIZE_UNICODE
                             1817 ; 422  |extern const BYTE g_Manufacturer[];
                             1818 ; 423  |extern const BYTE g_ProductName[];
                             1819 ; 424  |extern const BYTE g_ConfigString[];
                             1820 ; 425  |extern const BYTE g_Interface0String[];
                             1821 ; 426  |extern const BYTE g_Interface1String[];
                             1822 ; 427  |extern const BYTE g_MSOSDescriptorString[];
                             1823 ; 428  |#else   // CUSTOMIZE_UNICODE
                             1824 ; 429  |extern const WORD g_Manufacturer[];
                             1825 ; 430  |extern const WORD g_ProductName[];
                             1826 ; 431  |extern const WORD g_ConfigString[];
                             1827 ; 432  |extern const WORD g_Interface0String[];
                             1828 ; 433  |extern const WORD g_Interface1String[];
                             1829 ; 434  |extern const WORD g_MSOSDescriptorString[];
                             1830 ; 435  |#endif
                             1831 ; 436  |extern WORD g_LanguageList[];
                             1832 ; 437  |
                             1833 ; 438  |extern const BYTE g_SCSIVendorID[];
                             1834 ; 439  |extern const BYTE g_SCSIProductID[];
                             1835 ; 440  |extern void *g_pStrings[];
                             1836 ; 441  |
                             1837 ; 442  |extern WORD g_wUSBVendorID;
                             1838 ; 443  |extern WORD g_wUSBProductID;
                             1839 ; 444  |extern WORD g_wUSBReleaseID;
                             1840 ; 445  |
                             1841 ; 446  |#endif
                             1842 ; 447  |/* EOF */
                             1843 ; 448  |
                             1844 
                             1846 
                             1847 ; 9    |#include "..\usb_internal.h"
                             1848 
                             1850 
                             1851 ; 1    |#ifndef _USB_INTERNAL_H
                             1852 ; 2    |#define _USB_INTERNAL_H
                             1853 ; 3    |
                             1854 ; 4    |#include "project.h"
                             1855 
                             1857 
                             1858 ; 1    |/////////////////////////////////////////////////////////////////////////////////
                             1859 ; 2    |//  Copyright(C) SigmaTel, Inc. 2000-2004
                             1860 ; 3    |//  Filename: project.inc
                             1861 ; 4    |//  Description: 
                             1862 ; 5    |/////////////////////////////////////////////////////////////////////////////////
                             1863 ; 6    |
                             1864 ; 7    |#if (!defined(_PROJECT_INC))
                             1865 ; 8    |#define _PROJECT_INC 1
                             1866 ; 9    |
                             1867 ; 10   |#if defined(STMP_BUILD_PLAYER)
                             1868 ; 11   |#include "hwequ.h"
                             1869 ; 12   |#else 
                             1870 ; 13   |//include "regscodec.inc"
                             1871 ; 14   |#endif
TASKING DSP2410 assembler v1.5r1 Build 138 SN 00100122
                                                                                                                            Page  32

M:ADDR CODE           CYCLES LINE SOURCELINE
                             1872 ; 15   |
                             1873 ; 16   |//////////////////////////////////////////////////////////////////////////////////
                             1874 ; 17   |// Uncomment next define to allow player boot if you have stfm1000 macro enabled (defaults
                                   ON) & 
                             1875 ; 18   |// your board crystal is not able to output nominal voltage range. Used in player main.asm
                                  . STMP00012148
                             1876 ; 19   |// Defining this will result in lower battery life (price of using a lower quality crystal
                                  ). 
                             1877 ; 20   |// Those that want to save battery life and have good crystals that meet our HW team's spe
                                  cs can 
                             1878 ; 21   |// comment out this line to reduce crystal bias current and so battery current in player m
                                  ode.  
                             1879 ; 22   |#define SUPPORT_MARGINAL_XTALS 1
                             1880 ; 23   |
                             1881 ; 24   |/////////////////////////////////////////////////////////////////////////////////
                             1882 ; 25   |// BOOT SPEED CONFIG & ASSOCIATED BATTERY VOLTAGE CHECK ENABLE
                             1883 ; 26   |/////////////////////////////////////////////////////////////////////////////////
                             1884 ; 27   |// Users can enable one of ATTEMPT_FAST_BOOT or FASTEST boot or neither project define bel
                                  ow by defining
                             1885 ; 28   |// values as 0 or 1, else it defaults to the boot speed used in previous SDKs.
                             1886 ; 29   |#define ATTEMPT_FAST_BOOT 1
                             1887 ; 30   |#define ATTEMPT_FASTEST_BOOT 0   
                             1888 ; 31   |// Changing this define to 0 removes Vbat threshholding & unconditionally gives fast boot 
                                  config above- 
                             1889 ; 32   |// disabling this check is suggested for profiling if you want to try to tweak down thresh
                                  holds by maybe 50mV.
                             1890 ; 33   |// Also the tests should clear the fast boot config defines to link & boot at normal speed
                                  .
                             1891 ; 34   |#define SPEED_BOOT_BATTERY_CHECK 1
                             1892 ; 35   |
                             1893 ; 36   |/////////////////////////////////////////////////////////////////////////////////
                             1894 ; 37   |// MEDIA DEFINITIONS
                             1895 ; 38   |/////////////////////////////////////////////////////////////////////////////////
                             1896 ; 39   |
                             1897 ; 40   |/////////////////////////////////////////////////////////////////////////////////
                             1898 ; 41   |// MNAND - Number of chips forming the internal physical device (i.e. # of NANDs)
                             1899 ; 42   |#if defined(NAND1)
                             1900 ; 43   |#define SM_INTERNAL_CHIPS 1
                             1901 ; 44   |#else 
                             1902 ; 45   |#if defined(NAND2)
                             1903 ; 46   |#define SM_INTERNAL_CHIPS 2
                             1904 ; 47   |#else 
                             1905 ; 48   |#if defined(NAND3)
                             1906 ; 49   |#define SM_INTERNAL_CHIPS 3
                             1907 ; 50   |#else 
                             1908 ; 51   |#if defined(NAND4)
                             1909 ; 52   |#define SM_INTERNAL_CHIPS 4
                             1910 ; 53   |#else 
                             1911 ; 54   |#define SM_INTERNAL_CHIPS 1
                             1912 ; 55   |#endif
                             1913 ; 56   |#endif
                             1914 ; 57   |#endif
                             1915 ; 58   |#endif
                             1916 ; 59   |
                             1917 ; 60   |/////////////////////////////////////////////////////////////////////////////////
                             1918 ; 61   |// If SMARTMEDIA_DETECT_ACTIVE_HIGH is defined:
                             1919 ; 62   |//   SmartMedia will be detected as inserted if the GPIO pin reads 1 and removed if it rea
                                  ds 0.  
                             1920 ; 63   |// If SMARTMEDIA_DETECT_ACTIVE_HIGH is not defined ** comment out next line **
                             1921 ; 64   |//   SmartMedia will be detected as inserted if the GPIO pin reads 0 and removed if it rea
                                  ds 1.
                             1922 ; 65   |//*** comment out if active high ****
TASKING DSP2410 assembler v1.5r1 Build 138 SN 00100122
                                                                                                                            Page  33

M:ADDR CODE           CYCLES LINE SOURCELINE
                             1923 ; 66   |//SMARTMEDIA_DETECT_ACTIVE_HIGH  equ     1
                             1924 ; 67   |
                             1925 ; 68   |#if defined(SMEDIA)
                             1926 ; 69   |#define NUM_REMOVABLE_MEDIA 1
                             1927 ; 70   |#define NUM_SM_EXTERNAL 1
                             1928 ; 71   |#define MMC_MAX_PHYSICAL_DEVICES 0
                             1929 ; 72   |#define SM_MAX_LOGICAL_DEVICES 2
                             1930 ; 73   |#else 
                             1931 ; 74   |#if defined(MMC)
                             1932 ; 75   |#define NUM_REMOVABLE_MEDIA 1
                             1933 ; 76   |#define NUM_SM_EXTERNAL 0
                             1934 ; 77   |#define MMC_MAX_PHYSICAL_DEVICES 1
                             1935 ; 78   |#define SM_MAX_LOGICAL_DEVICES 1
                             1936 ; 79   |#else 
                             1937 ; 80   |#define NUM_REMOVABLE_MEDIA 0
                             1938 ; 81   |#define NUM_SM_EXTERNAL 0
                             1939 ; 82   |#define MMC_MAX_PHYSICAL_DEVICES 0
                             1940 ; 83   |#define SM_MAX_LOGICAL_DEVICES 1
                             1941 ; 84   |#endif
                             1942 ; 85   |#endif
                             1943 ; 86   |
                             1944 ; 87   |/////////////////////////////////////////////////////////////////////////////////
                             1945 ; 88   |// Mass Storage Class definitions
                             1946 ; 89   |/////////////////////////////////////////////////////////////////////////////////
                             1947 ; 90   |// Set to 0 if Composite Device build is desired.    
                             1948 ; 91   |#define MULTI_LUN_BUILD 1   
                             1949 ; 92   |
                             1950 ; 93   |////////////////////////////////////////////////////////////////////////////////
                             1951 ; 94   |//  SCSI
                             1952 ; 95   |#if (MULTI_LUN_BUILD==0)
                             1953 ; 96   |  #if (NUM_REMOVABLE_MEDIA == 1)
                             1954 ; 97   |    #define SCSI_NUM_TARGETS                        2
                             1955 ; 98   |    #define SCSI_DEVICE_NUM_LUNS_DEV_0              1
                             1956 ; 99   |    #define SCSI_DEVICE_NUM_LUNS_DEV_1              1
                             1957 ; 100  |  #else
                             1958 ; 101  |    #define SCSI_NUM_TARGETS                        1
                             1959 ; 102  |    #define SCSI_DEVICE_NUM_LUNS_DEV_0              1
                             1960 ; 103  |  #endif
                             1961 ; 104  |#else
                             1962 ; 105  |    #define SCSI_NUM_TARGETS                        1
                             1963 ; 106  |  #if (NUM_REMOVABLE_MEDIA == 1)
                             1964 ; 107  |    #define SCSI_DEVICE_NUM_LUNS_DEV_0              2
                             1965 ; 108  |  #else
                             1966 ; 109  |    #define SCSI_DEVICE_NUM_LUNS_DEV_0              1  
                             1967 ; 110  |  #endif
                             1968 ; 111  |#endif
                             1969 ; 112  |
                             1970 ; 113  |
                             1971 ; 114  |#define USBMSC_NUM_DEVICES                      SCSI_NUM_TARGETS
                             1972 ; 115  |
                             1973 ; 116  |
                             1974 ; 117  |////////////////////////////////////////////////////////////////////////////////
                             1975 ; 118  |// Define number of logical medias and drives for three builds (MTP, USBMSC, and Player)
                             1976 ; 119  |////////////////////////////////////////////////////////////////////////////////
                             1977 ; 120  |#ifdef MMC
                             1978 ; 121  |#ifdef MTP_BUILD
                             1979 ; 122  |// --------------------
                             1980 ; 123  |// MTP and MMC
                             1981 ; 124  |// --------------------
                             1982 ; 125  |#define NUM_LOGICAL_MEDIA       2
                             1983 ; 126  |#define NUM_LOGICAL_DRIVES      8
                             1984 ; 127  |#else  // ifndef MTP_BUILD
TASKING DSP2410 assembler v1.5r1 Build 138 SN 00100122
                                                                                                                            Page  34

M:ADDR CODE           CYCLES LINE SOURCELINE
                             1985 ; 128  |#ifdef STMP_BUILD_PLAYER
                             1986 ; 129  |// --------------------
                             1987 ; 130  |// Player and MMC
                             1988 ; 131  |// --------------------
                             1989 ; 132  |#else
                             1990 ; 133  |// --------------------
                             1991 ; 134  |// USBMSC and MMC
                             1992 ; 135  |// --------------------
                             1993 ; 136  |#define NUM_LOGICAL_MEDIA       3
                             1994 ; 137  |#define NUM_LOGICAL_DRIVES      8
                             1995 ; 138  |#endif // ifdef STMP_BUILD_PLAYER
                             1996 ; 139  |#endif // ifdef MTP_BUILD
                             1997 ; 140  |#else  // ifndef MMC
                             1998 ; 141  |#ifdef MTP_BUILD
                             1999 ; 142  |// --------------------
                             2000 ; 143  |// MTP and NAND only
                             2001 ; 144  |// --------------------
                             2002 ; 145  |#define NUM_LOGICAL_MEDIA       1
                             2003 ; 146  |#define NUM_LOGICAL_DRIVES      7
                             2004 ; 147  |#else  // ifndef MTP_BUILD
                             2005 ; 148  |#ifdef STMP_BUILD_PLAYER
                             2006 ; 149  |// --------------------
                             2007 ; 150  |// Player and NAND only
                             2008 ; 151  |// --------------------
                             2009 ; 152  |#else
                             2010 ; 153  |// --------------------
                             2011 ; 154  |// USBMSC and NAND only
                             2012 ; 155  |// --------------------
                             2013 ; 156  |#define NUM_LOGICAL_MEDIA       2
                             2014 ; 157  |#define NUM_LOGICAL_DRIVES      7
                             2015 ; 158  |#endif // ifdef STMP_BUILD_PLAYER
                             2016 ; 159  |#endif // ifdef MTP_BUILD
                             2017 ; 160  |#endif // ifdef MMC 
                             2018 ; 161  |
                             2019 ; 162  |// If we are in an MTP build then we don't use as many transfers buffers.
                             2020 ; 163  |#if (defined(MTP_BUILD))
                             2021 ; 164  |#define MAX_USB_TRANSFERS_QUEUED 16
                             2022 ; 165  |
                             2023 ; 166  |////!
                             2024 ; 167  |////! This varible holds the watchdog count for the store flush.
                             2025 ; 168  |////!
                             2026 ; 169  |///
                             2027 ; 170  |#include <types.h>
                             2028 ; 171  |extern volatile INT g_StoreWatchDogCount;
                             2029 ; 172  |extern const INT g_StoreWatchDogTimeout;
                             2030 ; 173  |#endif
                             2031 ; 174  |
                             2032 ; 175  |////////////////////////////////////////////////////////////////////////////////
                             2033 ; 176  |// These are needed here for Mass Storage Class
                             2034 ; 177  |// Needs to be cleaned up
                             2035 ; 178  |////////////////////////////////////////////////////////////////////////////////
                             2036 ; 179  |#if (!defined(STMP_BUILD_PLAYER))
                             2037 ; 180  |#define SCRATCH_USER_Y_SIZE 512
                             2038 ; 181  |#define SCRATCH_USER_X_SIZE 512
                             2039 ; 182  |
                             2040 ; 183  |#define BROWNOUT_LEVEL1_DETECTED                0x000001
                             2041 ; 184  |
                             2042 ; 185  |#endif
                             2043 ; 186  |
                             2044 ; 187  |
                             2045 ; 188  |/////////////////////////////////////////////////////////////////////////////////
                             2046 ; 189  |// SmartMedia/NAND defs
TASKING DSP2410 assembler v1.5r1 Build 138 SN 00100122
                                                                                                                            Page  35

M:ADDR CODE           CYCLES LINE SOURCELINE
                             2047 ; 190  |#define SM_MAX_PHYSICAL_DEVICES SM_INTERNAL_CHIPS+NUM_SM_EXTERNAL
                             2048 ; 191  |#define SM_REMOVABLE_DEVICE_NUM SM_INTERNAL_CHIPS
                             2049 ; 192  |
                             2050 ; 193  |/////////////////////////////////////////////////////////////////////////////////
                             2051 ; 194  |// Sysloadresources defs
                             2052 ; 195  |#define SM_MAX_RESOURCE_DEVICES SM_INTERNAL_CHIPS+NUM_SM_EXTERNAL
                             2053 ; 196  |
                             2054 ; 197  |/////////////////////////////////////////////////////////////////////////////////
                             2055 ; 198  |// MMC defs
                             2056 ; 199  |#define MMC_MAX_PARTITIONS 1
                             2057 ; 200  |#define MMC_MAX_LOGICAL_DEVICES MMC_MAX_PHYSICAL_DEVICES*MMC_MAX_PARTITIONS
                             2058 ; 201  |
                             2059 ; 202  |/////////////////////////////////////////////////////////////////////////////////
                             2060 ; 203  |// SPI defs
                             2061 ; 204  |#define SPI_MAX_DEVICES MMC_MAX_PHYSICAL_DEVICES
                             2062 ; 205  |
                             2063 ; 206  |/////////////////////////////////////////////////////////////////////////////////
                             2064 ; 207  |// Global media defs
                             2065 ; 208  |#define MAX_PHYSICAL_DEVICES SM_MAX_PHYSICAL_DEVICES+MMC_MAX_PHYSICAL_DEVICES
                             2066 ; 209  |#define MAX_LOGICAL_DEVICES SM_MAX_LOGICAL_DEVICES+MMC_MAX_LOGICAL_DEVICES
                             2067 ; 210  |
                             2068 ; 211  |/////////////////////////////////////////////////////////////////////////////////
                             2069 ; 212  |// DO NOT CHANGE THESE!!!
                             2070 ; 213  |#define SM_MAX_PARTITIONS 4
                             2071 ; 214  |#define MAX_HANDLES 2
                             2072 ; 215  |/////////////////////////////////////////////////////////////////////////////////
                             2073 ; 216  |
                             2074 ; 217  |
                             2075 ; 218  |/////////////////////////////////////////////////////////////////////////////////
                             2076 ; 219  |// Battery LRADC Values 
                             2077 ; 220  |/////////////////////////////////////////////////////////////////////////////////
                             2078 ; 221  |// brownout trip point in mV (moved by RS)
                             2079 ; 222  |// BATT_SAFETY_MARGIN:  percentage value used by:
                             2080 ; 223  |//   * SysSaveSettings to determine if enough power is left to attempt a settings save. 
                             2081 ; 224  |//   * Recorder to conditionally prevent the start or continuation of 
                             2082 ; 225  |//     audio recording to media.
                             2083 ; 226  |#define BATT_SAFETY_MARGIN 10
                             2084 ; 227  |
                             2085 ; 228  |//; player resource drive refresh allowed only when battery usable % is above this value. 
                                  
                             2086 ; 229  |//; 50% of usable range [0.9V to 1.5V] is around 1.2V This is the safe target alkaline vol
                                  tage to do a refresh.
                             2087 ; 230  |//; LIION will also require 50% which will work but that could be changed in the future. 
                             2088 ; 231  |//RESOURCE_REFRESH_MIN_BATT_PCT equ 50
                             2089 ; 232  |
                             2090 ; 233  |// stmp00005071 adds these for mp3 encode stability at low battery per battery type & mmc 
                                  presence.
                             2091 ; 234  |
                             2092 ; 235  |//// Vbat threshholds empirically tuned by profiling max bat current for 3 HW cases: 
                             2093 ; 236  |//// 1 GigaByte MMC, NAND flash only, & LiIon Buck mode. See voicemenu pre-encode Vbat che
                                  ck.
                             2094 ; 237  |#if (!defined(CLCD))
                             2095 ; 238  |#define MP3_ENC_MMC_MIN_V_BAT_MV 1100
                             2096 ; 239  |#define MP3_ENC_NANDONLY_MIN_V_BAT_MV 1000
                             2097 ; 240  |#else 
                             2098 ; 241  |#define MP3_ENC_MMC_MIN_V_BAT_MV 1250
                             2099 ; 242  |#define MP3_ENC_NANDONLY_MIN_V_BAT_MV 1150
                             2100 ; 243  |#endif
                             2101 ; 244  |#define MP3_ENC_BUCKMODE_MIN_V_BAT_MV 3300
                             2102 ; 245  |
                             2103 ; 246  |// These Vbat use-range-percentages are derived to correspond with target battery 
TASKING DSP2410 assembler v1.5r1 Build 138 SN 00100122
                                                                                                                            Page  36

M:ADDR CODE           CYCLES LINE SOURCELINE
                             2104 ; 247  |// voltages of 1.10V for MMC, 1.0V for nand only (alkaline or nimh), and 3.3V for any LiIo
                                  n.
                             2105 ; 248  |// See mp3 encoder overlay.
                             2106 ; 249  |#define MP3_ENC_MMC_MIN_V_BAT_RANGE_PCT 33
                             2107 ; 250  |#define MP3_ENC_NANDONLY_MIN_V_BAT_RANGE_PCT 17
                             2108 ; 251  |#define MP3_ENC_BUCKMODE_MIN_V_BAT_RANGE_PCT 25
                             2109 ; 252  |
                             2110 ; 253  |/////////////////////////////////////////////////////////////////////////////////
                             2111 ; 254  |// Voice recording filenames
                             2112 ; 255  |// number of digits in filename Vxxx.wav
                             2113 ; 256  |/////////////////////////////////////////////////////////////////////////////////
                             2114 ; 257  |#define DIGITS_IN_VOICE_FILENAME 3   
                             2115 ; 258  |
                             2116 ; 259  |/////////////////////////////////////////////////////////////////////////////////
                             2117 ; 260  |// Mic Bias: Set this enable to 1 to internally generate mic bias voltage. 
                             2118 ; 261  |// Also below, must configure internal resistor value and pin to use for DC bias. 
                             2119 ; 262  |// Can set to 0 to disable internally generated mic bias voltage at pin lradc1/2.
                             2120 ; 263  |#if defined(DEVICE_3500)
                             2121 ; 264  |#define ENABLE_INTERNALLY_GENERATED_MICBIAS 1 
                             2122 ; 265  |// MIC BIAS circuit source selection: use Low Resolution ADC pin 2 or 1 to bias mic. 
                             2123 ; 266  |// Per your layout: select LRADC 2 or 1 below 
                             2124 ; 267  |//   (pin LRADC 2 for 35xx cpu card revB, LRADC 1 for 35xx cpu card revC, ref schematics, 
                                  & demo player)
                             2125 ; 268  |#define LRADC_NUM_FOR_MIC_BIAS 1 
                             2126 ; 269  |// Sets internal mic bias R to value 2, 4, or 8 (in kOhms).
                             2127 ; 270  |#define MICBIAS_CONFIGURED_RESISTOR_KOHMS 8
                             2128 ; 271  |
                             2129 ; 272  |// Allows mic bias to settle before sampling. This delay currently unused. For rec btn whe
                                  n bias not yet ready.
                             2130 ; 273  |#define REC_BTN_INTERNAL_MIC_BIAS_SETTLING_DELAY_MS 400 
                             2131 ; 274  |// Option always keeps bias enabled after mainmenu init. This allows for start pop prevent
                                  ion if you use rec button from outside voice menu.
                             2132 ; 275  |// This selection costs 1 mWatt but gains the desired low record button to sampling latenc
                                  y in the record-from-music-menu use-case.
                             2133 ; 276  |#define KEEP_MIC_BIAS_ENABLED 0
                             2134 ; 277  |
                             2135 ; 278  |#else 
                             2136 ; 279  |// STMP3410
                             2137 ; 280  |#define ENABLE_INTERNALLY_GENERATED_MICBIAS 0
                             2138 ; 281  |#define LRADC_NUM_FOR_MIC_BIAS 1 
                             2139 ; 282  |#define MICBIAS_CONFIGURED_RESISTOR_KOHMS 2
                             2140 ; 283  |#endif
                             2141 ; 284  |
                             2142 ; 285  |/////////////////////////////////////////////////////////////////////////////////
                             2143 ; 286  |// Number of available soft timers
                             2144 ; 287  |/////////////////////////////////////////////////////////////////////////////////
                             2145 ; 288  |#if defined(SYNC_LYRICS)
                             2146 ; 289  |#define SOFT_TIMERS 10
                             2147 ; 290  |#else 
                             2148 ; 291  |#if defined(JPEG_DECODER)
                             2149 ; 292  |#define SOFT_TIMERS 10
                             2150 ; 293  |#else 
                             2151 ; 294  |#define SOFT_TIMERS 9
                             2152 ; 295  |#endif
                             2153 ; 296  |#endif
                             2154 ; 297  |
                             2155 ; 298  |/////////////////////////////////////////////////////////////////////////////////
                             2156 ; 299  |//  sizes
                             2157 ; 300  |/////////////////////////////////////////////////////////////////////////////////
                             2158 ; 301  |#if defined(MMC)
                             2159 ; 302  |#if defined(USE_PLAYLIST5)
                             2160 ; 303  |#define MENU_STACK_SIZE 1500
TASKING DSP2410 assembler v1.5r1 Build 138 SN 00100122
                                                                                                                            Page  37

M:ADDR CODE           CYCLES LINE SOURCELINE
                             2161 ; 304  |#else 
                             2162 ; 305  |#define MENU_STACK_SIZE 1250
                             2163 ; 306  |#endif //if @def('USE_PLAYLIST5')
                             2164 ; 307  |#else 
                             2165 ; 308  |#if defined(USE_PLAYLIST5)
                             2166 ; 309  |#define MENU_STACK_SIZE 1500
                             2167 ; 310  |#else 
                             2168 ; 311  |#define MENU_STACK_SIZE 1250
                             2169 ; 312  |#endif //if @def('USE_PLAYLIST5')
                             2170 ; 313  |#endif //if @def('MMC')
                             2171 ; 314  |
                             2172 ; 315  |// NOTE: SDK2.6 USED 550 FOR NEXT LINE, BUT SDK3.0BETA USED 750. Should it be ifdef MTP 75
                                  0 else 550 for other builds? TOVERIFY. MYALLOC
                             2173 ; 316  |// 
                             2174 ; 317  |#define STACK_L1_SIZE 750
                             2175 ; 318  |#define STACK_L2_SIZE 100
                             2176 ; 319  |#define STACK_L3_SIZE 160
                             2177 ; 320  |
                             2178 ; 321  |// If we are in MTP mode the overlay task stack can shrink.
                             2179 ; 322  |// TODO shrink this stack for MTP, I will leave it at 500 until we verify that it 
                             2180 ; 323  |// is ok with switching code.
                             2181 ; 324  |#if defined(MTP_BUILD)
                             2182 ; 325  |#define OVERLAY_MANAGER_STACK_SIZE 300
                             2183 ; 326  |#endif
                             2184 ; 327  |
                             2185 ; 328  |/////////////////////////////////////////////////////////////////////////////////
                             2186 ; 329  |// maximum number of nested funclets 
                             2187 ; 330  |/////////////////////////////////////////////////////////////////////////////////
                             2188 ; 331  |#define MAX_NESTED_FUNCLET 6 
                             2189 ; 332  |
                             2190 ; 333  |/////////////////////////////////////////////////////////////////////////////////
                             2191 ; 334  |//    LCD DEFINITIONS
                             2192 ; 335  |/////////////////////////////////////////////////////////////////////////////////
                             2193 ; 336  |
                             2194 ; 337  |#define SPACE_CHAR 0x000020          
                             2195 ; 338  |#define ZERO_CHAR 0x000030
                             2196 ; 339  |#define COLON_CHAR 0x00003A
                             2197 ; 340  |#define PERIOD_CHAR 0x00002E
                             2198 ; 341  |
                             2199 ; 342  |#if (defined(S6B33B0A_LCD))
                             2200 ; 343  |#define LCD_X_SIZE 128
                             2201 ; 344  |#define LCD_Y_SIZE 159
                             2202 ; 345  |#endif
                             2203 ; 346  |
                             2204 ; 347  |#if (defined(SED15XX_LCD))
                             2205 ; 348  |#define LCD_X_SIZE 128
                             2206 ; 349  |#define LCD_Y_SIZE 64
                             2207 ; 350  |#endif
                             2208 ; 351  |
                             2209 ; 352  |
                             2210 ; 353  |//////////////////////////////////////////////////////////////////////////////////
                             2211 ; 354  |//   Details on Customizing Contrast
                             2212 ; 355  |/////////////////////////////////////////////////////////////////////////////////
                             2213 ; 356  |//   Max supported LCD range is 0 - 3F; however due to hardware/voltage differences
                             2214 ; 357  |//   the range of visibility is usually smaller than this.  It is important to 
                             2215 ; 358  |//   calibrate the visible range, because the contrast setting is saved.
                             2216 ; 359  |//   If the user shuts off the player while lcd is not visible, the player is useless
                             2217 ; 360  |//   unless the ezact sequence is remembered.
                             2218 ; 361  |//   To find out what range your player supports: 
                             2219 ; 362  |//   change these equs to full range or comment out (full range is default)
                             2220 ; 363  |//;;;;;;
                             2221 ; 364  |// uncomment the line below to build code that will provide raw contrast value
TASKING DSP2410 assembler v1.5r1 Build 138 SN 00100122
                                                                                                                            Page  38

M:ADDR CODE           CYCLES LINE SOURCELINE
                             2222 ; 365  |// recommended calibration using player -- uncomment 
                             2223 ; 366  |//;;;;;;
                             2224 ; 367  |//CONTRAST_CALIBRATION    equ  1
                             2225 ; 368  |////////////////////////////
                             2226 ; 369  |#if (defined(DEMO_HW))
                             2227 ; 370  |// this is the setting for ET301 demos; Next 2 line have not been updated for new Shingyi 
                                  LCD (June6'05)
                             2228 ; 371  |#define LCD_MAX_CONTRAST 0x32 
                             2229 ; 372  |#define LCD_MIN_CONTRAST 0x1E
                             2230 ; 373  |#else 
                             2231 ; 374  |
                             2232 ; 375  |#if (defined(S6B33B0A_LCD))
                             2233 ; 376  |#define LCD_MAX_CONTRAST 210
                             2234 ; 377  |#define LCD_MIN_CONTRAST 160    
                             2235 ; 378  |#endif
                             2236 ; 379  |
                             2237 ; 380  |#if (defined(SED15XX_LCD))
                             2238 ; 381  |// Next 3 line comment was for OLD shingyi LCD: (default LCD before sdk2.6)
                             2239 ; 382  |// Engineering board regs support range [17-37].
                             2240 ; 383  |//   Engineering board DC/DC support range [24-46]. 
                             2241 ; 384  |//   One default contrast range [24-42] works for both.
                             2242 ; 385  |// The 3 sets of contrast ranges below are updated for SDK2.6 to support either 
                             2243 ; 386  |// new or old ShingYih LCDs. "File" refers to \resource\shingyih\system_lcd_init_seq.src
                             2244 ; 387  |// 3/10/05 - Use one of the 2 next contrast ranges depending on which
                             2245 ; 388  |// ShingYih LCD you have.  See \resources\shingyi\readme.txt 
                             2246 ; 389  |// Optimal for NEW LCD with NEW file (SDK2.6 default)  
                             2247 ; 390  |// G098064-41 LCD module (present on engr board revH LCD card)
                             2248 ; 391  |
                             2249 ; 392  |#if (defined(NEWSHINGYIH))
                             2250 ; 393  |#define LCD_MAX_CONTRAST 250
                             2251 ; 394  |#define LCD_MIN_CONTRAST 0
                             2252 ; 395  |#else 
                             2253 ; 396  |//-----
                             2254 ; 397  |// Near optimal for OLD LCD with NEW file. 
                             2255 ; 398  |// NOT optimal for the new lcd but pretty good. So u may use this if u want 1 build for bo
                                  th LCDs.
                             2256 ; 399  |#define LCD_MAX_CONTRAST 250
                             2257 ; 400  |#define LCD_MIN_CONTRAST 0
                             2258 ; 401  |
                             2259 ; 402  |//=====
                             2260 ; 403  |// Optimal for OLD ShingYih LCD with OLD file (as sdk2.521)
                             2261 ; 404  |// Suggest going with default new init file & values above for your LCD instead of this hi
                                  storic ver.
                             2262 ; 405  |//LCD_MAX_CONTRAST equ 42
                             2263 ; 406  |//LCD_MIN_CONTRAST equ 24 
                             2264 ; 407  |
                             2265 ; 408  |#endif
                             2266 ; 409  |#endif
                             2267 ; 410  |
                             2268 ; 411  |#endif
                             2269 ; 412  |
                             2270 ; 413  |//////////////////////////////////////////////////////////////////////////////////
                             2271 ; 414  |// The default value of the lcd contrast in % of range
                             2272 ; 415  |//   the default value is used when no settings.dat is available
                             2273 ; 416  |//////////////////////////////////////////////////////////////////////////////////
                             2274 ; 417  |
                             2275 ; 418  |#if (defined(S6B33B0A_LCD))
                             2276 ; 419  |// 60% of range is default value
                             2277 ; 420  |#define DEFAULT_CONTRAST 50 
                             2278 ; 421  |#endif
                             2279 ; 422  |
                             2280 ; 423  |#if (defined(SED15XX_LCD))
TASKING DSP2410 assembler v1.5r1 Build 138 SN 00100122
                                                                                                                            Page  39

M:ADDR CODE           CYCLES LINE SOURCELINE
                             2281 ; 424  |// % of range is default value (was 60%)
                             2282 ; 425  |#define DEFAULT_CONTRAST 50 
                             2283 ; 426  |#endif
                             2284 ; 427  |
                             2285 ; 428  |
                             2286 ; 429  |// percentage change per increment/decrement message (LCD_DEC_CONTRAST/LCD_INC_CONTRAST)
                             2287 ; 430  |// make lower when doing calibration
                             2288 ; 431  |#define LCD_STEPSIZE_CONTRAST 10  
                             2289 ; 432  |
                             2290 ; 433  |
                             2291 ; 434  |/////////////////////////////////////////////////////////////////////////////////
                             2292 ; 435  |// For FFWD and RWND
                             2293 ; 436  |/////////////////////////////////////////////////////////////////////////////////
                             2294 ; 437  |#define SECONDS_TO_SKIP 1
                             2295 ; 438  |#define SECONDS_TO_SKIP1 3
                             2296 ; 439  |#define SECONDS_TO_SKIP2 6
                             2297 ; 440  |// number of seconds to cause reset to begin of song for PREV push
                             2298 ; 441  |#define PREV_SONG_THRESHOLD 5  
                             2299 ; 442  |// number of 300 mSec periods before the numbers of seconds to skip increases
                             2300 ; 443  |#define FIRST_TIME_BOUNDARY 15 
                             2301 ; 444  |// number of 300 mSec periods before the numbers of seconds to skip increases
                             2302 ; 445  |#define SECOND_TIME_BOUNDARY 30 
                             2303 ; 446  |
                             2304 ; 447  |// For audible FFW/RWD
                             2305 ; 448  |#define SECONDS_TO_SKIP_FOR_3X_RATE 1
                             2306 ; 449  |#define SECONDS_TO_SKIP_FOR_60X_RATE 18
                             2307 ; 450  |#define SECONDS_TO_SKIP_FOR_600X_RATE 180
                             2308 ; 451  |#define SECONDS_TO_SKIP_FOR_1800X_RATE 540
                             2309 ; 452  |// number of 300 mSec periods before the numbers of seconds to skip increases
                             2310 ; 453  |#define LEVEL1_BOUNDARY 17 
                             2311 ; 454  |// number of 300 mSec periods before the numbers of seconds to skip increases
                             2312 ; 455  |#define LEVEL2_BOUNDARY 33 
                             2313 ; 456  |// number of 300 mSec periods before the numbers of seconds to skip increases
                             2314 ; 457  |#define LEVEL3_BOUNDARY 50 
                             2315 ; 458  |// Stmp00010296 Ticket #71685:  for song shorter than the min. skip size
                             2316 ; 459  |// if song_time < skip_size, bCurrentSongShort=>TRUE (ignore FWD/RWD commands)
                             2317 ; 460  |// Short Song Time, songs too short to play.
                             2318 ; 461  |#define SHORT_SONG_TIME SECONDS_TO_SKIP         
                             2319 ; 462  |
                             2320 ; 463  |/////////////////////////////////////////////////////////////////////////////////
                             2321 ; 464  |// MP3 Sync Values
                             2322 ; 465  |/////////////////////////////////////////////////////////////////////////////////
                             2323 ; 466  |// # bytes to look for sync before marking it bad
                             2324 ; 467  |#define MP3_SYNC_THRESHOLD 70000 
                             2325 ; 468  |// # bytes to look for sync before slowing decoder isr frequency (to let menus run)
                             2326 ; 469  |#define MP3_SYNC_THRESHOLD1 10000 
                             2327 ; 470  |// once we have sync'd, the isr should be called this frequently
                             2328 ; 471  |#define MP3_DECODERISR_FAST 7500  
                             2329 ; 472  |// if decoder is having difficulty syncing, switch isr to be called less frequently
                             2330 ; 473  |#define MP3_DECODERISR_SLOW 50000 
                             2331 ; 474  |
                             2332 ; 475  |
                             2333 ; 476  |/////////////////////////////////////////////////////////////////////////////////
                             2334 ; 477  |//// Multi-Stage Volume Control Definitions
                             2335 ; 478  |/////////////////////////////////////////////////////////////////////////////////
                             2336 ; 479  |//// Use Multi-Stage Volume
                             2337 ; 480  |#define MULTI_STAGE_VOLUME 0x1                  
                             2338 ; 481  |
                             2339 ; 482  |//// Master Volume definitions
                             2340 ; 483  |#define MIX_MSTR_MAX_VOL 0x0
                             2341 ; 484  |#define NUM_MSTR_ATT_STEPS (0x1F-MIX_MSTR_MAX_VOL)
                             2342 ; 485  |
TASKING DSP2410 assembler v1.5r1 Build 138 SN 00100122
                                                                                                                            Page  40

M:ADDR CODE           CYCLES LINE SOURCELINE
                             2343 ; 486  |//// DAC-Mode definitions
                             2344 ; 487  |//// Adjusts 0dB point
                             2345 ; 488  |#define MIX_DAC_NOM_VOL 0x6                  
                             2346 ; 489  |#define MIX_DAC_MIN_VOL 0x1F
                             2347 ; 490  |// For minimum clipping: Set MIX_DAC_MAX_VOL below to match MIX_DAC_NOM_VOL value 2 lines 
                                  above.
                             2348 ; 491  |// For additional gain (with possible clipping): Set MIX_DAC_MAX_VOL in range below. 
                             2349 ; 492  |//                                               Each integer below MIX_DAC_NOM_VOL provid
                                  es 1.5 dB gain on Stmp34x0; 
                             2350 ; 493  |//                                               Max gain possible: 8 step diff would prov
                                  ide +12dB gain.   
                             2351 ; 494  |// range: [0 to MIX_DAC_NOM_VOL] (0 for loudest volume)
                             2352 ; 495  |#define MIX_DAC_MAX_VOL 0x0  
                             2353 ; 496  |
                             2354 ; 497  |#define NUM_DAC_ATT_STEPS (MIX_DAC_MIN_VOL-MIX_DAC_NOM_VOL+1)
                             2355 ; 498  |#define NUM_DAC_GAIN_STEPS (MIX_DAC_NOM_VOL-MIX_DAC_MAX_VOL)
                             2356 ; 499  |#define NUM_DAC_MODE_VOL_STEPS (NUM_DAC_ATT_STEPS+NUM_MSTR_ATT_STEPS+NUM_DAC_GAIN_STEPS+1)
                                  
                             2357 ; 500  |
                             2358 ; 501  |//// If there is no stored volume, set to 50% of DAC-Mode max; change if DAC Mode is not t
                                  he default
                             2359 ; 502  |//// STMP35xx has 2dB attenuation per step so default needs a few more steps above midpoin
                                  t.
                             2360 ; 503  |#define DEFAULT_VOLUME ((NUM_DAC_MODE_VOL_STEPS/2)+6)         
                             2361 ; 504  |
                             2362 ; 505  |//// Set maximum restored volume to 75% of DAC-Mode max; change if DAC Mode is not the def
                                  ault
                             2363 ; 506  |#define MAX_RESTORED_VOLUME ((3*NUM_DAC_MODE_VOL_STEPS)/4)   
                             2364 ; 507  |
                             2365 ; 508  |
                             2366 ; 509  |//// Line In definitions (used for Line-In 1)
                             2367 ; 510  |//// 0dB point of the Line In
                             2368 ; 511  |#define MIX_LINE_NOM_VOL 0x8                  
                             2369 ; 512  |//// Minimum volume of Line In
                             2370 ; 513  |#define MIX_LINE_MIN_VOL 0x1F                 
                             2371 ; 514  |//// Maximum volume of Line In (can adjust extra gain)
                             2372 ; 515  |#define MIX_LINE_MAX_VOL 0x6                  
                             2373 ; 516  |#define NUM_LINE_ATT_STEPS (MIX_LINE_MIN_VOL-MIX_LINE_NOM_VOL+1)
                             2374 ; 517  |#define NUM_LINE_GAIN_STEPS (MIX_LINE_NOM_VOL-MIX_LINE_MAX_VOL)
                             2375 ; 518  |#define NUM_LINE_MODE_VOL_STEPS (NUM_LINE_ATT_STEPS+NUM_MSTR_ATT_STEPS+NUM_LINE_GAIN_STEPS
                                  +1)
                             2376 ; 519  |
                             2377 ; 520  |//// Line In definitions (used for FM tuner with 144 pin package)
                             2378 ; 521  |//// 0dB point of the Line In
                             2379 ; 522  |#define MIX_FM_NOM_VOL 0x8                  
                             2380 ; 523  |//// Minimum volume of Line In
                             2381 ; 524  |#define MIX_FM_MIN_VOL 0x1F                 
                             2382 ; 525  |//// Maximum volume of Line In (can adjust extra gain)
                             2383 ; 526  |#define MIX_FM_MAX_VOL 0x6                  
                             2384 ; 527  |#define NUM_FM_ATT_STEPS (MIX_FM_MIN_VOL-MIX_FM_NOM_VOL+1)
                             2385 ; 528  |#define NUM_FM_GAIN_STEPS (MIX_FM_NOM_VOL-MIX_FM_MAX_VOL)
                             2386 ; 529  |#define NUM_FM_MODE_VOL_STEPS (NUM_FM_ATT_STEPS+NUM_MSTR_ATT_STEPS+NUM_FM_GAIN_STEPS+1)
                             2387 ; 530  |
                             2388 ; 531  |/////////////////////////////////////////////////////////////////////////////////
                             2389 ; 532  |//// When enabled (1), periodically checks for one of several FM state machine invalid dea
                                  dlock states & recovers. 
                             2390 ; 533  |//// Define as 0 to disable FM-deadlock-state checking and recovery.
                             2391 ; 534  |#define FM_WATCHDOG_ENABLE 1
                             2392 ; 535  |
                             2393 ; 536  |#if !defined(STMP_BUILD_PLAYER)
                             2394 ; 537  |////
                             2395 ; 538  |////! This varible holds the lcd display state for the mtp project.
TASKING DSP2410 assembler v1.5r1 Build 138 SN 00100122
                                                                                                                            Page  41

M:ADDR CODE           CYCLES LINE SOURCELINE
                             2396 ; 539  |////
                             2397 ; 540  |///
                             2398 ; 541  |#include <types.h>
                             2399 ; 542  |extern volatile WORD g_wActivityState;
                             2400 ; 543  |#endif // if !@def('STMP_BUILD_PLAYER')
                             2401 ; 544  |
                             2402 ; 545  |void _reentrant Init5VSense(void);
                             2403 ; 546  |void _reentrant ServiceDCDC(void);
                             2404 ; 547  |
                             2405 ; 548  |////////////////////////////////////////////////////////////////////////////
                             2406 ; 549  |//// JPEG Thumbnail Mode Setting
                             2407 ; 550  |//// number of column in thumbnail mode
                             2408 ; 551  |#define THUMBNAIL_X 2           
                             2409 ; 552  |//// number of row in  thumbnail mode
                             2410 ; 553  |#define THUMBNAIL_Y 2           
                             2411 ; 554  |//// thumbnail boundary offset x
                             2412 ; 555  |#define THUMBNAIL_X_OFFSET 4            
                             2413 ; 556  |//// thumbnail boundary offset y
                             2414 ; 557  |#define THUMBNAIL_Y_OFFSET 4            
                             2415 ; 558  |
                             2416 ; 559  |#endif // if (!@def(_PROJECT_INC))
                             2417 ; 560  |
                             2418 
                             2420 
                             2421 ; 5    |
                             2422 ; 6    |#ifndef MAX_USB_STRINGS
                             2423 ; 7    |#define MAX_USB_STRINGS 9
                             2424 ; 8    |#endif
                             2425 ; 9    |
                             2426 ; 10   |
                             2427 ; 11   |#define  USB_SELF_POWERED                    (0x01)
                             2428 ; 12   |#define  USB_REMOTE_WAKEUP                   (0x02)
                             2429 ; 13   |
                             2430 ; 14   |#define MAX_DESC_SIZE       86      // (255/3)+1
                             2431 ; 15   |
                             2432 ; 16   |#define MS_OS_STRING_DESCRIPTOR_INDEX 0xEE
                             2433 ; 17   |#define MS_OS_STRING_DESCRIPTOR_INDEX_IN_ARRAY 7
                             2434 ; 18   |
                             2435 ; 19   |/* The USB Device State Structure */
                             2436 ; 20   |typedef struct {
                             2437 ; 21   |   BYTE         btSpeed;                // Speed of device when connected
                             2438 ; 22   |                                        // High Speed or Full Speed
                             2439 ; 23   |   BYTE         btCurConfig;            // Current configuration number (0 means not confi
                                  gured yet)
                             2440 ; 24   |                                        // or default interface
                             2441 ; 25   |   BYTE         btCurInterface;         // Current Alternate Interface (0 means not config
                                  ured yet)                                                         
                             2442 ; 26   |   BYTE         btAddress;              // USB device address
                             2443 ; 27   |   USHORT       usUsbState;             // State USB (UNKNOWN, POWERED, DEFAULT, ADDRESSED
                                  , CONFIGURED, SUSPENDED)
                             2444 ; 28   |   USHORT       usUsbStatePriorSusp;    // Ste USB prior a SUSPEND. This state needs to be
                                   restore
                             2445 ; 29   |                                        // once the USB resumes
                             2446 ; 30   |   USHORT       usUsbDeviceState;       // State of the device (SelfPowered, Remote Wakeup
                                  )
                             2447 ; 31   |   USHORT       usSofCount;
                             2448 ; 32   |   BYTE         btBusResetting;         // Set during a reset phase
                             2449 ; 33   |   BYTE         btServicesRegistered;   // Number of services registered
                             2450 ; 34   |   WORD         wError;                 // Increments each time a USB Error Interrupt occu
                                  rs
                             2451 ; 35   |   BOOL         bEnterTestMode;         // Set when entered in test mode. To clear the dev
                                  ice
TASKING DSP2410 assembler v1.5r1 Build 138 SN 00100122
                                                                                                                            Page  42

M:ADDR CODE           CYCLES LINE SOURCELINE
                             2452 ; 36   |                                        // must be powered down
                             2453 ; 37   |   USHORT       usConnectionState;      // State of the USB connection (CONNECTED, DISCONN
                                  ECTED, UNKNOWN)                                         
                             2454 ; 38   |} Dev_State_Struct;
                             2455 ; 39   |
                             2456 ; 40   |typedef struct xd_struct_type{
                             2457 ; 41   |   BYTE         btEndpointNum;          // Endpoint number 
                             2458 ; 42   |   BYTE         btDirection;            // Direction : Send/Receive
                             2459 ; 43   |   BYTE         btEndpointType;         // Type of the endpoint: Ctrl, Isoch, Bulk,Int 
                             2460 ; 44   |   BYTE         btStatus;               // Current transfer status 
                             2461 ; 45   |   WORD _X *    pbtStartAddressWord;    // Address of first byte (DSP Word address in STMP
                                   space)
                             2462 ; 46   |   BYTE         btStartOffsetByte;      // Address of first byte (Word Byte offset in STMP
                                   space)
                             2463 ; 47   |   USHORT       usTotalLength;          // Number of bytes to send/recv 
                             2464 ; 48   |   USHORT       usMaxPacketSize;        // Max Packet size 
                             2465 ; 49   |   BYTE         btDontZeroTerminate;
                             2466 ; 50   |   BOOL         bIsDataPhase;           // Set to TRUE if the transfer is data phase
                             2467 ; 51   |                                        // of a setup transfer
                             2468 ; 52   |   struct xd_struct_type _USB_MEM*pNext;     // pointer to the next xd_struct
                             2469 ; 53   |   WORD         wPrivateData;           //data to be passed to the service handler
                             2470 ; 54   |   USHORT       usBytesCopied;          //number of bytes copied so far
                             2471 ; 55   |   WORD         wCurrentOffsetByte;
                             2472 ; 56   |   WORD _X*    pbtCurrentAddressWord;
                             2473 ; 57   |} xd_struct;
                             2474 ; 58   |
                             2475 ; 59   |// If MAX_NUM_EP is not defined, default to 4
                             2476 ; 60   |// *** NOTE: if you change this definition, change the equate for MAX_NUM_EP in usb20ddmem
                                  .asm as well.
                             2477 ; 61   |// The two definitions must be equivalent for proper operation.
                             2478 ; 62   |#define MAX_NUM_EP  4
                             2479 
                             2495 
                             2496 ; 63   |
                             2497 ; 64   |extern Dev_State_Struct _USB_MEM stDeviceState;
                             2498 
                             2520 
                             2521 ; 65   |
                             2522 ; 66   |extern xd_struct _USB_MEM * g_dXD_Queues[MAX_NUM_EP][2];
                             2523 ; 67   |
                             2524 ; 68   |BYTE _reentrant usb_device_call_service(BYTE btType, BOOL bSetup, BYTE btDirection, WORD _
                                  X*ptbBuffer, WORD wLength, WORD wPrivateData);
                             2525 ; 69   |xd_struct _USB_MEM * GetEmptyXd(void);
                             2526 ; 70   |void FreeXd(xd_struct _USB_MEM * pTemp);
                             2527 ; 71   |void AddXdToQueue(xd_struct _USB_MEM *pHead,xd_struct _USB_MEM *pElement);
                             2528 ; 72   |void InitXdPool(void);
                             2529 ; 73   |_reentrant void usb_PackDescriptor(void* pDescriptor,void _X * pDestination, WORD startInd
                                  ex);
                             2530 ; 74   |_reentrant void parse_strings(void);
                             2531 ; 75   |
                             2532 ; 76   |
                             2533 ; 77   |    // Service structures.
                             2534 ; 78   |    // Those are the structures storing the function handler for a specific
                             2535 ; 79   |    // USB service.
                             2536 ; 80   |    // There is a service per Endpoint + Reset + Suspend + Start Of Frame
                             2537 ; 81   |    //                                 + Resume + Sleep + Speed Detection  
                             2538 ; 82   |    // The service structs are setup by the USB application using the device driver
                             2539 ; 83   |typedef struct {
                             2540 ; 84   |   BYTE             btType;     // Which service type
                             2541 ; 85   |                                // Pointer to the service function
                             2542 ; 86   |   void (* Service)(BOOL bSetup, BYTE btDirection, WORD _X* pbtBuffer, WORD wLength, WORD 
                                  wPrivateData);
TASKING DSP2410 assembler v1.5r1 Build 138 SN 00100122
                                                                                                                            Page  43

M:ADDR CODE           CYCLES LINE SOURCELINE
                             2543 ; 87   |} Service_Struct;
                             2544 ; 88   |
                             2545 ; 89   |
                             2546 ; 90   |#endif
                             2547 
                             2549 
                             2550 ; 10   |#include "regsrevision.h"
                             2551 
                             2553 
                             2554 ; 1    |#if !(defined(__HW_REVR))
                             2555 ; 2    |#define __HW_REVR 1
                             2556 ; 3    |
                             2557 ; 4    |
                             2558 ; 5    |#define HW_GLUE_BASEADDR 0xFA00
                             2559 ; 6    |
                             2560 ; 7    |#define HW_REVR_RMN_BITPOS (0)
                             2561 ; 8    |#define HW_REVR_DCDCMODE_BITPOS (5)
                             2562 ; 9    |#define HW_REVR_RMJ_BITPOS (8)
                             2563 ; 10   |
                             2564 ; 11   |#define HW_REVR_RMN_WIDTH (5)
                             2565 ; 12   |#define HW_REVR_DCDCMODE_WIDTH (3)
                             2566 ; 13   |
                             2567 ; 14   |#define HW_REVR_DCDCMODE_SETMASK (((1<<HW_REVR_DCDCMODE_WIDTH)-1)<<HW_REVR_DCDCMODE_BITPOS
                                  )
                             2568 ; 15   |
                             2569 ; 16   |#define HW_REVR_DCDCMODE_CLRMASK (~(WORD)HW_REVR_DCDCMODE_SETMASK)
                             2570 ; 17   |
                             2571 ; 18   |
                             2572 ; 19   |/////////////////////////////////////////////////////////////////////////////////
                             2573 ; 20   |//  Revision Register (HW_REVR) bitfields and values. (read only)
                             2574 ; 21   |//  June15 2004: C struct updated to be correct: 
                             2575 ; 22   |//   Added DCDCMODE bitfield. Removed RMP bitfield. Reduced size of RMN bitfield to 5 bits
                                  .
                             2576 ; 23   |typedef union               
                             2577 ; 24   |{
                             2578 ; 25   |    struct {
                             2579 ; 26   |        unsigned RMN    :5;     //Minor Revision
                             2580 ; 27   |        unsigned DCDCMODE : 3;  //DCDC mode field function depends on DCDC mode pin strapp
                                  ing
                             2581 ; 28   |           #define DCDCMODE_7_CONVERTER1_2CH_BOOST_CONVERTER2_OFF      7
                             2582 ; 29   |           #define DCDCMODE_6_RESERVED                                 6
                             2583 ; 30   |           #define DCDCMODE_5_CONVERTER1_3CH_BOOST_CONVERTER2_OFF      5
                             2584 ; 31   |           #define DCDCMODE_4_RESERVED                                 4
                             2585 ; 32   |           #define DCDCMODE_3_CONVERTER1_1CH_BUCK_CONVERTER2_OFF       3
                             2586 ; 33   |           #define DCDCMODE_2_CONVERTER1_OFF_CONVERTER2_OFF            2
                             2587 ; 34   |           #define DCDCMODE_1_CONVERTER1_1CH_BUCK_CONVERTER2_1CH_BOOST 1
                             2588 ; 35   |           #define DCDCMODE_0_CONVERTER1_1CH_BUCK_CONVERTER2_1CH_BUCK  0
                             2589 ; 36   |           #define DCDCMODE_X_BUCK_MASKED_SETMASK 0x4
                             2590 ; 37   |        unsigned RMJ    :16;    //Major Revision
                             2591 ; 38   |    } B;
                             2592 ; 39   |
                             2593 ; 40   |    int I;
                             2594 ; 41   |
                             2595 ; 42   |} revr_type;
                             2596 ; 43   |#define HW_REVR (*(volatile revr_type _X*) (HW_GLUE_BASEADDR+2))
                             2597 ; 44   |
                             2598 ; 45   |#define HW_REVR_DCDCMODE_B0_BITPOS 5
                             2599 ; 46   |#define HW_REVR_DCDCMODE_B1_BITPOS 6
                             2600 ; 47   |#define HW_REVR_DCDCMODE_B2_BITPOS 7
                             2601 ; 48   |
                             2602 ; 49   |#define HW_REVR_DCDCMODE_BUCK_MASK_POS HW_REVR_DCDCMODE_B2_BITPOS
TASKING DSP2410 assembler v1.5r1 Build 138 SN 00100122
                                                                                                                            Page  44

M:ADDR CODE           CYCLES LINE SOURCELINE
                             2603 ; 50   |// 3 bit bitfield: (HW_REVR_DCDCMODE_B2_BITPOS|HW_REVR_DCDCMODE_B1_BITPOS|HW_REVR_DCDCMODE
                                  _B0_BITPOS)
                             2604 ; 51   |#define HW_REVR_DCDC_MODE_SETMASK 0x0000E0
                             2605 ; 52   |#define HW_REVR_RMN_SETMASK 0xFF<<HW_REVR_RMN_BITPOS
                             2606 ; 53   |#define HW_REVR_RMJ_SETMASK 0xFFFF<<HW_REVR_RMJ_BITPOS
                             2607 ; 54   |
                             2608 ; 55   |#define HW_REVR_RMN_CLRMASK ~(WORD)HW_REVR_RMN_SETMASK
                             2609 ; 56   |#define HW_REVR_RMJ_CLRMASK ~(WORD)HW_REVR_RMJ_SETMASK
                             2610 ; 57   |
                             2611 ; 58   |#endif //!@def(__HW_REVR)
                             2612 ; 59   |
                             2613 
                             2615 
                             2616 ; 11   |
                             2617 ; 12   |BYTE _X * _reentrant GetDescriptor(BYTE btDescType, BYTE btDevSpeed, BYTE btIndex);
                             2618 ; 13   |void _reentrant BuildConfigDescriptor(BYTE _USB_MEM *pConfigRule[], WORD _X *pPackedDescri
                                  ptor);
                             2619 ; 14   |void _reentrant BuildStringDescriptor(BYTE _X * _X pbtBuffer);
                             2620 ; 15   |
                             2621 ; 16   |//#define MAX_DESC_SIZE       86      // (255/3)+1 //fam:moved to usb_internal.h
                             2622 ; 17   |WORD _X Descriptor[MAX_DESC_SIZE];
                             2623 
                             2644 
                             2645 ; 18   |extern Struct_Standard_Dev_Desc _USB_MEM StDescDevice;
                             2646 
                             2659 
                             2660 ; 19   |extern Struct_Dev_Qualifier_Desc _USB_MEM StDescDeviceQualFs;
                             2661 ; 20   |extern Struct_Dev_Qualifier_Desc _USB_MEM StDescDeviceQualHs;
                             2662 ; 21   |extern BYTE _USB_MEM *ConfigStruct[];
                             2663 ; 22   |extern _circ _X WORD *lcl_StringDescriptor[MAX_USB_STRINGS+1];
                             2664 ; 23   |_reentrant void usb_PackDescriptor(void* pDescriptor,void _X * pDestination, WORD startInd
                                  ex);
                             2665 ; 24   |
                             2666 ; 25   |#ifdef MTP_BUILD
                             2667 ; 26   |extern _reentrant void usb_PackDescriptor_From_X(Struct_String_Desc _X * pDescriptor,void 
                                  _X * pDestination, WORD startIndex);
                             2668 ; 27   |#endif
                             2669 ; 28   |
                             2670 ; 29   |
                             2671 ; 30   |#ifdef MTP_BUILD
                             2672 ; 31   |extern Struct_String_Desc _X StStringDescriptor[MAX_USB_STRINGS];
                             2673 ; 32   |#else
                             2674 
                             2681 
                             2682 ; 33   |extern Struct_String_Desc StStringDescriptor[MAX_USB_STRINGS];
                             2683 ; 34   |#endif
                             2684 ; 35   |
                             2685 ; 36   |// global flag created from hardware capability bit
                             2686 ; 37   |extern BOOL g_bUsbHsEnabled;
                             2687 ; 38   |
                             2688 ; 39   |////////////////////////////////////////////////////////////////////////////////
                             2689 ; 40   |//
                             2690 ; 41   |//>  Name:          GetDescriptor
                             2691 ; 42   |//
                             2692 ; 43   |//   Type:          Function
                             2693 ; 44   |//
                             2694 ; 45   |//   Description:   Get Descriptor
                             2695 ; 46   |//
                             2696 ; 47   |//   Inputs:        
                             2697 ; 48   |//                  btDescType : Descriptor Type
                             2698 ; 49   |//                  btDevSpeed : Actual speed of the device
                             2699 ; 50   |//                  btIndex    : Depends on the type of descriptor
TASKING DSP2410 assembler v1.5r1 Build 138 SN 00100122
                                                                                                                            Page  45

M:ADDR CODE           CYCLES LINE SOURCELINE
                             2700 ; 51   |//                               For strings it is the strin Index
                             2701 ; 52   |//                               For Config, it is the config number    
                             2702 ; 53   |//   Outputs:       None
                             2703 ; 54   |//
                             2704 ; 55   |//   Notes:         
                             2705 ; 56   |//<
                             2706 ; 57   |////////////////////////////////////////////////////////////////////////////////
                             2707 ; 58   |BYTE _X * _reentrant GetDescriptor(BYTE btDescType, BYTE btDevSpeed, BYTE btIndex)
                             2708 ; 59   |{ /* Body */
                             2709 
P:0000                       2710         org     p,".ptextpackdesc":
                             2717 FGetDescriptor:
P:0000 055F7C         2    2 2718         movec   ssh,y:(r7)+
P:0001 205F00         2    4 2721         move    (r7)+
                             2741 
                             2742 ; 60   |    
                             2743 ; 61   |    INT     i, j;
                             2744 ; 62   |    WORD    wReg;
                             2745 ; 63   |    void _USB_MEM*pDescriptor;
                             2746 ; 64   |    BOOL    bDescTypeOtherSpeed = FALSE;
                             2747 
P:0002 21B500         2    6 2749         move    b1,r5
P:0003 250000         2    8 2752         move    #0,x1
                             2754 
                             2755 ; 65   |    
                             2756 ; 66   |    switch (btDescType)
                             2757 
P:0004 57F400 000001  3   11 2759         move    #>1,b
P:0006 2A0000         2   13 2760         move    #0,a2
P:0007 62F414 rrrrrr  3   16 2761         sub     b,a     #L62,r2
P:0009 0AF0A8 rrrrrr  6   22 2762         jcs     L51
P:000B 57F400 000006  3   25 2763         move    #>6,b
P:000D 21DA05         2   27 2764         cmp     b,a     a,n2
P:000E 0AF0A7 rrrrrr  6   33 2765         jgt     L51
P:0010 07EA92         8   41 2766         movem   p:(r2+n2),r2
P:0011 000000         2   43 2767         nop
P:0012 0AE280         4   47 2768         jmp     (r2)
                             2769 
P:0013 rrrrrr                2770 L62:    dc      L33     ; case 1:
P:0014 rrrrrr                2771         dc      L37     ; case 2:
P:0015 rrrrrr                2772         dc      L41     ; case 3:
P:0016 rrrrrr                2773         dc      L51     ; default:
P:0017 rrrrrr                2774         dc      L51     ; default:
P:0018 rrrrrr                2775         dc      L46     ; case 6:
P:0019 rrrrrr                2776         dc      L34     ; case 7:
                             2777 
                             2778 
                             2779 ; 67   |    {
                             2780 ; 68   |
                             2781 ; 69   |        case DESCRIPTOR_TYPE_DEVICE:
                             2782 ; 70   |
                             2783 ; 71   |            // Copy speed dependent information
                             2784 ; 72   |            
                             2785 ; 73   |            if (btDevSpeed==USB_SPEED_HIGH)
                             2786 
P:001A 22AF00         2   49 2788 L33:    move    r5,b
P:001B 46F400 000002  3   52 2789         move    #>2,y0
P:001D 20005D         2   54 2790         cmp     y0,b
P:001E 0AF0A2 rrrrrr  6   60 2791         jne     L52
                             2792 
                             2793 ; 74   |            {
                             2794 ; 75   |                StDescDevice.btDeviceClass    = StDescDeviceQualHs.btDeviceClass;
TASKING DSP2410 assembler v1.5r1 Build 138 SN 00100122
                                                                                                                            Page  46

M:ADDR CODE           CYCLES LINE SOURCELINE
                             2795 
P:0020 7EF000 rrrrrr  3   63 2797         move    y:FStDescDeviceQualHs+4,n6
P:0022 7E7000 rrrrrr  3   66 2798         move    n6,y:FStDescDevice+4
                             2799 
                             2800 ; 76   |                StDescDevice.btDeviceSubclass = StDescDeviceQualHs.btDeviceSubclass;
                             2801 
P:0024 6CF000 rrrrrr  3   69 2803         move    y:FStDescDeviceQualHs+5,r4
P:0026 6C7000 rrrrrr  3   72 2804         move    r4,y:FStDescDevice+5
                             2805 
                             2806 ; 77   |                StDescDevice.btDeviceProtocol = StDescDeviceQualHs.btDeviceProtocol;
                             2807 
P:0028 7BF000 rrrrrr  3   75 2809         move    y:FStDescDeviceQualHs+6,n3
P:002A 7B7000 rrrrrr  3   78 2810         move    n3,y:FStDescDevice+6
                             2811 
                             2812 ; 78   |                StDescDevice.btMaxPacketSize0 = StDescDeviceQualHs.btMaxPacketSize0;
                             2813 
P:002C 69F000 rrrrrr  3   81 2815         move    y:FStDescDeviceQualHs+7,r1
P:002E 697000 rrrrrr  3   84 2816         move    r1,y:FStDescDevice+7
                             2817 
                             2818 ; 79   |            }
                             2819 
P:0030 0AF080 rrrrrr  6   90 2821         jmp     L53
                             2822 
                             2823 ; 80   |            else
                             2824 ; 81   |            {
                             2825 ; 82   |                StDescDevice.btDeviceClass    = StDescDeviceQualFs.btDeviceClass;
                             2826 ; 83   |                StDescDevice.btDeviceSubclass = StDescDeviceQualFs.btDeviceSubclass;
                             2827 ; 84   |                StDescDevice.btDeviceProtocol = StDescDeviceQualFs.btDeviceProtocol;
                             2828 ; 85   |                StDescDevice.btMaxPacketSize0 = StDescDeviceQualFs.btMaxPacketSize0;
                             2829 ; 86   |            }
                             2830 ; 87   |            
                             2831 ; 88   |
                             2832 ; 89   |                        // For devices that do not support High Speed USB such as STMP3501
                                  /02/03
                             2833 ; 90   |                        if(g_bUsbHsEnabled == FALSE)
                             2834 ; 91   |                        {
                             2835 ; 92   |                    StDescDevice.btBcdUsbLsb = 0x10;
                             2836 ; 93   |                    StDescDevice.btBcdUsbMsb = 0x01;
                             2837 ; 94   |                        }
                             2838 ; 95   |
                             2839 ; 96   |            usb_PackDescriptor(&StDescDevice,Descriptor,0);
                             2840 ; 97   |
                             2841 ; 98   |            break;
                             2842 ; 99   |
                             2843 ; 100  |        
                             2844 ; 101  |        case DESCRIPTOR_TYPE_OTHER_SPEED_CONFIG:
                             2845 ; 102  |            //in this case, lets change report the device speed we're not
                             2846 ; 103  |            if(btDevSpeed == USB_SPEED_HIGH)
                             2847 
P:0032 22AE00         2   92 2849 L34:    move    r5,a
P:0033 47F400 000002  3   95 2851         move    #>2,y1
P:0035 200075         2   97 2852         cmp     y1,a
P:0036 0AF0A2 rrrrrr  6  103 2853         jne     L35
                             2854 
                             2855 ; 104  |                btDevSpeed = USB_SPEED_FULL;
                             2856 
P:0038 350000         2  105 2858         move    #0,r5
P:0039 0AF080 rrrrrr  6  111 2859         jmp     L36
                             2860 
                             2861 ; 105  |            else
                             2862 ; 106  |                btDevSpeed = USB_SPEED_HIGH;
                             2863 
TASKING DSP2410 assembler v1.5r1 Build 138 SN 00100122
                                                                                                                            Page  47

M:ADDR CODE           CYCLES LINE SOURCELINE
P:003B 20F500         2  113 2865 L35:    move    y1,r5
P:003C 22AF00         2  115 2866 L36:    move    r5,b
                             2867 
                             2868 ; 107  |
                             2869 ; 108  |            // Set flag to modify the descriptor type after building the 
                             2870 ; 109  |            // configuration descriptor
                             2871 ; 110  |            bDescTypeOtherSpeed = TRUE;    
                             2872 
P:003D 45F400 000001  3  118 2874         move    #>1,x1
                             2875 
                             2876 ; 111  |            
                             2877 ; 112  |                
                             2878 ; 113  |        case DESCRIPTOR_TYPE_CONFIG:
                             2879 ; 114  |        // Prepare Configuration Descriptor transfer.
                             2880 ; 115  |        // A configuration descriptor includes all related interfaces descriptor (1 or mor
                                  e per configuration)
                             2881 ; 116  |        // and all related endpoints (1 or more per interface)
                             2882 ; 117  |            {
                             2883 ; 118  |                BYTE _USB_MEM **pConfig = ConfigStruct;
                             2884 
                             2886 L37:
P:003F 66F400 rrrrrr  3  121 2894         move    #FConfigStruct,r6
                             2898 
                             2899 ; 119  |                int iConfigs=0;
                             2900 
P:0041 260000         2  123 2902         move    #0,y0
                             2904 
                             2905 ; 120  |                while(*pConfig)
                             2906 
P:0042 47F400 000001  3  126 2908         move    #>1,y1
P:0044 0AF080 rrrrrr  6  132 2909         jmp     L39
                             2910 
                             2911 ; 121  |                {
                             2912 ; 122  |                    pConfig++;
                             2913 
P:0046 205E00         2  134 2915 L38:    move    (r6)+
                             2916 
                             2917 ; 123  |                    pConfig++;
                             2918 
P:0047 205E00         2  136 2920         move    (r6)+
                             2921 
                             2922 ; 124  |                    iConfigs++;
                             2923 
P:0048 200051         2  138 2925         tfr     y0,a
P:0049 200070         2  140 2926         add     y1,a
P:004A 218600         2  142 2929         move    a1,y0
P:004B 5FE600         2  144 2933 L39:    move    y:(r6),b
P:004C 21FE00         2  146 2934         move    b,n6
P:004D 20000B         2  148 2935         tst     b
P:004E 0AF0A2 rrrrrr  6  154 2936         jne     L38
                             2937 
                             2938 ; 125  |                }
                             2939 ; 126  |            if((btIndex < 0) || (btIndex >= iConfigs))
                             2940 
P:0050 200049         2  156 2942         tfr     x0,b
P:0051 21AE00         2  158 2943         move    b1,a
P:0052 200003         2  160 2946         tst     a
P:0053 0AF0A9 rrrrrr  6  166 2947         jlt     L51
P:0055 200055         2  168 2948         cmp     y0,a
P:0056 0AF0A1 rrrrrr  6  174 2949         jge     L51
                             2950 
                             2951 ; 127  |                return(NULL);
TASKING DSP2410 assembler v1.5r1 Build 138 SN 00100122
                                                                                                                            Page  48

M:ADDR CODE           CYCLES LINE SOURCELINE
                             2952 ; 128  |
                             2953 ; 129  |            btIndex = 2 * btIndex;
                             2954 
P:0058 20003B         2  176 2956         lsl     b
P:0059 21AE00         2  178 2958         move    b1,a
                             2960 
                             2961 ; 130  |
                             2962 ; 131  |            if(btDevSpeed==USB_SPEED_HIGH)
                             2963 
P:005A 22AF00         2  180 2965         move    r5,b
P:005B 46F400 000002  3  183 2966         move    #>2,y0
P:005D 20005D         2  185 2967         cmp     y0,b
P:005E 0AF0A2 rrrrrr  6  191 2969         jne     L40
                             2970 
                             2971 ; 132  |                btIndex ++;
                             2972 
P:0060 200070         2  193 2974         add     y1,a
P:0061 045FA0         2  195 2975 L40:    movec   m0,n7
P:0062 000000         2  197 2976         nop
P:0063 4D6F00         4  201 2977         move    x1,y:(r7+n7)
                             2980 
                             2981 ; 133  |           
                             2982 ; 134  |            BuildConfigDescriptor((void _USB_MEM*)*(ConfigStruct+btIndex),Descriptor);
                             2983 
P:0064 219D00         2  203 2985         move    a1,n5
P:0065 65F400 rrrrrr  3  206 2986         move    #FConfigStruct,r5
P:0067 000000         2  208 2987         nop
P:0068 044D16         4  212 2988         lua     (r5)+n5,r6
P:0069 000000         2  214 2993         nop
P:006A 68E600         2  216 2994         move    y:(r6),r0
P:006B 64F400 rrrrrr  3  219 2995         move    #FDescriptor,r4
P:006D 0BF080 rrrrrr  6  225 2996         jsr     FBuildConfigDescriptor
                             2998 
                             2999 ; 135  |            
                             3000 ; 136  |            if(bDescTypeOtherSpeed == TRUE)
                             3001 
P:006F 045FA0         2  227 3003         movec   m0,n7
P:0070 000000         2  229 3004         nop
P:0071 5EEF00         4  233 3005         move    y:(r7+n7),a
P:0072 45F400 000001  3  236 3006         move    #>1,x1
P:0074 2A0000         2  238 3007         move    #0,a2
P:0075 200065         2  240 3008         cmp     x1,a
P:0076 0AF0A2 rrrrrr  6  246 3011         jne     L60
                             3012 
                             3013 ; 137  |            {
                             3014 ; 138  |                // Modify the descriptor byte to DESCRIPTOR_TYPE_OTHER_SPEED_CONFIG
                             3015 ; 139  |                Descriptor[0] &= 0xff00ff;
                             3016 
P:0078 55F000 rrrrrr  3  249 3018         move    x:FDescriptor,b1
P:007A 46F400 FF00FF  3  252 3019         move    #16711935,y0
P:007C 20005E         2  254 3020         and     y0,b
P:007D 557000 rrrrrr  3  257 3021         move    b1,x:FDescriptor
                             3022 
                             3023 ; 140  |                Descriptor[0] |= (DESCRIPTOR_TYPE_OTHER_SPEED_CONFIG << 8);
                             3024 
P:007F 0ACD68         4  261 3026         bset    #8,b1
P:0080 0ACD69         4  265 3027         bset    #9,b1
P:0081 0ACD6A         4  269 3028         bset    #10,b1
P:0082 557000 rrrrrr  3  272 3029         move    b1,x:FDescriptor
                             3031 
                             3032 ; 141  |            }
                             3033 ; 142  |
TASKING DSP2410 assembler v1.5r1 Build 138 SN 00100122
                                                                                                                            Page  49

M:ADDR CODE           CYCLES LINE SOURCELINE
                             3034 ; 143  |            }break;
                             3035 
P:0084 0AF080 rrrrrr  6  278 3037         jmp     L60
                             3038 
                             3039 ; 144  |                        
                             3040 ; 145  |        case DESCRIPTOR_TYPE_STRING:
                             3041 ; 146  |            {
                             3042 ; 147  |                int iStrings = 0;
                             3043 
                             3045 L41:
P:0086 200013         2  280 3050         clr     a   
                             3059 
                             3060 ; 148  |                WORD **pString = lcl_StringDescriptor;
                             3061 
P:0087 66F400 rrrrrr  3  283 3063         move    #Flcl_StringDescriptor,r6
                             3065 
                             3066 ; 149  |
                             3067 ; 150  |                while(*pString)
                             3068 
P:0089 46F400 000001  3  286 3070         move    #>1,y0
P:008B 0AF080 rrrrrr  6  292 3071         jmp     L43
                             3072 
                             3073 ; 151  |                {
                             3074 ; 152  |                    pString++;
                             3075 
P:008D 205E00         2  294 3077 L42:    move    (r6)+
                             3078 
                             3079 ; 153  |                    iStrings++;
                             3080 
P:008E 200050         2  296 3082         add     y0,a
P:008F 5FE600         2  298 3084 L43:    move    y:(r6),b
P:0090 21FE00         2  300 3085         move    b,n6
P:0091 20000B         2  302 3086         tst     b
P:0092 0AF0A2 rrrrrr  6  308 3087         jne     L42
                             3088 
                             3089 ; 154  |                }
                             3090 ; 155  |
                             3091 ; 156  |                                if( btIndex == MS_OS_STRING_DESCRIPTOR_INDEX )
                             3092 
P:0094 200049         2  310 3094         tfr     x0,b
P:0095 46F400 0000EE  3  313 3095         move    #>238,y0
P:0097 20005D         2  315 3096         cmp     y0,b
P:0098 0AF0A2 rrrrrr  6  321 3097         jne     L44
                             3098 
                             3099 ; 157  |                                {
                             3100 ; 158  |#ifdef MTP_BUILD
                             3101 ; 159  |                                        usb_PackDescriptor_From_X(&StStringDescriptor[MS_O
                                  S_STRING_DESCRIPTOR_INDEX_IN_ARRAY],Descriptor,0);
                             3102 ; 160  |#else                           
                             3103 ; 161  |                                        usb_PackDescriptor(&StStringDescriptor[MS_OS_STRIN
                                  G_DESCRIPTOR_INDEX_IN_ARRAY],Descriptor,0);
                             3104 
P:009A 64F400 rrrrrr  3  324 3106         move    #FDescriptor,r4
P:009C 60F400 rrrrrr  3  327 3107         move    #FStStringDescriptor+434,r0
P:009E 200013         2  329 3108         clr     a   
P:009F 0BF080 rrrrrr  6  335 3109         jsr     Fusb_PackDescriptor
                             3113 
                             3114 ; 162  |#endif
                             3115 ; 163  |                                        break;
                             3116 
P:00A1 0AF080 rrrrrr  6  341 3118         jmp     L60
                             3119 
TASKING DSP2410 assembler v1.5r1 Build 138 SN 00100122
                                                                                                                            Page  50

M:ADDR CODE           CYCLES LINE SOURCELINE
                             3120 ; 164  |                                }
                             3121 ; 165  |
                             3122 ; 166  |                if(btIndex < iStrings)
                             3123 
                             3125 L44:
P:00A3 20000D         2  343 3128         cmp     a,b
P:00A4 0AF0A1 rrrrrr  6  349 3129         jge     L45
                             3130 
                             3131 ; 167  |                {
                             3132 ; 168  |#ifdef MTP_BUILD
                             3133 ; 169  |                    usb_PackDescriptor_From_X(&StStringDescriptor[btIndex],Descriptor,0);
                             3134 ; 170  |#else                           
                             3135 ; 171  |                    usb_PackDescriptor(&StStringDescriptor[btIndex],Descriptor,0);
                             3136 
P:00A6 45F400 00003E  3  352 3138         move    #>$3E,x1
P:00A8 2000A8         2  354 3139         mpy     x0,x1,b
P:00A9 20002A         2  356 3140         asr     b
P:00AA 213800         2  358 3141         move    b0,n0
P:00AB 60F400 rrrrrr  3  361 3142         move    #FStStringDescriptor,r0
P:00AD 000000         2  363 3143         nop
P:00AE 204800         2  365 3144         move    (r0)+n0
P:00AF 64F400 rrrrrr  3  368 3145         move    #FDescriptor,r4
P:00B1 200013         2  370 3146         clr     a   
P:00B2 0BF080 rrrrrr  6  376 3147         jsr     Fusb_PackDescriptor
                             3150 
                             3151 ; 172  |#endif
                             3152 ; 173  |                }
                             3153 
P:00B4 0AF080 rrrrrr  6  382 3155         jmp     L60
                             3156 
                             3157 ; 174  |                else
                             3158 ; 175  |                {
                             3159 ; 176  |                    // Return the last string descriptor by default
                             3160 ; 177  |#ifdef MTP_BUILD
                             3161 ; 178  |                    usb_PackDescriptor_From_X(&StStringDescriptor[iStrings-1],Descriptor,0
                                  );
                             3162 ; 179  |#else                           
                             3163 ; 180  |                    usb_PackDescriptor(&StStringDescriptor[iStrings-1],Descriptor,0);
                             3164 
                             3166 L45:
P:00B6 47F400 00003E  3  385 3168         move    #>$3E,y1
P:00B8 218600         2  387 3169         move    a1,y0
P:00B9 2000B0         2  389 3170         mpy     y0,y1,a
P:00BA 200022         2  391 3171         asr     a
P:00BB 211E00         2  393 3174         move    a0,n6
P:00BC 66F400 rrrrrr  3  396 3175         move    #FStStringDescriptor-62,r6
P:00BE 000000         2  398 3176         nop
P:00BF 044E10         4  402 3177         lua     (r6)+n6,r0
P:00C0 64F400 rrrrrr  3  405 3178         move    #FDescriptor,r4
P:00C2 200013         2  407 3179         clr     a   
P:00C3 0BF080 rrrrrr  6  413 3180         jsr     Fusb_PackDescriptor
                             3183 
                             3184 ; 181  |#endif
                             3185 ; 182  |                }
                             3186 ; 183  |            }break;
                             3187 
P:00C5 0AF080 rrrrrr  6  419 3189         jmp     L60
                             3190 
                             3191 ; 184  |
                             3192 ; 185  |        case DESCRIPTOR_TYPE_DEVICE_QUALIFIER:
                             3193 ; 186  |            // Copy speed dependent information
                             3194 ; 187  |            if(btDevSpeed==USB_SPEED_HIGH)
TASKING DSP2410 assembler v1.5r1 Build 138 SN 00100122
                                                                                                                            Page  51

M:ADDR CODE           CYCLES LINE SOURCELINE
                             3195 
                             3197 L46:
P:00C7 22AF00         2  421 3199         move    r5,b
P:00C8 56F400 000002  3  424 3200         move    #>2,a
P:00CA 20000D         2  426 3201         cmp     a,b
                             3202 
                             3203 ; 188  |                pDescriptor = &StDescDeviceQualHs;
                             3204 
P:00CB 60F400 rrrrrr  3  429 3206         move    #FStDescDeviceQualHs,r0
P:00CD 0AF0AA rrrrrr  6  435 3208         jeq     L48
                             3209 
                             3210 ; 189  |            else 
                             3211 ; 190  |                pDescriptor = &StDescDeviceQualFs;
                             3212 
P:00CF 60F400 rrrrrr  3  438 3214         move    #FStDescDeviceQualFs,r0
                             3215 
                             3216 ; 191  |
                             3217 ; 192  |            usb_PackDescriptor(pDescriptor,Descriptor,0);
                             3218 
P:00D1 64F400 rrrrrr  3  441 3220 L48:    move    #FDescriptor,r4
P:00D3 200013         2  443 3221         clr     a   
P:00D4 0BF080 rrrrrr  6  449 3222         jsr     Fusb_PackDescriptor
                             3225 
                             3226 ; 193  |                
                             3227 ; 194  |            break;
                             3228 
P:00D6 0AF080 rrrrrr  6  455 3230         jmp     L60
                             3231 
                             3232 ; 195  |
                             3233 ; 196  |        default:
                             3234 ; 197  |            return(NULL);
                             3235 
P:00D8 300000         2  457 3237 L51:    move    #0,r0
P:00D9 0AF080 rrrrrr  6  463 3238         jmp     L61
P:00DB 4CF000 rrrrrr  3  466 3240 L52:    move    y:FStDescDeviceQualFs+4,x0
P:00DD 4C7000 rrrrrr  3  469 3241         move    x0,y:FStDescDevice+4
P:00DF 5DF000 rrrrrr  3  472 3243         move    y:FStDescDeviceQualFs+5,b1
P:00E1 5D7000 rrrrrr  3  475 3244         move    b1,y:FStDescDevice+5
P:00E3 5CF000 rrrrrr  3  478 3246         move    y:FStDescDeviceQualFs+6,a1
P:00E5 5C7000 rrrrrr  3  481 3247         move    a1,y:FStDescDevice+6
P:00E7 6EF000 rrrrrr  3  484 3249         move    y:FStDescDeviceQualFs+7,r6
P:00E9 6E7000 rrrrrr  3  487 3250         move    r6,y:FStDescDevice+7
P:00EB 5FF000 rrrrrr  3  490 3252 L53:    move    y:Fg_bUsbHsEnabled,b
P:00ED 2B0000         2  492 3253         move    #0,b2
P:00EE 20000B         2  494 3254         tst     b
P:00EF 0AF0A2 rrrrrr  6  500 3255         jne     L54
P:00F1 341000         2  502 3257         move    #$10,r4
P:00F2 6C7000 rrrrrr  3  505 3258         move    r4,y:FStDescDevice+2
P:00F4 3B0100         2  507 3260         move    #1,n3
P:00F5 7B7000 rrrrrr  3  510 3261         move    n3,y:FStDescDevice+3
P:00F7 64F400 rrrrrr  3  513 3263 L54:    move    #FDescriptor,r4
P:00F9 60F400 rrrrrr  3  516 3264         move    #FStDescDevice,r0
P:00FB 200013         2  518 3265         clr     a   
P:00FC 0BF080 rrrrrr  6  524 3266         jsr     Fusb_PackDescriptor
                             3267 
                             3268 ; 198  |
                             3269 ; 199  |    } /* Endswitch */
                             3270 ; 200  |
                             3271 ; 201  |    return((BYTE _X *)Descriptor);
                             3272 
P:00FE 60F400 rrrrrr  3  527 3274 L60:    move    #FDescriptor,r0
                             3275 
TASKING DSP2410 assembler v1.5r1 Build 138 SN 00100122
                                                                                                                            Page  52

M:ADDR CODE           CYCLES LINE SOURCELINE
                             3276 ; 202  |} /* Endbody */
                             3277 
P:0100 205700         2  529 3279 L61:    move    (r7)-
P:0101 05FF7C         4  533 3281         movec   y:-(r7),ssh
P:0102 000000         2  535 3284         nop
P:0103 00000C         4  539 3285         rts
                             3287 
                             3288 ; 203  |
                             3289 ; 204  |
                             3290 ; 205  |
                             3291 ; 206  |////////////////////////////////////////////////////////////////////////////////
                             3292 ; 207  |//
                             3293 ; 208  |//>  Name:          BuildConfigDescriptor
                             3294 ; 209  |//
                             3295 ; 210  |//   Type:          Function
                             3296 ; 211  |//
                             3297 ; 212  |//   Description:   Build the string descriptor
                             3298 ; 213  |//
                             3299 ; 214  |//   Inputs:        BYTE _USB_MEM *pConfigRule[]        The rule to build a descriptor for
                                  
                             3300 ; 215  |//
                             3301 ; 216  |//   Outputs:       None
                             3302 ; 217  |//
                             3303 ; 218  |//   Notes:
                             3304 ; 219  |//      This function is not really reentrant. It uses 1 global variable
                             3305 ; 220  |//      that is not protected.         
                             3306 ; 221  |//<
                             3307 ; 222  |////////////////////////////////////////////////////////////////////////////////
                             3308 ; 223  |void _reentrant BuildConfigDescriptor(BYTE _USB_MEM *pConfigRule[], WORD _X *pPackedDescri
                                  ptor)
                             3309 ; 224  |{
                             3310 
                             3315 FBuildConfigDescriptor:
P:0104 055F7C         2  541 3316         movec   ssh,y:(r7)+
P:0105 3F0400         2  543 3319         move    #4,n7
P:0106 000000         2  545 3320         nop
P:0107 204F00         2  547 3321         move    (r7)+n7
                             3339 
                             3340 ; 225  |    INT     i;
                             3341 ; 226  |    WORD    wSizeMask;
                             3342 ; 227  |    BYTE    btByteOffset, btCurElem;
                             3343 ; 228  |    USHORT  usTotalBytes;    
                             3344 ; 229  |    BYTE    _USB_MEM *pDescriptor;
                             3345 
P:0108 77F400 FFFFFD  3  550 3347         move    #-3,n7
P:010A 000000         2  552 3348         nop
P:010B 6C6F00         4  556 3349         move    r4,y:(r7+n7)
                             3352 
                             3353 ; 230  |
                             3354 ; 231  |
                             3355 ; 232  |    btByteOffset = 0;
                             3356 ; 233  |    btCurElem = 0;                      //  Current element descriptor array
                             3357 ; 234  |    usTotalBytes = 0;
                             3358 
P:010C 3B0000         2  558 3360         move    #0,n3
                             3362 
                             3363 ; 235  |    
                             3364 ; 236  |    pDescriptor= *(pConfigRule);    // Points Current Descriptor
                             3365 
P:010D 6EE000         2  560 3367         move    y:(r0),r6
                             3369 
                             3370 ; 237  |
TASKING DSP2410 assembler v1.5r1 Build 138 SN 00100122
                                                                                                                            Page  53

M:ADDR CODE           CYCLES LINE SOURCELINE
                             3371 ; 238  |    while(pDescriptor != NULL)          // Process all descriptors from the Config Rule
                             3372 
P:010E 0AF080 rrrrrr  6  566 3374         jmp     L70
P:0110 77F400 FFFFFC  3  569 3375 L69:    move    #-4,n7
P:0112 000000         2  571 3376         nop
P:0113 686F00         4  575 3377         move    r0,y:(r7+n7)
                             3380 
                             3381 ; 239  |    {                                   // NULL pointer demarks end of config
                             3382 ; 240  |        usb_PackDescriptor(pDescriptor,pPackedDescriptor,usTotalBytes);
                             3383 
P:0114 045FA0         2  577 3385         movec   m0,n7
P:0115 000000         2  579 3386         nop
P:0116 6E6F00         4  583 3387         move    r6,y:(r7+n7)
P:0117 22D000         2  585 3388         move    r6,r0
P:0118 77F400 FFFFFD  3  588 3391         move    #-3,n7
P:011A 000000         2  590 3392         nop
P:011B 6CEF00         4  594 3393         move    y:(r7+n7),r4
P:011C 77F400 FFFFFE  3  597 3394         move    #-2,n7
P:011E 000000         2  599 3395         nop
P:011F 7B6F00         4  603 3396         move    n3,y:(r7+n7)
P:0120 236E00         2  605 3397         move    n3,a
P:0121 0BF080 rrrrrr  6  611 3402         jsr     Fusb_PackDescriptor
                             3405 
                             3406 ; 241  |        usTotalBytes += *pDescriptor;   // Update total descriptor length
                             3407 
P:0123 045FA0         2  613 3409         movec   m0,n7
P:0124 000000         2  615 3410         nop
P:0125 6EEF00         4  619 3411         move    y:(r7+n7),r6
P:0126 000000         2  621 3412         nop
P:0127 4EE600         2  623 3413         move    y:(r6),y0
P:0128 77F400 FFFFFE  3  626 3416         move    #-2,n7
P:012A 000000         2  628 3417         nop
P:012B 5FEF00         4  632 3418         move    y:(r7+n7),b
P:012C 200058         2  634 3419         add     y0,b
P:012D 21BB00         2  636 3423         move    b1,n3
                             3425 
                             3426 ; 242  |         
                             3427 ; 243  |
                             3428 ; 244  |        pDescriptor = *(++pConfigRule);      // Points Current Descriptor
                             3429 
P:012E 77F400 FFFFFC  3  639 3431         move    #-4,n7
P:0130 000000         2  641 3432         nop
P:0131 6EEF00         4  645 3433         move    y:(r7+n7),r6
P:0132 000000         2  647 3434         nop
P:0133 205E00         2  649 3435         move    (r6)+
P:0134 22D000         2  651 3441         move    r6,r0
P:0135 6EE600         2  653 3444         move    y:(r6),r6
P:0136 22CF00         2  655 3447 L70:    move    r6,b
P:0137 20000B         2  657 3448         tst     b
P:0138 0AF0A2 rrrrrr  6  663 3449         jne     L69
                             3450 
                             3451 ; 245  |    
                             3452 ; 246  |    };
                             3453 ; 247  |    
                             3454 ; 248  |    // Update the descriptor size
                             3455 ; 249  |    *pPackedDescriptor &= 0x00ffff;
                             3456 
P:013A 77F400 FFFFFD  3  666 3458         move    #-3,n7
P:013C 000000         2  668 3459         nop
P:013D 6BEF00         4  672 3460         move    y:(r7+n7),r3
P:013E 000000         2  674 3461         nop
P:013F 54E300         2  676 3462         move    x:(r3),a1
TASKING DSP2410 assembler v1.5r1 Build 138 SN 00100122
                                                                                                                            Page  54

M:ADDR CODE           CYCLES LINE SOURCELINE
P:0140 46F400 00FFFF  3  679 3465         move    #$FFFF,y0
P:0142 200056         2  681 3466         and     y0,a
P:0143 546300         2  683 3467         move    a1,x:(r3)
                             3468 
                             3469 ; 250  |    wSizeMask = usTotalBytes & 0x0000ff;
                             3470 
P:0144 236D00         2  685 3472         move    n3,b1
P:0145 44F400 0000FF  3  688 3473         move    #>$FF,x0
P:0147 20004E         2  690 3474         and     x0,b
P:0148 21A600         2  692 3475         move    b1,y0
                             3477 
                             3478 ; 251  |    *pPackedDescriptor |= (wSizeMask << 16);
                             3479 
P:0149 0108E8         2  694 3481         mpy     y0,#8,b
P:014A 212600         2  696 3482         move    b0,y0
P:014B 200052         2  698 3483         or      y0,a
P:014C 545B00         2  700 3485         move    a1,x:(r3)+
                             3487 
                             3488 ; 252  |     
                             3489 ; 253  |    *(pPackedDescriptor+1) &= 0xffff00;
                             3490 
P:014D 55E300         2  702 3492         move    x:(r3),b1
P:014E 46F400 FFFF00  3  705 3493         move    #$FFFF00,y0
P:0150 20005E         2  707 3494         and     y0,b
P:0151 556300         2  709 3495         move    b1,x:(r3)
                             3496 
                             3497 ; 254  |    wSizeMask = usTotalBytes & 0x00ff00;
                             3498 
P:0152 236C00         2  711 3500         move    n3,a1
P:0153 44F400 00FF00  3  714 3501         move    #$FF00,x0
P:0155 200046         2  716 3502         and     x0,a
                             3507 
                             3508 ; 255  |    *(pPackedDescriptor+1) |= (wSizeMask >> 8);
                             3509 
P:0156 060880 rrrrrr  6  722 3511         do      #8,L71
P:0158 200023         2  724 3513         lsr     a
P:0159 000000         2  726 3514         nop
                         (4) 3515 L71:
P:015A 218600         2  728 3518         move    a1,y0
P:015B 20005A         2  730 3519         or      y0,b
P:015C 556300         2  732 3520         move    b1,x:(r3)
                             3521 
                             3522 ; 256  |
                             3523 ; 257  |}
                             3524 
P:015D 77F400 FFFFFB  3  735 3526         move    #-5,n7
P:015F 000000         2  737 3527         nop
P:0160 05EF7C         4  741 3528         movec   y:(r7+n7),ssh
P:0161 204F00         2  743 3530         move    (r7)+n7
P:0162 00000C         4  747 3532         rts
                             3553 
                             3557 
X:0000                       3558         org     x,".xbsspackdesc",bss:
                             3559 FDescriptor:
X:0000                       3560         ds      86
   |   RESERVED                   
X:0055
                             3561 
                             3562         extern  y:FConfigStruct, y:FStDescDevice, y:FStDescDeviceQualFs
                             3563         extern  y:FStDescDeviceQualHs, y:FStStringDescriptor
                             3564         extern  y:Fg_bUsbHsEnabled, y:Flcl_StringDescriptor
                             3565         extern  Fusb_PackDescriptor
TASKING DSP2410 assembler v1.5r1 Build 138 SN 00100122
                                                                                                                            Page  55

M:ADDR CODE           CYCLES LINE SOURCELINE
                             3566 
                             3567         global  FBuildConfigDescriptor, FDescriptor, FGetDescriptor
                             3568 
                             3569         local   L33, L34, L35, L36, L37, L38, L39, L40, L41, L42, L43, L44
                             3570         local   L45, L46, L48, L51, L52, L53, L54, L60, L61, L62, L69, L70
                             3571         local   L71
                             3572 
                             3573         calls   "BuildConfigDescriptor", "usb_PackDescriptor"
                             3574         calls   "GetDescriptor", "BuildConfigDescriptor"
                             3575         calls   "GetDescriptor", "usb_PackDescriptor"
                             3576 
